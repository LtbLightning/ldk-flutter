// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<uintptr_t> _MAX_BUF_SIZE =
      _lookup<uintptr_t>('MAX_BUF_SIZE');

  int get MAX_BUF_SIZE => _MAX_BUF_SIZE.value;

  set MAX_BUF_SIZE(int value) => _MAX_BUF_SIZE.value = value;

  late final ffi.Pointer<ffi.Uint64> _MIN_RELAY_FEE_SAT_PER_1000_WEIGHT =
      _lookup<ffi.Uint64>('MIN_RELAY_FEE_SAT_PER_1000_WEIGHT');

  int get MIN_RELAY_FEE_SAT_PER_1000_WEIGHT =>
      _MIN_RELAY_FEE_SAT_PER_1000_WEIGHT.value;

  set MIN_RELAY_FEE_SAT_PER_1000_WEIGHT(int value) =>
      _MIN_RELAY_FEE_SAT_PER_1000_WEIGHT.value = value;

  late final ffi.Pointer<ffi.Uint32> _FEERATE_FLOOR_SATS_PER_KW =
      _lookup<ffi.Uint32>('FEERATE_FLOOR_SATS_PER_KW');

  int get FEERATE_FLOOR_SATS_PER_KW => _FEERATE_FLOOR_SATS_PER_KW.value;

  set FEERATE_FLOOR_SATS_PER_KW(int value) =>
      _FEERATE_FLOOR_SATS_PER_KW.value = value;

  late final ffi.Pointer<ffi.Uint64> _CLOSED_CHANNEL_UPDATE_ID =
      _lookup<ffi.Uint64>('CLOSED_CHANNEL_UPDATE_ID');

  int get CLOSED_CHANNEL_UPDATE_ID => _CLOSED_CHANNEL_UPDATE_ID.value;

  set CLOSED_CHANNEL_UPDATE_ID(int value) =>
      _CLOSED_CHANNEL_UPDATE_ID.value = value;

  late final ffi.Pointer<ffi.Uint32> _ANTI_REORG_DELAY =
      _lookup<ffi.Uint32>('ANTI_REORG_DELAY');

  int get ANTI_REORG_DELAY => _ANTI_REORG_DELAY.value;

  set ANTI_REORG_DELAY(int value) => _ANTI_REORG_DELAY.value = value;

  late final ffi.Pointer<ffi.Uint16> _BREAKDOWN_TIMEOUT =
      _lookup<ffi.Uint16>('BREAKDOWN_TIMEOUT');

  int get BREAKDOWN_TIMEOUT => _BREAKDOWN_TIMEOUT.value;

  set BREAKDOWN_TIMEOUT(int value) => _BREAKDOWN_TIMEOUT.value = value;

  late final ffi.Pointer<ffi.Uint16> _MIN_CLTV_EXPIRY_DELTA =
      _lookup<ffi.Uint16>('MIN_CLTV_EXPIRY_DELTA');

  int get MIN_CLTV_EXPIRY_DELTA => _MIN_CLTV_EXPIRY_DELTA.value;

  set MIN_CLTV_EXPIRY_DELTA(int value) => _MIN_CLTV_EXPIRY_DELTA.value = value;

  late final ffi.Pointer<ffi.Uint32> _MIN_FINAL_CLTV_EXPIRY =
      _lookup<ffi.Uint32>('MIN_FINAL_CLTV_EXPIRY');

  int get MIN_FINAL_CLTV_EXPIRY => _MIN_FINAL_CLTV_EXPIRY.value;

  set MIN_FINAL_CLTV_EXPIRY(int value) => _MIN_FINAL_CLTV_EXPIRY.value = value;

  late final ffi.Pointer<uintptr_t> _REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH =
      _lookup<uintptr_t>('REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH');

  int get REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH =>
      _REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH.value;

  set REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH(int value) =>
      _REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH.value = value;

  late final ffi.Pointer<ffi.Uint64> _UNKNOWN_CHANNEL_CAPACITY_MSAT =
      _lookup<ffi.Uint64>('UNKNOWN_CHANNEL_CAPACITY_MSAT');

  int get UNKNOWN_CHANNEL_CAPACITY_MSAT => _UNKNOWN_CHANNEL_CAPACITY_MSAT.value;

  set UNKNOWN_CHANNEL_CAPACITY_MSAT(int value) =>
      _UNKNOWN_CHANNEL_CAPACITY_MSAT.value = value;

  late final ffi.Pointer<ffi.Uint32> _DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA =
      _lookup<ffi.Uint32>('DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA');

  int get DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA =>
      _DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA.value;

  set DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA(int value) =>
      _DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA.value = value;

  late final ffi.Pointer<ffi.Uint8> _DEFAULT_MAX_PATH_COUNT =
      _lookup<ffi.Uint8>('DEFAULT_MAX_PATH_COUNT');

  int get DEFAULT_MAX_PATH_COUNT => _DEFAULT_MAX_PATH_COUNT.value;

  set DEFAULT_MAX_PATH_COUNT(int value) =>
      _DEFAULT_MAX_PATH_COUNT.value = value;

  late final ffi.Pointer<ffi.Uint64> _MAX_TIMESTAMP =
      _lookup<ffi.Uint64>('MAX_TIMESTAMP');

  int get MAX_TIMESTAMP => _MAX_TIMESTAMP.value;

  set MAX_TIMESTAMP(int value) => _MAX_TIMESTAMP.value = value;

  late final ffi.Pointer<ffi.Uint64> _DEFAULT_EXPIRY_TIME =
      _lookup<ffi.Uint64>('DEFAULT_EXPIRY_TIME');

  int get DEFAULT_EXPIRY_TIME => _DEFAULT_EXPIRY_TIME.value;

  set DEFAULT_EXPIRY_TIME(int value) => _DEFAULT_EXPIRY_TIME.value = value;

  late final ffi.Pointer<ffi.Uint64> _DEFAULT_MIN_FINAL_CLTV_EXPIRY =
      _lookup<ffi.Uint64>('DEFAULT_MIN_FINAL_CLTV_EXPIRY');

  int get DEFAULT_MIN_FINAL_CLTV_EXPIRY => _DEFAULT_MIN_FINAL_CLTV_EXPIRY.value;

  set DEFAULT_MIN_FINAL_CLTV_EXPIRY(int value) =>
      _DEFAULT_MIN_FINAL_CLTV_EXPIRY.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_PAYMENT_HASH =
      _lookup<ffi.Uint8>('TAG_PAYMENT_HASH');

  int get TAG_PAYMENT_HASH => _TAG_PAYMENT_HASH.value;

  set TAG_PAYMENT_HASH(int value) => _TAG_PAYMENT_HASH.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_DESCRIPTION =
      _lookup<ffi.Uint8>('TAG_DESCRIPTION');

  int get TAG_DESCRIPTION => _TAG_DESCRIPTION.value;

  set TAG_DESCRIPTION(int value) => _TAG_DESCRIPTION.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_PAYEE_PUB_KEY =
      _lookup<ffi.Uint8>('TAG_PAYEE_PUB_KEY');

  int get TAG_PAYEE_PUB_KEY => _TAG_PAYEE_PUB_KEY.value;

  set TAG_PAYEE_PUB_KEY(int value) => _TAG_PAYEE_PUB_KEY.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_DESCRIPTION_HASH =
      _lookup<ffi.Uint8>('TAG_DESCRIPTION_HASH');

  int get TAG_DESCRIPTION_HASH => _TAG_DESCRIPTION_HASH.value;

  set TAG_DESCRIPTION_HASH(int value) => _TAG_DESCRIPTION_HASH.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_EXPIRY_TIME =
      _lookup<ffi.Uint8>('TAG_EXPIRY_TIME');

  int get TAG_EXPIRY_TIME => _TAG_EXPIRY_TIME.value;

  set TAG_EXPIRY_TIME(int value) => _TAG_EXPIRY_TIME.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_MIN_FINAL_CLTV_EXPIRY =
      _lookup<ffi.Uint8>('TAG_MIN_FINAL_CLTV_EXPIRY');

  int get TAG_MIN_FINAL_CLTV_EXPIRY => _TAG_MIN_FINAL_CLTV_EXPIRY.value;

  set TAG_MIN_FINAL_CLTV_EXPIRY(int value) =>
      _TAG_MIN_FINAL_CLTV_EXPIRY.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_FALLBACK =
      _lookup<ffi.Uint8>('TAG_FALLBACK');

  int get TAG_FALLBACK => _TAG_FALLBACK.value;

  set TAG_FALLBACK(int value) => _TAG_FALLBACK.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_PRIVATE_ROUTE =
      _lookup<ffi.Uint8>('TAG_PRIVATE_ROUTE');

  int get TAG_PRIVATE_ROUTE => _TAG_PRIVATE_ROUTE.value;

  set TAG_PRIVATE_ROUTE(int value) => _TAG_PRIVATE_ROUTE.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_PAYMENT_SECRET =
      _lookup<ffi.Uint8>('TAG_PAYMENT_SECRET');

  int get TAG_PAYMENT_SECRET => _TAG_PAYMENT_SECRET.value;

  set TAG_PAYMENT_SECRET(int value) => _TAG_PAYMENT_SECRET.value = value;

  late final ffi.Pointer<ffi.Uint8> _TAG_FEATURES =
      _lookup<ffi.Uint8>('TAG_FEATURES');

  int get TAG_FEATURES => _TAG_FEATURES.value;

  set TAG_FEATURES(int value) => _TAG_FEATURES.value = value;

  LDKStr _ldk_get_compiled_version() {
    return __ldk_get_compiled_version();
  }

  late final __ldk_get_compiled_versionPtr =
      _lookup<ffi.NativeFunction<LDKStr Function()>>(
          '_ldk_get_compiled_version');
  late final __ldk_get_compiled_version =
      __ldk_get_compiled_versionPtr.asFunction<LDKStr Function()>();

  LDKStr _ldk_c_bindings_get_compiled_version() {
    return __ldk_c_bindings_get_compiled_version();
  }

  late final __ldk_c_bindings_get_compiled_versionPtr =
      _lookup<ffi.NativeFunction<LDKStr Function()>>(
          '_ldk_c_bindings_get_compiled_version');
  late final __ldk_c_bindings_get_compiled_version =
      __ldk_c_bindings_get_compiled_versionPtr.asFunction<LDKStr Function()>();

  /// Creates a new Bech32Error which has the same data as `orig`
  LDKBech32Error Bech32Error_clone(
    ffi.Pointer<LDKBech32Error> orig,
  ) {
    return _Bech32Error_clone(
      orig,
    );
  }

  late final _Bech32Error_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKBech32Error Function(
              ffi.Pointer<LDKBech32Error>)>>('Bech32Error_clone');
  late final _Bech32Error_clone = _Bech32Error_clonePtr.asFunction<
      LDKBech32Error Function(ffi.Pointer<LDKBech32Error>)>();

  /// Releases any memory held by the given `Bech32Error` (which is currently none)
  void Bech32Error_free(
    LDKBech32Error o,
  ) {
    return _Bech32Error_free(
      o,
    );
  }

  late final _Bech32Error_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBech32Error)>>(
          'Bech32Error_free');
  late final _Bech32Error_free =
      _Bech32Error_freePtr.asFunction<void Function(LDKBech32Error)>();

  /// Frees the data buffer, if data_is_owned is set and datalen > 0.
  void Transaction_free(
    LDKTransaction _res,
  ) {
    return _Transaction_free(
      _res,
    );
  }

  late final _Transaction_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKTransaction)>>(
          'Transaction_free');
  late final _Transaction_free =
      _Transaction_freePtr.asFunction<void Function(LDKTransaction)>();

  /// Convenience function for constructing a new TxOut
  LDKTxOut TxOut_new(
    LDKCVec_u8Z script_pubkey,
    int value,
  ) {
    return _TxOut_new(
      script_pubkey,
      value,
    );
  }

  late final _TxOut_newPtr =
      _lookup<ffi.NativeFunction<LDKTxOut Function(LDKCVec_u8Z, ffi.Uint64)>>(
          'TxOut_new');
  late final _TxOut_new =
      _TxOut_newPtr.asFunction<LDKTxOut Function(LDKCVec_u8Z, int)>();

  /// Frees the data pointed to by script_pubkey.
  void TxOut_free(
    LDKTxOut _res,
  ) {
    return _TxOut_free(
      _res,
    );
  }

  late final _TxOut_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKTxOut)>>('TxOut_free');
  late final _TxOut_free = _TxOut_freePtr.asFunction<void Function(LDKTxOut)>();

  /// Creates a new TxOut which has the same data as `orig` but with a new script buffer.
  LDKTxOut TxOut_clone(
    ffi.Pointer<LDKTxOut> orig,
  ) {
    return _TxOut_clone(
      orig,
    );
  }

  late final _TxOut_clonePtr =
      _lookup<ffi.NativeFunction<LDKTxOut Function(ffi.Pointer<LDKTxOut>)>>(
          'TxOut_clone');
  late final _TxOut_clone =
      _TxOut_clonePtr.asFunction<LDKTxOut Function(ffi.Pointer<LDKTxOut>)>();

  /// Frees the data buffer, if chars_is_owned is set and len > 0.
  void Str_free(
    LDKStr _res,
  ) {
    return _Str_free(
      _res,
    );
  }

  late final _Str_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKStr)>>('Str_free');
  late final _Str_free = _Str_freePtr.asFunction<void Function(LDKStr)>();

  /// Creates a new CResult_NoneNoneZ in the success state.
  LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok() {
    return _CResult_NoneNoneZ_ok();
  }

  late final _CResult_NoneNoneZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneNoneZ Function()>>(
          'CResult_NoneNoneZ_ok');
  late final _CResult_NoneNoneZ_ok =
      _CResult_NoneNoneZ_okPtr.asFunction<LDKCResult_NoneNoneZ Function()>();

  /// Creates a new CResult_NoneNoneZ in the error state.
  LDKCResult_NoneNoneZ CResult_NoneNoneZ_err() {
    return _CResult_NoneNoneZ_err();
  }

  late final _CResult_NoneNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneNoneZ Function()>>(
          'CResult_NoneNoneZ_err');
  late final _CResult_NoneNoneZ_err =
      _CResult_NoneNoneZ_errPtr.asFunction<LDKCResult_NoneNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneNoneZ_is_ok(
    ffi.Pointer<LDKCResult_NoneNoneZ> o,
  ) {
    return _CResult_NoneNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneNoneZ_is_okPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKCResult_NoneNoneZ>)>>('CResult_NoneNoneZ_is_ok');
  late final _CResult_NoneNoneZ_is_ok = _CResult_NoneNoneZ_is_okPtr.asFunction<
      bool Function(ffi.Pointer<LDKCResult_NoneNoneZ>)>();

  /// Frees any resources used by the CResult_NoneNoneZ.
  void CResult_NoneNoneZ_free(
    LDKCResult_NoneNoneZ _res,
  ) {
    return _CResult_NoneNoneZ_free(
      _res,
    );
  }

  late final _CResult_NoneNoneZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_NoneNoneZ)>>(
          'CResult_NoneNoneZ_free');
  late final _CResult_NoneNoneZ_free = _CResult_NoneNoneZ_freePtr.asFunction<
      void Function(LDKCResult_NoneNoneZ)>();

  /// Creates a new CResult_NoneNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(
    ffi.Pointer<LDKCResult_NoneNoneZ> orig,
  ) {
    return _CResult_NoneNoneZ_clone(
      orig,
    );
  }

  late final _CResult_NoneNoneZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneNoneZ Function(
              ffi.Pointer<LDKCResult_NoneNoneZ>)>>('CResult_NoneNoneZ_clone');
  late final _CResult_NoneNoneZ_clone = _CResult_NoneNoneZ_clonePtr.asFunction<
      LDKCResult_NoneNoneZ Function(ffi.Pointer<LDKCResult_NoneNoneZ>)>();

  /// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ
      CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(
    LDKCounterpartyCommitmentSecrets o,
  ) {
    return _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
                  LDKCounterpartyCommitmentSecrets)>>(
      'CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok');
  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok =
      _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_okPtr.asFunction<
          LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
              LDKCounterpartyCommitmentSecrets)>();

  /// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ
      CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
                      LDKDecodeError)>>(
          'CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err');
  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err =
      _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_errPtr.asFunction<
          LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ> o,
  ) {
    return _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ>)>>(
      'CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok');
  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok =
      _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
  void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(
    LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res,
  ) {
    return _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ)>>(
          'CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free');
  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free =
      _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ)>();

  /// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ
      CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ> orig,
  ) {
    return _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ>)>>(
      'CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone');
  late final _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone =
      _CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ>)>();

  /// Creates a new CResult_SecretKeyErrorZ in the success state.
  LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(
    LDKSecretKey o,
  ) {
    return _CResult_SecretKeyErrorZ_ok(
      o,
    );
  }

  late final _CResult_SecretKeyErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SecretKeyErrorZ Function(
              LDKSecretKey)>>('CResult_SecretKeyErrorZ_ok');
  late final _CResult_SecretKeyErrorZ_ok = _CResult_SecretKeyErrorZ_okPtr
      .asFunction<LDKCResult_SecretKeyErrorZ Function(LDKSecretKey)>();

  /// Creates a new CResult_SecretKeyErrorZ in the error state.
  LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(
    int e,
  ) {
    return _CResult_SecretKeyErrorZ_err(
      e,
    );
  }

  late final _CResult_SecretKeyErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_SecretKeyErrorZ Function(ffi.Int32)>>(
      'CResult_SecretKeyErrorZ_err');
  late final _CResult_SecretKeyErrorZ_err = _CResult_SecretKeyErrorZ_errPtr
      .asFunction<LDKCResult_SecretKeyErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_SecretKeyErrorZ_is_ok(
    ffi.Pointer<LDKCResult_SecretKeyErrorZ> o,
  ) {
    return _CResult_SecretKeyErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_SecretKeyErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_SecretKeyErrorZ>)>>(
      'CResult_SecretKeyErrorZ_is_ok');
  late final _CResult_SecretKeyErrorZ_is_ok = _CResult_SecretKeyErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_SecretKeyErrorZ>)>();

  /// Frees any resources used by the CResult_SecretKeyErrorZ.
  void CResult_SecretKeyErrorZ_free(
    LDKCResult_SecretKeyErrorZ _res,
  ) {
    return _CResult_SecretKeyErrorZ_free(
      _res,
    );
  }

  late final _CResult_SecretKeyErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_SecretKeyErrorZ)>>(
      'CResult_SecretKeyErrorZ_free');
  late final _CResult_SecretKeyErrorZ_free = _CResult_SecretKeyErrorZ_freePtr
      .asFunction<void Function(LDKCResult_SecretKeyErrorZ)>();

  /// Creates a new CResult_SecretKeyErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_clone(
    ffi.Pointer<LDKCResult_SecretKeyErrorZ> orig,
  ) {
    return _CResult_SecretKeyErrorZ_clone(
      orig,
    );
  }

  late final _CResult_SecretKeyErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SecretKeyErrorZ Function(
                  ffi.Pointer<LDKCResult_SecretKeyErrorZ>)>>(
      'CResult_SecretKeyErrorZ_clone');
  late final _CResult_SecretKeyErrorZ_clone =
      _CResult_SecretKeyErrorZ_clonePtr.asFunction<
          LDKCResult_SecretKeyErrorZ Function(
              ffi.Pointer<LDKCResult_SecretKeyErrorZ>)>();

  /// Creates a new CResult_PublicKeyErrorZ in the success state.
  LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(
    LDKPublicKey o,
  ) {
    return _CResult_PublicKeyErrorZ_ok(
      o,
    );
  }

  late final _CResult_PublicKeyErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PublicKeyErrorZ Function(
              LDKPublicKey)>>('CResult_PublicKeyErrorZ_ok');
  late final _CResult_PublicKeyErrorZ_ok = _CResult_PublicKeyErrorZ_okPtr
      .asFunction<LDKCResult_PublicKeyErrorZ Function(LDKPublicKey)>();

  /// Creates a new CResult_PublicKeyErrorZ in the error state.
  LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(
    int e,
  ) {
    return _CResult_PublicKeyErrorZ_err(
      e,
    );
  }

  late final _CResult_PublicKeyErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PublicKeyErrorZ Function(ffi.Int32)>>(
      'CResult_PublicKeyErrorZ_err');
  late final _CResult_PublicKeyErrorZ_err = _CResult_PublicKeyErrorZ_errPtr
      .asFunction<LDKCResult_PublicKeyErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PublicKeyErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PublicKeyErrorZ> o,
  ) {
    return _CResult_PublicKeyErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PublicKeyErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_PublicKeyErrorZ>)>>(
      'CResult_PublicKeyErrorZ_is_ok');
  late final _CResult_PublicKeyErrorZ_is_ok = _CResult_PublicKeyErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_PublicKeyErrorZ>)>();

  /// Frees any resources used by the CResult_PublicKeyErrorZ.
  void CResult_PublicKeyErrorZ_free(
    LDKCResult_PublicKeyErrorZ _res,
  ) {
    return _CResult_PublicKeyErrorZ_free(
      _res,
    );
  }

  late final _CResult_PublicKeyErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_PublicKeyErrorZ)>>(
      'CResult_PublicKeyErrorZ_free');
  late final _CResult_PublicKeyErrorZ_free = _CResult_PublicKeyErrorZ_freePtr
      .asFunction<void Function(LDKCResult_PublicKeyErrorZ)>();

  /// Creates a new CResult_PublicKeyErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(
    ffi.Pointer<LDKCResult_PublicKeyErrorZ> orig,
  ) {
    return _CResult_PublicKeyErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PublicKeyErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PublicKeyErrorZ Function(
                  ffi.Pointer<LDKCResult_PublicKeyErrorZ>)>>(
      'CResult_PublicKeyErrorZ_clone');
  late final _CResult_PublicKeyErrorZ_clone =
      _CResult_PublicKeyErrorZ_clonePtr.asFunction<
          LDKCResult_PublicKeyErrorZ Function(
              ffi.Pointer<LDKCResult_PublicKeyErrorZ>)>();

  /// Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
  LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(
    LDKTxCreationKeys o,
  ) {
    return _CResult_TxCreationKeysDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_TxCreationKeysDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(
              LDKTxCreationKeys)>>('CResult_TxCreationKeysDecodeErrorZ_ok');
  late final _CResult_TxCreationKeysDecodeErrorZ_ok =
      _CResult_TxCreationKeysDecodeErrorZ_okPtr.asFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(LDKTxCreationKeys)>();

  /// Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
  LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_TxCreationKeysDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_TxCreationKeysDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_TxCreationKeysDecodeErrorZ_err');
  late final _CResult_TxCreationKeysDecodeErrorZ_err =
      _CResult_TxCreationKeysDecodeErrorZ_errPtr.asFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_TxCreationKeysDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ> o,
  ) {
    return _CResult_TxCreationKeysDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_TxCreationKeysDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ>)>>(
      'CResult_TxCreationKeysDecodeErrorZ_is_ok');
  late final _CResult_TxCreationKeysDecodeErrorZ_is_ok =
      _CResult_TxCreationKeysDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
  void CResult_TxCreationKeysDecodeErrorZ_free(
    LDKCResult_TxCreationKeysDecodeErrorZ _res,
  ) {
    return _CResult_TxCreationKeysDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_TxCreationKeysDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_TxCreationKeysDecodeErrorZ)>>(
      'CResult_TxCreationKeysDecodeErrorZ_free');
  late final _CResult_TxCreationKeysDecodeErrorZ_free =
      _CResult_TxCreationKeysDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_TxCreationKeysDecodeErrorZ)>();

  /// Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_TxCreationKeysDecodeErrorZ
      CResult_TxCreationKeysDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ> orig,
  ) {
    return _CResult_TxCreationKeysDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_TxCreationKeysDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TxCreationKeysDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ>)>>(
      'CResult_TxCreationKeysDecodeErrorZ_clone');
  late final _CResult_TxCreationKeysDecodeErrorZ_clone =
      _CResult_TxCreationKeysDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_TxCreationKeysDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
  LDKCResult_ChannelPublicKeysDecodeErrorZ
      CResult_ChannelPublicKeysDecodeErrorZ_ok(
    LDKChannelPublicKeys o,
  ) {
    return _CResult_ChannelPublicKeysDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelPublicKeysDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
                  LDKChannelPublicKeys)>>(
      'CResult_ChannelPublicKeysDecodeErrorZ_ok');
  late final _CResult_ChannelPublicKeysDecodeErrorZ_ok =
      _CResult_ChannelPublicKeysDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
              LDKChannelPublicKeys)>();

  /// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
  LDKCResult_ChannelPublicKeysDecodeErrorZ
      CResult_ChannelPublicKeysDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelPublicKeysDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelPublicKeysDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelPublicKeysDecodeErrorZ_err');
  late final _CResult_ChannelPublicKeysDecodeErrorZ_err =
      _CResult_ChannelPublicKeysDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelPublicKeysDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ> o,
  ) {
    return _CResult_ChannelPublicKeysDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelPublicKeysDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ>)>>(
      'CResult_ChannelPublicKeysDecodeErrorZ_is_ok');
  late final _CResult_ChannelPublicKeysDecodeErrorZ_is_ok =
      _CResult_ChannelPublicKeysDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
  void CResult_ChannelPublicKeysDecodeErrorZ_free(
    LDKCResult_ChannelPublicKeysDecodeErrorZ _res,
  ) {
    return _CResult_ChannelPublicKeysDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelPublicKeysDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelPublicKeysDecodeErrorZ)>>(
      'CResult_ChannelPublicKeysDecodeErrorZ_free');
  late final _CResult_ChannelPublicKeysDecodeErrorZ_free =
      _CResult_ChannelPublicKeysDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelPublicKeysDecodeErrorZ)>();

  /// Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelPublicKeysDecodeErrorZ
      CResult_ChannelPublicKeysDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelPublicKeysDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelPublicKeysDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ>)>>(
      'CResult_ChannelPublicKeysDecodeErrorZ_clone');
  late final _CResult_ChannelPublicKeysDecodeErrorZ_clone =
      _CResult_ChannelPublicKeysDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelPublicKeysDecodeErrorZ>)>();

  /// Creates a new CResult_TxCreationKeysErrorZ in the success state.
  LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(
    LDKTxCreationKeys o,
  ) {
    return _CResult_TxCreationKeysErrorZ_ok(
      o,
    );
  }

  late final _CResult_TxCreationKeysErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysErrorZ Function(
              LDKTxCreationKeys)>>('CResult_TxCreationKeysErrorZ_ok');
  late final _CResult_TxCreationKeysErrorZ_ok =
      _CResult_TxCreationKeysErrorZ_okPtr.asFunction<
          LDKCResult_TxCreationKeysErrorZ Function(LDKTxCreationKeys)>();

  /// Creates a new CResult_TxCreationKeysErrorZ in the error state.
  LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(
    int e,
  ) {
    return _CResult_TxCreationKeysErrorZ_err(
      e,
    );
  }

  late final _CResult_TxCreationKeysErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysErrorZ Function(
              ffi.Int32)>>('CResult_TxCreationKeysErrorZ_err');
  late final _CResult_TxCreationKeysErrorZ_err =
      _CResult_TxCreationKeysErrorZ_errPtr.asFunction<
          LDKCResult_TxCreationKeysErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_TxCreationKeysErrorZ_is_ok(
    ffi.Pointer<LDKCResult_TxCreationKeysErrorZ> o,
  ) {
    return _CResult_TxCreationKeysErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_TxCreationKeysErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_TxCreationKeysErrorZ>)>>(
      'CResult_TxCreationKeysErrorZ_is_ok');
  late final _CResult_TxCreationKeysErrorZ_is_ok =
      _CResult_TxCreationKeysErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_TxCreationKeysErrorZ>)>();

  /// Frees any resources used by the CResult_TxCreationKeysErrorZ.
  void CResult_TxCreationKeysErrorZ_free(
    LDKCResult_TxCreationKeysErrorZ _res,
  ) {
    return _CResult_TxCreationKeysErrorZ_free(
      _res,
    );
  }

  late final _CResult_TxCreationKeysErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_TxCreationKeysErrorZ)>>(
      'CResult_TxCreationKeysErrorZ_free');
  late final _CResult_TxCreationKeysErrorZ_free =
      _CResult_TxCreationKeysErrorZ_freePtr.asFunction<
          void Function(LDKCResult_TxCreationKeysErrorZ)>();

  /// Creates a new CResult_TxCreationKeysErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_clone(
    ffi.Pointer<LDKCResult_TxCreationKeysErrorZ> orig,
  ) {
    return _CResult_TxCreationKeysErrorZ_clone(
      orig,
    );
  }

  late final _CResult_TxCreationKeysErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TxCreationKeysErrorZ Function(
                  ffi.Pointer<LDKCResult_TxCreationKeysErrorZ>)>>(
      'CResult_TxCreationKeysErrorZ_clone');
  late final _CResult_TxCreationKeysErrorZ_clone =
      _CResult_TxCreationKeysErrorZ_clonePtr.asFunction<
          LDKCResult_TxCreationKeysErrorZ Function(
              ffi.Pointer<LDKCResult_TxCreationKeysErrorZ>)>();

  /// Constructs a new COption_u32Z containing a u32
  LDKCOption_u32Z COption_u32Z_some(
    int o,
  ) {
    return _COption_u32Z_some(
      o,
    );
  }

  late final _COption_u32Z_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u32Z Function(ffi.Uint32)>>(
          'COption_u32Z_some');
  late final _COption_u32Z_some =
      _COption_u32Z_somePtr.asFunction<LDKCOption_u32Z Function(int)>();

  /// Constructs a new COption_u32Z containing nothing
  LDKCOption_u32Z COption_u32Z_none() {
    return _COption_u32Z_none();
  }

  late final _COption_u32Z_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u32Z Function()>>(
          'COption_u32Z_none');
  late final _COption_u32Z_none =
      _COption_u32Z_nonePtr.asFunction<LDKCOption_u32Z Function()>();

  /// Frees any resources associated with the u32, if we are in the Some state
  void COption_u32Z_free(
    LDKCOption_u32Z _res,
  ) {
    return _COption_u32Z_free(
      _res,
    );
  }

  late final _COption_u32Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_u32Z)>>(
          'COption_u32Z_free');
  late final _COption_u32Z_free =
      _COption_u32Z_freePtr.asFunction<void Function(LDKCOption_u32Z)>();

  /// Creates a new COption_u32Z which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_u32Z COption_u32Z_clone(
    ffi.Pointer<LDKCOption_u32Z> orig,
  ) {
    return _COption_u32Z_clone(
      orig,
    );
  }

  late final _COption_u32Z_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u32Z Function(
              ffi.Pointer<LDKCOption_u32Z>)>>('COption_u32Z_clone');
  late final _COption_u32Z_clone = _COption_u32Z_clonePtr.asFunction<
      LDKCOption_u32Z Function(ffi.Pointer<LDKCOption_u32Z>)>();

  /// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
  LDKCResult_HTLCOutputInCommitmentDecodeErrorZ
      CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(
    LDKHTLCOutputInCommitment o,
  ) {
    return _CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
                  LDKHTLCOutputInCommitment)>>(
      'CResult_HTLCOutputInCommitmentDecodeErrorZ_ok');
  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_ok =
      _CResult_HTLCOutputInCommitmentDecodeErrorZ_okPtr.asFunction<
          LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
              LDKHTLCOutputInCommitment)>();

  /// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
  LDKCResult_HTLCOutputInCommitmentDecodeErrorZ
      CResult_HTLCOutputInCommitmentDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_HTLCOutputInCommitmentDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_HTLCOutputInCommitmentDecodeErrorZ_err');
  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_err =
      _CResult_HTLCOutputInCommitmentDecodeErrorZ_errPtr.asFunction<
          LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ> o,
  ) {
    return _CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ>)>>(
      'CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok');
  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok =
      _CResult_HTLCOutputInCommitmentDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
  void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(
    LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res,
  ) {
    return _CResult_HTLCOutputInCommitmentDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_HTLCOutputInCommitmentDecodeErrorZ)>>(
      'CResult_HTLCOutputInCommitmentDecodeErrorZ_free');
  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_free =
      _CResult_HTLCOutputInCommitmentDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ)>();

  /// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_HTLCOutputInCommitmentDecodeErrorZ
      CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ> orig,
  ) {
    return _CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ>)>>(
      'CResult_HTLCOutputInCommitmentDecodeErrorZ_clone');
  late final _CResult_HTLCOutputInCommitmentDecodeErrorZ_clone =
      _CResult_HTLCOutputInCommitmentDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_HTLCOutputInCommitmentDecodeErrorZ>)>();

  /// Constructs a new COption_NoneZ containing a
  int COption_NoneZ_some() {
    return _COption_NoneZ_some();
  }

  late final _COption_NoneZ_somePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('COption_NoneZ_some');
  late final _COption_NoneZ_some =
      _COption_NoneZ_somePtr.asFunction<int Function()>();

  /// Constructs a new COption_NoneZ containing nothing
  int COption_NoneZ_none() {
    return _COption_NoneZ_none();
  }

  late final _COption_NoneZ_nonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('COption_NoneZ_none');
  late final _COption_NoneZ_none =
      _COption_NoneZ_nonePtr.asFunction<int Function()>();

  /// Frees any resources associated with the , if we are in the Some state
  void COption_NoneZ_free(
    int _res,
  ) {
    return _COption_NoneZ_free(
      _res,
    );
  }

  late final _COption_NoneZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'COption_NoneZ_free');
  late final _COption_NoneZ_free =
      _COption_NoneZ_freePtr.asFunction<void Function(int)>();

  /// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
      CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(
    LDKCounterpartyChannelTransactionParameters o,
  ) {
    return _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
                      Function(LDKCounterpartyChannelTransactionParameters)>>(
          'CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok');
  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok =
      _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_okPtr
          .asFunction<
              LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
                  Function(LDKCounterpartyChannelTransactionParameters)>();

  /// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
      CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
                      Function(LDKDecodeError)>>(
          'CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err');
  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err =
      _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_errPtr
          .asFunction<
              LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
                  Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>
        o,
  ) {
    return _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_okPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<
                          LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>)>>(
          'CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok');
  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok =
      _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_okPtr
          .asFunction<
              bool Function(
                  ffi.Pointer<
                      LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
  void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(
    LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res,
  ) {
    return _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ)>>(
          'CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free');
  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free =
      _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_freePtr
          .asFunction<
              void Function(
                  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ)>();

  /// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
      CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>
        orig,
  ) {
    return _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clonePtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ Function(
                      ffi.Pointer<
                          LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>)>>(
          'CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone');
  late final _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone =
      _CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
  LDKCResult_ChannelTransactionParametersDecodeErrorZ
      CResult_ChannelTransactionParametersDecodeErrorZ_ok(
    LDKChannelTransactionParameters o,
  ) {
    return _CResult_ChannelTransactionParametersDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelTransactionParametersDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
                  LDKChannelTransactionParameters)>>(
      'CResult_ChannelTransactionParametersDecodeErrorZ_ok');
  late final _CResult_ChannelTransactionParametersDecodeErrorZ_ok =
      _CResult_ChannelTransactionParametersDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
              LDKChannelTransactionParameters)>();

  /// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
  LDKCResult_ChannelTransactionParametersDecodeErrorZ
      CResult_ChannelTransactionParametersDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelTransactionParametersDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelTransactionParametersDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_ChannelTransactionParametersDecodeErrorZ_err');
  late final _CResult_ChannelTransactionParametersDecodeErrorZ_err =
      _CResult_ChannelTransactionParametersDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelTransactionParametersDecodeErrorZ> o,
  ) {
    return _CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelTransactionParametersDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_ChannelTransactionParametersDecodeErrorZ>)>>(
      'CResult_ChannelTransactionParametersDecodeErrorZ_is_ok');
  late final _CResult_ChannelTransactionParametersDecodeErrorZ_is_ok =
      _CResult_ChannelTransactionParametersDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_ChannelTransactionParametersDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
  void CResult_ChannelTransactionParametersDecodeErrorZ_free(
    LDKCResult_ChannelTransactionParametersDecodeErrorZ _res,
  ) {
    return _CResult_ChannelTransactionParametersDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelTransactionParametersDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_ChannelTransactionParametersDecodeErrorZ)>>(
          'CResult_ChannelTransactionParametersDecodeErrorZ_free');
  late final _CResult_ChannelTransactionParametersDecodeErrorZ_free =
      _CResult_ChannelTransactionParametersDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelTransactionParametersDecodeErrorZ)>();

  /// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelTransactionParametersDecodeErrorZ
      CResult_ChannelTransactionParametersDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelTransactionParametersDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelTransactionParametersDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelTransactionParametersDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_ChannelTransactionParametersDecodeErrorZ>)>>(
      'CResult_ChannelTransactionParametersDecodeErrorZ_clone');
  late final _CResult_ChannelTransactionParametersDecodeErrorZ_clone =
      _CResult_ChannelTransactionParametersDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_ChannelTransactionParametersDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_SignatureZ_free(
    LDKCVec_SignatureZ _res,
  ) {
    return _CVec_SignatureZ_free(
      _res,
    );
  }

  late final _CVec_SignatureZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_SignatureZ)>>(
          'CVec_SignatureZ_free');
  late final _CVec_SignatureZ_free =
      _CVec_SignatureZ_freePtr.asFunction<void Function(LDKCVec_SignatureZ)>();

  /// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
  LDKCResult_HolderCommitmentTransactionDecodeErrorZ
      CResult_HolderCommitmentTransactionDecodeErrorZ_ok(
    LDKHolderCommitmentTransaction o,
  ) {
    return _CResult_HolderCommitmentTransactionDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
                  LDKHolderCommitmentTransaction)>>(
      'CResult_HolderCommitmentTransactionDecodeErrorZ_ok');
  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_ok =
      _CResult_HolderCommitmentTransactionDecodeErrorZ_okPtr.asFunction<
          LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
              LDKHolderCommitmentTransaction)>();

  /// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
  LDKCResult_HolderCommitmentTransactionDecodeErrorZ
      CResult_HolderCommitmentTransactionDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_HolderCommitmentTransactionDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_HolderCommitmentTransactionDecodeErrorZ_err');
  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_err =
      _CResult_HolderCommitmentTransactionDecodeErrorZ_errPtr.asFunction<
          LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_HolderCommitmentTransactionDecodeErrorZ> o,
  ) {
    return _CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_HolderCommitmentTransactionDecodeErrorZ>)>>(
      'CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok');
  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok =
      _CResult_HolderCommitmentTransactionDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_HolderCommitmentTransactionDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
  void CResult_HolderCommitmentTransactionDecodeErrorZ_free(
    LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res,
  ) {
    return _CResult_HolderCommitmentTransactionDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_HolderCommitmentTransactionDecodeErrorZ)>>(
      'CResult_HolderCommitmentTransactionDecodeErrorZ_free');
  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_free =
      _CResult_HolderCommitmentTransactionDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_HolderCommitmentTransactionDecodeErrorZ)>();

  /// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_HolderCommitmentTransactionDecodeErrorZ
      CResult_HolderCommitmentTransactionDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_HolderCommitmentTransactionDecodeErrorZ> orig,
  ) {
    return _CResult_HolderCommitmentTransactionDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_HolderCommitmentTransactionDecodeErrorZ>)>>(
      'CResult_HolderCommitmentTransactionDecodeErrorZ_clone');
  late final _CResult_HolderCommitmentTransactionDecodeErrorZ_clone =
      _CResult_HolderCommitmentTransactionDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_HolderCommitmentTransactionDecodeErrorZ>)>();

  /// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ
      CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(
    LDKBuiltCommitmentTransaction o,
  ) {
    return _CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
                  LDKBuiltCommitmentTransaction)>>(
      'CResult_BuiltCommitmentTransactionDecodeErrorZ_ok');
  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_ok =
      _CResult_BuiltCommitmentTransactionDecodeErrorZ_okPtr.asFunction<
          LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
              LDKBuiltCommitmentTransaction)>();

  /// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ
      CResult_BuiltCommitmentTransactionDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_BuiltCommitmentTransactionDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_BuiltCommitmentTransactionDecodeErrorZ_err');
  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_err =
      _CResult_BuiltCommitmentTransactionDecodeErrorZ_errPtr.asFunction<
          LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_BuiltCommitmentTransactionDecodeErrorZ> o,
  ) {
    return _CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_BuiltCommitmentTransactionDecodeErrorZ>)>>(
      'CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok');
  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok =
      _CResult_BuiltCommitmentTransactionDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
  void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(
    LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res,
  ) {
    return _CResult_BuiltCommitmentTransactionDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ)>>(
      'CResult_BuiltCommitmentTransactionDecodeErrorZ_free');
  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_free =
      _CResult_BuiltCommitmentTransactionDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ)>();

  /// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ
      CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_BuiltCommitmentTransactionDecodeErrorZ> orig,
  ) {
    return _CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_BuiltCommitmentTransactionDecodeErrorZ>)>>(
      'CResult_BuiltCommitmentTransactionDecodeErrorZ_clone');
  late final _CResult_BuiltCommitmentTransactionDecodeErrorZ_clone =
      _CResult_BuiltCommitmentTransactionDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ>)>();

  /// Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
  LDKCResult_TrustedClosingTransactionNoneZ
      CResult_TrustedClosingTransactionNoneZ_ok(
    LDKTrustedClosingTransaction o,
  ) {
    return _CResult_TrustedClosingTransactionNoneZ_ok(
      o,
    );
  }

  late final _CResult_TrustedClosingTransactionNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TrustedClosingTransactionNoneZ Function(
                  LDKTrustedClosingTransaction)>>(
      'CResult_TrustedClosingTransactionNoneZ_ok');
  late final _CResult_TrustedClosingTransactionNoneZ_ok =
      _CResult_TrustedClosingTransactionNoneZ_okPtr.asFunction<
          LDKCResult_TrustedClosingTransactionNoneZ Function(
              LDKTrustedClosingTransaction)>();

  /// Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
  LDKCResult_TrustedClosingTransactionNoneZ
      CResult_TrustedClosingTransactionNoneZ_err() {
    return _CResult_TrustedClosingTransactionNoneZ_err();
  }

  late final _CResult_TrustedClosingTransactionNoneZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TrustedClosingTransactionNoneZ
              Function()>>('CResult_TrustedClosingTransactionNoneZ_err');
  late final _CResult_TrustedClosingTransactionNoneZ_err =
      _CResult_TrustedClosingTransactionNoneZ_errPtr.asFunction<
          LDKCResult_TrustedClosingTransactionNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_TrustedClosingTransactionNoneZ_is_ok(
    ffi.Pointer<LDKCResult_TrustedClosingTransactionNoneZ> o,
  ) {
    return _CResult_TrustedClosingTransactionNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_TrustedClosingTransactionNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_TrustedClosingTransactionNoneZ>)>>(
      'CResult_TrustedClosingTransactionNoneZ_is_ok');
  late final _CResult_TrustedClosingTransactionNoneZ_is_ok =
      _CResult_TrustedClosingTransactionNoneZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_TrustedClosingTransactionNoneZ>)>();

  /// Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
  void CResult_TrustedClosingTransactionNoneZ_free(
    LDKCResult_TrustedClosingTransactionNoneZ _res,
  ) {
    return _CResult_TrustedClosingTransactionNoneZ_free(
      _res,
    );
  }

  late final _CResult_TrustedClosingTransactionNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_TrustedClosingTransactionNoneZ)>>(
      'CResult_TrustedClosingTransactionNoneZ_free');
  late final _CResult_TrustedClosingTransactionNoneZ_free =
      _CResult_TrustedClosingTransactionNoneZ_freePtr.asFunction<
          void Function(LDKCResult_TrustedClosingTransactionNoneZ)>();

  /// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
  LDKCResult_CommitmentTransactionDecodeErrorZ
      CResult_CommitmentTransactionDecodeErrorZ_ok(
    LDKCommitmentTransaction o,
  ) {
    return _CResult_CommitmentTransactionDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_CommitmentTransactionDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CommitmentTransactionDecodeErrorZ Function(
                  LDKCommitmentTransaction)>>(
      'CResult_CommitmentTransactionDecodeErrorZ_ok');
  late final _CResult_CommitmentTransactionDecodeErrorZ_ok =
      _CResult_CommitmentTransactionDecodeErrorZ_okPtr.asFunction<
          LDKCResult_CommitmentTransactionDecodeErrorZ Function(
              LDKCommitmentTransaction)>();

  /// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
  LDKCResult_CommitmentTransactionDecodeErrorZ
      CResult_CommitmentTransactionDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_CommitmentTransactionDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_CommitmentTransactionDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CommitmentTransactionDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_CommitmentTransactionDecodeErrorZ_err');
  late final _CResult_CommitmentTransactionDecodeErrorZ_err =
      _CResult_CommitmentTransactionDecodeErrorZ_errPtr.asFunction<
          LDKCResult_CommitmentTransactionDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ> o,
  ) {
    return _CResult_CommitmentTransactionDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CommitmentTransactionDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ>)>>(
      'CResult_CommitmentTransactionDecodeErrorZ_is_ok');
  late final _CResult_CommitmentTransactionDecodeErrorZ_is_ok =
      _CResult_CommitmentTransactionDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
  void CResult_CommitmentTransactionDecodeErrorZ_free(
    LDKCResult_CommitmentTransactionDecodeErrorZ _res,
  ) {
    return _CResult_CommitmentTransactionDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_CommitmentTransactionDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_CommitmentTransactionDecodeErrorZ)>>(
      'CResult_CommitmentTransactionDecodeErrorZ_free');
  late final _CResult_CommitmentTransactionDecodeErrorZ_free =
      _CResult_CommitmentTransactionDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_CommitmentTransactionDecodeErrorZ)>();

  /// Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CommitmentTransactionDecodeErrorZ
      CResult_CommitmentTransactionDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ> orig,
  ) {
    return _CResult_CommitmentTransactionDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CommitmentTransactionDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CommitmentTransactionDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ>)>>(
      'CResult_CommitmentTransactionDecodeErrorZ_clone');
  late final _CResult_CommitmentTransactionDecodeErrorZ_clone =
      _CResult_CommitmentTransactionDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_CommitmentTransactionDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_CommitmentTransactionDecodeErrorZ>)>();

  /// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
  LDKCResult_TrustedCommitmentTransactionNoneZ
      CResult_TrustedCommitmentTransactionNoneZ_ok(
    LDKTrustedCommitmentTransaction o,
  ) {
    return _CResult_TrustedCommitmentTransactionNoneZ_ok(
      o,
    );
  }

  late final _CResult_TrustedCommitmentTransactionNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TrustedCommitmentTransactionNoneZ Function(
                  LDKTrustedCommitmentTransaction)>>(
      'CResult_TrustedCommitmentTransactionNoneZ_ok');
  late final _CResult_TrustedCommitmentTransactionNoneZ_ok =
      _CResult_TrustedCommitmentTransactionNoneZ_okPtr.asFunction<
          LDKCResult_TrustedCommitmentTransactionNoneZ Function(
              LDKTrustedCommitmentTransaction)>();

  /// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
  LDKCResult_TrustedCommitmentTransactionNoneZ
      CResult_TrustedCommitmentTransactionNoneZ_err() {
    return _CResult_TrustedCommitmentTransactionNoneZ_err();
  }

  late final _CResult_TrustedCommitmentTransactionNoneZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TrustedCommitmentTransactionNoneZ
              Function()>>('CResult_TrustedCommitmentTransactionNoneZ_err');
  late final _CResult_TrustedCommitmentTransactionNoneZ_err =
      _CResult_TrustedCommitmentTransactionNoneZ_errPtr.asFunction<
          LDKCResult_TrustedCommitmentTransactionNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(
    ffi.Pointer<LDKCResult_TrustedCommitmentTransactionNoneZ> o,
  ) {
    return _CResult_TrustedCommitmentTransactionNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_TrustedCommitmentTransactionNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_TrustedCommitmentTransactionNoneZ>)>>(
      'CResult_TrustedCommitmentTransactionNoneZ_is_ok');
  late final _CResult_TrustedCommitmentTransactionNoneZ_is_ok =
      _CResult_TrustedCommitmentTransactionNoneZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_TrustedCommitmentTransactionNoneZ>)>();

  /// Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
  void CResult_TrustedCommitmentTransactionNoneZ_free(
    LDKCResult_TrustedCommitmentTransactionNoneZ _res,
  ) {
    return _CResult_TrustedCommitmentTransactionNoneZ_free(
      _res,
    );
  }

  late final _CResult_TrustedCommitmentTransactionNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_TrustedCommitmentTransactionNoneZ)>>(
      'CResult_TrustedCommitmentTransactionNoneZ_free');
  late final _CResult_TrustedCommitmentTransactionNoneZ_free =
      _CResult_TrustedCommitmentTransactionNoneZ_freePtr.asFunction<
          void Function(LDKCResult_TrustedCommitmentTransactionNoneZ)>();

  /// Creates a new CResult_CVec_SignatureZNoneZ in the success state.
  LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(
    LDKCVec_SignatureZ o,
  ) {
    return _CResult_CVec_SignatureZNoneZ_ok(
      o,
    );
  }

  late final _CResult_CVec_SignatureZNoneZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_SignatureZNoneZ Function(
              LDKCVec_SignatureZ)>>('CResult_CVec_SignatureZNoneZ_ok');
  late final _CResult_CVec_SignatureZNoneZ_ok =
      _CResult_CVec_SignatureZNoneZ_okPtr.asFunction<
          LDKCResult_CVec_SignatureZNoneZ Function(LDKCVec_SignatureZ)>();

  /// Creates a new CResult_CVec_SignatureZNoneZ in the error state.
  LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err() {
    return _CResult_CVec_SignatureZNoneZ_err();
  }

  late final _CResult_CVec_SignatureZNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_CVec_SignatureZNoneZ Function()>>(
          'CResult_CVec_SignatureZNoneZ_err');
  late final _CResult_CVec_SignatureZNoneZ_err =
      _CResult_CVec_SignatureZNoneZ_errPtr.asFunction<
          LDKCResult_CVec_SignatureZNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_CVec_SignatureZNoneZ_is_ok(
    ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ> o,
  ) {
    return _CResult_CVec_SignatureZNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_CVec_SignatureZNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ>)>>(
      'CResult_CVec_SignatureZNoneZ_is_ok');
  late final _CResult_CVec_SignatureZNoneZ_is_ok =
      _CResult_CVec_SignatureZNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ>)>();

  /// Frees any resources used by the CResult_CVec_SignatureZNoneZ.
  void CResult_CVec_SignatureZNoneZ_free(
    LDKCResult_CVec_SignatureZNoneZ _res,
  ) {
    return _CResult_CVec_SignatureZNoneZ_free(
      _res,
    );
  }

  late final _CResult_CVec_SignatureZNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_CVec_SignatureZNoneZ)>>(
      'CResult_CVec_SignatureZNoneZ_free');
  late final _CResult_CVec_SignatureZNoneZ_free =
      _CResult_CVec_SignatureZNoneZ_freePtr.asFunction<
          void Function(LDKCResult_CVec_SignatureZNoneZ)>();

  /// Creates a new CResult_CVec_SignatureZNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(
    ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ> orig,
  ) {
    return _CResult_CVec_SignatureZNoneZ_clone(
      orig,
    );
  }

  late final _CResult_CVec_SignatureZNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_SignatureZNoneZ Function(
                  ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ>)>>(
      'CResult_CVec_SignatureZNoneZ_clone');
  late final _CResult_CVec_SignatureZNoneZ_clone =
      _CResult_CVec_SignatureZNoneZ_clonePtr.asFunction<
          LDKCResult_CVec_SignatureZNoneZ Function(
              ffi.Pointer<LDKCResult_CVec_SignatureZNoneZ>)>();

  /// Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
  LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(
    LDKShutdownScript o,
  ) {
    return _CResult_ShutdownScriptDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ShutdownScriptDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(
              LDKShutdownScript)>>('CResult_ShutdownScriptDecodeErrorZ_ok');
  late final _CResult_ShutdownScriptDecodeErrorZ_ok =
      _CResult_ShutdownScriptDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(LDKShutdownScript)>();

  /// Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
  LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ShutdownScriptDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ShutdownScriptDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ShutdownScriptDecodeErrorZ_err');
  late final _CResult_ShutdownScriptDecodeErrorZ_err =
      _CResult_ShutdownScriptDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ShutdownScriptDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ> o,
  ) {
    return _CResult_ShutdownScriptDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ShutdownScriptDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ>)>>(
      'CResult_ShutdownScriptDecodeErrorZ_is_ok');
  late final _CResult_ShutdownScriptDecodeErrorZ_is_ok =
      _CResult_ShutdownScriptDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
  void CResult_ShutdownScriptDecodeErrorZ_free(
    LDKCResult_ShutdownScriptDecodeErrorZ _res,
  ) {
    return _CResult_ShutdownScriptDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ShutdownScriptDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ShutdownScriptDecodeErrorZ)>>(
      'CResult_ShutdownScriptDecodeErrorZ_free');
  late final _CResult_ShutdownScriptDecodeErrorZ_free =
      _CResult_ShutdownScriptDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ShutdownScriptDecodeErrorZ)>();

  /// Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ShutdownScriptDecodeErrorZ
      CResult_ShutdownScriptDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ> orig,
  ) {
    return _CResult_ShutdownScriptDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ShutdownScriptDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ShutdownScriptDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ>)>>(
      'CResult_ShutdownScriptDecodeErrorZ_clone');
  late final _CResult_ShutdownScriptDecodeErrorZ_clone =
      _CResult_ShutdownScriptDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ShutdownScriptDecodeErrorZ>)>();

  /// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
  LDKCResult_ShutdownScriptInvalidShutdownScriptZ
      CResult_ShutdownScriptInvalidShutdownScriptZ_ok(
    LDKShutdownScript o,
  ) {
    return _CResult_ShutdownScriptInvalidShutdownScriptZ_ok(
      o,
    );
  }

  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
                  LDKShutdownScript)>>(
      'CResult_ShutdownScriptInvalidShutdownScriptZ_ok');
  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_ok =
      _CResult_ShutdownScriptInvalidShutdownScriptZ_okPtr.asFunction<
          LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
              LDKShutdownScript)>();

  /// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
  LDKCResult_ShutdownScriptInvalidShutdownScriptZ
      CResult_ShutdownScriptInvalidShutdownScriptZ_err(
    LDKInvalidShutdownScript e,
  ) {
    return _CResult_ShutdownScriptInvalidShutdownScriptZ_err(
      e,
    );
  }

  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
                  LDKInvalidShutdownScript)>>(
      'CResult_ShutdownScriptInvalidShutdownScriptZ_err');
  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_err =
      _CResult_ShutdownScriptInvalidShutdownScriptZ_errPtr.asFunction<
          LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
              LDKInvalidShutdownScript)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(
    ffi.Pointer<LDKCResult_ShutdownScriptInvalidShutdownScriptZ> o,
  ) {
    return _CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(
      o,
    );
  }

  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_ShutdownScriptInvalidShutdownScriptZ>)>>(
      'CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok');
  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok =
      _CResult_ShutdownScriptInvalidShutdownScriptZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ShutdownScriptInvalidShutdownScriptZ>)>();

  /// Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
  void CResult_ShutdownScriptInvalidShutdownScriptZ_free(
    LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res,
  ) {
    return _CResult_ShutdownScriptInvalidShutdownScriptZ_free(
      _res,
    );
  }

  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_ShutdownScriptInvalidShutdownScriptZ)>>(
      'CResult_ShutdownScriptInvalidShutdownScriptZ_free');
  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_free =
      _CResult_ShutdownScriptInvalidShutdownScriptZ_freePtr.asFunction<
          void Function(LDKCResult_ShutdownScriptInvalidShutdownScriptZ)>();

  /// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ShutdownScriptInvalidShutdownScriptZ
      CResult_ShutdownScriptInvalidShutdownScriptZ_clone(
    ffi.Pointer<LDKCResult_ShutdownScriptInvalidShutdownScriptZ> orig,
  ) {
    return _CResult_ShutdownScriptInvalidShutdownScriptZ_clone(
      orig,
    );
  }

  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
                  ffi.Pointer<
                      LDKCResult_ShutdownScriptInvalidShutdownScriptZ>)>>(
      'CResult_ShutdownScriptInvalidShutdownScriptZ_clone');
  late final _CResult_ShutdownScriptInvalidShutdownScriptZ_clone =
      _CResult_ShutdownScriptInvalidShutdownScriptZ_clonePtr.asFunction<
          LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
              ffi.Pointer<LDKCResult_ShutdownScriptInvalidShutdownScriptZ>)>();

  /// Creates a new CResult_NoneErrorZ in the success state.
  LDKCResult_NoneErrorZ CResult_NoneErrorZ_ok() {
    return _CResult_NoneErrorZ_ok();
  }

  late final _CResult_NoneErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneErrorZ Function()>>(
          'CResult_NoneErrorZ_ok');
  late final _CResult_NoneErrorZ_ok =
      _CResult_NoneErrorZ_okPtr.asFunction<LDKCResult_NoneErrorZ Function()>();

  /// Creates a new CResult_NoneErrorZ in the error state.
  LDKCResult_NoneErrorZ CResult_NoneErrorZ_err(
    int e,
  ) {
    return _CResult_NoneErrorZ_err(
      e,
    );
  }

  late final _CResult_NoneErrorZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneErrorZ Function(ffi.Int32)>>(
          'CResult_NoneErrorZ_err');
  late final _CResult_NoneErrorZ_err = _CResult_NoneErrorZ_errPtr.asFunction<
      LDKCResult_NoneErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NoneErrorZ> o,
  ) {
    return _CResult_NoneErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneErrorZ_is_okPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKCResult_NoneErrorZ>)>>('CResult_NoneErrorZ_is_ok');
  late final _CResult_NoneErrorZ_is_ok = _CResult_NoneErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_NoneErrorZ>)>();

  /// Frees any resources used by the CResult_NoneErrorZ.
  void CResult_NoneErrorZ_free(
    LDKCResult_NoneErrorZ _res,
  ) {
    return _CResult_NoneErrorZ_free(
      _res,
    );
  }

  late final _CResult_NoneErrorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_NoneErrorZ)>>(
          'CResult_NoneErrorZ_free');
  late final _CResult_NoneErrorZ_free = _CResult_NoneErrorZ_freePtr.asFunction<
      void Function(LDKCResult_NoneErrorZ)>();

  /// Creates a new CResult_NoneErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneErrorZ CResult_NoneErrorZ_clone(
    ffi.Pointer<LDKCResult_NoneErrorZ> orig,
  ) {
    return _CResult_NoneErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NoneErrorZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneErrorZ Function(
              ffi.Pointer<LDKCResult_NoneErrorZ>)>>('CResult_NoneErrorZ_clone');
  late final _CResult_NoneErrorZ_clone =
      _CResult_NoneErrorZ_clonePtr.asFunction<
          LDKCResult_NoneErrorZ Function(ffi.Pointer<LDKCResult_NoneErrorZ>)>();

  /// Creates a new CResult_RouteHopDecodeErrorZ in the success state.
  LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(
    LDKRouteHop o,
  ) {
    return _CResult_RouteHopDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteHopDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(
              LDKRouteHop)>>('CResult_RouteHopDecodeErrorZ_ok');
  late final _CResult_RouteHopDecodeErrorZ_ok =
      _CResult_RouteHopDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(LDKRouteHop)>();

  /// Creates a new CResult_RouteHopDecodeErrorZ in the error state.
  LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RouteHopDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteHopDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RouteHopDecodeErrorZ_err');
  late final _CResult_RouteHopDecodeErrorZ_err =
      _CResult_RouteHopDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteHopDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ> o,
  ) {
    return _CResult_RouteHopDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteHopDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ>)>>(
      'CResult_RouteHopDecodeErrorZ_is_ok');
  late final _CResult_RouteHopDecodeErrorZ_is_ok =
      _CResult_RouteHopDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RouteHopDecodeErrorZ.
  void CResult_RouteHopDecodeErrorZ_free(
    LDKCResult_RouteHopDecodeErrorZ _res,
  ) {
    return _CResult_RouteHopDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteHopDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RouteHopDecodeErrorZ)>>(
      'CResult_RouteHopDecodeErrorZ_free');
  late final _CResult_RouteHopDecodeErrorZ_free =
      _CResult_RouteHopDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteHopDecodeErrorZ)>();

  /// Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ> orig,
  ) {
    return _CResult_RouteHopDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteHopDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteHopDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ>)>>(
      'CResult_RouteHopDecodeErrorZ_clone');
  late final _CResult_RouteHopDecodeErrorZ_clone =
      _CResult_RouteHopDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RouteHopDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_RouteHopZ_free(
    LDKCVec_RouteHopZ _res,
  ) {
    return _CVec_RouteHopZ_free(
      _res,
    );
  }

  late final _CVec_RouteHopZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_RouteHopZ)>>(
          'CVec_RouteHopZ_free');
  late final _CVec_RouteHopZ_free =
      _CVec_RouteHopZ_freePtr.asFunction<void Function(LDKCVec_RouteHopZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_CVec_RouteHopZZ_free(
    LDKCVec_CVec_RouteHopZZ _res,
  ) {
    return _CVec_CVec_RouteHopZZ_free(
      _res,
    );
  }

  late final _CVec_CVec_RouteHopZZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_CVec_RouteHopZZ)>>(
          'CVec_CVec_RouteHopZZ_free');
  late final _CVec_CVec_RouteHopZZ_free = _CVec_CVec_RouteHopZZ_freePtr
      .asFunction<void Function(LDKCVec_CVec_RouteHopZZ)>();

  /// Creates a new CResult_RouteDecodeErrorZ in the success state.
  LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(
    LDKRoute o,
  ) {
    return _CResult_RouteDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_RouteDecodeErrorZ Function(LDKRoute)>>(
      'CResult_RouteDecodeErrorZ_ok');
  late final _CResult_RouteDecodeErrorZ_ok = _CResult_RouteDecodeErrorZ_okPtr
      .asFunction<LDKCResult_RouteDecodeErrorZ Function(LDKRoute)>();

  /// Creates a new CResult_RouteDecodeErrorZ in the error state.
  LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RouteDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RouteDecodeErrorZ_err');
  late final _CResult_RouteDecodeErrorZ_err = _CResult_RouteDecodeErrorZ_errPtr
      .asFunction<LDKCResult_RouteDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteDecodeErrorZ> o,
  ) {
    return _CResult_RouteDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_RouteDecodeErrorZ>)>>(
      'CResult_RouteDecodeErrorZ_is_ok');
  late final _CResult_RouteDecodeErrorZ_is_ok =
      _CResult_RouteDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RouteDecodeErrorZ.
  void CResult_RouteDecodeErrorZ_free(
    LDKCResult_RouteDecodeErrorZ _res,
  ) {
    return _CResult_RouteDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_RouteDecodeErrorZ)>>(
      'CResult_RouteDecodeErrorZ_free');
  late final _CResult_RouteDecodeErrorZ_free =
      _CResult_RouteDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteDecodeErrorZ)>();

  /// Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteDecodeErrorZ> orig,
  ) {
    return _CResult_RouteDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteDecodeErrorZ>)>>(
      'CResult_RouteDecodeErrorZ_clone');
  late final _CResult_RouteDecodeErrorZ_clone =
      _CResult_RouteDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RouteDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RouteDecodeErrorZ>)>();

  /// Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
  LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(
    LDKRouteParameters o,
  ) {
    return _CResult_RouteParametersDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteParametersDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(
              LDKRouteParameters)>>('CResult_RouteParametersDecodeErrorZ_ok');
  late final _CResult_RouteParametersDecodeErrorZ_ok =
      _CResult_RouteParametersDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(
              LDKRouteParameters)>();

  /// Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
  LDKCResult_RouteParametersDecodeErrorZ
      CResult_RouteParametersDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RouteParametersDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteParametersDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RouteParametersDecodeErrorZ_err');
  late final _CResult_RouteParametersDecodeErrorZ_err =
      _CResult_RouteParametersDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteParametersDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ> o,
  ) {
    return _CResult_RouteParametersDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteParametersDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ>)>>(
      'CResult_RouteParametersDecodeErrorZ_is_ok');
  late final _CResult_RouteParametersDecodeErrorZ_is_ok =
      _CResult_RouteParametersDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
  void CResult_RouteParametersDecodeErrorZ_free(
    LDKCResult_RouteParametersDecodeErrorZ _res,
  ) {
    return _CResult_RouteParametersDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteParametersDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RouteParametersDecodeErrorZ)>>(
      'CResult_RouteParametersDecodeErrorZ_free');
  late final _CResult_RouteParametersDecodeErrorZ_free =
      _CResult_RouteParametersDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteParametersDecodeErrorZ)>();

  /// Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteParametersDecodeErrorZ
      CResult_RouteParametersDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ> orig,
  ) {
    return _CResult_RouteParametersDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteParametersDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteParametersDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ>)>>(
      'CResult_RouteParametersDecodeErrorZ_clone');
  late final _CResult_RouteParametersDecodeErrorZ_clone =
      _CResult_RouteParametersDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RouteParametersDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_RouteHintZ_free(
    LDKCVec_RouteHintZ _res,
  ) {
    return _CVec_RouteHintZ_free(
      _res,
    );
  }

  late final _CVec_RouteHintZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_RouteHintZ)>>(
          'CVec_RouteHintZ_free');
  late final _CVec_RouteHintZ_free =
      _CVec_RouteHintZ_freePtr.asFunction<void Function(LDKCVec_RouteHintZ)>();

  /// Constructs a new COption_u64Z containing a u64
  LDKCOption_u64Z COption_u64Z_some(
    int o,
  ) {
    return _COption_u64Z_some(
      o,
    );
  }

  late final _COption_u64Z_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u64Z Function(ffi.Uint64)>>(
          'COption_u64Z_some');
  late final _COption_u64Z_some =
      _COption_u64Z_somePtr.asFunction<LDKCOption_u64Z Function(int)>();

  /// Constructs a new COption_u64Z containing nothing
  LDKCOption_u64Z COption_u64Z_none() {
    return _COption_u64Z_none();
  }

  late final _COption_u64Z_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u64Z Function()>>(
          'COption_u64Z_none');
  late final _COption_u64Z_none =
      _COption_u64Z_nonePtr.asFunction<LDKCOption_u64Z Function()>();

  /// Frees any resources associated with the u64, if we are in the Some state
  void COption_u64Z_free(
    LDKCOption_u64Z _res,
  ) {
    return _COption_u64Z_free(
      _res,
    );
  }

  late final _COption_u64Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_u64Z)>>(
          'COption_u64Z_free');
  late final _COption_u64Z_free =
      _COption_u64Z_freePtr.asFunction<void Function(LDKCOption_u64Z)>();

  /// Creates a new COption_u64Z which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_u64Z COption_u64Z_clone(
    ffi.Pointer<LDKCOption_u64Z> orig,
  ) {
    return _COption_u64Z_clone(
      orig,
    );
  }

  late final _COption_u64Z_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u64Z Function(
              ffi.Pointer<LDKCOption_u64Z>)>>('COption_u64Z_clone');
  late final _COption_u64Z_clone = _COption_u64Z_clonePtr.asFunction<
      LDKCOption_u64Z Function(ffi.Pointer<LDKCOption_u64Z>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_u64Z_free(
    LDKCVec_u64Z _res,
  ) {
    return _CVec_u64Z_free(
      _res,
    );
  }

  late final _CVec_u64Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_u64Z)>>(
          'CVec_u64Z_free');
  late final _CVec_u64Z_free =
      _CVec_u64Z_freePtr.asFunction<void Function(LDKCVec_u64Z)>();

  /// Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
  LDKCResult_PaymentParametersDecodeErrorZ
      CResult_PaymentParametersDecodeErrorZ_ok(
    LDKPaymentParameters o,
  ) {
    return _CResult_PaymentParametersDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_PaymentParametersDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentParametersDecodeErrorZ Function(
                  LDKPaymentParameters)>>(
      'CResult_PaymentParametersDecodeErrorZ_ok');
  late final _CResult_PaymentParametersDecodeErrorZ_ok =
      _CResult_PaymentParametersDecodeErrorZ_okPtr.asFunction<
          LDKCResult_PaymentParametersDecodeErrorZ Function(
              LDKPaymentParameters)>();

  /// Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
  LDKCResult_PaymentParametersDecodeErrorZ
      CResult_PaymentParametersDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_PaymentParametersDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_PaymentParametersDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentParametersDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_PaymentParametersDecodeErrorZ_err');
  late final _CResult_PaymentParametersDecodeErrorZ_err =
      _CResult_PaymentParametersDecodeErrorZ_errPtr.asFunction<
          LDKCResult_PaymentParametersDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentParametersDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ> o,
  ) {
    return _CResult_PaymentParametersDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentParametersDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ>)>>(
      'CResult_PaymentParametersDecodeErrorZ_is_ok');
  late final _CResult_PaymentParametersDecodeErrorZ_is_ok =
      _CResult_PaymentParametersDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
  void CResult_PaymentParametersDecodeErrorZ_free(
    LDKCResult_PaymentParametersDecodeErrorZ _res,
  ) {
    return _CResult_PaymentParametersDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_PaymentParametersDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentParametersDecodeErrorZ)>>(
      'CResult_PaymentParametersDecodeErrorZ_free');
  late final _CResult_PaymentParametersDecodeErrorZ_free =
      _CResult_PaymentParametersDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentParametersDecodeErrorZ)>();

  /// Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentParametersDecodeErrorZ
      CResult_PaymentParametersDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ> orig,
  ) {
    return _CResult_PaymentParametersDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentParametersDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentParametersDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ>)>>(
      'CResult_PaymentParametersDecodeErrorZ_clone');
  late final _CResult_PaymentParametersDecodeErrorZ_clone =
      _CResult_PaymentParametersDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_PaymentParametersDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_PaymentParametersDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_RouteHintHopZ_free(
    LDKCVec_RouteHintHopZ _res,
  ) {
    return _CVec_RouteHintHopZ_free(
      _res,
    );
  }

  late final _CVec_RouteHintHopZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_RouteHintHopZ)>>(
          'CVec_RouteHintHopZ_free');
  late final _CVec_RouteHintHopZ_free = _CVec_RouteHintHopZ_freePtr.asFunction<
      void Function(LDKCVec_RouteHintHopZ)>();

  /// Creates a new CResult_RouteHintDecodeErrorZ in the success state.
  LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(
    LDKRouteHint o,
  ) {
    return _CResult_RouteHintDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteHintDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(
              LDKRouteHint)>>('CResult_RouteHintDecodeErrorZ_ok');
  late final _CResult_RouteHintDecodeErrorZ_ok =
      _CResult_RouteHintDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(LDKRouteHint)>();

  /// Creates a new CResult_RouteHintDecodeErrorZ in the error state.
  LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RouteHintDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteHintDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RouteHintDecodeErrorZ_err');
  late final _CResult_RouteHintDecodeErrorZ_err =
      _CResult_RouteHintDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteHintDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ> o,
  ) {
    return _CResult_RouteHintDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteHintDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ>)>>(
      'CResult_RouteHintDecodeErrorZ_is_ok');
  late final _CResult_RouteHintDecodeErrorZ_is_ok =
      _CResult_RouteHintDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RouteHintDecodeErrorZ.
  void CResult_RouteHintDecodeErrorZ_free(
    LDKCResult_RouteHintDecodeErrorZ _res,
  ) {
    return _CResult_RouteHintDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteHintDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RouteHintDecodeErrorZ)>>(
      'CResult_RouteHintDecodeErrorZ_free');
  late final _CResult_RouteHintDecodeErrorZ_free =
      _CResult_RouteHintDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteHintDecodeErrorZ)>();

  /// Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ> orig,
  ) {
    return _CResult_RouteHintDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteHintDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteHintDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ>)>>(
      'CResult_RouteHintDecodeErrorZ_clone');
  late final _CResult_RouteHintDecodeErrorZ_clone =
      _CResult_RouteHintDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RouteHintDecodeErrorZ>)>();

  /// Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
  LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(
    LDKRouteHintHop o,
  ) {
    return _CResult_RouteHintHopDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteHintHopDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(
              LDKRouteHintHop)>>('CResult_RouteHintHopDecodeErrorZ_ok');
  late final _CResult_RouteHintHopDecodeErrorZ_ok =
      _CResult_RouteHintHopDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(LDKRouteHintHop)>();

  /// Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
  LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RouteHintHopDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteHintHopDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RouteHintHopDecodeErrorZ_err');
  late final _CResult_RouteHintHopDecodeErrorZ_err =
      _CResult_RouteHintHopDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteHintHopDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ> o,
  ) {
    return _CResult_RouteHintHopDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteHintHopDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ>)>>(
      'CResult_RouteHintHopDecodeErrorZ_is_ok');
  late final _CResult_RouteHintHopDecodeErrorZ_is_ok =
      _CResult_RouteHintHopDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
  void CResult_RouteHintHopDecodeErrorZ_free(
    LDKCResult_RouteHintHopDecodeErrorZ _res,
  ) {
    return _CResult_RouteHintHopDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteHintHopDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RouteHintHopDecodeErrorZ)>>(
      'CResult_RouteHintHopDecodeErrorZ_free');
  late final _CResult_RouteHintHopDecodeErrorZ_free =
      _CResult_RouteHintHopDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteHintHopDecodeErrorZ)>();

  /// Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ> orig,
  ) {
    return _CResult_RouteHintHopDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteHintHopDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteHintHopDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ>)>>(
      'CResult_RouteHintHopDecodeErrorZ_clone');
  late final _CResult_RouteHintHopDecodeErrorZ_clone =
      _CResult_RouteHintHopDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RouteHintHopDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_ChannelDetailsZ_free(
    LDKCVec_ChannelDetailsZ _res,
  ) {
    return _CVec_ChannelDetailsZ_free(
      _res,
    );
  }

  late final _CVec_ChannelDetailsZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_ChannelDetailsZ)>>(
          'CVec_ChannelDetailsZ_free');
  late final _CVec_ChannelDetailsZ_free = _CVec_ChannelDetailsZ_freePtr
      .asFunction<void Function(LDKCVec_ChannelDetailsZ)>();

  /// Creates a new CResult_RouteLightningErrorZ in the success state.
  LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(
    LDKRoute o,
  ) {
    return _CResult_RouteLightningErrorZ_ok(
      o,
    );
  }

  late final _CResult_RouteLightningErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteLightningErrorZ Function(
              LDKRoute)>>('CResult_RouteLightningErrorZ_ok');
  late final _CResult_RouteLightningErrorZ_ok =
      _CResult_RouteLightningErrorZ_okPtr.asFunction<
          LDKCResult_RouteLightningErrorZ Function(LDKRoute)>();

  /// Creates a new CResult_RouteLightningErrorZ in the error state.
  LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(
    LDKLightningError e,
  ) {
    return _CResult_RouteLightningErrorZ_err(
      e,
    );
  }

  late final _CResult_RouteLightningErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteLightningErrorZ Function(
              LDKLightningError)>>('CResult_RouteLightningErrorZ_err');
  late final _CResult_RouteLightningErrorZ_err =
      _CResult_RouteLightningErrorZ_errPtr.asFunction<
          LDKCResult_RouteLightningErrorZ Function(LDKLightningError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RouteLightningErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RouteLightningErrorZ> o,
  ) {
    return _CResult_RouteLightningErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RouteLightningErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_RouteLightningErrorZ>)>>(
      'CResult_RouteLightningErrorZ_is_ok');
  late final _CResult_RouteLightningErrorZ_is_ok =
      _CResult_RouteLightningErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RouteLightningErrorZ>)>();

  /// Frees any resources used by the CResult_RouteLightningErrorZ.
  void CResult_RouteLightningErrorZ_free(
    LDKCResult_RouteLightningErrorZ _res,
  ) {
    return _CResult_RouteLightningErrorZ_free(
      _res,
    );
  }

  late final _CResult_RouteLightningErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RouteLightningErrorZ)>>(
      'CResult_RouteLightningErrorZ_free');
  late final _CResult_RouteLightningErrorZ_free =
      _CResult_RouteLightningErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RouteLightningErrorZ)>();

  /// Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(
    ffi.Pointer<LDKCResult_RouteLightningErrorZ> orig,
  ) {
    return _CResult_RouteLightningErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RouteLightningErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RouteLightningErrorZ Function(
                  ffi.Pointer<LDKCResult_RouteLightningErrorZ>)>>(
      'CResult_RouteLightningErrorZ_clone');
  late final _CResult_RouteLightningErrorZ_clone =
      _CResult_RouteLightningErrorZ_clonePtr.asFunction<
          LDKCResult_RouteLightningErrorZ Function(
              ffi.Pointer<LDKCResult_RouteLightningErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_PublicKeyZ_free(
    LDKCVec_PublicKeyZ _res,
  ) {
    return _CVec_PublicKeyZ_free(
      _res,
    );
  }

  late final _CVec_PublicKeyZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_PublicKeyZ)>>(
          'CVec_PublicKeyZ_free');
  late final _CVec_PublicKeyZ_free =
      _CVec_PublicKeyZ_freePtr.asFunction<void Function(LDKCVec_PublicKeyZ)>();

  /// Creates a new CResult_PaymentPurposeDecodeErrorZ in the success state.
  LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_ok(
    LDKPaymentPurpose o,
  ) {
    return _CResult_PaymentPurposeDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_PaymentPurposeDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(
              LDKPaymentPurpose)>>('CResult_PaymentPurposeDecodeErrorZ_ok');
  late final _CResult_PaymentPurposeDecodeErrorZ_ok =
      _CResult_PaymentPurposeDecodeErrorZ_okPtr.asFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(LDKPaymentPurpose)>();

  /// Creates a new CResult_PaymentPurposeDecodeErrorZ in the error state.
  LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_PaymentPurposeDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_PaymentPurposeDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_PaymentPurposeDecodeErrorZ_err');
  late final _CResult_PaymentPurposeDecodeErrorZ_err =
      _CResult_PaymentPurposeDecodeErrorZ_errPtr.asFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentPurposeDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ> o,
  ) {
    return _CResult_PaymentPurposeDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentPurposeDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ>)>>(
      'CResult_PaymentPurposeDecodeErrorZ_is_ok');
  late final _CResult_PaymentPurposeDecodeErrorZ_is_ok =
      _CResult_PaymentPurposeDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_PaymentPurposeDecodeErrorZ.
  void CResult_PaymentPurposeDecodeErrorZ_free(
    LDKCResult_PaymentPurposeDecodeErrorZ _res,
  ) {
    return _CResult_PaymentPurposeDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_PaymentPurposeDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentPurposeDecodeErrorZ)>>(
      'CResult_PaymentPurposeDecodeErrorZ_free');
  late final _CResult_PaymentPurposeDecodeErrorZ_free =
      _CResult_PaymentPurposeDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentPurposeDecodeErrorZ)>();

  /// Creates a new CResult_PaymentPurposeDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentPurposeDecodeErrorZ
      CResult_PaymentPurposeDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ> orig,
  ) {
    return _CResult_PaymentPurposeDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentPurposeDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentPurposeDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ>)>>(
      'CResult_PaymentPurposeDecodeErrorZ_clone');
  late final _CResult_PaymentPurposeDecodeErrorZ_clone =
      _CResult_PaymentPurposeDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_PaymentPurposeDecodeErrorZ>)>();

  /// Constructs a new COption_ClosureReasonZ containing a crate::lightning::util::events::ClosureReason
  LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(
    LDKClosureReason o,
  ) {
    return _COption_ClosureReasonZ_some(
      o,
    );
  }

  late final _COption_ClosureReasonZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_ClosureReasonZ Function(
              LDKClosureReason)>>('COption_ClosureReasonZ_some');
  late final _COption_ClosureReasonZ_some = _COption_ClosureReasonZ_somePtr
      .asFunction<LDKCOption_ClosureReasonZ Function(LDKClosureReason)>();

  /// Constructs a new COption_ClosureReasonZ containing nothing
  LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none() {
    return _COption_ClosureReasonZ_none();
  }

  late final _COption_ClosureReasonZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_ClosureReasonZ Function()>>(
          'COption_ClosureReasonZ_none');
  late final _COption_ClosureReasonZ_none = _COption_ClosureReasonZ_nonePtr
      .asFunction<LDKCOption_ClosureReasonZ Function()>();

  /// Frees any resources associated with the crate::lightning::util::events::ClosureReason, if we are in the Some state
  void COption_ClosureReasonZ_free(
    LDKCOption_ClosureReasonZ _res,
  ) {
    return _COption_ClosureReasonZ_free(
      _res,
    );
  }

  late final _COption_ClosureReasonZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_ClosureReasonZ)>>(
          'COption_ClosureReasonZ_free');
  late final _COption_ClosureReasonZ_free = _COption_ClosureReasonZ_freePtr
      .asFunction<void Function(LDKCOption_ClosureReasonZ)>();

  /// Creates a new COption_ClosureReasonZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(
    ffi.Pointer<LDKCOption_ClosureReasonZ> orig,
  ) {
    return _COption_ClosureReasonZ_clone(
      orig,
    );
  }

  late final _COption_ClosureReasonZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_ClosureReasonZ Function(
                  ffi.Pointer<LDKCOption_ClosureReasonZ>)>>(
      'COption_ClosureReasonZ_clone');
  late final _COption_ClosureReasonZ_clone =
      _COption_ClosureReasonZ_clonePtr.asFunction<
          LDKCOption_ClosureReasonZ Function(
              ffi.Pointer<LDKCOption_ClosureReasonZ>)>();

  /// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
  LDKCResult_COption_ClosureReasonZDecodeErrorZ
      CResult_COption_ClosureReasonZDecodeErrorZ_ok(
    LDKCOption_ClosureReasonZ o,
  ) {
    return _CResult_COption_ClosureReasonZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_ClosureReasonZDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
                  LDKCOption_ClosureReasonZ)>>(
      'CResult_COption_ClosureReasonZDecodeErrorZ_ok');
  late final _CResult_COption_ClosureReasonZDecodeErrorZ_ok =
      _CResult_COption_ClosureReasonZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
              LDKCOption_ClosureReasonZ)>();

  /// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
  LDKCResult_COption_ClosureReasonZDecodeErrorZ
      CResult_COption_ClosureReasonZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_ClosureReasonZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_ClosureReasonZDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_COption_ClosureReasonZDecodeErrorZ_err');
  late final _CResult_COption_ClosureReasonZDecodeErrorZ_err =
      _CResult_COption_ClosureReasonZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ> o,
  ) {
    return _CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_ClosureReasonZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ>)>>(
      'CResult_COption_ClosureReasonZDecodeErrorZ_is_ok');
  late final _CResult_COption_ClosureReasonZDecodeErrorZ_is_ok =
      _CResult_COption_ClosureReasonZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
  void CResult_COption_ClosureReasonZDecodeErrorZ_free(
    LDKCResult_COption_ClosureReasonZDecodeErrorZ _res,
  ) {
    return _CResult_COption_ClosureReasonZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_ClosureReasonZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_COption_ClosureReasonZDecodeErrorZ)>>(
      'CResult_COption_ClosureReasonZDecodeErrorZ_free');
  late final _CResult_COption_ClosureReasonZDecodeErrorZ_free =
      _CResult_COption_ClosureReasonZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_ClosureReasonZDecodeErrorZ)>();

  /// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_ClosureReasonZDecodeErrorZ
      CResult_COption_ClosureReasonZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_ClosureReasonZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_ClosureReasonZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ>)>>(
      'CResult_COption_ClosureReasonZDecodeErrorZ_clone');
  late final _CResult_COption_ClosureReasonZDecodeErrorZ_clone =
      _CResult_COption_ClosureReasonZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_ClosureReasonZDecodeErrorZ>)>();

  /// Constructs a new COption_HTLCDestinationZ containing a crate::lightning::util::events::HTLCDestination
  LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_some(
    LDKHTLCDestination o,
  ) {
    return _COption_HTLCDestinationZ_some(
      o,
    );
  }

  late final _COption_HTLCDestinationZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_HTLCDestinationZ Function(
              LDKHTLCDestination)>>('COption_HTLCDestinationZ_some');
  late final _COption_HTLCDestinationZ_some = _COption_HTLCDestinationZ_somePtr
      .asFunction<LDKCOption_HTLCDestinationZ Function(LDKHTLCDestination)>();

  /// Constructs a new COption_HTLCDestinationZ containing nothing
  LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_none() {
    return _COption_HTLCDestinationZ_none();
  }

  late final _COption_HTLCDestinationZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_HTLCDestinationZ Function()>>(
          'COption_HTLCDestinationZ_none');
  late final _COption_HTLCDestinationZ_none = _COption_HTLCDestinationZ_nonePtr
      .asFunction<LDKCOption_HTLCDestinationZ Function()>();

  /// Frees any resources associated with the crate::lightning::util::events::HTLCDestination, if we are in the Some state
  void COption_HTLCDestinationZ_free(
    LDKCOption_HTLCDestinationZ _res,
  ) {
    return _COption_HTLCDestinationZ_free(
      _res,
    );
  }

  late final _COption_HTLCDestinationZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCOption_HTLCDestinationZ)>>(
      'COption_HTLCDestinationZ_free');
  late final _COption_HTLCDestinationZ_free = _COption_HTLCDestinationZ_freePtr
      .asFunction<void Function(LDKCOption_HTLCDestinationZ)>();

  /// Creates a new COption_HTLCDestinationZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_clone(
    ffi.Pointer<LDKCOption_HTLCDestinationZ> orig,
  ) {
    return _COption_HTLCDestinationZ_clone(
      orig,
    );
  }

  late final _COption_HTLCDestinationZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_HTLCDestinationZ Function(
                  ffi.Pointer<LDKCOption_HTLCDestinationZ>)>>(
      'COption_HTLCDestinationZ_clone');
  late final _COption_HTLCDestinationZ_clone =
      _COption_HTLCDestinationZ_clonePtr.asFunction<
          LDKCOption_HTLCDestinationZ Function(
              ffi.Pointer<LDKCOption_HTLCDestinationZ>)>();

  /// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the success state.
  LDKCResult_COption_HTLCDestinationZDecodeErrorZ
      CResult_COption_HTLCDestinationZDecodeErrorZ_ok(
    LDKCOption_HTLCDestinationZ o,
  ) {
    return _CResult_COption_HTLCDestinationZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
                  LDKCOption_HTLCDestinationZ)>>(
      'CResult_COption_HTLCDestinationZDecodeErrorZ_ok');
  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_ok =
      _CResult_COption_HTLCDestinationZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
              LDKCOption_HTLCDestinationZ)>();

  /// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the error state.
  LDKCResult_COption_HTLCDestinationZDecodeErrorZ
      CResult_COption_HTLCDestinationZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_HTLCDestinationZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_COption_HTLCDestinationZDecodeErrorZ_err');
  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_err =
      _CResult_COption_HTLCDestinationZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_HTLCDestinationZDecodeErrorZ> o,
  ) {
    return _CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_COption_HTLCDestinationZDecodeErrorZ>)>>(
      'CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok');
  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok =
      _CResult_COption_HTLCDestinationZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_COption_HTLCDestinationZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_HTLCDestinationZDecodeErrorZ.
  void CResult_COption_HTLCDestinationZDecodeErrorZ_free(
    LDKCResult_COption_HTLCDestinationZDecodeErrorZ _res,
  ) {
    return _CResult_COption_HTLCDestinationZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_COption_HTLCDestinationZDecodeErrorZ)>>(
      'CResult_COption_HTLCDestinationZDecodeErrorZ_free');
  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_free =
      _CResult_COption_HTLCDestinationZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_HTLCDestinationZDecodeErrorZ)>();

  /// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_HTLCDestinationZDecodeErrorZ
      CResult_COption_HTLCDestinationZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_HTLCDestinationZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_HTLCDestinationZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_COption_HTLCDestinationZDecodeErrorZ>)>>(
      'CResult_COption_HTLCDestinationZDecodeErrorZ_clone');
  late final _CResult_COption_HTLCDestinationZDecodeErrorZ_clone =
      _CResult_COption_HTLCDestinationZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_HTLCDestinationZDecodeErrorZ>)>();

  /// Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::gossip::NetworkUpdate
  LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(
    LDKNetworkUpdate o,
  ) {
    return _COption_NetworkUpdateZ_some(
      o,
    );
  }

  late final _COption_NetworkUpdateZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_NetworkUpdateZ Function(
              LDKNetworkUpdate)>>('COption_NetworkUpdateZ_some');
  late final _COption_NetworkUpdateZ_some = _COption_NetworkUpdateZ_somePtr
      .asFunction<LDKCOption_NetworkUpdateZ Function(LDKNetworkUpdate)>();

  /// Constructs a new COption_NetworkUpdateZ containing nothing
  LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none() {
    return _COption_NetworkUpdateZ_none();
  }

  late final _COption_NetworkUpdateZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_NetworkUpdateZ Function()>>(
          'COption_NetworkUpdateZ_none');
  late final _COption_NetworkUpdateZ_none = _COption_NetworkUpdateZ_nonePtr
      .asFunction<LDKCOption_NetworkUpdateZ Function()>();

  /// Frees any resources associated with the crate::lightning::routing::gossip::NetworkUpdate, if we are in the Some state
  void COption_NetworkUpdateZ_free(
    LDKCOption_NetworkUpdateZ _res,
  ) {
    return _COption_NetworkUpdateZ_free(
      _res,
    );
  }

  late final _COption_NetworkUpdateZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_NetworkUpdateZ)>>(
          'COption_NetworkUpdateZ_free');
  late final _COption_NetworkUpdateZ_free = _COption_NetworkUpdateZ_freePtr
      .asFunction<void Function(LDKCOption_NetworkUpdateZ)>();

  /// Creates a new COption_NetworkUpdateZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(
    ffi.Pointer<LDKCOption_NetworkUpdateZ> orig,
  ) {
    return _COption_NetworkUpdateZ_clone(
      orig,
    );
  }

  late final _COption_NetworkUpdateZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_NetworkUpdateZ Function(
                  ffi.Pointer<LDKCOption_NetworkUpdateZ>)>>(
      'COption_NetworkUpdateZ_clone');
  late final _COption_NetworkUpdateZ_clone =
      _COption_NetworkUpdateZ_clonePtr.asFunction<
          LDKCOption_NetworkUpdateZ Function(
              ffi.Pointer<LDKCOption_NetworkUpdateZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_SpendableOutputDescriptorZ_free(
    LDKCVec_SpendableOutputDescriptorZ _res,
  ) {
    return _CVec_SpendableOutputDescriptorZ_free(
      _res,
    );
  }

  late final _CVec_SpendableOutputDescriptorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_SpendableOutputDescriptorZ)>>(
      'CVec_SpendableOutputDescriptorZ_free');
  late final _CVec_SpendableOutputDescriptorZ_free =
      _CVec_SpendableOutputDescriptorZ_freePtr.asFunction<
          void Function(LDKCVec_SpendableOutputDescriptorZ)>();

  /// Constructs a new COption_EventZ containing a crate::lightning::util::events::Event
  LDKCOption_EventZ COption_EventZ_some(
    LDKEvent o,
  ) {
    return _COption_EventZ_some(
      o,
    );
  }

  late final _COption_EventZ_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_EventZ Function(LDKEvent)>>(
          'COption_EventZ_some');
  late final _COption_EventZ_some = _COption_EventZ_somePtr.asFunction<
      LDKCOption_EventZ Function(LDKEvent)>();

  /// Constructs a new COption_EventZ containing nothing
  LDKCOption_EventZ COption_EventZ_none() {
    return _COption_EventZ_none();
  }

  late final _COption_EventZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_EventZ Function()>>(
          'COption_EventZ_none');
  late final _COption_EventZ_none =
      _COption_EventZ_nonePtr.asFunction<LDKCOption_EventZ Function()>();

  /// Frees any resources associated with the crate::lightning::util::events::Event, if we are in the Some state
  void COption_EventZ_free(
    LDKCOption_EventZ _res,
  ) {
    return _COption_EventZ_free(
      _res,
    );
  }

  late final _COption_EventZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_EventZ)>>(
          'COption_EventZ_free');
  late final _COption_EventZ_free =
      _COption_EventZ_freePtr.asFunction<void Function(LDKCOption_EventZ)>();

  /// Creates a new COption_EventZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_EventZ COption_EventZ_clone(
    ffi.Pointer<LDKCOption_EventZ> orig,
  ) {
    return _COption_EventZ_clone(
      orig,
    );
  }

  late final _COption_EventZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_EventZ Function(
              ffi.Pointer<LDKCOption_EventZ>)>>('COption_EventZ_clone');
  late final _COption_EventZ_clone = _COption_EventZ_clonePtr.asFunction<
      LDKCOption_EventZ Function(ffi.Pointer<LDKCOption_EventZ>)>();

  /// Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
  LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(
    LDKCOption_EventZ o,
  ) {
    return _CResult_COption_EventZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_EventZDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(
              LDKCOption_EventZ)>>('CResult_COption_EventZDecodeErrorZ_ok');
  late final _CResult_COption_EventZDecodeErrorZ_ok =
      _CResult_COption_EventZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(LDKCOption_EventZ)>();

  /// Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
  LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_EventZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_EventZDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_COption_EventZDecodeErrorZ_err');
  late final _CResult_COption_EventZDecodeErrorZ_err =
      _CResult_COption_EventZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_EventZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ> o,
  ) {
    return _CResult_COption_EventZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_EventZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ>)>>(
      'CResult_COption_EventZDecodeErrorZ_is_ok');
  late final _CResult_COption_EventZDecodeErrorZ_is_ok =
      _CResult_COption_EventZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
  void CResult_COption_EventZDecodeErrorZ_free(
    LDKCResult_COption_EventZDecodeErrorZ _res,
  ) {
    return _CResult_COption_EventZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_EventZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_COption_EventZDecodeErrorZ)>>(
      'CResult_COption_EventZDecodeErrorZ_free');
  late final _CResult_COption_EventZDecodeErrorZ_free =
      _CResult_COption_EventZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_EventZDecodeErrorZ)>();

  /// Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_EventZDecodeErrorZ
      CResult_COption_EventZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_EventZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_EventZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_EventZDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ>)>>(
      'CResult_COption_EventZDecodeErrorZ_clone');
  late final _CResult_COption_EventZDecodeErrorZ_clone =
      _CResult_COption_EventZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_EventZDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_MessageSendEventZ_free(
    LDKCVec_MessageSendEventZ _res,
  ) {
    return _CVec_MessageSendEventZ_free(
      _res,
    );
  }

  late final _CVec_MessageSendEventZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_MessageSendEventZ)>>(
          'CVec_MessageSendEventZ_free');
  late final _CVec_MessageSendEventZ_free = _CVec_MessageSendEventZ_freePtr
      .asFunction<void Function(LDKCVec_MessageSendEventZ)>();

  /// Creates a new CResult_TxOutAccessErrorZ in the success state.
  LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(
    LDKTxOut o,
  ) {
    return _CResult_TxOutAccessErrorZ_ok(
      o,
    );
  }

  late final _CResult_TxOutAccessErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_TxOutAccessErrorZ Function(LDKTxOut)>>(
      'CResult_TxOutAccessErrorZ_ok');
  late final _CResult_TxOutAccessErrorZ_ok = _CResult_TxOutAccessErrorZ_okPtr
      .asFunction<LDKCResult_TxOutAccessErrorZ Function(LDKTxOut)>();

  /// Creates a new CResult_TxOutAccessErrorZ in the error state.
  LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(
    int e,
  ) {
    return _CResult_TxOutAccessErrorZ_err(
      e,
    );
  }

  late final _CResult_TxOutAccessErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_TxOutAccessErrorZ Function(ffi.Int32)>>(
      'CResult_TxOutAccessErrorZ_err');
  late final _CResult_TxOutAccessErrorZ_err = _CResult_TxOutAccessErrorZ_errPtr
      .asFunction<LDKCResult_TxOutAccessErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_TxOutAccessErrorZ_is_ok(
    ffi.Pointer<LDKCResult_TxOutAccessErrorZ> o,
  ) {
    return _CResult_TxOutAccessErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_TxOutAccessErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_TxOutAccessErrorZ>)>>(
      'CResult_TxOutAccessErrorZ_is_ok');
  late final _CResult_TxOutAccessErrorZ_is_ok =
      _CResult_TxOutAccessErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_TxOutAccessErrorZ>)>();

  /// Frees any resources used by the CResult_TxOutAccessErrorZ.
  void CResult_TxOutAccessErrorZ_free(
    LDKCResult_TxOutAccessErrorZ _res,
  ) {
    return _CResult_TxOutAccessErrorZ_free(
      _res,
    );
  }

  late final _CResult_TxOutAccessErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_TxOutAccessErrorZ)>>(
      'CResult_TxOutAccessErrorZ_free');
  late final _CResult_TxOutAccessErrorZ_free =
      _CResult_TxOutAccessErrorZ_freePtr.asFunction<
          void Function(LDKCResult_TxOutAccessErrorZ)>();

  /// Creates a new CResult_TxOutAccessErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(
    ffi.Pointer<LDKCResult_TxOutAccessErrorZ> orig,
  ) {
    return _CResult_TxOutAccessErrorZ_clone(
      orig,
    );
  }

  late final _CResult_TxOutAccessErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TxOutAccessErrorZ Function(
                  ffi.Pointer<LDKCResult_TxOutAccessErrorZ>)>>(
      'CResult_TxOutAccessErrorZ_clone');
  late final _CResult_TxOutAccessErrorZ_clone =
      _CResult_TxOutAccessErrorZ_clonePtr.asFunction<
          LDKCResult_TxOutAccessErrorZ Function(
              ffi.Pointer<LDKCResult_TxOutAccessErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(
    ffi.Pointer<LDKC2Tuple_usizeTransactionZ> orig,
  ) {
    return _C2Tuple_usizeTransactionZ_clone(
      orig,
    );
  }

  late final _C2Tuple_usizeTransactionZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_usizeTransactionZ Function(
                  ffi.Pointer<LDKC2Tuple_usizeTransactionZ>)>>(
      'C2Tuple_usizeTransactionZ_clone');
  late final _C2Tuple_usizeTransactionZ_clone =
      _C2Tuple_usizeTransactionZ_clonePtr.asFunction<
          LDKC2Tuple_usizeTransactionZ Function(
              ffi.Pointer<LDKC2Tuple_usizeTransactionZ>)>();

  /// Creates a new C2Tuple_usizeTransactionZ from the contained elements.
  LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(
    int a,
    LDKTransaction b,
  ) {
    return _C2Tuple_usizeTransactionZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_usizeTransactionZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_usizeTransactionZ Function(
              uintptr_t, LDKTransaction)>>('C2Tuple_usizeTransactionZ_new');
  late final _C2Tuple_usizeTransactionZ_new = _C2Tuple_usizeTransactionZ_newPtr
      .asFunction<LDKC2Tuple_usizeTransactionZ Function(int, LDKTransaction)>();

  /// Frees any resources used by the C2Tuple_usizeTransactionZ.
  void C2Tuple_usizeTransactionZ_free(
    LDKC2Tuple_usizeTransactionZ _res,
  ) {
    return _C2Tuple_usizeTransactionZ_free(
      _res,
    );
  }

  late final _C2Tuple_usizeTransactionZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_usizeTransactionZ)>>(
      'C2Tuple_usizeTransactionZ_free');
  late final _C2Tuple_usizeTransactionZ_free =
      _C2Tuple_usizeTransactionZ_freePtr.asFunction<
          void Function(LDKC2Tuple_usizeTransactionZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_usizeTransactionZZ_free(
    LDKCVec_C2Tuple_usizeTransactionZZ _res,
  ) {
    return _CVec_C2Tuple_usizeTransactionZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_usizeTransactionZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_C2Tuple_usizeTransactionZZ)>>(
      'CVec_C2Tuple_usizeTransactionZZ_free');
  late final _CVec_C2Tuple_usizeTransactionZZ_free =
      _CVec_C2Tuple_usizeTransactionZZ_freePtr.asFunction<
          void Function(LDKCVec_C2Tuple_usizeTransactionZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_TxidZ_free(
    LDKCVec_TxidZ _res,
  ) {
    return _CVec_TxidZ_free(
      _res,
    );
  }

  late final _CVec_TxidZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_TxidZ)>>(
          'CVec_TxidZ_free');
  late final _CVec_TxidZ_free =
      _CVec_TxidZ_freePtr.asFunction<void Function(LDKCVec_TxidZ)>();

  /// Creates a new CResult_NoneChannelMonitorUpdateErrZ in the success state.
  LDKCResult_NoneChannelMonitorUpdateErrZ
      CResult_NoneChannelMonitorUpdateErrZ_ok() {
    return _CResult_NoneChannelMonitorUpdateErrZ_ok();
  }

  late final _CResult_NoneChannelMonitorUpdateErrZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ
              Function()>>('CResult_NoneChannelMonitorUpdateErrZ_ok');
  late final _CResult_NoneChannelMonitorUpdateErrZ_ok =
      _CResult_NoneChannelMonitorUpdateErrZ_okPtr.asFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function()>();

  /// Creates a new CResult_NoneChannelMonitorUpdateErrZ in the error state.
  LDKCResult_NoneChannelMonitorUpdateErrZ
      CResult_NoneChannelMonitorUpdateErrZ_err(
    int e,
  ) {
    return _CResult_NoneChannelMonitorUpdateErrZ_err(
      e,
    );
  }

  late final _CResult_NoneChannelMonitorUpdateErrZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function(
              ffi.Int32)>>('CResult_NoneChannelMonitorUpdateErrZ_err');
  late final _CResult_NoneChannelMonitorUpdateErrZ_err =
      _CResult_NoneChannelMonitorUpdateErrZ_errPtr.asFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneChannelMonitorUpdateErrZ_is_ok(
    ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ> o,
  ) {
    return _CResult_NoneChannelMonitorUpdateErrZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneChannelMonitorUpdateErrZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ>)>>(
      'CResult_NoneChannelMonitorUpdateErrZ_is_ok');
  late final _CResult_NoneChannelMonitorUpdateErrZ_is_ok =
      _CResult_NoneChannelMonitorUpdateErrZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ>)>();

  /// Frees any resources used by the CResult_NoneChannelMonitorUpdateErrZ.
  void CResult_NoneChannelMonitorUpdateErrZ_free(
    LDKCResult_NoneChannelMonitorUpdateErrZ _res,
  ) {
    return _CResult_NoneChannelMonitorUpdateErrZ_free(
      _res,
    );
  }

  late final _CResult_NoneChannelMonitorUpdateErrZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NoneChannelMonitorUpdateErrZ)>>(
      'CResult_NoneChannelMonitorUpdateErrZ_free');
  late final _CResult_NoneChannelMonitorUpdateErrZ_free =
      _CResult_NoneChannelMonitorUpdateErrZ_freePtr.asFunction<
          void Function(LDKCResult_NoneChannelMonitorUpdateErrZ)>();

  /// Creates a new CResult_NoneChannelMonitorUpdateErrZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneChannelMonitorUpdateErrZ
      CResult_NoneChannelMonitorUpdateErrZ_clone(
    ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ> orig,
  ) {
    return _CResult_NoneChannelMonitorUpdateErrZ_clone(
      orig,
    );
  }

  late final _CResult_NoneChannelMonitorUpdateErrZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneChannelMonitorUpdateErrZ Function(
                  ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ>)>>(
      'CResult_NoneChannelMonitorUpdateErrZ_clone');
  late final _CResult_NoneChannelMonitorUpdateErrZ_clone =
      _CResult_NoneChannelMonitorUpdateErrZ_clonePtr.asFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function(
              ffi.Pointer<LDKCResult_NoneChannelMonitorUpdateErrZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_MonitorEventZ_free(
    LDKCVec_MonitorEventZ _res,
  ) {
    return _CVec_MonitorEventZ_free(
      _res,
    );
  }

  late final _CVec_MonitorEventZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_MonitorEventZ)>>(
          'CVec_MonitorEventZ_free');
  late final _CVec_MonitorEventZ_free = _CVec_MonitorEventZ_freePtr.asFunction<
      void Function(LDKCVec_MonitorEventZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ
      C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(
    ffi.Pointer<LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ> orig,
  ) {
    return _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(
      orig,
    );
  }

  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ Function(
                  ffi.Pointer<
                      LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ>)>>(
      'C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone');
  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone =
      _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clonePtr.asFunction<
          LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ Function(
              ffi.Pointer<LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ>)>();

  /// Creates a new C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ from the contained elements.
  LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ
      C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(
    LDKOutPoint a,
    LDKCVec_MonitorEventZ b,
    LDKPublicKey c,
  ) {
    return _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(
      a,
      b,
      c,
    );
  }

  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_newPtr = _lookup<
          ffi.NativeFunction<
              LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ Function(
                  LDKOutPoint, LDKCVec_MonitorEventZ, LDKPublicKey)>>(
      'C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new');
  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new =
      _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_newPtr.asFunction<
          LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ Function(
              LDKOutPoint, LDKCVec_MonitorEventZ, LDKPublicKey)>();

  /// Frees any resources used by the C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ.
  void C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(
    LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ _res,
  ) {
    return _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(
      _res,
    );
  }

  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ)>>(
      'C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free');
  late final _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free =
      _C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_freePtr.asFunction<
          void Function(LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(
    LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ _res,
  ) {
    return _CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(
      _res,
    );
  }

  late final _CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ)>>(
          'CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free');
  late final _CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free =
      _CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_freePtr.asFunction<
          void Function(
              LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ)>();

  /// Constructs a new COption_C2Tuple_usizeTransactionZZ containing a crate::c_types::derived::C2Tuple_usizeTransactionZ
  LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_some(
    LDKC2Tuple_usizeTransactionZ o,
  ) {
    return _COption_C2Tuple_usizeTransactionZZ_some(
      o,
    );
  }

  late final _COption_C2Tuple_usizeTransactionZZ_somePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_C2Tuple_usizeTransactionZZ Function(
                  LDKC2Tuple_usizeTransactionZ)>>(
      'COption_C2Tuple_usizeTransactionZZ_some');
  late final _COption_C2Tuple_usizeTransactionZZ_some =
      _COption_C2Tuple_usizeTransactionZZ_somePtr.asFunction<
          LDKCOption_C2Tuple_usizeTransactionZZ Function(
              LDKC2Tuple_usizeTransactionZ)>();

  /// Constructs a new COption_C2Tuple_usizeTransactionZZ containing nothing
  LDKCOption_C2Tuple_usizeTransactionZZ
      COption_C2Tuple_usizeTransactionZZ_none() {
    return _COption_C2Tuple_usizeTransactionZZ_none();
  }

  late final _COption_C2Tuple_usizeTransactionZZ_nonePtr = _lookup<
          ffi.NativeFunction<LDKCOption_C2Tuple_usizeTransactionZZ Function()>>(
      'COption_C2Tuple_usizeTransactionZZ_none');
  late final _COption_C2Tuple_usizeTransactionZZ_none =
      _COption_C2Tuple_usizeTransactionZZ_nonePtr.asFunction<
          LDKCOption_C2Tuple_usizeTransactionZZ Function()>();

  /// Frees any resources associated with the crate::c_types::derived::C2Tuple_usizeTransactionZ, if we are in the Some state
  void COption_C2Tuple_usizeTransactionZZ_free(
    LDKCOption_C2Tuple_usizeTransactionZZ _res,
  ) {
    return _COption_C2Tuple_usizeTransactionZZ_free(
      _res,
    );
  }

  late final _COption_C2Tuple_usizeTransactionZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCOption_C2Tuple_usizeTransactionZZ)>>(
      'COption_C2Tuple_usizeTransactionZZ_free');
  late final _COption_C2Tuple_usizeTransactionZZ_free =
      _COption_C2Tuple_usizeTransactionZZ_freePtr.asFunction<
          void Function(LDKCOption_C2Tuple_usizeTransactionZZ)>();

  /// Creates a new COption_C2Tuple_usizeTransactionZZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_C2Tuple_usizeTransactionZZ
      COption_C2Tuple_usizeTransactionZZ_clone(
    ffi.Pointer<LDKCOption_C2Tuple_usizeTransactionZZ> orig,
  ) {
    return _COption_C2Tuple_usizeTransactionZZ_clone(
      orig,
    );
  }

  late final _COption_C2Tuple_usizeTransactionZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_C2Tuple_usizeTransactionZZ Function(
                  ffi.Pointer<LDKCOption_C2Tuple_usizeTransactionZZ>)>>(
      'COption_C2Tuple_usizeTransactionZZ_clone');
  late final _COption_C2Tuple_usizeTransactionZZ_clone =
      _COption_C2Tuple_usizeTransactionZZ_clonePtr.asFunction<
          LDKCOption_C2Tuple_usizeTransactionZZ Function(
              ffi.Pointer<LDKCOption_C2Tuple_usizeTransactionZZ>)>();

  /// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
  LDKCResult_FixedPenaltyScorerDecodeErrorZ
      CResult_FixedPenaltyScorerDecodeErrorZ_ok(
    LDKFixedPenaltyScorer o,
  ) {
    return _CResult_FixedPenaltyScorerDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_FixedPenaltyScorerDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
                  LDKFixedPenaltyScorer)>>(
      'CResult_FixedPenaltyScorerDecodeErrorZ_ok');
  late final _CResult_FixedPenaltyScorerDecodeErrorZ_ok =
      _CResult_FixedPenaltyScorerDecodeErrorZ_okPtr.asFunction<
          LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
              LDKFixedPenaltyScorer)>();

  /// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
  LDKCResult_FixedPenaltyScorerDecodeErrorZ
      CResult_FixedPenaltyScorerDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_FixedPenaltyScorerDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_FixedPenaltyScorerDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_FixedPenaltyScorerDecodeErrorZ_err');
  late final _CResult_FixedPenaltyScorerDecodeErrorZ_err =
      _CResult_FixedPenaltyScorerDecodeErrorZ_errPtr.asFunction<
          LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ> o,
  ) {
    return _CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_FixedPenaltyScorerDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ>)>>(
      'CResult_FixedPenaltyScorerDecodeErrorZ_is_ok');
  late final _CResult_FixedPenaltyScorerDecodeErrorZ_is_ok =
      _CResult_FixedPenaltyScorerDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
  void CResult_FixedPenaltyScorerDecodeErrorZ_free(
    LDKCResult_FixedPenaltyScorerDecodeErrorZ _res,
  ) {
    return _CResult_FixedPenaltyScorerDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_FixedPenaltyScorerDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_FixedPenaltyScorerDecodeErrorZ)>>(
      'CResult_FixedPenaltyScorerDecodeErrorZ_free');
  late final _CResult_FixedPenaltyScorerDecodeErrorZ_free =
      _CResult_FixedPenaltyScorerDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_FixedPenaltyScorerDecodeErrorZ)>();

  /// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_FixedPenaltyScorerDecodeErrorZ
      CResult_FixedPenaltyScorerDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ> orig,
  ) {
    return _CResult_FixedPenaltyScorerDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_FixedPenaltyScorerDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ>)>>(
      'CResult_FixedPenaltyScorerDecodeErrorZ_clone');
  late final _CResult_FixedPenaltyScorerDecodeErrorZ_clone =
      _CResult_FixedPenaltyScorerDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_FixedPenaltyScorerDecodeErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_clone(
    ffi.Pointer<LDKC2Tuple_u64u64Z> orig,
  ) {
    return _C2Tuple_u64u64Z_clone(
      orig,
    );
  }

  late final _C2Tuple_u64u64Z_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u64u64Z Function(
              ffi.Pointer<LDKC2Tuple_u64u64Z>)>>('C2Tuple_u64u64Z_clone');
  late final _C2Tuple_u64u64Z_clone = _C2Tuple_u64u64Z_clonePtr.asFunction<
      LDKC2Tuple_u64u64Z Function(ffi.Pointer<LDKC2Tuple_u64u64Z>)>();

  /// Creates a new C2Tuple_u64u64Z from the contained elements.
  LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_new(
    int a,
    int b,
  ) {
    return _C2Tuple_u64u64Z_new(
      a,
      b,
    );
  }

  late final _C2Tuple_u64u64Z_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u64u64Z Function(
              ffi.Uint64, ffi.Uint64)>>('C2Tuple_u64u64Z_new');
  late final _C2Tuple_u64u64Z_new = _C2Tuple_u64u64Z_newPtr.asFunction<
      LDKC2Tuple_u64u64Z Function(int, int)>();

  /// Frees any resources used by the C2Tuple_u64u64Z.
  void C2Tuple_u64u64Z_free(
    LDKC2Tuple_u64u64Z _res,
  ) {
    return _C2Tuple_u64u64Z_free(
      _res,
    );
  }

  late final _C2Tuple_u64u64Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_u64u64Z)>>(
          'C2Tuple_u64u64Z_free');
  late final _C2Tuple_u64u64Z_free =
      _C2Tuple_u64u64Z_freePtr.asFunction<void Function(LDKC2Tuple_u64u64Z)>();

  /// Constructs a new COption_C2Tuple_u64u64ZZ containing a crate::c_types::derived::C2Tuple_u64u64Z
  LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_some(
    LDKC2Tuple_u64u64Z o,
  ) {
    return _COption_C2Tuple_u64u64ZZ_some(
      o,
    );
  }

  late final _COption_C2Tuple_u64u64ZZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_C2Tuple_u64u64ZZ Function(
              LDKC2Tuple_u64u64Z)>>('COption_C2Tuple_u64u64ZZ_some');
  late final _COption_C2Tuple_u64u64ZZ_some = _COption_C2Tuple_u64u64ZZ_somePtr
      .asFunction<LDKCOption_C2Tuple_u64u64ZZ Function(LDKC2Tuple_u64u64Z)>();

  /// Constructs a new COption_C2Tuple_u64u64ZZ containing nothing
  LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_none() {
    return _COption_C2Tuple_u64u64ZZ_none();
  }

  late final _COption_C2Tuple_u64u64ZZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_C2Tuple_u64u64ZZ Function()>>(
          'COption_C2Tuple_u64u64ZZ_none');
  late final _COption_C2Tuple_u64u64ZZ_none = _COption_C2Tuple_u64u64ZZ_nonePtr
      .asFunction<LDKCOption_C2Tuple_u64u64ZZ Function()>();

  /// Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u64Z, if we are in the Some state
  void COption_C2Tuple_u64u64ZZ_free(
    LDKCOption_C2Tuple_u64u64ZZ _res,
  ) {
    return _COption_C2Tuple_u64u64ZZ_free(
      _res,
    );
  }

  late final _COption_C2Tuple_u64u64ZZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCOption_C2Tuple_u64u64ZZ)>>(
      'COption_C2Tuple_u64u64ZZ_free');
  late final _COption_C2Tuple_u64u64ZZ_free = _COption_C2Tuple_u64u64ZZ_freePtr
      .asFunction<void Function(LDKCOption_C2Tuple_u64u64ZZ)>();

  /// Creates a new COption_C2Tuple_u64u64ZZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_clone(
    ffi.Pointer<LDKCOption_C2Tuple_u64u64ZZ> orig,
  ) {
    return _COption_C2Tuple_u64u64ZZ_clone(
      orig,
    );
  }

  late final _COption_C2Tuple_u64u64ZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_C2Tuple_u64u64ZZ Function(
                  ffi.Pointer<LDKCOption_C2Tuple_u64u64ZZ>)>>(
      'COption_C2Tuple_u64u64ZZ_clone');
  late final _COption_C2Tuple_u64u64ZZ_clone =
      _COption_C2Tuple_u64u64ZZ_clonePtr.asFunction<
          LDKCOption_C2Tuple_u64u64ZZ Function(
              ffi.Pointer<LDKCOption_C2Tuple_u64u64ZZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_NodeIdZ_free(
    LDKCVec_NodeIdZ _res,
  ) {
    return _CVec_NodeIdZ_free(
      _res,
    );
  }

  late final _CVec_NodeIdZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_NodeIdZ)>>(
          'CVec_NodeIdZ_free');
  late final _CVec_NodeIdZ_free =
      _CVec_NodeIdZ_freePtr.asFunction<void Function(LDKCVec_NodeIdZ)>();

  /// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
  LDKCResult_ProbabilisticScorerDecodeErrorZ
      CResult_ProbabilisticScorerDecodeErrorZ_ok(
    LDKProbabilisticScorer o,
  ) {
    return _CResult_ProbabilisticScorerDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ProbabilisticScorerDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
                  LDKProbabilisticScorer)>>(
      'CResult_ProbabilisticScorerDecodeErrorZ_ok');
  late final _CResult_ProbabilisticScorerDecodeErrorZ_ok =
      _CResult_ProbabilisticScorerDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
              LDKProbabilisticScorer)>();

  /// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
  LDKCResult_ProbabilisticScorerDecodeErrorZ
      CResult_ProbabilisticScorerDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ProbabilisticScorerDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ProbabilisticScorerDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ProbabilisticScorerDecodeErrorZ_err');
  late final _CResult_ProbabilisticScorerDecodeErrorZ_err =
      _CResult_ProbabilisticScorerDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ProbabilisticScorerDecodeErrorZ> o,
  ) {
    return _CResult_ProbabilisticScorerDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ProbabilisticScorerDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ProbabilisticScorerDecodeErrorZ>)>>(
      'CResult_ProbabilisticScorerDecodeErrorZ_is_ok');
  late final _CResult_ProbabilisticScorerDecodeErrorZ_is_ok =
      _CResult_ProbabilisticScorerDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ProbabilisticScorerDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
  void CResult_ProbabilisticScorerDecodeErrorZ_free(
    LDKCResult_ProbabilisticScorerDecodeErrorZ _res,
  ) {
    return _CResult_ProbabilisticScorerDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ProbabilisticScorerDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ProbabilisticScorerDecodeErrorZ)>>(
      'CResult_ProbabilisticScorerDecodeErrorZ_free');
  late final _CResult_ProbabilisticScorerDecodeErrorZ_free =
      _CResult_ProbabilisticScorerDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ProbabilisticScorerDecodeErrorZ)>();

  /// Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
  LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(
    LDKInitFeatures o,
  ) {
    return _CResult_InitFeaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_InitFeaturesDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(
              LDKInitFeatures)>>('CResult_InitFeaturesDecodeErrorZ_ok');
  late final _CResult_InitFeaturesDecodeErrorZ_ok =
      _CResult_InitFeaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(LDKInitFeatures)>();

  /// Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
  LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_InitFeaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_InitFeaturesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_InitFeaturesDecodeErrorZ_err');
  late final _CResult_InitFeaturesDecodeErrorZ_err =
      _CResult_InitFeaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InitFeaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ> o,
  ) {
    return _CResult_InitFeaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InitFeaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ>)>>(
      'CResult_InitFeaturesDecodeErrorZ_is_ok');
  late final _CResult_InitFeaturesDecodeErrorZ_is_ok =
      _CResult_InitFeaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
  void CResult_InitFeaturesDecodeErrorZ_free(
    LDKCResult_InitFeaturesDecodeErrorZ _res,
  ) {
    return _CResult_InitFeaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_InitFeaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InitFeaturesDecodeErrorZ)>>(
      'CResult_InitFeaturesDecodeErrorZ_free');
  late final _CResult_InitFeaturesDecodeErrorZ_free =
      _CResult_InitFeaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InitFeaturesDecodeErrorZ)>();

  /// Creates a new CResult_InitFeaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ> orig,
  ) {
    return _CResult_InitFeaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InitFeaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InitFeaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ>)>>(
      'CResult_InitFeaturesDecodeErrorZ_clone');
  late final _CResult_InitFeaturesDecodeErrorZ_clone =
      _CResult_InitFeaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_InitFeaturesDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
  LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(
    LDKChannelFeatures o,
  ) {
    return _CResult_ChannelFeaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelFeaturesDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(
              LDKChannelFeatures)>>('CResult_ChannelFeaturesDecodeErrorZ_ok');
  late final _CResult_ChannelFeaturesDecodeErrorZ_ok =
      _CResult_ChannelFeaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(
              LDKChannelFeatures)>();

  /// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
  LDKCResult_ChannelFeaturesDecodeErrorZ
      CResult_ChannelFeaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelFeaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelFeaturesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelFeaturesDecodeErrorZ_err');
  late final _CResult_ChannelFeaturesDecodeErrorZ_err =
      _CResult_ChannelFeaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ> o,
  ) {
    return _CResult_ChannelFeaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelFeaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ>)>>(
      'CResult_ChannelFeaturesDecodeErrorZ_is_ok');
  late final _CResult_ChannelFeaturesDecodeErrorZ_is_ok =
      _CResult_ChannelFeaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
  void CResult_ChannelFeaturesDecodeErrorZ_free(
    LDKCResult_ChannelFeaturesDecodeErrorZ _res,
  ) {
    return _CResult_ChannelFeaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelFeaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelFeaturesDecodeErrorZ)>>(
      'CResult_ChannelFeaturesDecodeErrorZ_free');
  late final _CResult_ChannelFeaturesDecodeErrorZ_free =
      _CResult_ChannelFeaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelFeaturesDecodeErrorZ)>();

  /// Creates a new CResult_ChannelFeaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelFeaturesDecodeErrorZ
      CResult_ChannelFeaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelFeaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelFeaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelFeaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ>)>>(
      'CResult_ChannelFeaturesDecodeErrorZ_clone');
  late final _CResult_ChannelFeaturesDecodeErrorZ_clone =
      _CResult_ChannelFeaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelFeaturesDecodeErrorZ>)>();

  /// Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
  LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(
    LDKNodeFeatures o,
  ) {
    return _CResult_NodeFeaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeFeaturesDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(
              LDKNodeFeatures)>>('CResult_NodeFeaturesDecodeErrorZ_ok');
  late final _CResult_NodeFeaturesDecodeErrorZ_ok =
      _CResult_NodeFeaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(LDKNodeFeatures)>();

  /// Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
  LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeFeaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeFeaturesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeFeaturesDecodeErrorZ_err');
  late final _CResult_NodeFeaturesDecodeErrorZ_err =
      _CResult_NodeFeaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeFeaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ> o,
  ) {
    return _CResult_NodeFeaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeFeaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ>)>>(
      'CResult_NodeFeaturesDecodeErrorZ_is_ok');
  late final _CResult_NodeFeaturesDecodeErrorZ_is_ok =
      _CResult_NodeFeaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
  void CResult_NodeFeaturesDecodeErrorZ_free(
    LDKCResult_NodeFeaturesDecodeErrorZ _res,
  ) {
    return _CResult_NodeFeaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeFeaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NodeFeaturesDecodeErrorZ)>>(
      'CResult_NodeFeaturesDecodeErrorZ_free');
  late final _CResult_NodeFeaturesDecodeErrorZ_free =
      _CResult_NodeFeaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeFeaturesDecodeErrorZ)>();

  /// Creates a new CResult_NodeFeaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ> orig,
  ) {
    return _CResult_NodeFeaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeFeaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeFeaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ>)>>(
      'CResult_NodeFeaturesDecodeErrorZ_clone');
  late final _CResult_NodeFeaturesDecodeErrorZ_clone =
      _CResult_NodeFeaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeFeaturesDecodeErrorZ>)>();

  /// Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the success state.
  LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(
    LDKInvoiceFeatures o,
  ) {
    return _CResult_InvoiceFeaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_InvoiceFeaturesDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
              LDKInvoiceFeatures)>>('CResult_InvoiceFeaturesDecodeErrorZ_ok');
  late final _CResult_InvoiceFeaturesDecodeErrorZ_ok =
      _CResult_InvoiceFeaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
              LDKInvoiceFeatures)>();

  /// Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the error state.
  LDKCResult_InvoiceFeaturesDecodeErrorZ
      CResult_InvoiceFeaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_InvoiceFeaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_InvoiceFeaturesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_InvoiceFeaturesDecodeErrorZ_err');
  late final _CResult_InvoiceFeaturesDecodeErrorZ_err =
      _CResult_InvoiceFeaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InvoiceFeaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ> o,
  ) {
    return _CResult_InvoiceFeaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InvoiceFeaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ>)>>(
      'CResult_InvoiceFeaturesDecodeErrorZ_is_ok');
  late final _CResult_InvoiceFeaturesDecodeErrorZ_is_ok =
      _CResult_InvoiceFeaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_InvoiceFeaturesDecodeErrorZ.
  void CResult_InvoiceFeaturesDecodeErrorZ_free(
    LDKCResult_InvoiceFeaturesDecodeErrorZ _res,
  ) {
    return _CResult_InvoiceFeaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_InvoiceFeaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InvoiceFeaturesDecodeErrorZ)>>(
      'CResult_InvoiceFeaturesDecodeErrorZ_free');
  late final _CResult_InvoiceFeaturesDecodeErrorZ_free =
      _CResult_InvoiceFeaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InvoiceFeaturesDecodeErrorZ)>();

  /// Creates a new CResult_InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InvoiceFeaturesDecodeErrorZ
      CResult_InvoiceFeaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ> orig,
  ) {
    return _CResult_InvoiceFeaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InvoiceFeaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ>)>>(
      'CResult_InvoiceFeaturesDecodeErrorZ_clone');
  late final _CResult_InvoiceFeaturesDecodeErrorZ_clone =
      _CResult_InvoiceFeaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_InvoiceFeaturesDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
  LDKCResult_ChannelTypeFeaturesDecodeErrorZ
      CResult_ChannelTypeFeaturesDecodeErrorZ_ok(
    LDKChannelTypeFeatures o,
  ) {
    return _CResult_ChannelTypeFeaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
                  LDKChannelTypeFeatures)>>(
      'CResult_ChannelTypeFeaturesDecodeErrorZ_ok');
  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_ok =
      _CResult_ChannelTypeFeaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
              LDKChannelTypeFeatures)>();

  /// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
  LDKCResult_ChannelTypeFeaturesDecodeErrorZ
      CResult_ChannelTypeFeaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelTypeFeaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelTypeFeaturesDecodeErrorZ_err');
  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_err =
      _CResult_ChannelTypeFeaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ> o,
  ) {
    return _CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ>)>>(
      'CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok');
  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok =
      _CResult_ChannelTypeFeaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
  void CResult_ChannelTypeFeaturesDecodeErrorZ_free(
    LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res,
  ) {
    return _CResult_ChannelTypeFeaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelTypeFeaturesDecodeErrorZ)>>(
      'CResult_ChannelTypeFeaturesDecodeErrorZ_free');
  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_free =
      _CResult_ChannelTypeFeaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelTypeFeaturesDecodeErrorZ)>();

  /// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelTypeFeaturesDecodeErrorZ
      CResult_ChannelTypeFeaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelTypeFeaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ>)>>(
      'CResult_ChannelTypeFeaturesDecodeErrorZ_clone');
  late final _CResult_ChannelTypeFeaturesDecodeErrorZ_clone =
      _CResult_ChannelTypeFeaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelTypeFeaturesDecodeErrorZ>)>();

  /// Creates a new CResult_NodeIdDecodeErrorZ in the success state.
  LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(
    LDKNodeId o,
  ) {
    return _CResult_NodeIdDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeIdDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeIdDecodeErrorZ Function(
              LDKNodeId)>>('CResult_NodeIdDecodeErrorZ_ok');
  late final _CResult_NodeIdDecodeErrorZ_ok = _CResult_NodeIdDecodeErrorZ_okPtr
      .asFunction<LDKCResult_NodeIdDecodeErrorZ Function(LDKNodeId)>();

  /// Creates a new CResult_NodeIdDecodeErrorZ in the error state.
  LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeIdDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeIdDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeIdDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeIdDecodeErrorZ_err');
  late final _CResult_NodeIdDecodeErrorZ_err =
      _CResult_NodeIdDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeIdDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeIdDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ> o,
  ) {
    return _CResult_NodeIdDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeIdDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ>)>>(
      'CResult_NodeIdDecodeErrorZ_is_ok');
  late final _CResult_NodeIdDecodeErrorZ_is_ok =
      _CResult_NodeIdDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeIdDecodeErrorZ.
  void CResult_NodeIdDecodeErrorZ_free(
    LDKCResult_NodeIdDecodeErrorZ _res,
  ) {
    return _CResult_NodeIdDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeIdDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_NodeIdDecodeErrorZ)>>(
      'CResult_NodeIdDecodeErrorZ_free');
  late final _CResult_NodeIdDecodeErrorZ_free =
      _CResult_NodeIdDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeIdDecodeErrorZ)>();

  /// Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ> orig,
  ) {
    return _CResult_NodeIdDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeIdDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeIdDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ>)>>(
      'CResult_NodeIdDecodeErrorZ_clone');
  late final _CResult_NodeIdDecodeErrorZ_clone =
      _CResult_NodeIdDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeIdDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeIdDecodeErrorZ>)>();

  /// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
  LDKCResult_COption_NetworkUpdateZDecodeErrorZ
      CResult_COption_NetworkUpdateZDecodeErrorZ_ok(
    LDKCOption_NetworkUpdateZ o,
  ) {
    return _CResult_COption_NetworkUpdateZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
                  LDKCOption_NetworkUpdateZ)>>(
      'CResult_COption_NetworkUpdateZDecodeErrorZ_ok');
  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_ok =
      _CResult_COption_NetworkUpdateZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
              LDKCOption_NetworkUpdateZ)>();

  /// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
  LDKCResult_COption_NetworkUpdateZDecodeErrorZ
      CResult_COption_NetworkUpdateZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_NetworkUpdateZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_COption_NetworkUpdateZDecodeErrorZ_err');
  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_err =
      _CResult_COption_NetworkUpdateZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ> o,
  ) {
    return _CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ>)>>(
      'CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok');
  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok =
      _CResult_COption_NetworkUpdateZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
  void CResult_COption_NetworkUpdateZDecodeErrorZ_free(
    LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res,
  ) {
    return _CResult_COption_NetworkUpdateZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_COption_NetworkUpdateZDecodeErrorZ)>>(
      'CResult_COption_NetworkUpdateZDecodeErrorZ_free');
  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_free =
      _CResult_COption_NetworkUpdateZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_NetworkUpdateZDecodeErrorZ)>();

  /// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_NetworkUpdateZDecodeErrorZ
      CResult_COption_NetworkUpdateZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_NetworkUpdateZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ>)>>(
      'CResult_COption_NetworkUpdateZDecodeErrorZ_clone');
  late final _CResult_COption_NetworkUpdateZDecodeErrorZ_clone =
      _CResult_COption_NetworkUpdateZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_NetworkUpdateZDecodeErrorZ>)>();

  /// Constructs a new COption_AccessZ containing a crate::lightning::chain::Access
  LDKCOption_AccessZ COption_AccessZ_some(
    LDKAccess o,
  ) {
    return _COption_AccessZ_some(
      o,
    );
  }

  late final _COption_AccessZ_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_AccessZ Function(LDKAccess)>>(
          'COption_AccessZ_some');
  late final _COption_AccessZ_some = _COption_AccessZ_somePtr.asFunction<
      LDKCOption_AccessZ Function(LDKAccess)>();

  /// Constructs a new COption_AccessZ containing nothing
  LDKCOption_AccessZ COption_AccessZ_none() {
    return _COption_AccessZ_none();
  }

  late final _COption_AccessZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_AccessZ Function()>>(
          'COption_AccessZ_none');
  late final _COption_AccessZ_none =
      _COption_AccessZ_nonePtr.asFunction<LDKCOption_AccessZ Function()>();

  /// Frees any resources associated with the crate::lightning::chain::Access, if we are in the Some state
  void COption_AccessZ_free(
    LDKCOption_AccessZ _res,
  ) {
    return _COption_AccessZ_free(
      _res,
    );
  }

  late final _COption_AccessZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_AccessZ)>>(
          'COption_AccessZ_free');
  late final _COption_AccessZ_free =
      _COption_AccessZ_freePtr.asFunction<void Function(LDKCOption_AccessZ)>();

  /// Creates a new CResult_boolLightningErrorZ in the success state.
  LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(
    bool o,
  ) {
    return _CResult_boolLightningErrorZ_ok(
      o,
    );
  }

  late final _CResult_boolLightningErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_boolLightningErrorZ Function(
              ffi.Bool)>>('CResult_boolLightningErrorZ_ok');
  late final _CResult_boolLightningErrorZ_ok =
      _CResult_boolLightningErrorZ_okPtr.asFunction<
          LDKCResult_boolLightningErrorZ Function(bool)>();

  /// Creates a new CResult_boolLightningErrorZ in the error state.
  LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(
    LDKLightningError e,
  ) {
    return _CResult_boolLightningErrorZ_err(
      e,
    );
  }

  late final _CResult_boolLightningErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_boolLightningErrorZ Function(
              LDKLightningError)>>('CResult_boolLightningErrorZ_err');
  late final _CResult_boolLightningErrorZ_err =
      _CResult_boolLightningErrorZ_errPtr.asFunction<
          LDKCResult_boolLightningErrorZ Function(LDKLightningError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_boolLightningErrorZ_is_ok(
    ffi.Pointer<LDKCResult_boolLightningErrorZ> o,
  ) {
    return _CResult_boolLightningErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_boolLightningErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_boolLightningErrorZ>)>>(
      'CResult_boolLightningErrorZ_is_ok');
  late final _CResult_boolLightningErrorZ_is_ok =
      _CResult_boolLightningErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_boolLightningErrorZ>)>();

  /// Frees any resources used by the CResult_boolLightningErrorZ.
  void CResult_boolLightningErrorZ_free(
    LDKCResult_boolLightningErrorZ _res,
  ) {
    return _CResult_boolLightningErrorZ_free(
      _res,
    );
  }

  late final _CResult_boolLightningErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_boolLightningErrorZ)>>(
      'CResult_boolLightningErrorZ_free');
  late final _CResult_boolLightningErrorZ_free =
      _CResult_boolLightningErrorZ_freePtr.asFunction<
          void Function(LDKCResult_boolLightningErrorZ)>();

  /// Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(
    ffi.Pointer<LDKCResult_boolLightningErrorZ> orig,
  ) {
    return _CResult_boolLightningErrorZ_clone(
      orig,
    );
  }

  late final _CResult_boolLightningErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_boolLightningErrorZ Function(
                  ffi.Pointer<LDKCResult_boolLightningErrorZ>)>>(
      'CResult_boolLightningErrorZ_clone');
  late final _CResult_boolLightningErrorZ_clone =
      _CResult_boolLightningErrorZ_clonePtr.asFunction<
          LDKCResult_boolLightningErrorZ Function(
              ffi.Pointer<LDKCResult_boolLightningErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
      C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(
    ffi.Pointer<LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ> orig,
  ) {
    return _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(
      orig,
    );
  }

  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ Function(
                  ffi.Pointer<
                      LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ>)>>(
      'C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone');
  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone =
      _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clonePtr.asFunction<
          LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ Function(
              ffi.Pointer<
                  LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ>)>();

  /// Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
  LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
      C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(
    LDKChannelAnnouncement a,
    LDKChannelUpdate b,
    LDKChannelUpdate c,
  ) {
    return _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(
      a,
      b,
      c,
    );
  }

  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_newPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ Function(
                      LDKChannelAnnouncement,
                      LDKChannelUpdate,
                      LDKChannelUpdate)>>(
          'C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new');
  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new =
      _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_newPtr.asFunction<
          LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ Function(
              LDKChannelAnnouncement, LDKChannelUpdate, LDKChannelUpdate)>();

  /// Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
  void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(
    LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res,
  ) {
    return _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(
      _res,
    );
  }

  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ)>>(
          'C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free');
  late final _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free =
      _C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_freePtr
          .asFunction<
              void Function(
                  LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(
    LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res,
  ) {
    return _CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(
      _res,
    );
  }

  late final _CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ)>>(
          'CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free');
  late final _CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free =
      _CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_freePtr
          .asFunction<
              void Function(
                  LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_NodeAnnouncementZ_free(
    LDKCVec_NodeAnnouncementZ _res,
  ) {
    return _CVec_NodeAnnouncementZ_free(
      _res,
    );
  }

  late final _CVec_NodeAnnouncementZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_NodeAnnouncementZ)>>(
          'CVec_NodeAnnouncementZ_free');
  late final _CVec_NodeAnnouncementZ_free = _CVec_NodeAnnouncementZ_freePtr
      .asFunction<void Function(LDKCVec_NodeAnnouncementZ)>();

  /// Creates a new CResult_NoneLightningErrorZ in the success state.
  LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok() {
    return _CResult_NoneLightningErrorZ_ok();
  }

  late final _CResult_NoneLightningErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneLightningErrorZ Function()>>(
          'CResult_NoneLightningErrorZ_ok');
  late final _CResult_NoneLightningErrorZ_ok =
      _CResult_NoneLightningErrorZ_okPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function()>();

  /// Creates a new CResult_NoneLightningErrorZ in the error state.
  LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(
    LDKLightningError e,
  ) {
    return _CResult_NoneLightningErrorZ_err(
      e,
    );
  }

  late final _CResult_NoneLightningErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneLightningErrorZ Function(
              LDKLightningError)>>('CResult_NoneLightningErrorZ_err');
  late final _CResult_NoneLightningErrorZ_err =
      _CResult_NoneLightningErrorZ_errPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(LDKLightningError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneLightningErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NoneLightningErrorZ> o,
  ) {
    return _CResult_NoneLightningErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneLightningErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NoneLightningErrorZ>)>>(
      'CResult_NoneLightningErrorZ_is_ok');
  late final _CResult_NoneLightningErrorZ_is_ok =
      _CResult_NoneLightningErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NoneLightningErrorZ>)>();

  /// Frees any resources used by the CResult_NoneLightningErrorZ.
  void CResult_NoneLightningErrorZ_free(
    LDKCResult_NoneLightningErrorZ _res,
  ) {
    return _CResult_NoneLightningErrorZ_free(
      _res,
    );
  }

  late final _CResult_NoneLightningErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NoneLightningErrorZ)>>(
      'CResult_NoneLightningErrorZ_free');
  late final _CResult_NoneLightningErrorZ_free =
      _CResult_NoneLightningErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NoneLightningErrorZ)>();

  /// Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(
    ffi.Pointer<LDKCResult_NoneLightningErrorZ> orig,
  ) {
    return _CResult_NoneLightningErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NoneLightningErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKCResult_NoneLightningErrorZ>)>>(
      'CResult_NoneLightningErrorZ_clone');
  late final _CResult_NoneLightningErrorZ_clone =
      _CResult_NoneLightningErrorZ_clonePtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(
              ffi.Pointer<LDKCResult_NoneLightningErrorZ>)>();

  /// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
  LDKCResult_ChannelUpdateInfoDecodeErrorZ
      CResult_ChannelUpdateInfoDecodeErrorZ_ok(
    LDKChannelUpdateInfo o,
  ) {
    return _CResult_ChannelUpdateInfoDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelUpdateInfoDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
                  LDKChannelUpdateInfo)>>(
      'CResult_ChannelUpdateInfoDecodeErrorZ_ok');
  late final _CResult_ChannelUpdateInfoDecodeErrorZ_ok =
      _CResult_ChannelUpdateInfoDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
              LDKChannelUpdateInfo)>();

  /// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
  LDKCResult_ChannelUpdateInfoDecodeErrorZ
      CResult_ChannelUpdateInfoDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelUpdateInfoDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelUpdateInfoDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelUpdateInfoDecodeErrorZ_err');
  late final _CResult_ChannelUpdateInfoDecodeErrorZ_err =
      _CResult_ChannelUpdateInfoDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ> o,
  ) {
    return _CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelUpdateInfoDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ>)>>(
      'CResult_ChannelUpdateInfoDecodeErrorZ_is_ok');
  late final _CResult_ChannelUpdateInfoDecodeErrorZ_is_ok =
      _CResult_ChannelUpdateInfoDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
  void CResult_ChannelUpdateInfoDecodeErrorZ_free(
    LDKCResult_ChannelUpdateInfoDecodeErrorZ _res,
  ) {
    return _CResult_ChannelUpdateInfoDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelUpdateInfoDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelUpdateInfoDecodeErrorZ)>>(
      'CResult_ChannelUpdateInfoDecodeErrorZ_free');
  late final _CResult_ChannelUpdateInfoDecodeErrorZ_free =
      _CResult_ChannelUpdateInfoDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelUpdateInfoDecodeErrorZ)>();

  /// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelUpdateInfoDecodeErrorZ
      CResult_ChannelUpdateInfoDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelUpdateInfoDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelUpdateInfoDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ>)>>(
      'CResult_ChannelUpdateInfoDecodeErrorZ_clone');
  late final _CResult_ChannelUpdateInfoDecodeErrorZ_clone =
      _CResult_ChannelUpdateInfoDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelUpdateInfoDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
  LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(
    LDKChannelInfo o,
  ) {
    return _CResult_ChannelInfoDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelInfoDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(
              LDKChannelInfo)>>('CResult_ChannelInfoDecodeErrorZ_ok');
  late final _CResult_ChannelInfoDecodeErrorZ_ok =
      _CResult_ChannelInfoDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(LDKChannelInfo)>();

  /// Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
  LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelInfoDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelInfoDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelInfoDecodeErrorZ_err');
  late final _CResult_ChannelInfoDecodeErrorZ_err =
      _CResult_ChannelInfoDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelInfoDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ> o,
  ) {
    return _CResult_ChannelInfoDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelInfoDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ>)>>(
      'CResult_ChannelInfoDecodeErrorZ_is_ok');
  late final _CResult_ChannelInfoDecodeErrorZ_is_ok =
      _CResult_ChannelInfoDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
  void CResult_ChannelInfoDecodeErrorZ_free(
    LDKCResult_ChannelInfoDecodeErrorZ _res,
  ) {
    return _CResult_ChannelInfoDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelInfoDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelInfoDecodeErrorZ)>>(
      'CResult_ChannelInfoDecodeErrorZ_free');
  late final _CResult_ChannelInfoDecodeErrorZ_free =
      _CResult_ChannelInfoDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelInfoDecodeErrorZ)>();

  /// Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelInfoDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelInfoDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelInfoDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ>)>>(
      'CResult_ChannelInfoDecodeErrorZ_clone');
  late final _CResult_ChannelInfoDecodeErrorZ_clone =
      _CResult_ChannelInfoDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelInfoDecodeErrorZ>)>();

  /// Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
  LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(
    LDKRoutingFees o,
  ) {
    return _CResult_RoutingFeesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RoutingFeesDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(
              LDKRoutingFees)>>('CResult_RoutingFeesDecodeErrorZ_ok');
  late final _CResult_RoutingFeesDecodeErrorZ_ok =
      _CResult_RoutingFeesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(LDKRoutingFees)>();

  /// Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
  LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RoutingFeesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RoutingFeesDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RoutingFeesDecodeErrorZ_err');
  late final _CResult_RoutingFeesDecodeErrorZ_err =
      _CResult_RoutingFeesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RoutingFeesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ> o,
  ) {
    return _CResult_RoutingFeesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RoutingFeesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ>)>>(
      'CResult_RoutingFeesDecodeErrorZ_is_ok');
  late final _CResult_RoutingFeesDecodeErrorZ_is_ok =
      _CResult_RoutingFeesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
  void CResult_RoutingFeesDecodeErrorZ_free(
    LDKCResult_RoutingFeesDecodeErrorZ _res,
  ) {
    return _CResult_RoutingFeesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RoutingFeesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RoutingFeesDecodeErrorZ)>>(
      'CResult_RoutingFeesDecodeErrorZ_free');
  late final _CResult_RoutingFeesDecodeErrorZ_free =
      _CResult_RoutingFeesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RoutingFeesDecodeErrorZ)>();

  /// Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ> orig,
  ) {
    return _CResult_RoutingFeesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RoutingFeesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RoutingFeesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ>)>>(
      'CResult_RoutingFeesDecodeErrorZ_clone');
  late final _CResult_RoutingFeesDecodeErrorZ_clone =
      _CResult_RoutingFeesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RoutingFeesDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_NetAddressZ_free(
    LDKCVec_NetAddressZ _res,
  ) {
    return _CVec_NetAddressZ_free(
      _res,
    );
  }

  late final _CVec_NetAddressZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_NetAddressZ)>>(
          'CVec_NetAddressZ_free');
  late final _CVec_NetAddressZ_free = _CVec_NetAddressZ_freePtr.asFunction<
      void Function(LDKCVec_NetAddressZ)>();

  /// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
  LDKCResult_NodeAnnouncementInfoDecodeErrorZ
      CResult_NodeAnnouncementInfoDecodeErrorZ_ok(
    LDKNodeAnnouncementInfo o,
  ) {
    return _CResult_NodeAnnouncementInfoDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
                  LDKNodeAnnouncementInfo)>>(
      'CResult_NodeAnnouncementInfoDecodeErrorZ_ok');
  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_ok =
      _CResult_NodeAnnouncementInfoDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
              LDKNodeAnnouncementInfo)>();

  /// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
  LDKCResult_NodeAnnouncementInfoDecodeErrorZ
      CResult_NodeAnnouncementInfoDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeAnnouncementInfoDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeAnnouncementInfoDecodeErrorZ_err');
  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_err =
      _CResult_NodeAnnouncementInfoDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ> o,
  ) {
    return _CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ>)>>(
      'CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok');
  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok =
      _CResult_NodeAnnouncementInfoDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
  void CResult_NodeAnnouncementInfoDecodeErrorZ_free(
    LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res,
  ) {
    return _CResult_NodeAnnouncementInfoDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NodeAnnouncementInfoDecodeErrorZ)>>(
      'CResult_NodeAnnouncementInfoDecodeErrorZ_free');
  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_free =
      _CResult_NodeAnnouncementInfoDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeAnnouncementInfoDecodeErrorZ)>();

  /// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeAnnouncementInfoDecodeErrorZ
      CResult_NodeAnnouncementInfoDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ> orig,
  ) {
    return _CResult_NodeAnnouncementInfoDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ>)>>(
      'CResult_NodeAnnouncementInfoDecodeErrorZ_clone');
  late final _CResult_NodeAnnouncementInfoDecodeErrorZ_clone =
      _CResult_NodeAnnouncementInfoDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeAnnouncementInfoDecodeErrorZ>)>();

  /// Creates a new CResult_NodeAliasDecodeErrorZ in the success state.
  LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_ok(
    LDKNodeAlias o,
  ) {
    return _CResult_NodeAliasDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeAliasDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(
              LDKNodeAlias)>>('CResult_NodeAliasDecodeErrorZ_ok');
  late final _CResult_NodeAliasDecodeErrorZ_ok =
      _CResult_NodeAliasDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(LDKNodeAlias)>();

  /// Creates a new CResult_NodeAliasDecodeErrorZ in the error state.
  LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeAliasDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeAliasDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeAliasDecodeErrorZ_err');
  late final _CResult_NodeAliasDecodeErrorZ_err =
      _CResult_NodeAliasDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeAliasDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ> o,
  ) {
    return _CResult_NodeAliasDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeAliasDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ>)>>(
      'CResult_NodeAliasDecodeErrorZ_is_ok');
  late final _CResult_NodeAliasDecodeErrorZ_is_ok =
      _CResult_NodeAliasDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeAliasDecodeErrorZ.
  void CResult_NodeAliasDecodeErrorZ_free(
    LDKCResult_NodeAliasDecodeErrorZ _res,
  ) {
    return _CResult_NodeAliasDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeAliasDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NodeAliasDecodeErrorZ)>>(
      'CResult_NodeAliasDecodeErrorZ_free');
  late final _CResult_NodeAliasDecodeErrorZ_free =
      _CResult_NodeAliasDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeAliasDecodeErrorZ)>();

  /// Creates a new CResult_NodeAliasDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ> orig,
  ) {
    return _CResult_NodeAliasDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeAliasDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeAliasDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ>)>>(
      'CResult_NodeAliasDecodeErrorZ_clone');
  late final _CResult_NodeAliasDecodeErrorZ_clone =
      _CResult_NodeAliasDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeAliasDecodeErrorZ>)>();

  /// Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
  LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(
    LDKNodeInfo o,
  ) {
    return _CResult_NodeInfoDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeInfoDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(
              LDKNodeInfo)>>('CResult_NodeInfoDecodeErrorZ_ok');
  late final _CResult_NodeInfoDecodeErrorZ_ok =
      _CResult_NodeInfoDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(LDKNodeInfo)>();

  /// Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
  LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeInfoDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeInfoDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeInfoDecodeErrorZ_err');
  late final _CResult_NodeInfoDecodeErrorZ_err =
      _CResult_NodeInfoDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeInfoDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ> o,
  ) {
    return _CResult_NodeInfoDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeInfoDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ>)>>(
      'CResult_NodeInfoDecodeErrorZ_is_ok');
  late final _CResult_NodeInfoDecodeErrorZ_is_ok =
      _CResult_NodeInfoDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
  void CResult_NodeInfoDecodeErrorZ_free(
    LDKCResult_NodeInfoDecodeErrorZ _res,
  ) {
    return _CResult_NodeInfoDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeInfoDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NodeInfoDecodeErrorZ)>>(
      'CResult_NodeInfoDecodeErrorZ_free');
  late final _CResult_NodeInfoDecodeErrorZ_free =
      _CResult_NodeInfoDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeInfoDecodeErrorZ)>();

  /// Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ> orig,
  ) {
    return _CResult_NodeInfoDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeInfoDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeInfoDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ>)>>(
      'CResult_NodeInfoDecodeErrorZ_clone');
  late final _CResult_NodeInfoDecodeErrorZ_clone =
      _CResult_NodeInfoDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeInfoDecodeErrorZ>)>();

  /// Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
  LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(
    LDKNetworkGraph o,
  ) {
    return _CResult_NetworkGraphDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NetworkGraphDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetworkGraphDecodeErrorZ Function(
              LDKNetworkGraph)>>('CResult_NetworkGraphDecodeErrorZ_ok');
  late final _CResult_NetworkGraphDecodeErrorZ_ok =
      _CResult_NetworkGraphDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NetworkGraphDecodeErrorZ Function(LDKNetworkGraph)>();

  /// Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
  LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NetworkGraphDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NetworkGraphDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetworkGraphDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NetworkGraphDecodeErrorZ_err');
  late final _CResult_NetworkGraphDecodeErrorZ_err =
      _CResult_NetworkGraphDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NetworkGraphDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NetworkGraphDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NetworkGraphDecodeErrorZ> o,
  ) {
    return _CResult_NetworkGraphDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NetworkGraphDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NetworkGraphDecodeErrorZ>)>>(
      'CResult_NetworkGraphDecodeErrorZ_is_ok');
  late final _CResult_NetworkGraphDecodeErrorZ_is_ok =
      _CResult_NetworkGraphDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NetworkGraphDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
  void CResult_NetworkGraphDecodeErrorZ_free(
    LDKCResult_NetworkGraphDecodeErrorZ _res,
  ) {
    return _CResult_NetworkGraphDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NetworkGraphDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NetworkGraphDecodeErrorZ)>>(
      'CResult_NetworkGraphDecodeErrorZ_free');
  late final _CResult_NetworkGraphDecodeErrorZ_free =
      _CResult_NetworkGraphDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NetworkGraphDecodeErrorZ)>();

  /// Constructs a new COption_CVec_NetAddressZZ containing a crate::c_types::derived::CVec_NetAddressZ
  LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(
    LDKCVec_NetAddressZ o,
  ) {
    return _COption_CVec_NetAddressZZ_some(
      o,
    );
  }

  late final _COption_CVec_NetAddressZZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_CVec_NetAddressZZ Function(
              LDKCVec_NetAddressZ)>>('COption_CVec_NetAddressZZ_some');
  late final _COption_CVec_NetAddressZZ_some =
      _COption_CVec_NetAddressZZ_somePtr.asFunction<
          LDKCOption_CVec_NetAddressZZ Function(LDKCVec_NetAddressZ)>();

  /// Constructs a new COption_CVec_NetAddressZZ containing nothing
  LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none() {
    return _COption_CVec_NetAddressZZ_none();
  }

  late final _COption_CVec_NetAddressZZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_CVec_NetAddressZZ Function()>>(
          'COption_CVec_NetAddressZZ_none');
  late final _COption_CVec_NetAddressZZ_none =
      _COption_CVec_NetAddressZZ_nonePtr.asFunction<
          LDKCOption_CVec_NetAddressZZ Function()>();

  /// Frees any resources associated with the crate::c_types::derived::CVec_NetAddressZ, if we are in the Some state
  void COption_CVec_NetAddressZZ_free(
    LDKCOption_CVec_NetAddressZZ _res,
  ) {
    return _COption_CVec_NetAddressZZ_free(
      _res,
    );
  }

  late final _COption_CVec_NetAddressZZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCOption_CVec_NetAddressZZ)>>(
      'COption_CVec_NetAddressZZ_free');
  late final _COption_CVec_NetAddressZZ_free =
      _COption_CVec_NetAddressZZ_freePtr.asFunction<
          void Function(LDKCOption_CVec_NetAddressZZ)>();

  /// Creates a new COption_CVec_NetAddressZZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(
    ffi.Pointer<LDKCOption_CVec_NetAddressZZ> orig,
  ) {
    return _COption_CVec_NetAddressZZ_clone(
      orig,
    );
  }

  late final _COption_CVec_NetAddressZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_CVec_NetAddressZZ Function(
                  ffi.Pointer<LDKCOption_CVec_NetAddressZZ>)>>(
      'COption_CVec_NetAddressZZ_clone');
  late final _COption_CVec_NetAddressZZ_clone =
      _COption_CVec_NetAddressZZ_clonePtr.asFunction<
          LDKCOption_CVec_NetAddressZZ Function(
              ffi.Pointer<LDKCOption_CVec_NetAddressZZ>)>();

  /// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
      CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(
    LDKDelayedPaymentOutputDescriptor o,
  ) {
    return _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
                      Function(LDKDelayedPaymentOutputDescriptor)>>(
          'CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok');
  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok =
      _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_okPtr.asFunction<
          LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
              LDKDelayedPaymentOutputDescriptor)>();

  /// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
      CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
                      Function(LDKDecodeError)>>(
          'CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err');
  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err =
      _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_errPtr.asFunction<
          LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ> o,
  ) {
    return _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ>)>>(
      'CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok');
  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok =
      _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
  void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(
    LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res,
  ) {
    return _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ)>>(
          'CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free');
  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free =
      _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ)>();

  /// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
      CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ> orig,
  ) {
    return _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ>)>>(
      'CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone');
  late final _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone =
      _CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ>)>();

  /// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ
      CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(
    LDKStaticPaymentOutputDescriptor o,
  ) {
    return _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
                  LDKStaticPaymentOutputDescriptor)>>(
      'CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok');
  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok =
      _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_okPtr.asFunction<
          LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
              LDKStaticPaymentOutputDescriptor)>();

  /// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ
      CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
                      LDKDecodeError)>>(
          'CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err');
  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err =
      _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_errPtr.asFunction<
          LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ> o,
  ) {
    return _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ>)>>(
      'CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok');
  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok =
      _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
  void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(
    LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res,
  ) {
    return _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ)>>(
          'CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free');
  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free =
      _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ)>();

  /// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ
      CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ> orig,
  ) {
    return _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ>)>>(
      'CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone');
  late final _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone =
      _CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ>)>();

  /// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
  LDKCResult_SpendableOutputDescriptorDecodeErrorZ
      CResult_SpendableOutputDescriptorDecodeErrorZ_ok(
    LDKSpendableOutputDescriptor o,
  ) {
    return _CResult_SpendableOutputDescriptorDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
                  LDKSpendableOutputDescriptor)>>(
      'CResult_SpendableOutputDescriptorDecodeErrorZ_ok');
  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_ok =
      _CResult_SpendableOutputDescriptorDecodeErrorZ_okPtr.asFunction<
          LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
              LDKSpendableOutputDescriptor)>();

  /// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
  LDKCResult_SpendableOutputDescriptorDecodeErrorZ
      CResult_SpendableOutputDescriptorDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_SpendableOutputDescriptorDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_SpendableOutputDescriptorDecodeErrorZ_err');
  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_err =
      _CResult_SpendableOutputDescriptorDecodeErrorZ_errPtr.asFunction<
          LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_SpendableOutputDescriptorDecodeErrorZ> o,
  ) {
    return _CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_SpendableOutputDescriptorDecodeErrorZ>)>>(
      'CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok');
  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok =
      _CResult_SpendableOutputDescriptorDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_SpendableOutputDescriptorDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
  void CResult_SpendableOutputDescriptorDecodeErrorZ_free(
    LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res,
  ) {
    return _CResult_SpendableOutputDescriptorDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_SpendableOutputDescriptorDecodeErrorZ)>>(
      'CResult_SpendableOutputDescriptorDecodeErrorZ_free');
  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_free =
      _CResult_SpendableOutputDescriptorDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_SpendableOutputDescriptorDecodeErrorZ)>();

  /// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SpendableOutputDescriptorDecodeErrorZ
      CResult_SpendableOutputDescriptorDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_SpendableOutputDescriptorDecodeErrorZ> orig,
  ) {
    return _CResult_SpendableOutputDescriptorDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_SpendableOutputDescriptorDecodeErrorZ>)>>(
      'CResult_SpendableOutputDescriptorDecodeErrorZ_clone');
  late final _CResult_SpendableOutputDescriptorDecodeErrorZ_clone =
      _CResult_SpendableOutputDescriptorDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_SpendableOutputDescriptorDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_PaymentPreimageZ_free(
    LDKCVec_PaymentPreimageZ _res,
  ) {
    return _CVec_PaymentPreimageZ_free(
      _res,
    );
  }

  late final _CVec_PaymentPreimageZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_PaymentPreimageZ)>>(
          'CVec_PaymentPreimageZ_free');
  late final _CVec_PaymentPreimageZ_free = _CVec_PaymentPreimageZ_freePtr
      .asFunction<void Function(LDKCVec_PaymentPreimageZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(
    ffi.Pointer<LDKC2Tuple_SignatureCVec_SignatureZZ> orig,
  ) {
    return _C2Tuple_SignatureCVec_SignatureZZ_clone(
      orig,
    );
  }

  late final _C2Tuple_SignatureCVec_SignatureZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_SignatureCVec_SignatureZZ Function(
                  ffi.Pointer<LDKC2Tuple_SignatureCVec_SignatureZZ>)>>(
      'C2Tuple_SignatureCVec_SignatureZZ_clone');
  late final _C2Tuple_SignatureCVec_SignatureZZ_clone =
      _C2Tuple_SignatureCVec_SignatureZZ_clonePtr.asFunction<
          LDKC2Tuple_SignatureCVec_SignatureZZ Function(
              ffi.Pointer<LDKC2Tuple_SignatureCVec_SignatureZZ>)>();

  /// Creates a new C2Tuple_SignatureCVec_SignatureZZ from the contained elements.
  LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(
    LDKSignature a,
    LDKCVec_SignatureZ b,
  ) {
    return _C2Tuple_SignatureCVec_SignatureZZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_SignatureCVec_SignatureZZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_SignatureCVec_SignatureZZ Function(LDKSignature,
              LDKCVec_SignatureZ)>>('C2Tuple_SignatureCVec_SignatureZZ_new');
  late final _C2Tuple_SignatureCVec_SignatureZZ_new =
      _C2Tuple_SignatureCVec_SignatureZZ_newPtr.asFunction<
          LDKC2Tuple_SignatureCVec_SignatureZZ Function(
              LDKSignature, LDKCVec_SignatureZ)>();

  /// Frees any resources used by the C2Tuple_SignatureCVec_SignatureZZ.
  void C2Tuple_SignatureCVec_SignatureZZ_free(
    LDKC2Tuple_SignatureCVec_SignatureZZ _res,
  ) {
    return _C2Tuple_SignatureCVec_SignatureZZ_free(
      _res,
    );
  }

  late final _C2Tuple_SignatureCVec_SignatureZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_SignatureCVec_SignatureZZ)>>(
      'C2Tuple_SignatureCVec_SignatureZZ_free');
  late final _C2Tuple_SignatureCVec_SignatureZZ_free =
      _C2Tuple_SignatureCVec_SignatureZZ_freePtr.asFunction<
          void Function(LDKC2Tuple_SignatureCVec_SignatureZZ)>();

  /// Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the success state.
  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
      CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(
    LDKC2Tuple_SignatureCVec_SignatureZZ o,
  ) {
    return _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
                  LDKC2Tuple_SignatureCVec_SignatureZZ)>>(
      'CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok');
  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok =
      _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_okPtr.asFunction<
          LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
              LDKC2Tuple_SignatureCVec_SignatureZZ)>();

  /// Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the error state.
  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
      CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err() {
    return _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
  }

  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function()>>(
      'CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err');
  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err =
      _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_errPtr.asFunction<
          LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ> o,
  ) {
    return _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ>)>>(
      'CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok');
  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok =
      _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ.
  void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(
    LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res,
  ) {
    return _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ)>>(
      'CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free');
  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free =
      _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_freePtr.asFunction<
          void Function(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ)>();

  /// Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
      CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ> orig,
  ) {
    return _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ>)>>(
      'CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone');
  late final _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone =
      _CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ>)>();

  /// Creates a new CResult_SignatureNoneZ in the success state.
  LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(
    LDKSignature o,
  ) {
    return _CResult_SignatureNoneZ_ok(
      o,
    );
  }

  late final _CResult_SignatureNoneZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_SignatureNoneZ Function(LDKSignature)>>(
      'CResult_SignatureNoneZ_ok');
  late final _CResult_SignatureNoneZ_ok = _CResult_SignatureNoneZ_okPtr
      .asFunction<LDKCResult_SignatureNoneZ Function(LDKSignature)>();

  /// Creates a new CResult_SignatureNoneZ in the error state.
  LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err() {
    return _CResult_SignatureNoneZ_err();
  }

  late final _CResult_SignatureNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_SignatureNoneZ Function()>>(
          'CResult_SignatureNoneZ_err');
  late final _CResult_SignatureNoneZ_err = _CResult_SignatureNoneZ_errPtr
      .asFunction<LDKCResult_SignatureNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_SignatureNoneZ_is_ok(
    ffi.Pointer<LDKCResult_SignatureNoneZ> o,
  ) {
    return _CResult_SignatureNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_SignatureNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_SignatureNoneZ>)>>(
      'CResult_SignatureNoneZ_is_ok');
  late final _CResult_SignatureNoneZ_is_ok = _CResult_SignatureNoneZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_SignatureNoneZ>)>();

  /// Frees any resources used by the CResult_SignatureNoneZ.
  void CResult_SignatureNoneZ_free(
    LDKCResult_SignatureNoneZ _res,
  ) {
    return _CResult_SignatureNoneZ_free(
      _res,
    );
  }

  late final _CResult_SignatureNoneZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_SignatureNoneZ)>>(
          'CResult_SignatureNoneZ_free');
  late final _CResult_SignatureNoneZ_free = _CResult_SignatureNoneZ_freePtr
      .asFunction<void Function(LDKCResult_SignatureNoneZ)>();

  /// Creates a new CResult_SignatureNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(
    ffi.Pointer<LDKCResult_SignatureNoneZ> orig,
  ) {
    return _CResult_SignatureNoneZ_clone(
      orig,
    );
  }

  late final _CResult_SignatureNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SignatureNoneZ Function(
                  ffi.Pointer<LDKCResult_SignatureNoneZ>)>>(
      'CResult_SignatureNoneZ_clone');
  late final _CResult_SignatureNoneZ_clone =
      _CResult_SignatureNoneZ_clonePtr.asFunction<
          LDKCResult_SignatureNoneZ Function(
              ffi.Pointer<LDKCResult_SignatureNoneZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_clone(
    ffi.Pointer<LDKC2Tuple_SignatureSignatureZ> orig,
  ) {
    return _C2Tuple_SignatureSignatureZ_clone(
      orig,
    );
  }

  late final _C2Tuple_SignatureSignatureZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_SignatureSignatureZ Function(
                  ffi.Pointer<LDKC2Tuple_SignatureSignatureZ>)>>(
      'C2Tuple_SignatureSignatureZ_clone');
  late final _C2Tuple_SignatureSignatureZ_clone =
      _C2Tuple_SignatureSignatureZ_clonePtr.asFunction<
          LDKC2Tuple_SignatureSignatureZ Function(
              ffi.Pointer<LDKC2Tuple_SignatureSignatureZ>)>();

  /// Creates a new C2Tuple_SignatureSignatureZ from the contained elements.
  LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_new(
    LDKSignature a,
    LDKSignature b,
  ) {
    return _C2Tuple_SignatureSignatureZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_SignatureSignatureZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_SignatureSignatureZ Function(
              LDKSignature, LDKSignature)>>('C2Tuple_SignatureSignatureZ_new');
  late final _C2Tuple_SignatureSignatureZ_new =
      _C2Tuple_SignatureSignatureZ_newPtr.asFunction<
          LDKC2Tuple_SignatureSignatureZ Function(
              LDKSignature, LDKSignature)>();

  /// Frees any resources used by the C2Tuple_SignatureSignatureZ.
  void C2Tuple_SignatureSignatureZ_free(
    LDKC2Tuple_SignatureSignatureZ _res,
  ) {
    return _C2Tuple_SignatureSignatureZ_free(
      _res,
    );
  }

  late final _C2Tuple_SignatureSignatureZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_SignatureSignatureZ)>>(
      'C2Tuple_SignatureSignatureZ_free');
  late final _C2Tuple_SignatureSignatureZ_free =
      _C2Tuple_SignatureSignatureZ_freePtr.asFunction<
          void Function(LDKC2Tuple_SignatureSignatureZ)>();

  /// Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the success state.
  LDKCResult_C2Tuple_SignatureSignatureZNoneZ
      CResult_C2Tuple_SignatureSignatureZNoneZ_ok(
    LDKC2Tuple_SignatureSignatureZ o,
  ) {
    return _CResult_C2Tuple_SignatureSignatureZNoneZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function(
                  LDKC2Tuple_SignatureSignatureZ)>>(
      'CResult_C2Tuple_SignatureSignatureZNoneZ_ok');
  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_ok =
      _CResult_C2Tuple_SignatureSignatureZNoneZ_okPtr.asFunction<
          LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function(
              LDKC2Tuple_SignatureSignatureZ)>();

  /// Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the error state.
  LDKCResult_C2Tuple_SignatureSignatureZNoneZ
      CResult_C2Tuple_SignatureSignatureZNoneZ_err() {
    return _CResult_C2Tuple_SignatureSignatureZNoneZ_err();
  }

  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_SignatureSignatureZNoneZ
              Function()>>('CResult_C2Tuple_SignatureSignatureZNoneZ_err');
  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_err =
      _CResult_C2Tuple_SignatureSignatureZNoneZ_errPtr.asFunction<
          LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ> o,
  ) {
    return _CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ>)>>(
      'CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok');
  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok =
      _CResult_C2Tuple_SignatureSignatureZNoneZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_SignatureSignatureZNoneZ.
  void CResult_C2Tuple_SignatureSignatureZNoneZ_free(
    LDKCResult_C2Tuple_SignatureSignatureZNoneZ _res,
  ) {
    return _CResult_C2Tuple_SignatureSignatureZNoneZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_C2Tuple_SignatureSignatureZNoneZ)>>(
      'CResult_C2Tuple_SignatureSignatureZNoneZ_free');
  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_free =
      _CResult_C2Tuple_SignatureSignatureZNoneZ_freePtr.asFunction<
          void Function(LDKCResult_C2Tuple_SignatureSignatureZNoneZ)>();

  /// Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_SignatureSignatureZNoneZ
      CResult_C2Tuple_SignatureSignatureZNoneZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ> orig,
  ) {
    return _CResult_C2Tuple_SignatureSignatureZNoneZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function(
                  ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ>)>>(
      'CResult_C2Tuple_SignatureSignatureZNoneZ_clone');
  late final _CResult_C2Tuple_SignatureSignatureZNoneZ_clone =
      _CResult_C2Tuple_SignatureSignatureZNoneZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function(
              ffi.Pointer<LDKCResult_C2Tuple_SignatureSignatureZNoneZ>)>();

  /// Creates a new CResult_SecretKeyNoneZ in the success state.
  LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_ok(
    LDKSecretKey o,
  ) {
    return _CResult_SecretKeyNoneZ_ok(
      o,
    );
  }

  late final _CResult_SecretKeyNoneZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_SecretKeyNoneZ Function(LDKSecretKey)>>(
      'CResult_SecretKeyNoneZ_ok');
  late final _CResult_SecretKeyNoneZ_ok = _CResult_SecretKeyNoneZ_okPtr
      .asFunction<LDKCResult_SecretKeyNoneZ Function(LDKSecretKey)>();

  /// Creates a new CResult_SecretKeyNoneZ in the error state.
  LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_err() {
    return _CResult_SecretKeyNoneZ_err();
  }

  late final _CResult_SecretKeyNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_SecretKeyNoneZ Function()>>(
          'CResult_SecretKeyNoneZ_err');
  late final _CResult_SecretKeyNoneZ_err = _CResult_SecretKeyNoneZ_errPtr
      .asFunction<LDKCResult_SecretKeyNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_SecretKeyNoneZ_is_ok(
    ffi.Pointer<LDKCResult_SecretKeyNoneZ> o,
  ) {
    return _CResult_SecretKeyNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_SecretKeyNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_SecretKeyNoneZ>)>>(
      'CResult_SecretKeyNoneZ_is_ok');
  late final _CResult_SecretKeyNoneZ_is_ok = _CResult_SecretKeyNoneZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_SecretKeyNoneZ>)>();

  /// Frees any resources used by the CResult_SecretKeyNoneZ.
  void CResult_SecretKeyNoneZ_free(
    LDKCResult_SecretKeyNoneZ _res,
  ) {
    return _CResult_SecretKeyNoneZ_free(
      _res,
    );
  }

  late final _CResult_SecretKeyNoneZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_SecretKeyNoneZ)>>(
          'CResult_SecretKeyNoneZ_free');
  late final _CResult_SecretKeyNoneZ_free = _CResult_SecretKeyNoneZ_freePtr
      .asFunction<void Function(LDKCResult_SecretKeyNoneZ)>();

  /// Creates a new CResult_SecretKeyNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_clone(
    ffi.Pointer<LDKCResult_SecretKeyNoneZ> orig,
  ) {
    return _CResult_SecretKeyNoneZ_clone(
      orig,
    );
  }

  late final _CResult_SecretKeyNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SecretKeyNoneZ Function(
                  ffi.Pointer<LDKCResult_SecretKeyNoneZ>)>>(
      'CResult_SecretKeyNoneZ_clone');
  late final _CResult_SecretKeyNoneZ_clone =
      _CResult_SecretKeyNoneZ_clonePtr.asFunction<
          LDKCResult_SecretKeyNoneZ Function(
              ffi.Pointer<LDKCResult_SecretKeyNoneZ>)>();

  /// Creates a new CResult_SignDecodeErrorZ in the success state.
  LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(
    LDKSign o,
  ) {
    return _CResult_SignDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_SignDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_SignDecodeErrorZ Function(LDKSign)>>(
      'CResult_SignDecodeErrorZ_ok');
  late final _CResult_SignDecodeErrorZ_ok = _CResult_SignDecodeErrorZ_okPtr
      .asFunction<LDKCResult_SignDecodeErrorZ Function(LDKSign)>();

  /// Creates a new CResult_SignDecodeErrorZ in the error state.
  LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_SignDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_SignDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SignDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_SignDecodeErrorZ_err');
  late final _CResult_SignDecodeErrorZ_err = _CResult_SignDecodeErrorZ_errPtr
      .asFunction<LDKCResult_SignDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_SignDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_SignDecodeErrorZ> o,
  ) {
    return _CResult_SignDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_SignDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_SignDecodeErrorZ>)>>(
      'CResult_SignDecodeErrorZ_is_ok');
  late final _CResult_SignDecodeErrorZ_is_ok =
      _CResult_SignDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_SignDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_SignDecodeErrorZ.
  void CResult_SignDecodeErrorZ_free(
    LDKCResult_SignDecodeErrorZ _res,
  ) {
    return _CResult_SignDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_SignDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_SignDecodeErrorZ)>>(
      'CResult_SignDecodeErrorZ_free');
  late final _CResult_SignDecodeErrorZ_free = _CResult_SignDecodeErrorZ_freePtr
      .asFunction<void Function(LDKCResult_SignDecodeErrorZ)>();

  /// Creates a new CResult_SignDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_SignDecodeErrorZ> orig,
  ) {
    return _CResult_SignDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_SignDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SignDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_SignDecodeErrorZ>)>>(
      'CResult_SignDecodeErrorZ_clone');
  late final _CResult_SignDecodeErrorZ_clone =
      _CResult_SignDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_SignDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_SignDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_u5Z_free(
    LDKCVec_u5Z _res,
  ) {
    return _CVec_u5Z_free(
      _res,
    );
  }

  late final _CVec_u5Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_u5Z)>>(
          'CVec_u5Z_free');
  late final _CVec_u5Z_free =
      _CVec_u5Z_freePtr.asFunction<void Function(LDKCVec_u5Z)>();

  /// Creates a new CResult_RecoverableSignatureNoneZ in the success state.
  LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(
    LDKRecoverableSignature o,
  ) {
    return _CResult_RecoverableSignatureNoneZ_ok(
      o,
    );
  }

  late final _CResult_RecoverableSignatureNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RecoverableSignatureNoneZ Function(
                  LDKRecoverableSignature)>>(
      'CResult_RecoverableSignatureNoneZ_ok');
  late final _CResult_RecoverableSignatureNoneZ_ok =
      _CResult_RecoverableSignatureNoneZ_okPtr.asFunction<
          LDKCResult_RecoverableSignatureNoneZ Function(
              LDKRecoverableSignature)>();

  /// Creates a new CResult_RecoverableSignatureNoneZ in the error state.
  LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err() {
    return _CResult_RecoverableSignatureNoneZ_err();
  }

  late final _CResult_RecoverableSignatureNoneZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_RecoverableSignatureNoneZ Function()>>(
      'CResult_RecoverableSignatureNoneZ_err');
  late final _CResult_RecoverableSignatureNoneZ_err =
      _CResult_RecoverableSignatureNoneZ_errPtr.asFunction<
          LDKCResult_RecoverableSignatureNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_RecoverableSignatureNoneZ_is_ok(
    ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ> o,
  ) {
    return _CResult_RecoverableSignatureNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_RecoverableSignatureNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ>)>>(
      'CResult_RecoverableSignatureNoneZ_is_ok');
  late final _CResult_RecoverableSignatureNoneZ_is_ok =
      _CResult_RecoverableSignatureNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ>)>();

  /// Frees any resources used by the CResult_RecoverableSignatureNoneZ.
  void CResult_RecoverableSignatureNoneZ_free(
    LDKCResult_RecoverableSignatureNoneZ _res,
  ) {
    return _CResult_RecoverableSignatureNoneZ_free(
      _res,
    );
  }

  late final _CResult_RecoverableSignatureNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RecoverableSignatureNoneZ)>>(
      'CResult_RecoverableSignatureNoneZ_free');
  late final _CResult_RecoverableSignatureNoneZ_free =
      _CResult_RecoverableSignatureNoneZ_freePtr.asFunction<
          void Function(LDKCResult_RecoverableSignatureNoneZ)>();

  /// Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(
    ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ> orig,
  ) {
    return _CResult_RecoverableSignatureNoneZ_clone(
      orig,
    );
  }

  late final _CResult_RecoverableSignatureNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RecoverableSignatureNoneZ Function(
                  ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ>)>>(
      'CResult_RecoverableSignatureNoneZ_clone');
  late final _CResult_RecoverableSignatureNoneZ_clone =
      _CResult_RecoverableSignatureNoneZ_clonePtr.asFunction<
          LDKCResult_RecoverableSignatureNoneZ Function(
              ffi.Pointer<LDKCResult_RecoverableSignatureNoneZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_u8Z_free(
    LDKCVec_u8Z _res,
  ) {
    return _CVec_u8Z_free(
      _res,
    );
  }

  late final _CVec_u8Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_u8Z)>>(
          'CVec_u8Z_free');
  late final _CVec_u8Z_free =
      _CVec_u8Z_freePtr.asFunction<void Function(LDKCVec_u8Z)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_CVec_u8ZZ_free(
    LDKCVec_CVec_u8ZZ _res,
  ) {
    return _CVec_CVec_u8ZZ_free(
      _res,
    );
  }

  late final _CVec_CVec_u8ZZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_CVec_u8ZZ)>>(
          'CVec_CVec_u8ZZ_free');
  late final _CVec_CVec_u8ZZ_free =
      _CVec_CVec_u8ZZ_freePtr.asFunction<void Function(LDKCVec_CVec_u8ZZ)>();

  /// Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
  LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(
    LDKCVec_CVec_u8ZZ o,
  ) {
    return _CResult_CVec_CVec_u8ZZNoneZ_ok(
      o,
    );
  }

  late final _CResult_CVec_CVec_u8ZZNoneZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function(
              LDKCVec_CVec_u8ZZ)>>('CResult_CVec_CVec_u8ZZNoneZ_ok');
  late final _CResult_CVec_CVec_u8ZZNoneZ_ok =
      _CResult_CVec_CVec_u8ZZNoneZ_okPtr.asFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function(LDKCVec_CVec_u8ZZ)>();

  /// Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
  LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err() {
    return _CResult_CVec_CVec_u8ZZNoneZ_err();
  }

  late final _CResult_CVec_CVec_u8ZZNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_CVec_CVec_u8ZZNoneZ Function()>>(
          'CResult_CVec_CVec_u8ZZNoneZ_err');
  late final _CResult_CVec_CVec_u8ZZNoneZ_err =
      _CResult_CVec_CVec_u8ZZNoneZ_errPtr.asFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(
    ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ> o,
  ) {
    return _CResult_CVec_CVec_u8ZZNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_CVec_CVec_u8ZZNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ>)>>(
      'CResult_CVec_CVec_u8ZZNoneZ_is_ok');
  late final _CResult_CVec_CVec_u8ZZNoneZ_is_ok =
      _CResult_CVec_CVec_u8ZZNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ>)>();

  /// Frees any resources used by the CResult_CVec_CVec_u8ZZNoneZ.
  void CResult_CVec_CVec_u8ZZNoneZ_free(
    LDKCResult_CVec_CVec_u8ZZNoneZ _res,
  ) {
    return _CResult_CVec_CVec_u8ZZNoneZ_free(
      _res,
    );
  }

  late final _CResult_CVec_CVec_u8ZZNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_CVec_CVec_u8ZZNoneZ)>>(
      'CResult_CVec_CVec_u8ZZNoneZ_free');
  late final _CResult_CVec_CVec_u8ZZNoneZ_free =
      _CResult_CVec_CVec_u8ZZNoneZ_freePtr.asFunction<
          void Function(LDKCResult_CVec_CVec_u8ZZNoneZ)>();

  /// Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(
    ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ> orig,
  ) {
    return _CResult_CVec_CVec_u8ZZNoneZ_clone(
      orig,
    );
  }

  late final _CResult_CVec_CVec_u8ZZNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_CVec_u8ZZNoneZ Function(
                  ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ>)>>(
      'CResult_CVec_CVec_u8ZZNoneZ_clone');
  late final _CResult_CVec_CVec_u8ZZNoneZ_clone =
      _CResult_CVec_CVec_u8ZZNoneZ_clonePtr.asFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function(
              ffi.Pointer<LDKCResult_CVec_CVec_u8ZZNoneZ>)>();

  /// Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
  LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(
    LDKInMemorySigner o,
  ) {
    return _CResult_InMemorySignerDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_InMemorySignerDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(
              LDKInMemorySigner)>>('CResult_InMemorySignerDecodeErrorZ_ok');
  late final _CResult_InMemorySignerDecodeErrorZ_ok =
      _CResult_InMemorySignerDecodeErrorZ_okPtr.asFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(LDKInMemorySigner)>();

  /// Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
  LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_InMemorySignerDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_InMemorySignerDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_InMemorySignerDecodeErrorZ_err');
  late final _CResult_InMemorySignerDecodeErrorZ_err =
      _CResult_InMemorySignerDecodeErrorZ_errPtr.asFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InMemorySignerDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ> o,
  ) {
    return _CResult_InMemorySignerDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InMemorySignerDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ>)>>(
      'CResult_InMemorySignerDecodeErrorZ_is_ok');
  late final _CResult_InMemorySignerDecodeErrorZ_is_ok =
      _CResult_InMemorySignerDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
  void CResult_InMemorySignerDecodeErrorZ_free(
    LDKCResult_InMemorySignerDecodeErrorZ _res,
  ) {
    return _CResult_InMemorySignerDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_InMemorySignerDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InMemorySignerDecodeErrorZ)>>(
      'CResult_InMemorySignerDecodeErrorZ_free');
  late final _CResult_InMemorySignerDecodeErrorZ_free =
      _CResult_InMemorySignerDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InMemorySignerDecodeErrorZ)>();

  /// Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InMemorySignerDecodeErrorZ
      CResult_InMemorySignerDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ> orig,
  ) {
    return _CResult_InMemorySignerDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InMemorySignerDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InMemorySignerDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ>)>>(
      'CResult_InMemorySignerDecodeErrorZ_clone');
  late final _CResult_InMemorySignerDecodeErrorZ_clone =
      _CResult_InMemorySignerDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_InMemorySignerDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_TxOutZ_free(
    LDKCVec_TxOutZ _res,
  ) {
    return _CVec_TxOutZ_free(
      _res,
    );
  }

  late final _CVec_TxOutZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_TxOutZ)>>(
          'CVec_TxOutZ_free');
  late final _CVec_TxOutZ_free =
      _CVec_TxOutZ_freePtr.asFunction<void Function(LDKCVec_TxOutZ)>();

  /// Creates a new CResult_TransactionNoneZ in the success state.
  LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(
    LDKTransaction o,
  ) {
    return _CResult_TransactionNoneZ_ok(
      o,
    );
  }

  late final _CResult_TransactionNoneZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TransactionNoneZ Function(
              LDKTransaction)>>('CResult_TransactionNoneZ_ok');
  late final _CResult_TransactionNoneZ_ok = _CResult_TransactionNoneZ_okPtr
      .asFunction<LDKCResult_TransactionNoneZ Function(LDKTransaction)>();

  /// Creates a new CResult_TransactionNoneZ in the error state.
  LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err() {
    return _CResult_TransactionNoneZ_err();
  }

  late final _CResult_TransactionNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_TransactionNoneZ Function()>>(
          'CResult_TransactionNoneZ_err');
  late final _CResult_TransactionNoneZ_err = _CResult_TransactionNoneZ_errPtr
      .asFunction<LDKCResult_TransactionNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_TransactionNoneZ_is_ok(
    ffi.Pointer<LDKCResult_TransactionNoneZ> o,
  ) {
    return _CResult_TransactionNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_TransactionNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_TransactionNoneZ>)>>(
      'CResult_TransactionNoneZ_is_ok');
  late final _CResult_TransactionNoneZ_is_ok =
      _CResult_TransactionNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_TransactionNoneZ>)>();

  /// Frees any resources used by the CResult_TransactionNoneZ.
  void CResult_TransactionNoneZ_free(
    LDKCResult_TransactionNoneZ _res,
  ) {
    return _CResult_TransactionNoneZ_free(
      _res,
    );
  }

  late final _CResult_TransactionNoneZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_TransactionNoneZ)>>(
      'CResult_TransactionNoneZ_free');
  late final _CResult_TransactionNoneZ_free = _CResult_TransactionNoneZ_freePtr
      .asFunction<void Function(LDKCResult_TransactionNoneZ)>();

  /// Creates a new CResult_TransactionNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(
    ffi.Pointer<LDKCResult_TransactionNoneZ> orig,
  ) {
    return _CResult_TransactionNoneZ_clone(
      orig,
    );
  }

  late final _CResult_TransactionNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TransactionNoneZ Function(
                  ffi.Pointer<LDKCResult_TransactionNoneZ>)>>(
      'CResult_TransactionNoneZ_clone');
  late final _CResult_TransactionNoneZ_clone =
      _CResult_TransactionNoneZ_clonePtr.asFunction<
          LDKCResult_TransactionNoneZ Function(
              ffi.Pointer<LDKCResult_TransactionNoneZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(
    ffi.Pointer<LDKC2Tuple_BlockHashChannelMonitorZ> orig,
  ) {
    return _C2Tuple_BlockHashChannelMonitorZ_clone(
      orig,
    );
  }

  late final _C2Tuple_BlockHashChannelMonitorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_BlockHashChannelMonitorZ Function(
                  ffi.Pointer<LDKC2Tuple_BlockHashChannelMonitorZ>)>>(
      'C2Tuple_BlockHashChannelMonitorZ_clone');
  late final _C2Tuple_BlockHashChannelMonitorZ_clone =
      _C2Tuple_BlockHashChannelMonitorZ_clonePtr.asFunction<
          LDKC2Tuple_BlockHashChannelMonitorZ Function(
              ffi.Pointer<LDKC2Tuple_BlockHashChannelMonitorZ>)>();

  /// Creates a new C2Tuple_BlockHashChannelMonitorZ from the contained elements.
  LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(
    LDKThirtyTwoBytes a,
    LDKChannelMonitor b,
  ) {
    return _C2Tuple_BlockHashChannelMonitorZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_BlockHashChannelMonitorZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_BlockHashChannelMonitorZ Function(LDKThirtyTwoBytes,
              LDKChannelMonitor)>>('C2Tuple_BlockHashChannelMonitorZ_new');
  late final _C2Tuple_BlockHashChannelMonitorZ_new =
      _C2Tuple_BlockHashChannelMonitorZ_newPtr.asFunction<
          LDKC2Tuple_BlockHashChannelMonitorZ Function(
              LDKThirtyTwoBytes, LDKChannelMonitor)>();

  /// Frees any resources used by the C2Tuple_BlockHashChannelMonitorZ.
  void C2Tuple_BlockHashChannelMonitorZ_free(
    LDKC2Tuple_BlockHashChannelMonitorZ _res,
  ) {
    return _C2Tuple_BlockHashChannelMonitorZ_free(
      _res,
    );
  }

  late final _C2Tuple_BlockHashChannelMonitorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_BlockHashChannelMonitorZ)>>(
      'C2Tuple_BlockHashChannelMonitorZ_free');
  late final _C2Tuple_BlockHashChannelMonitorZ_free =
      _C2Tuple_BlockHashChannelMonitorZ_freePtr.asFunction<
          void Function(LDKC2Tuple_BlockHashChannelMonitorZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_BlockHashChannelMonitorZZ_free(
    LDKCVec_C2Tuple_BlockHashChannelMonitorZZ _res,
  ) {
    return _CVec_C2Tuple_BlockHashChannelMonitorZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_BlockHashChannelMonitorZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_C2Tuple_BlockHashChannelMonitorZZ)>>(
      'CVec_C2Tuple_BlockHashChannelMonitorZZ_free');
  late final _CVec_C2Tuple_BlockHashChannelMonitorZZ_free =
      _CVec_C2Tuple_BlockHashChannelMonitorZZ_freePtr.asFunction<
          void Function(LDKCVec_C2Tuple_BlockHashChannelMonitorZZ)>();

  /// Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the success state.
  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
      CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(
    LDKCVec_C2Tuple_BlockHashChannelMonitorZZ o,
  ) {
    return _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(
      o,
    );
  }

  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
                      Function(LDKCVec_C2Tuple_BlockHashChannelMonitorZZ)>>(
          'CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok');
  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok =
      _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_okPtr.asFunction<
          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
              LDKCVec_C2Tuple_BlockHashChannelMonitorZZ)>();

  /// Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the error state.
  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
      CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(
    int e,
  ) {
    return _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(
      e,
    );
  }

  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
                      Function(ffi.Int32)>>(
          'CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err');
  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err =
      _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_errPtr.asFunction<
          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
              int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ> o,
  ) {
    return _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_okPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<
                          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ>)>>(
          'CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok');
  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok =
      _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ>)>();

  /// Frees any resources used by the CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ.
  void CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(
    LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ _res,
  ) {
    return _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(
      _res,
    );
  }

  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ)>>(
          'CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free');
  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free =
      _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ)>();

  /// Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
      CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone(
    ffi.Pointer<LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ> orig,
  ) {
    return _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ>)>>(
      'CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone');
  late final _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone =
      _CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clonePtr.asFunction<
          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
              ffi.Pointer<
                  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ>)>();

  /// Constructs a new COption_u16Z containing a u16
  LDKCOption_u16Z COption_u16Z_some(
    int o,
  ) {
    return _COption_u16Z_some(
      o,
    );
  }

  late final _COption_u16Z_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u16Z Function(ffi.Uint16)>>(
          'COption_u16Z_some');
  late final _COption_u16Z_some =
      _COption_u16Z_somePtr.asFunction<LDKCOption_u16Z Function(int)>();

  /// Constructs a new COption_u16Z containing nothing
  LDKCOption_u16Z COption_u16Z_none() {
    return _COption_u16Z_none();
  }

  late final _COption_u16Z_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_u16Z Function()>>(
          'COption_u16Z_none');
  late final _COption_u16Z_none =
      _COption_u16Z_nonePtr.asFunction<LDKCOption_u16Z Function()>();

  /// Frees any resources associated with the u16, if we are in the Some state
  void COption_u16Z_free(
    LDKCOption_u16Z _res,
  ) {
    return _COption_u16Z_free(
      _res,
    );
  }

  late final _COption_u16Z_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_u16Z)>>(
          'COption_u16Z_free');
  late final _COption_u16Z_free =
      _COption_u16Z_freePtr.asFunction<void Function(LDKCOption_u16Z)>();

  /// Creates a new COption_u16Z which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_u16Z COption_u16Z_clone(
    ffi.Pointer<LDKCOption_u16Z> orig,
  ) {
    return _COption_u16Z_clone(
      orig,
    );
  }

  late final _COption_u16Z_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u16Z Function(
              ffi.Pointer<LDKCOption_u16Z>)>>('COption_u16Z_clone');
  late final _COption_u16Z_clone = _COption_u16Z_clonePtr.asFunction<
      LDKCOption_u16Z Function(ffi.Pointer<LDKCOption_u16Z>)>();

  /// Creates a new CResult_NoneAPIErrorZ in the success state.
  LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok() {
    return _CResult_NoneAPIErrorZ_ok();
  }

  late final _CResult_NoneAPIErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneAPIErrorZ Function()>>(
          'CResult_NoneAPIErrorZ_ok');
  late final _CResult_NoneAPIErrorZ_ok = _CResult_NoneAPIErrorZ_okPtr
      .asFunction<LDKCResult_NoneAPIErrorZ Function()>();

  /// Creates a new CResult_NoneAPIErrorZ in the error state.
  LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(
    LDKAPIError e,
  ) {
    return _CResult_NoneAPIErrorZ_err(
      e,
    );
  }

  late final _CResult_NoneAPIErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_NoneAPIErrorZ Function(LDKAPIError)>>(
      'CResult_NoneAPIErrorZ_err');
  late final _CResult_NoneAPIErrorZ_err = _CResult_NoneAPIErrorZ_errPtr
      .asFunction<LDKCResult_NoneAPIErrorZ Function(LDKAPIError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneAPIErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NoneAPIErrorZ> o,
  ) {
    return _CResult_NoneAPIErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneAPIErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NoneAPIErrorZ>)>>(
      'CResult_NoneAPIErrorZ_is_ok');
  late final _CResult_NoneAPIErrorZ_is_ok = _CResult_NoneAPIErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_NoneAPIErrorZ>)>();

  /// Frees any resources used by the CResult_NoneAPIErrorZ.
  void CResult_NoneAPIErrorZ_free(
    LDKCResult_NoneAPIErrorZ _res,
  ) {
    return _CResult_NoneAPIErrorZ_free(
      _res,
    );
  }

  late final _CResult_NoneAPIErrorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_NoneAPIErrorZ)>>(
          'CResult_NoneAPIErrorZ_free');
  late final _CResult_NoneAPIErrorZ_free = _CResult_NoneAPIErrorZ_freePtr
      .asFunction<void Function(LDKCResult_NoneAPIErrorZ)>();

  /// Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(
    ffi.Pointer<LDKCResult_NoneAPIErrorZ> orig,
  ) {
    return _CResult_NoneAPIErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NoneAPIErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneAPIErrorZ Function(
                  ffi.Pointer<LDKCResult_NoneAPIErrorZ>)>>(
      'CResult_NoneAPIErrorZ_clone');
  late final _CResult_NoneAPIErrorZ_clone =
      _CResult_NoneAPIErrorZ_clonePtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKCResult_NoneAPIErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_CResult_NoneAPIErrorZZ_free(
    LDKCVec_CResult_NoneAPIErrorZZ _res,
  ) {
    return _CVec_CResult_NoneAPIErrorZZ_free(
      _res,
    );
  }

  late final _CVec_CResult_NoneAPIErrorZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_CResult_NoneAPIErrorZZ)>>(
      'CVec_CResult_NoneAPIErrorZZ_free');
  late final _CVec_CResult_NoneAPIErrorZZ_free =
      _CVec_CResult_NoneAPIErrorZZ_freePtr.asFunction<
          void Function(LDKCVec_CResult_NoneAPIErrorZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_APIErrorZ_free(
    LDKCVec_APIErrorZ _res,
  ) {
    return _CVec_APIErrorZ_free(
      _res,
    );
  }

  late final _CVec_APIErrorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_APIErrorZ)>>(
          'CVec_APIErrorZ_free');
  late final _CVec_APIErrorZ_free =
      _CVec_APIErrorZ_freePtr.asFunction<void Function(LDKCVec_APIErrorZ)>();

  /// Creates a new CResult__u832APIErrorZ in the success state.
  LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult__u832APIErrorZ_ok(
      o,
    );
  }

  late final _CResult__u832APIErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult__u832APIErrorZ Function(
              LDKThirtyTwoBytes)>>('CResult__u832APIErrorZ_ok');
  late final _CResult__u832APIErrorZ_ok = _CResult__u832APIErrorZ_okPtr
      .asFunction<LDKCResult__u832APIErrorZ Function(LDKThirtyTwoBytes)>();

  /// Creates a new CResult__u832APIErrorZ in the error state.
  LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(
    LDKAPIError e,
  ) {
    return _CResult__u832APIErrorZ_err(
      e,
    );
  }

  late final _CResult__u832APIErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult__u832APIErrorZ Function(LDKAPIError)>>(
      'CResult__u832APIErrorZ_err');
  late final _CResult__u832APIErrorZ_err = _CResult__u832APIErrorZ_errPtr
      .asFunction<LDKCResult__u832APIErrorZ Function(LDKAPIError)>();

  /// Checks if the given object is currently in the success state
  bool CResult__u832APIErrorZ_is_ok(
    ffi.Pointer<LDKCResult__u832APIErrorZ> o,
  ) {
    return _CResult__u832APIErrorZ_is_ok(
      o,
    );
  }

  late final _CResult__u832APIErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult__u832APIErrorZ>)>>(
      'CResult__u832APIErrorZ_is_ok');
  late final _CResult__u832APIErrorZ_is_ok = _CResult__u832APIErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult__u832APIErrorZ>)>();

  /// Frees any resources used by the CResult__u832APIErrorZ.
  void CResult__u832APIErrorZ_free(
    LDKCResult__u832APIErrorZ _res,
  ) {
    return _CResult__u832APIErrorZ_free(
      _res,
    );
  }

  late final _CResult__u832APIErrorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult__u832APIErrorZ)>>(
          'CResult__u832APIErrorZ_free');
  late final _CResult__u832APIErrorZ_free = _CResult__u832APIErrorZ_freePtr
      .asFunction<void Function(LDKCResult__u832APIErrorZ)>();

  /// Creates a new CResult__u832APIErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(
    ffi.Pointer<LDKCResult__u832APIErrorZ> orig,
  ) {
    return _CResult__u832APIErrorZ_clone(
      orig,
    );
  }

  late final _CResult__u832APIErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult__u832APIErrorZ Function(
                  ffi.Pointer<LDKCResult__u832APIErrorZ>)>>(
      'CResult__u832APIErrorZ_clone');
  late final _CResult__u832APIErrorZ_clone =
      _CResult__u832APIErrorZ_clonePtr.asFunction<
          LDKCResult__u832APIErrorZ Function(
              ffi.Pointer<LDKCResult__u832APIErrorZ>)>();

  /// Creates a new CResult_PaymentIdPaymentSendFailureZ in the success state.
  LDKCResult_PaymentIdPaymentSendFailureZ
      CResult_PaymentIdPaymentSendFailureZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult_PaymentIdPaymentSendFailureZ_ok(
      o,
    );
  }

  late final _CResult_PaymentIdPaymentSendFailureZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              LDKThirtyTwoBytes)>>('CResult_PaymentIdPaymentSendFailureZ_ok');
  late final _CResult_PaymentIdPaymentSendFailureZ_ok =
      _CResult_PaymentIdPaymentSendFailureZ_okPtr.asFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              LDKThirtyTwoBytes)>();

  /// Creates a new CResult_PaymentIdPaymentSendFailureZ in the error state.
  LDKCResult_PaymentIdPaymentSendFailureZ
      CResult_PaymentIdPaymentSendFailureZ_err(
    LDKPaymentSendFailure e,
  ) {
    return _CResult_PaymentIdPaymentSendFailureZ_err(
      e,
    );
  }

  late final _CResult_PaymentIdPaymentSendFailureZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentIdPaymentSendFailureZ Function(
                  LDKPaymentSendFailure)>>(
      'CResult_PaymentIdPaymentSendFailureZ_err');
  late final _CResult_PaymentIdPaymentSendFailureZ_err =
      _CResult_PaymentIdPaymentSendFailureZ_errPtr.asFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              LDKPaymentSendFailure)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentIdPaymentSendFailureZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ> o,
  ) {
    return _CResult_PaymentIdPaymentSendFailureZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentIdPaymentSendFailureZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ>)>>(
      'CResult_PaymentIdPaymentSendFailureZ_is_ok');
  late final _CResult_PaymentIdPaymentSendFailureZ_is_ok =
      _CResult_PaymentIdPaymentSendFailureZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ>)>();

  /// Frees any resources used by the CResult_PaymentIdPaymentSendFailureZ.
  void CResult_PaymentIdPaymentSendFailureZ_free(
    LDKCResult_PaymentIdPaymentSendFailureZ _res,
  ) {
    return _CResult_PaymentIdPaymentSendFailureZ_free(
      _res,
    );
  }

  late final _CResult_PaymentIdPaymentSendFailureZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentIdPaymentSendFailureZ)>>(
      'CResult_PaymentIdPaymentSendFailureZ_free');
  late final _CResult_PaymentIdPaymentSendFailureZ_free =
      _CResult_PaymentIdPaymentSendFailureZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentIdPaymentSendFailureZ)>();

  /// Creates a new CResult_PaymentIdPaymentSendFailureZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentIdPaymentSendFailureZ
      CResult_PaymentIdPaymentSendFailureZ_clone(
    ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ> orig,
  ) {
    return _CResult_PaymentIdPaymentSendFailureZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentIdPaymentSendFailureZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentIdPaymentSendFailureZ Function(
                  ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ>)>>(
      'CResult_PaymentIdPaymentSendFailureZ_clone');
  late final _CResult_PaymentIdPaymentSendFailureZ_clone =
      _CResult_PaymentIdPaymentSendFailureZ_clonePtr.asFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              ffi.Pointer<LDKCResult_PaymentIdPaymentSendFailureZ>)>();

  /// Creates a new CResult_NonePaymentSendFailureZ in the success state.
  LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok() {
    return _CResult_NonePaymentSendFailureZ_ok();
  }

  late final _CResult_NonePaymentSendFailureZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_NonePaymentSendFailureZ Function()>>(
      'CResult_NonePaymentSendFailureZ_ok');
  late final _CResult_NonePaymentSendFailureZ_ok =
      _CResult_NonePaymentSendFailureZ_okPtr.asFunction<
          LDKCResult_NonePaymentSendFailureZ Function()>();

  /// Creates a new CResult_NonePaymentSendFailureZ in the error state.
  LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(
    LDKPaymentSendFailure e,
  ) {
    return _CResult_NonePaymentSendFailureZ_err(
      e,
    );
  }

  late final _CResult_NonePaymentSendFailureZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NonePaymentSendFailureZ Function(
              LDKPaymentSendFailure)>>('CResult_NonePaymentSendFailureZ_err');
  late final _CResult_NonePaymentSendFailureZ_err =
      _CResult_NonePaymentSendFailureZ_errPtr.asFunction<
          LDKCResult_NonePaymentSendFailureZ Function(LDKPaymentSendFailure)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NonePaymentSendFailureZ_is_ok(
    ffi.Pointer<LDKCResult_NonePaymentSendFailureZ> o,
  ) {
    return _CResult_NonePaymentSendFailureZ_is_ok(
      o,
    );
  }

  late final _CResult_NonePaymentSendFailureZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NonePaymentSendFailureZ>)>>(
      'CResult_NonePaymentSendFailureZ_is_ok');
  late final _CResult_NonePaymentSendFailureZ_is_ok =
      _CResult_NonePaymentSendFailureZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NonePaymentSendFailureZ>)>();

  /// Frees any resources used by the CResult_NonePaymentSendFailureZ.
  void CResult_NonePaymentSendFailureZ_free(
    LDKCResult_NonePaymentSendFailureZ _res,
  ) {
    return _CResult_NonePaymentSendFailureZ_free(
      _res,
    );
  }

  late final _CResult_NonePaymentSendFailureZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NonePaymentSendFailureZ)>>(
      'CResult_NonePaymentSendFailureZ_free');
  late final _CResult_NonePaymentSendFailureZ_free =
      _CResult_NonePaymentSendFailureZ_freePtr.asFunction<
          void Function(LDKCResult_NonePaymentSendFailureZ)>();

  /// Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(
    ffi.Pointer<LDKCResult_NonePaymentSendFailureZ> orig,
  ) {
    return _CResult_NonePaymentSendFailureZ_clone(
      orig,
    );
  }

  late final _CResult_NonePaymentSendFailureZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NonePaymentSendFailureZ Function(
                  ffi.Pointer<LDKCResult_NonePaymentSendFailureZ>)>>(
      'CResult_NonePaymentSendFailureZ_clone');
  late final _CResult_NonePaymentSendFailureZ_clone =
      _CResult_NonePaymentSendFailureZ_clonePtr.asFunction<
          LDKCResult_NonePaymentSendFailureZ Function(
              ffi.Pointer<LDKCResult_NonePaymentSendFailureZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(
    ffi.Pointer<LDKC2Tuple_PaymentHashPaymentIdZ> orig,
  ) {
    return _C2Tuple_PaymentHashPaymentIdZ_clone(
      orig,
    );
  }

  late final _C2Tuple_PaymentHashPaymentIdZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_PaymentHashPaymentIdZ Function(
                  ffi.Pointer<LDKC2Tuple_PaymentHashPaymentIdZ>)>>(
      'C2Tuple_PaymentHashPaymentIdZ_clone');
  late final _C2Tuple_PaymentHashPaymentIdZ_clone =
      _C2Tuple_PaymentHashPaymentIdZ_clonePtr.asFunction<
          LDKC2Tuple_PaymentHashPaymentIdZ Function(
              ffi.Pointer<LDKC2Tuple_PaymentHashPaymentIdZ>)>();

  /// Creates a new C2Tuple_PaymentHashPaymentIdZ from the contained elements.
  LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(
    LDKThirtyTwoBytes a,
    LDKThirtyTwoBytes b,
  ) {
    return _C2Tuple_PaymentHashPaymentIdZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_PaymentHashPaymentIdZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_PaymentHashPaymentIdZ Function(LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>>('C2Tuple_PaymentHashPaymentIdZ_new');
  late final _C2Tuple_PaymentHashPaymentIdZ_new =
      _C2Tuple_PaymentHashPaymentIdZ_newPtr.asFunction<
          LDKC2Tuple_PaymentHashPaymentIdZ Function(
              LDKThirtyTwoBytes, LDKThirtyTwoBytes)>();

  /// Frees any resources used by the C2Tuple_PaymentHashPaymentIdZ.
  void C2Tuple_PaymentHashPaymentIdZ_free(
    LDKC2Tuple_PaymentHashPaymentIdZ _res,
  ) {
    return _C2Tuple_PaymentHashPaymentIdZ_free(
      _res,
    );
  }

  late final _C2Tuple_PaymentHashPaymentIdZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_PaymentHashPaymentIdZ)>>(
      'C2Tuple_PaymentHashPaymentIdZ_free');
  late final _C2Tuple_PaymentHashPaymentIdZ_free =
      _C2Tuple_PaymentHashPaymentIdZ_freePtr.asFunction<
          void Function(LDKC2Tuple_PaymentHashPaymentIdZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the success state.
  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
      CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(
    LDKC2Tuple_PaymentHashPaymentIdZ o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
                      Function(LDKC2Tuple_PaymentHashPaymentIdZ)>>(
          'CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok =
      _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_okPtr
          .asFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
                  Function(LDKC2Tuple_PaymentHashPaymentIdZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the error state.
  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
      CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(
    LDKPaymentSendFailure e,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(
      e,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
                      Function(LDKPaymentSendFailure)>>(
          'CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err');
  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err =
      _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_errPtr
          .asFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
                  Function(LDKPaymentSendFailure)>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ> o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_okPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<
                          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ>)>>(
          'CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok =
      _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.
  void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(
    LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ)>>(
          'CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free');
  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free =
      _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_freePtr
          .asFunction<
              void Function(
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
      CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ>
        orig,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clonePtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
                      ffi.Pointer<
                          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ>)>>(
          'CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone');
  late final _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone =
      _CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_ThirtyTwoBytesZ_free(
    LDKCVec_ThirtyTwoBytesZ _res,
  ) {
    return _CVec_ThirtyTwoBytesZ_free(
      _res,
    );
  }

  late final _CVec_ThirtyTwoBytesZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_ThirtyTwoBytesZ)>>(
          'CVec_ThirtyTwoBytesZ_free');
  late final _CVec_ThirtyTwoBytesZ_free = _CVec_ThirtyTwoBytesZ_freePtr
      .asFunction<void Function(LDKCVec_ThirtyTwoBytesZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(
    ffi.Pointer<LDKC2Tuple_PaymentHashPaymentSecretZ> orig,
  ) {
    return _C2Tuple_PaymentHashPaymentSecretZ_clone(
      orig,
    );
  }

  late final _C2Tuple_PaymentHashPaymentSecretZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_PaymentHashPaymentSecretZ Function(
                  ffi.Pointer<LDKC2Tuple_PaymentHashPaymentSecretZ>)>>(
      'C2Tuple_PaymentHashPaymentSecretZ_clone');
  late final _C2Tuple_PaymentHashPaymentSecretZ_clone =
      _C2Tuple_PaymentHashPaymentSecretZ_clonePtr.asFunction<
          LDKC2Tuple_PaymentHashPaymentSecretZ Function(
              ffi.Pointer<LDKC2Tuple_PaymentHashPaymentSecretZ>)>();

  /// Creates a new C2Tuple_PaymentHashPaymentSecretZ from the contained elements.
  LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(
    LDKThirtyTwoBytes a,
    LDKThirtyTwoBytes b,
  ) {
    return _C2Tuple_PaymentHashPaymentSecretZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_PaymentHashPaymentSecretZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_PaymentHashPaymentSecretZ Function(LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>>('C2Tuple_PaymentHashPaymentSecretZ_new');
  late final _C2Tuple_PaymentHashPaymentSecretZ_new =
      _C2Tuple_PaymentHashPaymentSecretZ_newPtr.asFunction<
          LDKC2Tuple_PaymentHashPaymentSecretZ Function(
              LDKThirtyTwoBytes, LDKThirtyTwoBytes)>();

  /// Frees any resources used by the C2Tuple_PaymentHashPaymentSecretZ.
  void C2Tuple_PaymentHashPaymentSecretZ_free(
    LDKC2Tuple_PaymentHashPaymentSecretZ _res,
  ) {
    return _C2Tuple_PaymentHashPaymentSecretZ_free(
      _res,
    );
  }

  late final _C2Tuple_PaymentHashPaymentSecretZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_PaymentHashPaymentSecretZ)>>(
      'C2Tuple_PaymentHashPaymentSecretZ_free');
  late final _C2Tuple_PaymentHashPaymentSecretZ_free =
      _C2Tuple_PaymentHashPaymentSecretZ_freePtr.asFunction<
          void Function(LDKC2Tuple_PaymentHashPaymentSecretZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the success state.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
      CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(
    LDKC2Tuple_PaymentHashPaymentSecretZ o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
                  LDKC2Tuple_PaymentHashPaymentSecretZ)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok =
      _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_okPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
              LDKC2Tuple_PaymentHashPaymentSecretZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the error state.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
      CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err() {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err();
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function()>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err =
      _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_errPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ> o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ>)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok =
      _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ.
  void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(
    LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free =
      _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_freePtr.asFunction<
          void Function(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
      CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ> orig,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ>)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone =
      _CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ>)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the success state.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
      CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(
    LDKC2Tuple_PaymentHashPaymentSecretZ o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
                      Function(LDKC2Tuple_PaymentHashPaymentSecretZ)>>(
          'CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok =
      _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_okPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
              LDKC2Tuple_PaymentHashPaymentSecretZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the error state.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
      CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(
    LDKAPIError e,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(
      e,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
                      Function(LDKAPIError)>>(
          'CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err =
      _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_errPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
              LDKAPIError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ> o,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ>)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok =
      _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.
  void CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(
    LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ _res,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ)>>(
          'CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free =
      _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ)>();

  /// Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
      CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ> orig,
  ) {
    return _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ>)>>(
      'CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone');
  late final _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone =
      _CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ>)>();

  /// Creates a new CResult_PaymentSecretNoneZ in the success state.
  LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult_PaymentSecretNoneZ_ok(
      o,
    );
  }

  late final _CResult_PaymentSecretNoneZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentSecretNoneZ Function(
              LDKThirtyTwoBytes)>>('CResult_PaymentSecretNoneZ_ok');
  late final _CResult_PaymentSecretNoneZ_ok = _CResult_PaymentSecretNoneZ_okPtr
      .asFunction<LDKCResult_PaymentSecretNoneZ Function(LDKThirtyTwoBytes)>();

  /// Creates a new CResult_PaymentSecretNoneZ in the error state.
  LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err() {
    return _CResult_PaymentSecretNoneZ_err();
  }

  late final _CResult_PaymentSecretNoneZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_PaymentSecretNoneZ Function()>>(
          'CResult_PaymentSecretNoneZ_err');
  late final _CResult_PaymentSecretNoneZ_err =
      _CResult_PaymentSecretNoneZ_errPtr.asFunction<
          LDKCResult_PaymentSecretNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentSecretNoneZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentSecretNoneZ> o,
  ) {
    return _CResult_PaymentSecretNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentSecretNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_PaymentSecretNoneZ>)>>(
      'CResult_PaymentSecretNoneZ_is_ok');
  late final _CResult_PaymentSecretNoneZ_is_ok =
      _CResult_PaymentSecretNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PaymentSecretNoneZ>)>();

  /// Frees any resources used by the CResult_PaymentSecretNoneZ.
  void CResult_PaymentSecretNoneZ_free(
    LDKCResult_PaymentSecretNoneZ _res,
  ) {
    return _CResult_PaymentSecretNoneZ_free(
      _res,
    );
  }

  late final _CResult_PaymentSecretNoneZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_PaymentSecretNoneZ)>>(
      'CResult_PaymentSecretNoneZ_free');
  late final _CResult_PaymentSecretNoneZ_free =
      _CResult_PaymentSecretNoneZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentSecretNoneZ)>();

  /// Creates a new CResult_PaymentSecretNoneZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(
    ffi.Pointer<LDKCResult_PaymentSecretNoneZ> orig,
  ) {
    return _CResult_PaymentSecretNoneZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentSecretNoneZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentSecretNoneZ Function(
                  ffi.Pointer<LDKCResult_PaymentSecretNoneZ>)>>(
      'CResult_PaymentSecretNoneZ_clone');
  late final _CResult_PaymentSecretNoneZ_clone =
      _CResult_PaymentSecretNoneZ_clonePtr.asFunction<
          LDKCResult_PaymentSecretNoneZ Function(
              ffi.Pointer<LDKCResult_PaymentSecretNoneZ>)>();

  /// Creates a new CResult_PaymentSecretAPIErrorZ in the success state.
  LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult_PaymentSecretAPIErrorZ_ok(
      o,
    );
  }

  late final _CResult_PaymentSecretAPIErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(
              LDKThirtyTwoBytes)>>('CResult_PaymentSecretAPIErrorZ_ok');
  late final _CResult_PaymentSecretAPIErrorZ_ok =
      _CResult_PaymentSecretAPIErrorZ_okPtr.asFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(LDKThirtyTwoBytes)>();

  /// Creates a new CResult_PaymentSecretAPIErrorZ in the error state.
  LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(
    LDKAPIError e,
  ) {
    return _CResult_PaymentSecretAPIErrorZ_err(
      e,
    );
  }

  late final _CResult_PaymentSecretAPIErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(
              LDKAPIError)>>('CResult_PaymentSecretAPIErrorZ_err');
  late final _CResult_PaymentSecretAPIErrorZ_err =
      _CResult_PaymentSecretAPIErrorZ_errPtr.asFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(LDKAPIError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentSecretAPIErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ> o,
  ) {
    return _CResult_PaymentSecretAPIErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentSecretAPIErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ>)>>(
      'CResult_PaymentSecretAPIErrorZ_is_ok');
  late final _CResult_PaymentSecretAPIErrorZ_is_ok =
      _CResult_PaymentSecretAPIErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ>)>();

  /// Frees any resources used by the CResult_PaymentSecretAPIErrorZ.
  void CResult_PaymentSecretAPIErrorZ_free(
    LDKCResult_PaymentSecretAPIErrorZ _res,
  ) {
    return _CResult_PaymentSecretAPIErrorZ_free(
      _res,
    );
  }

  late final _CResult_PaymentSecretAPIErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentSecretAPIErrorZ)>>(
      'CResult_PaymentSecretAPIErrorZ_free');
  late final _CResult_PaymentSecretAPIErrorZ_free =
      _CResult_PaymentSecretAPIErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentSecretAPIErrorZ)>();

  /// Creates a new CResult_PaymentSecretAPIErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(
    ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ> orig,
  ) {
    return _CResult_PaymentSecretAPIErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentSecretAPIErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentSecretAPIErrorZ Function(
                  ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ>)>>(
      'CResult_PaymentSecretAPIErrorZ_clone');
  late final _CResult_PaymentSecretAPIErrorZ_clone =
      _CResult_PaymentSecretAPIErrorZ_clonePtr.asFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(
              ffi.Pointer<LDKCResult_PaymentSecretAPIErrorZ>)>();

  /// Creates a new CResult_PaymentPreimageAPIErrorZ in the success state.
  LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult_PaymentPreimageAPIErrorZ_ok(
      o,
    );
  }

  late final _CResult_PaymentPreimageAPIErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(
              LDKThirtyTwoBytes)>>('CResult_PaymentPreimageAPIErrorZ_ok');
  late final _CResult_PaymentPreimageAPIErrorZ_ok =
      _CResult_PaymentPreimageAPIErrorZ_okPtr.asFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(LDKThirtyTwoBytes)>();

  /// Creates a new CResult_PaymentPreimageAPIErrorZ in the error state.
  LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(
    LDKAPIError e,
  ) {
    return _CResult_PaymentPreimageAPIErrorZ_err(
      e,
    );
  }

  late final _CResult_PaymentPreimageAPIErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(
              LDKAPIError)>>('CResult_PaymentPreimageAPIErrorZ_err');
  late final _CResult_PaymentPreimageAPIErrorZ_err =
      _CResult_PaymentPreimageAPIErrorZ_errPtr.asFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(LDKAPIError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentPreimageAPIErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ> o,
  ) {
    return _CResult_PaymentPreimageAPIErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentPreimageAPIErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ>)>>(
      'CResult_PaymentPreimageAPIErrorZ_is_ok');
  late final _CResult_PaymentPreimageAPIErrorZ_is_ok =
      _CResult_PaymentPreimageAPIErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ>)>();

  /// Frees any resources used by the CResult_PaymentPreimageAPIErrorZ.
  void CResult_PaymentPreimageAPIErrorZ_free(
    LDKCResult_PaymentPreimageAPIErrorZ _res,
  ) {
    return _CResult_PaymentPreimageAPIErrorZ_free(
      _res,
    );
  }

  late final _CResult_PaymentPreimageAPIErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentPreimageAPIErrorZ)>>(
      'CResult_PaymentPreimageAPIErrorZ_free');
  late final _CResult_PaymentPreimageAPIErrorZ_free =
      _CResult_PaymentPreimageAPIErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentPreimageAPIErrorZ)>();

  /// Creates a new CResult_PaymentPreimageAPIErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(
    ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ> orig,
  ) {
    return _CResult_PaymentPreimageAPIErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentPreimageAPIErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentPreimageAPIErrorZ Function(
                  ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ>)>>(
      'CResult_PaymentPreimageAPIErrorZ_clone');
  late final _CResult_PaymentPreimageAPIErrorZ_clone =
      _CResult_PaymentPreimageAPIErrorZ_clonePtr.asFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(
              ffi.Pointer<LDKCResult_PaymentPreimageAPIErrorZ>)>();

  /// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ
      CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(
    LDKCounterpartyForwardingInfo o,
  ) {
    return _CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
                  LDKCounterpartyForwardingInfo)>>(
      'CResult_CounterpartyForwardingInfoDecodeErrorZ_ok');
  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_ok =
      _CResult_CounterpartyForwardingInfoDecodeErrorZ_okPtr.asFunction<
          LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
              LDKCounterpartyForwardingInfo)>();

  /// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ
      CResult_CounterpartyForwardingInfoDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_CounterpartyForwardingInfoDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_CounterpartyForwardingInfoDecodeErrorZ_err');
  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_err =
      _CResult_CounterpartyForwardingInfoDecodeErrorZ_errPtr.asFunction<
          LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CounterpartyForwardingInfoDecodeErrorZ> o,
  ) {
    return _CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_CounterpartyForwardingInfoDecodeErrorZ>)>>(
      'CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok');
  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok =
      _CResult_CounterpartyForwardingInfoDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
  void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(
    LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res,
  ) {
    return _CResult_CounterpartyForwardingInfoDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ)>>(
      'CResult_CounterpartyForwardingInfoDecodeErrorZ_free');
  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_free =
      _CResult_CounterpartyForwardingInfoDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ)>();

  /// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ
      CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_CounterpartyForwardingInfoDecodeErrorZ> orig,
  ) {
    return _CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_CounterpartyForwardingInfoDecodeErrorZ>)>>(
      'CResult_CounterpartyForwardingInfoDecodeErrorZ_clone');
  late final _CResult_CounterpartyForwardingInfoDecodeErrorZ_clone =
      _CResult_CounterpartyForwardingInfoDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
  LDKCResult_ChannelCounterpartyDecodeErrorZ
      CResult_ChannelCounterpartyDecodeErrorZ_ok(
    LDKChannelCounterparty o,
  ) {
    return _CResult_ChannelCounterpartyDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelCounterpartyDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
                  LDKChannelCounterparty)>>(
      'CResult_ChannelCounterpartyDecodeErrorZ_ok');
  late final _CResult_ChannelCounterpartyDecodeErrorZ_ok =
      _CResult_ChannelCounterpartyDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
              LDKChannelCounterparty)>();

  /// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
  LDKCResult_ChannelCounterpartyDecodeErrorZ
      CResult_ChannelCounterpartyDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelCounterpartyDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelCounterpartyDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelCounterpartyDecodeErrorZ_err');
  late final _CResult_ChannelCounterpartyDecodeErrorZ_err =
      _CResult_ChannelCounterpartyDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ> o,
  ) {
    return _CResult_ChannelCounterpartyDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelCounterpartyDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ>)>>(
      'CResult_ChannelCounterpartyDecodeErrorZ_is_ok');
  late final _CResult_ChannelCounterpartyDecodeErrorZ_is_ok =
      _CResult_ChannelCounterpartyDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
  void CResult_ChannelCounterpartyDecodeErrorZ_free(
    LDKCResult_ChannelCounterpartyDecodeErrorZ _res,
  ) {
    return _CResult_ChannelCounterpartyDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelCounterpartyDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelCounterpartyDecodeErrorZ)>>(
      'CResult_ChannelCounterpartyDecodeErrorZ_free');
  late final _CResult_ChannelCounterpartyDecodeErrorZ_free =
      _CResult_ChannelCounterpartyDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelCounterpartyDecodeErrorZ)>();

  /// Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelCounterpartyDecodeErrorZ
      CResult_ChannelCounterpartyDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelCounterpartyDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelCounterpartyDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ>)>>(
      'CResult_ChannelCounterpartyDecodeErrorZ_clone');
  late final _CResult_ChannelCounterpartyDecodeErrorZ_clone =
      _CResult_ChannelCounterpartyDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelCounterpartyDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
  LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(
    LDKChannelDetails o,
  ) {
    return _CResult_ChannelDetailsDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelDetailsDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(
              LDKChannelDetails)>>('CResult_ChannelDetailsDecodeErrorZ_ok');
  late final _CResult_ChannelDetailsDecodeErrorZ_ok =
      _CResult_ChannelDetailsDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(LDKChannelDetails)>();

  /// Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
  LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelDetailsDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelDetailsDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelDetailsDecodeErrorZ_err');
  late final _CResult_ChannelDetailsDecodeErrorZ_err =
      _CResult_ChannelDetailsDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelDetailsDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ> o,
  ) {
    return _CResult_ChannelDetailsDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelDetailsDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ>)>>(
      'CResult_ChannelDetailsDecodeErrorZ_is_ok');
  late final _CResult_ChannelDetailsDecodeErrorZ_is_ok =
      _CResult_ChannelDetailsDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
  void CResult_ChannelDetailsDecodeErrorZ_free(
    LDKCResult_ChannelDetailsDecodeErrorZ _res,
  ) {
    return _CResult_ChannelDetailsDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelDetailsDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelDetailsDecodeErrorZ)>>(
      'CResult_ChannelDetailsDecodeErrorZ_free');
  late final _CResult_ChannelDetailsDecodeErrorZ_free =
      _CResult_ChannelDetailsDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelDetailsDecodeErrorZ)>();

  /// Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelDetailsDecodeErrorZ
      CResult_ChannelDetailsDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelDetailsDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelDetailsDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelDetailsDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ>)>>(
      'CResult_ChannelDetailsDecodeErrorZ_clone');
  late final _CResult_ChannelDetailsDecodeErrorZ_clone =
      _CResult_ChannelDetailsDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelDetailsDecodeErrorZ>)>();

  /// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
  LDKCResult_PhantomRouteHintsDecodeErrorZ
      CResult_PhantomRouteHintsDecodeErrorZ_ok(
    LDKPhantomRouteHints o,
  ) {
    return _CResult_PhantomRouteHintsDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_PhantomRouteHintsDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
                  LDKPhantomRouteHints)>>(
      'CResult_PhantomRouteHintsDecodeErrorZ_ok');
  late final _CResult_PhantomRouteHintsDecodeErrorZ_ok =
      _CResult_PhantomRouteHintsDecodeErrorZ_okPtr.asFunction<
          LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
              LDKPhantomRouteHints)>();

  /// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
  LDKCResult_PhantomRouteHintsDecodeErrorZ
      CResult_PhantomRouteHintsDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_PhantomRouteHintsDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_PhantomRouteHintsDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_PhantomRouteHintsDecodeErrorZ_err');
  late final _CResult_PhantomRouteHintsDecodeErrorZ_err =
      _CResult_PhantomRouteHintsDecodeErrorZ_errPtr.asFunction<
          LDKCResult_PhantomRouteHintsDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ> o,
  ) {
    return _CResult_PhantomRouteHintsDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PhantomRouteHintsDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ>)>>(
      'CResult_PhantomRouteHintsDecodeErrorZ_is_ok');
  late final _CResult_PhantomRouteHintsDecodeErrorZ_is_ok =
      _CResult_PhantomRouteHintsDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
  void CResult_PhantomRouteHintsDecodeErrorZ_free(
    LDKCResult_PhantomRouteHintsDecodeErrorZ _res,
  ) {
    return _CResult_PhantomRouteHintsDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_PhantomRouteHintsDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PhantomRouteHintsDecodeErrorZ)>>(
      'CResult_PhantomRouteHintsDecodeErrorZ_free');
  late final _CResult_PhantomRouteHintsDecodeErrorZ_free =
      _CResult_PhantomRouteHintsDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PhantomRouteHintsDecodeErrorZ)>();

  /// Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PhantomRouteHintsDecodeErrorZ
      CResult_PhantomRouteHintsDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ> orig,
  ) {
    return _CResult_PhantomRouteHintsDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PhantomRouteHintsDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ>)>>(
      'CResult_PhantomRouteHintsDecodeErrorZ_clone');
  late final _CResult_PhantomRouteHintsDecodeErrorZ_clone =
      _CResult_PhantomRouteHintsDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_PhantomRouteHintsDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_ChannelMonitorZ_free(
    LDKCVec_ChannelMonitorZ _res,
  ) {
    return _CVec_ChannelMonitorZ_free(
      _res,
    );
  }

  late final _CVec_ChannelMonitorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_ChannelMonitorZ)>>(
          'CVec_ChannelMonitorZ_free');
  late final _CVec_ChannelMonitorZ_free = _CVec_ChannelMonitorZ_freePtr
      .asFunction<void Function(LDKCVec_ChannelMonitorZ)>();

  /// Creates a new C2Tuple_BlockHashChannelManagerZ from the contained elements.
  LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(
    LDKThirtyTwoBytes a,
    LDKChannelManager b,
  ) {
    return _C2Tuple_BlockHashChannelManagerZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_BlockHashChannelManagerZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_BlockHashChannelManagerZ Function(LDKThirtyTwoBytes,
              LDKChannelManager)>>('C2Tuple_BlockHashChannelManagerZ_new');
  late final _C2Tuple_BlockHashChannelManagerZ_new =
      _C2Tuple_BlockHashChannelManagerZ_newPtr.asFunction<
          LDKC2Tuple_BlockHashChannelManagerZ Function(
              LDKThirtyTwoBytes, LDKChannelManager)>();

  /// Frees any resources used by the C2Tuple_BlockHashChannelManagerZ.
  void C2Tuple_BlockHashChannelManagerZ_free(
    LDKC2Tuple_BlockHashChannelManagerZ _res,
  ) {
    return _C2Tuple_BlockHashChannelManagerZ_free(
      _res,
    );
  }

  late final _C2Tuple_BlockHashChannelManagerZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_BlockHashChannelManagerZ)>>(
      'C2Tuple_BlockHashChannelManagerZ_free');
  late final _C2Tuple_BlockHashChannelManagerZ_free =
      _C2Tuple_BlockHashChannelManagerZ_freePtr.asFunction<
          void Function(LDKC2Tuple_BlockHashChannelManagerZ)>();

  /// Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the success state.
  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
      CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(
    LDKC2Tuple_BlockHashChannelManagerZ o,
  ) {
    return _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
                      Function(LDKC2Tuple_BlockHashChannelManagerZ)>>(
          'CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok');
  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok =
      _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ Function(
              LDKC2Tuple_BlockHashChannelManagerZ)>();

  /// Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the error state.
  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
      CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
                      Function(LDKDecodeError)>>(
          'CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err');
  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err =
      _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ> o,
  ) {
    return _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_okPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<
                          LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ>)>>(
          'CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok');
  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok =
      _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.
  void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(
    LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res,
  ) {
    return _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ)>>(
          'CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free');
  late final _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free =
      _CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ)>();

  /// Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
  LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(
    LDKChannelConfig o,
  ) {
    return _CResult_ChannelConfigDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelConfigDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(
              LDKChannelConfig)>>('CResult_ChannelConfigDecodeErrorZ_ok');
  late final _CResult_ChannelConfigDecodeErrorZ_ok =
      _CResult_ChannelConfigDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(LDKChannelConfig)>();

  /// Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
  LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelConfigDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelConfigDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelConfigDecodeErrorZ_err');
  late final _CResult_ChannelConfigDecodeErrorZ_err =
      _CResult_ChannelConfigDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelConfigDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ> o,
  ) {
    return _CResult_ChannelConfigDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelConfigDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ>)>>(
      'CResult_ChannelConfigDecodeErrorZ_is_ok');
  late final _CResult_ChannelConfigDecodeErrorZ_is_ok =
      _CResult_ChannelConfigDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
  void CResult_ChannelConfigDecodeErrorZ_free(
    LDKCResult_ChannelConfigDecodeErrorZ _res,
  ) {
    return _CResult_ChannelConfigDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelConfigDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelConfigDecodeErrorZ)>>(
      'CResult_ChannelConfigDecodeErrorZ_free');
  late final _CResult_ChannelConfigDecodeErrorZ_free =
      _CResult_ChannelConfigDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelConfigDecodeErrorZ)>();

  /// Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelConfigDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelConfigDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelConfigDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ>)>>(
      'CResult_ChannelConfigDecodeErrorZ_clone');
  late final _CResult_ChannelConfigDecodeErrorZ_clone =
      _CResult_ChannelConfigDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelConfigDecodeErrorZ>)>();

  /// Creates a new CResult_OutPointDecodeErrorZ in the success state.
  LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(
    LDKOutPoint o,
  ) {
    return _CResult_OutPointDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_OutPointDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OutPointDecodeErrorZ Function(
              LDKOutPoint)>>('CResult_OutPointDecodeErrorZ_ok');
  late final _CResult_OutPointDecodeErrorZ_ok =
      _CResult_OutPointDecodeErrorZ_okPtr.asFunction<
          LDKCResult_OutPointDecodeErrorZ Function(LDKOutPoint)>();

  /// Creates a new CResult_OutPointDecodeErrorZ in the error state.
  LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_OutPointDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_OutPointDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OutPointDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_OutPointDecodeErrorZ_err');
  late final _CResult_OutPointDecodeErrorZ_err =
      _CResult_OutPointDecodeErrorZ_errPtr.asFunction<
          LDKCResult_OutPointDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_OutPointDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_OutPointDecodeErrorZ> o,
  ) {
    return _CResult_OutPointDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_OutPointDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_OutPointDecodeErrorZ>)>>(
      'CResult_OutPointDecodeErrorZ_is_ok');
  late final _CResult_OutPointDecodeErrorZ_is_ok =
      _CResult_OutPointDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_OutPointDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_OutPointDecodeErrorZ.
  void CResult_OutPointDecodeErrorZ_free(
    LDKCResult_OutPointDecodeErrorZ _res,
  ) {
    return _CResult_OutPointDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_OutPointDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_OutPointDecodeErrorZ)>>(
      'CResult_OutPointDecodeErrorZ_free');
  late final _CResult_OutPointDecodeErrorZ_free =
      _CResult_OutPointDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_OutPointDecodeErrorZ)>();

  /// Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_OutPointDecodeErrorZ> orig,
  ) {
    return _CResult_OutPointDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_OutPointDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_OutPointDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_OutPointDecodeErrorZ>)>>(
      'CResult_OutPointDecodeErrorZ_clone');
  late final _CResult_OutPointDecodeErrorZ_clone =
      _CResult_OutPointDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_OutPointDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_OutPointDecodeErrorZ>)>();

  /// Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
  LDKCOption_TypeZ COption_TypeZ_some(
    LDKType o,
  ) {
    return _COption_TypeZ_some(
      o,
    );
  }

  late final _COption_TypeZ_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_TypeZ Function(LDKType)>>(
          'COption_TypeZ_some');
  late final _COption_TypeZ_some =
      _COption_TypeZ_somePtr.asFunction<LDKCOption_TypeZ Function(LDKType)>();

  /// Constructs a new COption_TypeZ containing nothing
  LDKCOption_TypeZ COption_TypeZ_none() {
    return _COption_TypeZ_none();
  }

  late final _COption_TypeZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_TypeZ Function()>>(
          'COption_TypeZ_none');
  late final _COption_TypeZ_none =
      _COption_TypeZ_nonePtr.asFunction<LDKCOption_TypeZ Function()>();

  /// Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
  void COption_TypeZ_free(
    LDKCOption_TypeZ _res,
  ) {
    return _COption_TypeZ_free(
      _res,
    );
  }

  late final _COption_TypeZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_TypeZ)>>(
          'COption_TypeZ_free');
  late final _COption_TypeZ_free =
      _COption_TypeZ_freePtr.asFunction<void Function(LDKCOption_TypeZ)>();

  /// Creates a new COption_TypeZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_TypeZ COption_TypeZ_clone(
    ffi.Pointer<LDKCOption_TypeZ> orig,
  ) {
    return _COption_TypeZ_clone(
      orig,
    );
  }

  late final _COption_TypeZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_TypeZ Function(
              ffi.Pointer<LDKCOption_TypeZ>)>>('COption_TypeZ_clone');
  late final _COption_TypeZ_clone = _COption_TypeZ_clonePtr.asFunction<
      LDKCOption_TypeZ Function(ffi.Pointer<LDKCOption_TypeZ>)>();

  /// Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
  LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(
    LDKCOption_TypeZ o,
  ) {
    return _CResult_COption_TypeZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_TypeZDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(
              LDKCOption_TypeZ)>>('CResult_COption_TypeZDecodeErrorZ_ok');
  late final _CResult_COption_TypeZDecodeErrorZ_ok =
      _CResult_COption_TypeZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(LDKCOption_TypeZ)>();

  /// Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
  LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_TypeZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_TypeZDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_COption_TypeZDecodeErrorZ_err');
  late final _CResult_COption_TypeZDecodeErrorZ_err =
      _CResult_COption_TypeZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_TypeZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ> o,
  ) {
    return _CResult_COption_TypeZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_TypeZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ>)>>(
      'CResult_COption_TypeZDecodeErrorZ_is_ok');
  late final _CResult_COption_TypeZDecodeErrorZ_is_ok =
      _CResult_COption_TypeZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
  void CResult_COption_TypeZDecodeErrorZ_free(
    LDKCResult_COption_TypeZDecodeErrorZ _res,
  ) {
    return _CResult_COption_TypeZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_TypeZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_COption_TypeZDecodeErrorZ)>>(
      'CResult_COption_TypeZDecodeErrorZ_free');
  late final _CResult_COption_TypeZDecodeErrorZ_free =
      _CResult_COption_TypeZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_TypeZDecodeErrorZ)>();

  /// Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_TypeZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_TypeZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_TypeZDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ>)>>(
      'CResult_COption_TypeZDecodeErrorZ_clone');
  late final _CResult_COption_TypeZDecodeErrorZ_clone =
      _CResult_COption_TypeZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_TypeZDecodeErrorZ>)>();

  /// Creates a new CResult_PaymentIdPaymentErrorZ in the success state.
  LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_ok(
    LDKThirtyTwoBytes o,
  ) {
    return _CResult_PaymentIdPaymentErrorZ_ok(
      o,
    );
  }

  late final _CResult_PaymentIdPaymentErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              LDKThirtyTwoBytes)>>('CResult_PaymentIdPaymentErrorZ_ok');
  late final _CResult_PaymentIdPaymentErrorZ_ok =
      _CResult_PaymentIdPaymentErrorZ_okPtr.asFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(LDKThirtyTwoBytes)>();

  /// Creates a new CResult_PaymentIdPaymentErrorZ in the error state.
  LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_err(
    LDKPaymentError e,
  ) {
    return _CResult_PaymentIdPaymentErrorZ_err(
      e,
    );
  }

  late final _CResult_PaymentIdPaymentErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              LDKPaymentError)>>('CResult_PaymentIdPaymentErrorZ_err');
  late final _CResult_PaymentIdPaymentErrorZ_err =
      _CResult_PaymentIdPaymentErrorZ_errPtr.asFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(LDKPaymentError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PaymentIdPaymentErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ> o,
  ) {
    return _CResult_PaymentIdPaymentErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PaymentIdPaymentErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ>)>>(
      'CResult_PaymentIdPaymentErrorZ_is_ok');
  late final _CResult_PaymentIdPaymentErrorZ_is_ok =
      _CResult_PaymentIdPaymentErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ>)>();

  /// Frees any resources used by the CResult_PaymentIdPaymentErrorZ.
  void CResult_PaymentIdPaymentErrorZ_free(
    LDKCResult_PaymentIdPaymentErrorZ _res,
  ) {
    return _CResult_PaymentIdPaymentErrorZ_free(
      _res,
    );
  }

  late final _CResult_PaymentIdPaymentErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PaymentIdPaymentErrorZ)>>(
      'CResult_PaymentIdPaymentErrorZ_free');
  late final _CResult_PaymentIdPaymentErrorZ_free =
      _CResult_PaymentIdPaymentErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PaymentIdPaymentErrorZ)>();

  /// Creates a new CResult_PaymentIdPaymentErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_clone(
    ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ> orig,
  ) {
    return _CResult_PaymentIdPaymentErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PaymentIdPaymentErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PaymentIdPaymentErrorZ Function(
                  ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ>)>>(
      'CResult_PaymentIdPaymentErrorZ_clone');
  late final _CResult_PaymentIdPaymentErrorZ_clone =
      _CResult_PaymentIdPaymentErrorZ_clonePtr.asFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKCResult_PaymentIdPaymentErrorZ>)>();

  /// Creates a new CResult_SiPrefixParseErrorZ in the success state.
  LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_ok(
    int o,
  ) {
    return _CResult_SiPrefixParseErrorZ_ok(
      o,
    );
  }

  late final _CResult_SiPrefixParseErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SiPrefixParseErrorZ Function(
              ffi.Int32)>>('CResult_SiPrefixParseErrorZ_ok');
  late final _CResult_SiPrefixParseErrorZ_ok =
      _CResult_SiPrefixParseErrorZ_okPtr.asFunction<
          LDKCResult_SiPrefixParseErrorZ Function(int)>();

  /// Creates a new CResult_SiPrefixParseErrorZ in the error state.
  LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_err(
    LDKParseError e,
  ) {
    return _CResult_SiPrefixParseErrorZ_err(
      e,
    );
  }

  late final _CResult_SiPrefixParseErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SiPrefixParseErrorZ Function(
              LDKParseError)>>('CResult_SiPrefixParseErrorZ_err');
  late final _CResult_SiPrefixParseErrorZ_err =
      _CResult_SiPrefixParseErrorZ_errPtr.asFunction<
          LDKCResult_SiPrefixParseErrorZ Function(LDKParseError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_SiPrefixParseErrorZ_is_ok(
    ffi.Pointer<LDKCResult_SiPrefixParseErrorZ> o,
  ) {
    return _CResult_SiPrefixParseErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_SiPrefixParseErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_SiPrefixParseErrorZ>)>>(
      'CResult_SiPrefixParseErrorZ_is_ok');
  late final _CResult_SiPrefixParseErrorZ_is_ok =
      _CResult_SiPrefixParseErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_SiPrefixParseErrorZ>)>();

  /// Frees any resources used by the CResult_SiPrefixParseErrorZ.
  void CResult_SiPrefixParseErrorZ_free(
    LDKCResult_SiPrefixParseErrorZ _res,
  ) {
    return _CResult_SiPrefixParseErrorZ_free(
      _res,
    );
  }

  late final _CResult_SiPrefixParseErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_SiPrefixParseErrorZ)>>(
      'CResult_SiPrefixParseErrorZ_free');
  late final _CResult_SiPrefixParseErrorZ_free =
      _CResult_SiPrefixParseErrorZ_freePtr.asFunction<
          void Function(LDKCResult_SiPrefixParseErrorZ)>();

  /// Creates a new CResult_SiPrefixParseErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_clone(
    ffi.Pointer<LDKCResult_SiPrefixParseErrorZ> orig,
  ) {
    return _CResult_SiPrefixParseErrorZ_clone(
      orig,
    );
  }

  late final _CResult_SiPrefixParseErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SiPrefixParseErrorZ Function(
                  ffi.Pointer<LDKCResult_SiPrefixParseErrorZ>)>>(
      'CResult_SiPrefixParseErrorZ_clone');
  late final _CResult_SiPrefixParseErrorZ_clone =
      _CResult_SiPrefixParseErrorZ_clonePtr.asFunction<
          LDKCResult_SiPrefixParseErrorZ Function(
              ffi.Pointer<LDKCResult_SiPrefixParseErrorZ>)>();

  /// Creates a new CResult_InvoiceParseOrSemanticErrorZ in the success state.
  LDKCResult_InvoiceParseOrSemanticErrorZ
      CResult_InvoiceParseOrSemanticErrorZ_ok(
    LDKInvoice o,
  ) {
    return _CResult_InvoiceParseOrSemanticErrorZ_ok(
      o,
    );
  }

  late final _CResult_InvoiceParseOrSemanticErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceParseOrSemanticErrorZ Function(
              LDKInvoice)>>('CResult_InvoiceParseOrSemanticErrorZ_ok');
  late final _CResult_InvoiceParseOrSemanticErrorZ_ok =
      _CResult_InvoiceParseOrSemanticErrorZ_okPtr.asFunction<
          LDKCResult_InvoiceParseOrSemanticErrorZ Function(LDKInvoice)>();

  /// Creates a new CResult_InvoiceParseOrSemanticErrorZ in the error state.
  LDKCResult_InvoiceParseOrSemanticErrorZ
      CResult_InvoiceParseOrSemanticErrorZ_err(
    LDKParseOrSemanticError e,
  ) {
    return _CResult_InvoiceParseOrSemanticErrorZ_err(
      e,
    );
  }

  late final _CResult_InvoiceParseOrSemanticErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceParseOrSemanticErrorZ Function(
                  LDKParseOrSemanticError)>>(
      'CResult_InvoiceParseOrSemanticErrorZ_err');
  late final _CResult_InvoiceParseOrSemanticErrorZ_err =
      _CResult_InvoiceParseOrSemanticErrorZ_errPtr.asFunction<
          LDKCResult_InvoiceParseOrSemanticErrorZ Function(
              LDKParseOrSemanticError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InvoiceParseOrSemanticErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ> o,
  ) {
    return _CResult_InvoiceParseOrSemanticErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InvoiceParseOrSemanticErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ>)>>(
      'CResult_InvoiceParseOrSemanticErrorZ_is_ok');
  late final _CResult_InvoiceParseOrSemanticErrorZ_is_ok =
      _CResult_InvoiceParseOrSemanticErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ>)>();

  /// Frees any resources used by the CResult_InvoiceParseOrSemanticErrorZ.
  void CResult_InvoiceParseOrSemanticErrorZ_free(
    LDKCResult_InvoiceParseOrSemanticErrorZ _res,
  ) {
    return _CResult_InvoiceParseOrSemanticErrorZ_free(
      _res,
    );
  }

  late final _CResult_InvoiceParseOrSemanticErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InvoiceParseOrSemanticErrorZ)>>(
      'CResult_InvoiceParseOrSemanticErrorZ_free');
  late final _CResult_InvoiceParseOrSemanticErrorZ_free =
      _CResult_InvoiceParseOrSemanticErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InvoiceParseOrSemanticErrorZ)>();

  /// Creates a new CResult_InvoiceParseOrSemanticErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InvoiceParseOrSemanticErrorZ
      CResult_InvoiceParseOrSemanticErrorZ_clone(
    ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ> orig,
  ) {
    return _CResult_InvoiceParseOrSemanticErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InvoiceParseOrSemanticErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceParseOrSemanticErrorZ Function(
                  ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ>)>>(
      'CResult_InvoiceParseOrSemanticErrorZ_clone');
  late final _CResult_InvoiceParseOrSemanticErrorZ_clone =
      _CResult_InvoiceParseOrSemanticErrorZ_clonePtr.asFunction<
          LDKCResult_InvoiceParseOrSemanticErrorZ Function(
              ffi.Pointer<LDKCResult_InvoiceParseOrSemanticErrorZ>)>();

  /// Creates a new CResult_SignedRawInvoiceParseErrorZ in the success state.
  LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_ok(
    LDKSignedRawInvoice o,
  ) {
    return _CResult_SignedRawInvoiceParseErrorZ_ok(
      o,
    );
  }

  late final _CResult_SignedRawInvoiceParseErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(
              LDKSignedRawInvoice)>>('CResult_SignedRawInvoiceParseErrorZ_ok');
  late final _CResult_SignedRawInvoiceParseErrorZ_ok =
      _CResult_SignedRawInvoiceParseErrorZ_okPtr.asFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(
              LDKSignedRawInvoice)>();

  /// Creates a new CResult_SignedRawInvoiceParseErrorZ in the error state.
  LDKCResult_SignedRawInvoiceParseErrorZ
      CResult_SignedRawInvoiceParseErrorZ_err(
    LDKParseError e,
  ) {
    return _CResult_SignedRawInvoiceParseErrorZ_err(
      e,
    );
  }

  late final _CResult_SignedRawInvoiceParseErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(
              LDKParseError)>>('CResult_SignedRawInvoiceParseErrorZ_err');
  late final _CResult_SignedRawInvoiceParseErrorZ_err =
      _CResult_SignedRawInvoiceParseErrorZ_errPtr.asFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(LDKParseError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_SignedRawInvoiceParseErrorZ_is_ok(
    ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ> o,
  ) {
    return _CResult_SignedRawInvoiceParseErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_SignedRawInvoiceParseErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ>)>>(
      'CResult_SignedRawInvoiceParseErrorZ_is_ok');
  late final _CResult_SignedRawInvoiceParseErrorZ_is_ok =
      _CResult_SignedRawInvoiceParseErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ>)>();

  /// Frees any resources used by the CResult_SignedRawInvoiceParseErrorZ.
  void CResult_SignedRawInvoiceParseErrorZ_free(
    LDKCResult_SignedRawInvoiceParseErrorZ _res,
  ) {
    return _CResult_SignedRawInvoiceParseErrorZ_free(
      _res,
    );
  }

  late final _CResult_SignedRawInvoiceParseErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_SignedRawInvoiceParseErrorZ)>>(
      'CResult_SignedRawInvoiceParseErrorZ_free');
  late final _CResult_SignedRawInvoiceParseErrorZ_free =
      _CResult_SignedRawInvoiceParseErrorZ_freePtr.asFunction<
          void Function(LDKCResult_SignedRawInvoiceParseErrorZ)>();

  /// Creates a new CResult_SignedRawInvoiceParseErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_SignedRawInvoiceParseErrorZ
      CResult_SignedRawInvoiceParseErrorZ_clone(
    ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ> orig,
  ) {
    return _CResult_SignedRawInvoiceParseErrorZ_clone(
      orig,
    );
  }

  late final _CResult_SignedRawInvoiceParseErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SignedRawInvoiceParseErrorZ Function(
                  ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ>)>>(
      'CResult_SignedRawInvoiceParseErrorZ_clone');
  late final _CResult_SignedRawInvoiceParseErrorZ_clone =
      _CResult_SignedRawInvoiceParseErrorZ_clonePtr.asFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(
              ffi.Pointer<LDKCResult_SignedRawInvoiceParseErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ
      C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(
    ffi.Pointer<LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ> orig,
  ) {
    return _C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(
      orig,
    );
  }

  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
                  ffi.Pointer<LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ>)>>(
      'C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone');
  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone =
      _C3Tuple_RawInvoice_u832InvoiceSignatureZ_clonePtr.asFunction<
          LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
              ffi.Pointer<LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ>)>();

  /// Creates a new C3Tuple_RawInvoice_u832InvoiceSignatureZ from the contained elements.
  LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ
      C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(
    LDKRawInvoice a,
    LDKThirtyTwoBytes b,
    LDKInvoiceSignature c,
  ) {
    return _C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(
      a,
      b,
      c,
    );
  }

  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_newPtr = _lookup<
          ffi.NativeFunction<
              LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
                  LDKRawInvoice, LDKThirtyTwoBytes, LDKInvoiceSignature)>>(
      'C3Tuple_RawInvoice_u832InvoiceSignatureZ_new');
  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_new =
      _C3Tuple_RawInvoice_u832InvoiceSignatureZ_newPtr.asFunction<
          LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
              LDKRawInvoice, LDKThirtyTwoBytes, LDKInvoiceSignature)>();

  /// Frees any resources used by the C3Tuple_RawInvoice_u832InvoiceSignatureZ.
  void C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(
    LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res,
  ) {
    return _C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(
      _res,
    );
  }

  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ)>>(
      'C3Tuple_RawInvoice_u832InvoiceSignatureZ_free');
  late final _C3Tuple_RawInvoice_u832InvoiceSignatureZ_free =
      _C3Tuple_RawInvoice_u832InvoiceSignatureZ_freePtr.asFunction<
          void Function(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ)>();

  /// Creates a new CResult_PayeePubKeyErrorZ in the success state.
  LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(
    LDKPayeePubKey o,
  ) {
    return _CResult_PayeePubKeyErrorZ_ok(
      o,
    );
  }

  late final _CResult_PayeePubKeyErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PayeePubKeyErrorZ Function(
              LDKPayeePubKey)>>('CResult_PayeePubKeyErrorZ_ok');
  late final _CResult_PayeePubKeyErrorZ_ok = _CResult_PayeePubKeyErrorZ_okPtr
      .asFunction<LDKCResult_PayeePubKeyErrorZ Function(LDKPayeePubKey)>();

  /// Creates a new CResult_PayeePubKeyErrorZ in the error state.
  LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(
    int e,
  ) {
    return _CResult_PayeePubKeyErrorZ_err(
      e,
    );
  }

  late final _CResult_PayeePubKeyErrorZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PayeePubKeyErrorZ Function(ffi.Int32)>>(
      'CResult_PayeePubKeyErrorZ_err');
  late final _CResult_PayeePubKeyErrorZ_err = _CResult_PayeePubKeyErrorZ_errPtr
      .asFunction<LDKCResult_PayeePubKeyErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PayeePubKeyErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PayeePubKeyErrorZ> o,
  ) {
    return _CResult_PayeePubKeyErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PayeePubKeyErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_PayeePubKeyErrorZ>)>>(
      'CResult_PayeePubKeyErrorZ_is_ok');
  late final _CResult_PayeePubKeyErrorZ_is_ok =
      _CResult_PayeePubKeyErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PayeePubKeyErrorZ>)>();

  /// Frees any resources used by the CResult_PayeePubKeyErrorZ.
  void CResult_PayeePubKeyErrorZ_free(
    LDKCResult_PayeePubKeyErrorZ _res,
  ) {
    return _CResult_PayeePubKeyErrorZ_free(
      _res,
    );
  }

  late final _CResult_PayeePubKeyErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_PayeePubKeyErrorZ)>>(
      'CResult_PayeePubKeyErrorZ_free');
  late final _CResult_PayeePubKeyErrorZ_free =
      _CResult_PayeePubKeyErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PayeePubKeyErrorZ)>();

  /// Creates a new CResult_PayeePubKeyErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(
    ffi.Pointer<LDKCResult_PayeePubKeyErrorZ> orig,
  ) {
    return _CResult_PayeePubKeyErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PayeePubKeyErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PayeePubKeyErrorZ Function(
                  ffi.Pointer<LDKCResult_PayeePubKeyErrorZ>)>>(
      'CResult_PayeePubKeyErrorZ_clone');
  late final _CResult_PayeePubKeyErrorZ_clone =
      _CResult_PayeePubKeyErrorZ_clonePtr.asFunction<
          LDKCResult_PayeePubKeyErrorZ Function(
              ffi.Pointer<LDKCResult_PayeePubKeyErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_PrivateRouteZ_free(
    LDKCVec_PrivateRouteZ _res,
  ) {
    return _CVec_PrivateRouteZ_free(
      _res,
    );
  }

  late final _CVec_PrivateRouteZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_PrivateRouteZ)>>(
          'CVec_PrivateRouteZ_free');
  late final _CVec_PrivateRouteZ_free = _CVec_PrivateRouteZ_freePtr.asFunction<
      void Function(LDKCVec_PrivateRouteZ)>();

  /// Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
  LDKCResult_PositiveTimestampCreationErrorZ
      CResult_PositiveTimestampCreationErrorZ_ok(
    LDKPositiveTimestamp o,
  ) {
    return _CResult_PositiveTimestampCreationErrorZ_ok(
      o,
    );
  }

  late final _CResult_PositiveTimestampCreationErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PositiveTimestampCreationErrorZ Function(
                  LDKPositiveTimestamp)>>(
      'CResult_PositiveTimestampCreationErrorZ_ok');
  late final _CResult_PositiveTimestampCreationErrorZ_ok =
      _CResult_PositiveTimestampCreationErrorZ_okPtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              LDKPositiveTimestamp)>();

  /// Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
  LDKCResult_PositiveTimestampCreationErrorZ
      CResult_PositiveTimestampCreationErrorZ_err(
    int e,
  ) {
    return _CResult_PositiveTimestampCreationErrorZ_err(
      e,
    );
  }

  late final _CResult_PositiveTimestampCreationErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              ffi.Int32)>>('CResult_PositiveTimestampCreationErrorZ_err');
  late final _CResult_PositiveTimestampCreationErrorZ_err =
      _CResult_PositiveTimestampCreationErrorZ_errPtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PositiveTimestampCreationErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ> o,
  ) {
    return _CResult_PositiveTimestampCreationErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PositiveTimestampCreationErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ>)>>(
      'CResult_PositiveTimestampCreationErrorZ_is_ok');
  late final _CResult_PositiveTimestampCreationErrorZ_is_ok =
      _CResult_PositiveTimestampCreationErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ>)>();

  /// Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
  void CResult_PositiveTimestampCreationErrorZ_free(
    LDKCResult_PositiveTimestampCreationErrorZ _res,
  ) {
    return _CResult_PositiveTimestampCreationErrorZ_free(
      _res,
    );
  }

  late final _CResult_PositiveTimestampCreationErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PositiveTimestampCreationErrorZ)>>(
      'CResult_PositiveTimestampCreationErrorZ_free');
  late final _CResult_PositiveTimestampCreationErrorZ_free =
      _CResult_PositiveTimestampCreationErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PositiveTimestampCreationErrorZ)>();

  /// Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PositiveTimestampCreationErrorZ
      CResult_PositiveTimestampCreationErrorZ_clone(
    ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ> orig,
  ) {
    return _CResult_PositiveTimestampCreationErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PositiveTimestampCreationErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PositiveTimestampCreationErrorZ Function(
                  ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ>)>>(
      'CResult_PositiveTimestampCreationErrorZ_clone');
  late final _CResult_PositiveTimestampCreationErrorZ_clone =
      _CResult_PositiveTimestampCreationErrorZ_clonePtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              ffi.Pointer<LDKCResult_PositiveTimestampCreationErrorZ>)>();

  /// Creates a new CResult_NoneSemanticErrorZ in the success state.
  LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_ok() {
    return _CResult_NoneSemanticErrorZ_ok();
  }

  late final _CResult_NoneSemanticErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NoneSemanticErrorZ Function()>>(
          'CResult_NoneSemanticErrorZ_ok');
  late final _CResult_NoneSemanticErrorZ_ok = _CResult_NoneSemanticErrorZ_okPtr
      .asFunction<LDKCResult_NoneSemanticErrorZ Function()>();

  /// Creates a new CResult_NoneSemanticErrorZ in the error state.
  LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_err(
    int e,
  ) {
    return _CResult_NoneSemanticErrorZ_err(
      e,
    );
  }

  late final _CResult_NoneSemanticErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneSemanticErrorZ Function(
              ffi.Int32)>>('CResult_NoneSemanticErrorZ_err');
  late final _CResult_NoneSemanticErrorZ_err =
      _CResult_NoneSemanticErrorZ_errPtr.asFunction<
          LDKCResult_NoneSemanticErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NoneSemanticErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NoneSemanticErrorZ> o,
  ) {
    return _CResult_NoneSemanticErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NoneSemanticErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NoneSemanticErrorZ>)>>(
      'CResult_NoneSemanticErrorZ_is_ok');
  late final _CResult_NoneSemanticErrorZ_is_ok =
      _CResult_NoneSemanticErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NoneSemanticErrorZ>)>();

  /// Frees any resources used by the CResult_NoneSemanticErrorZ.
  void CResult_NoneSemanticErrorZ_free(
    LDKCResult_NoneSemanticErrorZ _res,
  ) {
    return _CResult_NoneSemanticErrorZ_free(
      _res,
    );
  }

  late final _CResult_NoneSemanticErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_NoneSemanticErrorZ)>>(
      'CResult_NoneSemanticErrorZ_free');
  late final _CResult_NoneSemanticErrorZ_free =
      _CResult_NoneSemanticErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NoneSemanticErrorZ)>();

  /// Creates a new CResult_NoneSemanticErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_clone(
    ffi.Pointer<LDKCResult_NoneSemanticErrorZ> orig,
  ) {
    return _CResult_NoneSemanticErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NoneSemanticErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneSemanticErrorZ Function(
                  ffi.Pointer<LDKCResult_NoneSemanticErrorZ>)>>(
      'CResult_NoneSemanticErrorZ_clone');
  late final _CResult_NoneSemanticErrorZ_clone =
      _CResult_NoneSemanticErrorZ_clonePtr.asFunction<
          LDKCResult_NoneSemanticErrorZ Function(
              ffi.Pointer<LDKCResult_NoneSemanticErrorZ>)>();

  /// Creates a new CResult_InvoiceSemanticErrorZ in the success state.
  LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_ok(
    LDKInvoice o,
  ) {
    return _CResult_InvoiceSemanticErrorZ_ok(
      o,
    );
  }

  late final _CResult_InvoiceSemanticErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(
              LDKInvoice)>>('CResult_InvoiceSemanticErrorZ_ok');
  late final _CResult_InvoiceSemanticErrorZ_ok =
      _CResult_InvoiceSemanticErrorZ_okPtr.asFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(LDKInvoice)>();

  /// Creates a new CResult_InvoiceSemanticErrorZ in the error state.
  LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_err(
    int e,
  ) {
    return _CResult_InvoiceSemanticErrorZ_err(
      e,
    );
  }

  late final _CResult_InvoiceSemanticErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(
              ffi.Int32)>>('CResult_InvoiceSemanticErrorZ_err');
  late final _CResult_InvoiceSemanticErrorZ_err =
      _CResult_InvoiceSemanticErrorZ_errPtr.asFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InvoiceSemanticErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ> o,
  ) {
    return _CResult_InvoiceSemanticErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InvoiceSemanticErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ>)>>(
      'CResult_InvoiceSemanticErrorZ_is_ok');
  late final _CResult_InvoiceSemanticErrorZ_is_ok =
      _CResult_InvoiceSemanticErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ>)>();

  /// Frees any resources used by the CResult_InvoiceSemanticErrorZ.
  void CResult_InvoiceSemanticErrorZ_free(
    LDKCResult_InvoiceSemanticErrorZ _res,
  ) {
    return _CResult_InvoiceSemanticErrorZ_free(
      _res,
    );
  }

  late final _CResult_InvoiceSemanticErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InvoiceSemanticErrorZ)>>(
      'CResult_InvoiceSemanticErrorZ_free');
  late final _CResult_InvoiceSemanticErrorZ_free =
      _CResult_InvoiceSemanticErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InvoiceSemanticErrorZ)>();

  /// Creates a new CResult_InvoiceSemanticErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_clone(
    ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ> orig,
  ) {
    return _CResult_InvoiceSemanticErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InvoiceSemanticErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceSemanticErrorZ Function(
                  ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ>)>>(
      'CResult_InvoiceSemanticErrorZ_clone');
  late final _CResult_InvoiceSemanticErrorZ_clone =
      _CResult_InvoiceSemanticErrorZ_clonePtr.asFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(
              ffi.Pointer<LDKCResult_InvoiceSemanticErrorZ>)>();

  /// Creates a new CResult_DescriptionCreationErrorZ in the success state.
  LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(
    LDKDescription o,
  ) {
    return _CResult_DescriptionCreationErrorZ_ok(
      o,
    );
  }

  late final _CResult_DescriptionCreationErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_DescriptionCreationErrorZ Function(
              LDKDescription)>>('CResult_DescriptionCreationErrorZ_ok');
  late final _CResult_DescriptionCreationErrorZ_ok =
      _CResult_DescriptionCreationErrorZ_okPtr.asFunction<
          LDKCResult_DescriptionCreationErrorZ Function(LDKDescription)>();

  /// Creates a new CResult_DescriptionCreationErrorZ in the error state.
  LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(
    int e,
  ) {
    return _CResult_DescriptionCreationErrorZ_err(
      e,
    );
  }

  late final _CResult_DescriptionCreationErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_DescriptionCreationErrorZ Function(
              ffi.Int32)>>('CResult_DescriptionCreationErrorZ_err');
  late final _CResult_DescriptionCreationErrorZ_err =
      _CResult_DescriptionCreationErrorZ_errPtr.asFunction<
          LDKCResult_DescriptionCreationErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_DescriptionCreationErrorZ_is_ok(
    ffi.Pointer<LDKCResult_DescriptionCreationErrorZ> o,
  ) {
    return _CResult_DescriptionCreationErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_DescriptionCreationErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_DescriptionCreationErrorZ>)>>(
      'CResult_DescriptionCreationErrorZ_is_ok');
  late final _CResult_DescriptionCreationErrorZ_is_ok =
      _CResult_DescriptionCreationErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_DescriptionCreationErrorZ>)>();

  /// Frees any resources used by the CResult_DescriptionCreationErrorZ.
  void CResult_DescriptionCreationErrorZ_free(
    LDKCResult_DescriptionCreationErrorZ _res,
  ) {
    return _CResult_DescriptionCreationErrorZ_free(
      _res,
    );
  }

  late final _CResult_DescriptionCreationErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_DescriptionCreationErrorZ)>>(
      'CResult_DescriptionCreationErrorZ_free');
  late final _CResult_DescriptionCreationErrorZ_free =
      _CResult_DescriptionCreationErrorZ_freePtr.asFunction<
          void Function(LDKCResult_DescriptionCreationErrorZ)>();

  /// Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(
    ffi.Pointer<LDKCResult_DescriptionCreationErrorZ> orig,
  ) {
    return _CResult_DescriptionCreationErrorZ_clone(
      orig,
    );
  }

  late final _CResult_DescriptionCreationErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_DescriptionCreationErrorZ Function(
                  ffi.Pointer<LDKCResult_DescriptionCreationErrorZ>)>>(
      'CResult_DescriptionCreationErrorZ_clone');
  late final _CResult_DescriptionCreationErrorZ_clone =
      _CResult_DescriptionCreationErrorZ_clonePtr.asFunction<
          LDKCResult_DescriptionCreationErrorZ Function(
              ffi.Pointer<LDKCResult_DescriptionCreationErrorZ>)>();

  /// Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
  LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(
    LDKPrivateRoute o,
  ) {
    return _CResult_PrivateRouteCreationErrorZ_ok(
      o,
    );
  }

  late final _CResult_PrivateRouteCreationErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(
              LDKPrivateRoute)>>('CResult_PrivateRouteCreationErrorZ_ok');
  late final _CResult_PrivateRouteCreationErrorZ_ok =
      _CResult_PrivateRouteCreationErrorZ_okPtr.asFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(LDKPrivateRoute)>();

  /// Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
  LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(
    int e,
  ) {
    return _CResult_PrivateRouteCreationErrorZ_err(
      e,
    );
  }

  late final _CResult_PrivateRouteCreationErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(
              ffi.Int32)>>('CResult_PrivateRouteCreationErrorZ_err');
  late final _CResult_PrivateRouteCreationErrorZ_err =
      _CResult_PrivateRouteCreationErrorZ_errPtr.asFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PrivateRouteCreationErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ> o,
  ) {
    return _CResult_PrivateRouteCreationErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PrivateRouteCreationErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ>)>>(
      'CResult_PrivateRouteCreationErrorZ_is_ok');
  late final _CResult_PrivateRouteCreationErrorZ_is_ok =
      _CResult_PrivateRouteCreationErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ>)>();

  /// Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
  void CResult_PrivateRouteCreationErrorZ_free(
    LDKCResult_PrivateRouteCreationErrorZ _res,
  ) {
    return _CResult_PrivateRouteCreationErrorZ_free(
      _res,
    );
  }

  late final _CResult_PrivateRouteCreationErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_PrivateRouteCreationErrorZ)>>(
      'CResult_PrivateRouteCreationErrorZ_free');
  late final _CResult_PrivateRouteCreationErrorZ_free =
      _CResult_PrivateRouteCreationErrorZ_freePtr.asFunction<
          void Function(LDKCResult_PrivateRouteCreationErrorZ)>();

  /// Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PrivateRouteCreationErrorZ
      CResult_PrivateRouteCreationErrorZ_clone(
    ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ> orig,
  ) {
    return _CResult_PrivateRouteCreationErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PrivateRouteCreationErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PrivateRouteCreationErrorZ Function(
                  ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ>)>>(
      'CResult_PrivateRouteCreationErrorZ_clone');
  late final _CResult_PrivateRouteCreationErrorZ_clone =
      _CResult_PrivateRouteCreationErrorZ_clonePtr.asFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(
              ffi.Pointer<LDKCResult_PrivateRouteCreationErrorZ>)>();

  /// Creates a new CResult_StringErrorZ in the success state.
  LDKCResult_StringErrorZ CResult_StringErrorZ_ok(
    LDKStr o,
  ) {
    return _CResult_StringErrorZ_ok(
      o,
    );
  }

  late final _CResult_StringErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_StringErrorZ Function(LDKStr)>>(
          'CResult_StringErrorZ_ok');
  late final _CResult_StringErrorZ_ok = _CResult_StringErrorZ_okPtr.asFunction<
      LDKCResult_StringErrorZ Function(LDKStr)>();

  /// Creates a new CResult_StringErrorZ in the error state.
  LDKCResult_StringErrorZ CResult_StringErrorZ_err(
    int e,
  ) {
    return _CResult_StringErrorZ_err(
      e,
    );
  }

  late final _CResult_StringErrorZ_errPtr =
      _lookup<ffi.NativeFunction<LDKCResult_StringErrorZ Function(ffi.Int32)>>(
          'CResult_StringErrorZ_err');
  late final _CResult_StringErrorZ_err = _CResult_StringErrorZ_errPtr
      .asFunction<LDKCResult_StringErrorZ Function(int)>();

  /// Checks if the given object is currently in the success state
  bool CResult_StringErrorZ_is_ok(
    ffi.Pointer<LDKCResult_StringErrorZ> o,
  ) {
    return _CResult_StringErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_StringErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_StringErrorZ>)>>(
      'CResult_StringErrorZ_is_ok');
  late final _CResult_StringErrorZ_is_ok = _CResult_StringErrorZ_is_okPtr
      .asFunction<bool Function(ffi.Pointer<LDKCResult_StringErrorZ>)>();

  /// Frees any resources used by the CResult_StringErrorZ.
  void CResult_StringErrorZ_free(
    LDKCResult_StringErrorZ _res,
  ) {
    return _CResult_StringErrorZ_free(
      _res,
    );
  }

  late final _CResult_StringErrorZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCResult_StringErrorZ)>>(
          'CResult_StringErrorZ_free');
  late final _CResult_StringErrorZ_free = _CResult_StringErrorZ_freePtr
      .asFunction<void Function(LDKCResult_StringErrorZ)>();

  /// Creates a new CResult_StringErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_StringErrorZ CResult_StringErrorZ_clone(
    ffi.Pointer<LDKCResult_StringErrorZ> orig,
  ) {
    return _CResult_StringErrorZ_clone(
      orig,
    );
  }

  late final _CResult_StringErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_StringErrorZ Function(
                  ffi.Pointer<LDKCResult_StringErrorZ>)>>(
      'CResult_StringErrorZ_clone');
  late final _CResult_StringErrorZ_clone =
      _CResult_StringErrorZ_clonePtr.asFunction<
          LDKCResult_StringErrorZ Function(
              ffi.Pointer<LDKCResult_StringErrorZ>)>();

  /// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
  LDKCResult_ChannelMonitorUpdateDecodeErrorZ
      CResult_ChannelMonitorUpdateDecodeErrorZ_ok(
    LDKChannelMonitorUpdate o,
  ) {
    return _CResult_ChannelMonitorUpdateDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
                  LDKChannelMonitorUpdate)>>(
      'CResult_ChannelMonitorUpdateDecodeErrorZ_ok');
  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_ok =
      _CResult_ChannelMonitorUpdateDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
              LDKChannelMonitorUpdate)>();

  /// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
  LDKCResult_ChannelMonitorUpdateDecodeErrorZ
      CResult_ChannelMonitorUpdateDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelMonitorUpdateDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelMonitorUpdateDecodeErrorZ_err');
  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_err =
      _CResult_ChannelMonitorUpdateDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ> o,
  ) {
    return _CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ>)>>(
      'CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok');
  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok =
      _CResult_ChannelMonitorUpdateDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
  void CResult_ChannelMonitorUpdateDecodeErrorZ_free(
    LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res,
  ) {
    return _CResult_ChannelMonitorUpdateDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelMonitorUpdateDecodeErrorZ)>>(
      'CResult_ChannelMonitorUpdateDecodeErrorZ_free');
  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_free =
      _CResult_ChannelMonitorUpdateDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelMonitorUpdateDecodeErrorZ)>();

  /// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelMonitorUpdateDecodeErrorZ
      CResult_ChannelMonitorUpdateDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelMonitorUpdateDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ>)>>(
      'CResult_ChannelMonitorUpdateDecodeErrorZ_clone');
  late final _CResult_ChannelMonitorUpdateDecodeErrorZ_clone =
      _CResult_ChannelMonitorUpdateDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelMonitorUpdateDecodeErrorZ>)>();

  /// Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
  LDKCOption_MonitorEventZ COption_MonitorEventZ_some(
    LDKMonitorEvent o,
  ) {
    return _COption_MonitorEventZ_some(
      o,
    );
  }

  late final _COption_MonitorEventZ_somePtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_MonitorEventZ Function(
              LDKMonitorEvent)>>('COption_MonitorEventZ_some');
  late final _COption_MonitorEventZ_some = _COption_MonitorEventZ_somePtr
      .asFunction<LDKCOption_MonitorEventZ Function(LDKMonitorEvent)>();

  /// Constructs a new COption_MonitorEventZ containing nothing
  LDKCOption_MonitorEventZ COption_MonitorEventZ_none() {
    return _COption_MonitorEventZ_none();
  }

  late final _COption_MonitorEventZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_MonitorEventZ Function()>>(
          'COption_MonitorEventZ_none');
  late final _COption_MonitorEventZ_none = _COption_MonitorEventZ_nonePtr
      .asFunction<LDKCOption_MonitorEventZ Function()>();

  /// Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
  void COption_MonitorEventZ_free(
    LDKCOption_MonitorEventZ _res,
  ) {
    return _COption_MonitorEventZ_free(
      _res,
    );
  }

  late final _COption_MonitorEventZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_MonitorEventZ)>>(
          'COption_MonitorEventZ_free');
  late final _COption_MonitorEventZ_free = _COption_MonitorEventZ_freePtr
      .asFunction<void Function(LDKCOption_MonitorEventZ)>();

  /// Creates a new COption_MonitorEventZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(
    ffi.Pointer<LDKCOption_MonitorEventZ> orig,
  ) {
    return _COption_MonitorEventZ_clone(
      orig,
    );
  }

  late final _COption_MonitorEventZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_MonitorEventZ Function(
                  ffi.Pointer<LDKCOption_MonitorEventZ>)>>(
      'COption_MonitorEventZ_clone');
  late final _COption_MonitorEventZ_clone =
      _COption_MonitorEventZ_clonePtr.asFunction<
          LDKCOption_MonitorEventZ Function(
              ffi.Pointer<LDKCOption_MonitorEventZ>)>();

  /// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
  LDKCResult_COption_MonitorEventZDecodeErrorZ
      CResult_COption_MonitorEventZDecodeErrorZ_ok(
    LDKCOption_MonitorEventZ o,
  ) {
    return _CResult_COption_MonitorEventZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_COption_MonitorEventZDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
                  LDKCOption_MonitorEventZ)>>(
      'CResult_COption_MonitorEventZDecodeErrorZ_ok');
  late final _CResult_COption_MonitorEventZDecodeErrorZ_ok =
      _CResult_COption_MonitorEventZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
              LDKCOption_MonitorEventZ)>();

  /// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
  LDKCResult_COption_MonitorEventZDecodeErrorZ
      CResult_COption_MonitorEventZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_COption_MonitorEventZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_COption_MonitorEventZDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_COption_MonitorEventZDecodeErrorZ_err');
  late final _CResult_COption_MonitorEventZDecodeErrorZ_err =
      _CResult_COption_MonitorEventZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ> o,
  ) {
    return _CResult_COption_MonitorEventZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_COption_MonitorEventZDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ>)>>(
      'CResult_COption_MonitorEventZDecodeErrorZ_is_ok');
  late final _CResult_COption_MonitorEventZDecodeErrorZ_is_ok =
      _CResult_COption_MonitorEventZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
  void CResult_COption_MonitorEventZDecodeErrorZ_free(
    LDKCResult_COption_MonitorEventZDecodeErrorZ _res,
  ) {
    return _CResult_COption_MonitorEventZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_COption_MonitorEventZDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_COption_MonitorEventZDecodeErrorZ)>>(
      'CResult_COption_MonitorEventZDecodeErrorZ_free');
  late final _CResult_COption_MonitorEventZDecodeErrorZ_free =
      _CResult_COption_MonitorEventZDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_COption_MonitorEventZDecodeErrorZ)>();

  /// Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_COption_MonitorEventZDecodeErrorZ
      CResult_COption_MonitorEventZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ> orig,
  ) {
    return _CResult_COption_MonitorEventZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_COption_MonitorEventZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ>)>>(
      'CResult_COption_MonitorEventZDecodeErrorZ_clone');
  late final _CResult_COption_MonitorEventZDecodeErrorZ_clone =
      _CResult_COption_MonitorEventZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_COption_MonitorEventZDecodeErrorZ>)>();

  /// Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
  LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(
    LDKHTLCUpdate o,
  ) {
    return _CResult_HTLCUpdateDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_HTLCUpdateDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(
              LDKHTLCUpdate)>>('CResult_HTLCUpdateDecodeErrorZ_ok');
  late final _CResult_HTLCUpdateDecodeErrorZ_ok =
      _CResult_HTLCUpdateDecodeErrorZ_okPtr.asFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(LDKHTLCUpdate)>();

  /// Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
  LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_HTLCUpdateDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_HTLCUpdateDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_HTLCUpdateDecodeErrorZ_err');
  late final _CResult_HTLCUpdateDecodeErrorZ_err =
      _CResult_HTLCUpdateDecodeErrorZ_errPtr.asFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_HTLCUpdateDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ> o,
  ) {
    return _CResult_HTLCUpdateDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_HTLCUpdateDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ>)>>(
      'CResult_HTLCUpdateDecodeErrorZ_is_ok');
  late final _CResult_HTLCUpdateDecodeErrorZ_is_ok =
      _CResult_HTLCUpdateDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
  void CResult_HTLCUpdateDecodeErrorZ_free(
    LDKCResult_HTLCUpdateDecodeErrorZ _res,
  ) {
    return _CResult_HTLCUpdateDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_HTLCUpdateDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_HTLCUpdateDecodeErrorZ)>>(
      'CResult_HTLCUpdateDecodeErrorZ_free');
  late final _CResult_HTLCUpdateDecodeErrorZ_free =
      _CResult_HTLCUpdateDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_HTLCUpdateDecodeErrorZ)>();

  /// Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ> orig,
  ) {
    return _CResult_HTLCUpdateDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_HTLCUpdateDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_HTLCUpdateDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ>)>>(
      'CResult_HTLCUpdateDecodeErrorZ_clone');
  late final _CResult_HTLCUpdateDecodeErrorZ_clone =
      _CResult_HTLCUpdateDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_HTLCUpdateDecodeErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(
    ffi.Pointer<LDKC2Tuple_OutPointScriptZ> orig,
  ) {
    return _C2Tuple_OutPointScriptZ_clone(
      orig,
    );
  }

  late final _C2Tuple_OutPointScriptZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_OutPointScriptZ Function(
                  ffi.Pointer<LDKC2Tuple_OutPointScriptZ>)>>(
      'C2Tuple_OutPointScriptZ_clone');
  late final _C2Tuple_OutPointScriptZ_clone =
      _C2Tuple_OutPointScriptZ_clonePtr.asFunction<
          LDKC2Tuple_OutPointScriptZ Function(
              ffi.Pointer<LDKC2Tuple_OutPointScriptZ>)>();

  /// Creates a new C2Tuple_OutPointScriptZ from the contained elements.
  LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(
    LDKOutPoint a,
    LDKCVec_u8Z b,
  ) {
    return _C2Tuple_OutPointScriptZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_OutPointScriptZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_OutPointScriptZ Function(
              LDKOutPoint, LDKCVec_u8Z)>>('C2Tuple_OutPointScriptZ_new');
  late final _C2Tuple_OutPointScriptZ_new =
      _C2Tuple_OutPointScriptZ_newPtr.asFunction<
          LDKC2Tuple_OutPointScriptZ Function(LDKOutPoint, LDKCVec_u8Z)>();

  /// Frees any resources used by the C2Tuple_OutPointScriptZ.
  void C2Tuple_OutPointScriptZ_free(
    LDKC2Tuple_OutPointScriptZ _res,
  ) {
    return _C2Tuple_OutPointScriptZ_free(
      _res,
    );
  }

  late final _C2Tuple_OutPointScriptZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_OutPointScriptZ)>>(
      'C2Tuple_OutPointScriptZ_free');
  late final _C2Tuple_OutPointScriptZ_free = _C2Tuple_OutPointScriptZ_freePtr
      .asFunction<void Function(LDKC2Tuple_OutPointScriptZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(
    ffi.Pointer<LDKC2Tuple_u32ScriptZ> orig,
  ) {
    return _C2Tuple_u32ScriptZ_clone(
      orig,
    );
  }

  late final _C2Tuple_u32ScriptZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u32ScriptZ Function(
              ffi.Pointer<LDKC2Tuple_u32ScriptZ>)>>('C2Tuple_u32ScriptZ_clone');
  late final _C2Tuple_u32ScriptZ_clone =
      _C2Tuple_u32ScriptZ_clonePtr.asFunction<
          LDKC2Tuple_u32ScriptZ Function(ffi.Pointer<LDKC2Tuple_u32ScriptZ>)>();

  /// Creates a new C2Tuple_u32ScriptZ from the contained elements.
  LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(
    int a,
    LDKCVec_u8Z b,
  ) {
    return _C2Tuple_u32ScriptZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_u32ScriptZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u32ScriptZ Function(
              ffi.Uint32, LDKCVec_u8Z)>>('C2Tuple_u32ScriptZ_new');
  late final _C2Tuple_u32ScriptZ_new = _C2Tuple_u32ScriptZ_newPtr.asFunction<
      LDKC2Tuple_u32ScriptZ Function(int, LDKCVec_u8Z)>();

  /// Frees any resources used by the C2Tuple_u32ScriptZ.
  void C2Tuple_u32ScriptZ_free(
    LDKC2Tuple_u32ScriptZ _res,
  ) {
    return _C2Tuple_u32ScriptZ_free(
      _res,
    );
  }

  late final _C2Tuple_u32ScriptZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_u32ScriptZ)>>(
          'C2Tuple_u32ScriptZ_free');
  late final _C2Tuple_u32ScriptZ_free = _C2Tuple_u32ScriptZ_freePtr.asFunction<
      void Function(LDKC2Tuple_u32ScriptZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_u32ScriptZZ_free(
    LDKCVec_C2Tuple_u32ScriptZZ _res,
  ) {
    return _CVec_C2Tuple_u32ScriptZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_u32ScriptZZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCVec_C2Tuple_u32ScriptZZ)>>(
      'CVec_C2Tuple_u32ScriptZZ_free');
  late final _CVec_C2Tuple_u32ScriptZZ_free = _CVec_C2Tuple_u32ScriptZZ_freePtr
      .asFunction<void Function(LDKCVec_C2Tuple_u32ScriptZZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ
      C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(
    ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ> orig,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(
      orig,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ Function(
                  ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ>)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone');
  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone =
      _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clonePtr.asFunction<
          LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ Function(
              ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ>)>();

  /// Creates a new C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ from the contained elements.
  LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ
      C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(
    LDKThirtyTwoBytes a,
    LDKCVec_C2Tuple_u32ScriptZZ b,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_newPtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ Function(
                  LDKThirtyTwoBytes, LDKCVec_C2Tuple_u32ScriptZZ)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new');
  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new =
      _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_newPtr.asFunction<
          LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ Function(
              LDKThirtyTwoBytes, LDKCVec_C2Tuple_u32ScriptZZ)>();

  /// Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ.
  void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(
    LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(
      _res,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free');
  late final _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free =
      _C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_freePtr.asFunction<
          void Function(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(
    LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res,
  ) {
    return _CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ)>>(
      'CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free');
  late final _CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free =
      _CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_freePtr.asFunction<
          void Function(LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_EventZ_free(
    LDKCVec_EventZ _res,
  ) {
    return _CVec_EventZ_free(
      _res,
    );
  }

  late final _CVec_EventZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_EventZ)>>(
          'CVec_EventZ_free');
  late final _CVec_EventZ_free =
      _CVec_EventZ_freePtr.asFunction<void Function(LDKCVec_EventZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_TransactionZ_free(
    LDKCVec_TransactionZ _res,
  ) {
    return _CVec_TransactionZ_free(
      _res,
    );
  }

  late final _CVec_TransactionZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_TransactionZ)>>(
          'CVec_TransactionZ_free');
  late final _CVec_TransactionZ_free = _CVec_TransactionZ_freePtr.asFunction<
      void Function(LDKCVec_TransactionZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(
    ffi.Pointer<LDKC2Tuple_u32TxOutZ> orig,
  ) {
    return _C2Tuple_u32TxOutZ_clone(
      orig,
    );
  }

  late final _C2Tuple_u32TxOutZ_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u32TxOutZ Function(
              ffi.Pointer<LDKC2Tuple_u32TxOutZ>)>>('C2Tuple_u32TxOutZ_clone');
  late final _C2Tuple_u32TxOutZ_clone = _C2Tuple_u32TxOutZ_clonePtr.asFunction<
      LDKC2Tuple_u32TxOutZ Function(ffi.Pointer<LDKC2Tuple_u32TxOutZ>)>();

  /// Creates a new C2Tuple_u32TxOutZ from the contained elements.
  LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(
    int a,
    LDKTxOut b,
  ) {
    return _C2Tuple_u32TxOutZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_u32TxOutZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_u32TxOutZ Function(
              ffi.Uint32, LDKTxOut)>>('C2Tuple_u32TxOutZ_new');
  late final _C2Tuple_u32TxOutZ_new = _C2Tuple_u32TxOutZ_newPtr.asFunction<
      LDKC2Tuple_u32TxOutZ Function(int, LDKTxOut)>();

  /// Frees any resources used by the C2Tuple_u32TxOutZ.
  void C2Tuple_u32TxOutZ_free(
    LDKC2Tuple_u32TxOutZ _res,
  ) {
    return _C2Tuple_u32TxOutZ_free(
      _res,
    );
  }

  late final _C2Tuple_u32TxOutZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_u32TxOutZ)>>(
          'C2Tuple_u32TxOutZ_free');
  late final _C2Tuple_u32TxOutZ_free = _C2Tuple_u32TxOutZ_freePtr.asFunction<
      void Function(LDKC2Tuple_u32TxOutZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_u32TxOutZZ_free(
    LDKCVec_C2Tuple_u32TxOutZZ _res,
  ) {
    return _CVec_C2Tuple_u32TxOutZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_u32TxOutZZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCVec_C2Tuple_u32TxOutZZ)>>(
      'CVec_C2Tuple_u32TxOutZZ_free');
  late final _CVec_C2Tuple_u32TxOutZZ_free = _CVec_C2Tuple_u32TxOutZZ_freePtr
      .asFunction<void Function(LDKCVec_C2Tuple_u32TxOutZZ)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ
      C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(
    ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ> orig,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(
      orig,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ Function(
                  ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ>)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone');
  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone =
      _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clonePtr.asFunction<
          LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ Function(
              ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ>)>();

  /// Creates a new C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ from the contained elements.
  LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ
      C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(
    LDKThirtyTwoBytes a,
    LDKCVec_C2Tuple_u32TxOutZZ b,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_newPtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ Function(
                  LDKThirtyTwoBytes, LDKCVec_C2Tuple_u32TxOutZZ)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new');
  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new =
      _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_newPtr.asFunction<
          LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ Function(
              LDKThirtyTwoBytes, LDKCVec_C2Tuple_u32TxOutZZ)>();

  /// Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ.
  void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(
    LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res,
  ) {
    return _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(
      _res,
    );
  }

  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ)>>(
      'C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free');
  late final _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free =
      _C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_freePtr.asFunction<
          void Function(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_TransactionOutputsZ_free(
    LDKCVec_TransactionOutputsZ _res,
  ) {
    return _CVec_TransactionOutputsZ_free(
      _res,
    );
  }

  late final _CVec_TransactionOutputsZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCVec_TransactionOutputsZ)>>(
      'CVec_TransactionOutputsZ_free');
  late final _CVec_TransactionOutputsZ_free = _CVec_TransactionOutputsZ_freePtr
      .asFunction<void Function(LDKCVec_TransactionOutputsZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_BalanceZ_free(
    LDKCVec_BalanceZ _res,
  ) {
    return _CVec_BalanceZ_free(
      _res,
    );
  }

  late final _CVec_BalanceZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_BalanceZ)>>(
          'CVec_BalanceZ_free');
  late final _CVec_BalanceZ_free =
      _CVec_BalanceZ_freePtr.asFunction<void Function(LDKCVec_BalanceZ)>();

  /// Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the success state.
  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
      CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(
    LDKC2Tuple_BlockHashChannelMonitorZ o,
  ) {
    return _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_okPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
                      Function(LDKC2Tuple_BlockHashChannelMonitorZ)>>(
          'CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok');
  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok =
      _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_okPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
              LDKC2Tuple_BlockHashChannelMonitorZ)>();

  /// Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the error state.
  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
      CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_errPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
                      Function(LDKDecodeError)>>(
          'CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err');
  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err =
      _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_errPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ> o,
  ) {
    return _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_okPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<
                          LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ>)>>(
          'CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok');
  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok =
      _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.
  void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(
    LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res,
  ) {
    return _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_freePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ)>>(
          'CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free');
  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free =
      _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_freePtr.asFunction<
          void Function(
              LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ)>();

  /// Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
      CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ> orig,
  ) {
    return _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ>)>>(
      'CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone');
  late final _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone =
      _CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ>)>();

  /// Creates a new tuple which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(
    ffi.Pointer<LDKC2Tuple_PublicKeyTypeZ> orig,
  ) {
    return _C2Tuple_PublicKeyTypeZ_clone(
      orig,
    );
  }

  late final _C2Tuple_PublicKeyTypeZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_PublicKeyTypeZ Function(
                  ffi.Pointer<LDKC2Tuple_PublicKeyTypeZ>)>>(
      'C2Tuple_PublicKeyTypeZ_clone');
  late final _C2Tuple_PublicKeyTypeZ_clone =
      _C2Tuple_PublicKeyTypeZ_clonePtr.asFunction<
          LDKC2Tuple_PublicKeyTypeZ Function(
              ffi.Pointer<LDKC2Tuple_PublicKeyTypeZ>)>();

  /// Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
  LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(
    LDKPublicKey a,
    LDKType b,
  ) {
    return _C2Tuple_PublicKeyTypeZ_new(
      a,
      b,
    );
  }

  late final _C2Tuple_PublicKeyTypeZ_newPtr = _lookup<
      ffi.NativeFunction<
          LDKC2Tuple_PublicKeyTypeZ Function(
              LDKPublicKey, LDKType)>>('C2Tuple_PublicKeyTypeZ_new');
  late final _C2Tuple_PublicKeyTypeZ_new = _C2Tuple_PublicKeyTypeZ_newPtr
      .asFunction<LDKC2Tuple_PublicKeyTypeZ Function(LDKPublicKey, LDKType)>();

  /// Frees any resources used by the C2Tuple_PublicKeyTypeZ.
  void C2Tuple_PublicKeyTypeZ_free(
    LDKC2Tuple_PublicKeyTypeZ _res,
  ) {
    return _C2Tuple_PublicKeyTypeZ_free(
      _res,
    );
  }

  late final _C2Tuple_PublicKeyTypeZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKC2Tuple_PublicKeyTypeZ)>>(
          'C2Tuple_PublicKeyTypeZ_free');
  late final _C2Tuple_PublicKeyTypeZ_free = _C2Tuple_PublicKeyTypeZ_freePtr
      .asFunction<void Function(LDKC2Tuple_PublicKeyTypeZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_C2Tuple_PublicKeyTypeZZ_free(
    LDKCVec_C2Tuple_PublicKeyTypeZZ _res,
  ) {
    return _CVec_C2Tuple_PublicKeyTypeZZ_free(
      _res,
    );
  }

  late final _CVec_C2Tuple_PublicKeyTypeZZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_C2Tuple_PublicKeyTypeZZ)>>(
      'CVec_C2Tuple_PublicKeyTypeZZ_free');
  late final _CVec_C2Tuple_PublicKeyTypeZZ_free =
      _CVec_C2Tuple_PublicKeyTypeZZ_freePtr.asFunction<
          void Function(LDKCVec_C2Tuple_PublicKeyTypeZZ)>();

  /// Constructs a new COption_NetAddressZ containing a crate::lightning::ln::msgs::NetAddress
  LDKCOption_NetAddressZ COption_NetAddressZ_some(
    LDKNetAddress o,
  ) {
    return _COption_NetAddressZ_some(
      o,
    );
  }

  late final _COption_NetAddressZ_somePtr = _lookup<
          ffi.NativeFunction<LDKCOption_NetAddressZ Function(LDKNetAddress)>>(
      'COption_NetAddressZ_some');
  late final _COption_NetAddressZ_some = _COption_NetAddressZ_somePtr
      .asFunction<LDKCOption_NetAddressZ Function(LDKNetAddress)>();

  /// Constructs a new COption_NetAddressZ containing nothing
  LDKCOption_NetAddressZ COption_NetAddressZ_none() {
    return _COption_NetAddressZ_none();
  }

  late final _COption_NetAddressZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_NetAddressZ Function()>>(
          'COption_NetAddressZ_none');
  late final _COption_NetAddressZ_none = _COption_NetAddressZ_nonePtr
      .asFunction<LDKCOption_NetAddressZ Function()>();

  /// Frees any resources associated with the crate::lightning::ln::msgs::NetAddress, if we are in the Some state
  void COption_NetAddressZ_free(
    LDKCOption_NetAddressZ _res,
  ) {
    return _COption_NetAddressZ_free(
      _res,
    );
  }

  late final _COption_NetAddressZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_NetAddressZ)>>(
          'COption_NetAddressZ_free');
  late final _COption_NetAddressZ_free = _COption_NetAddressZ_freePtr
      .asFunction<void Function(LDKCOption_NetAddressZ)>();

  /// Creates a new COption_NetAddressZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCOption_NetAddressZ COption_NetAddressZ_clone(
    ffi.Pointer<LDKCOption_NetAddressZ> orig,
  ) {
    return _COption_NetAddressZ_clone(
      orig,
    );
  }

  late final _COption_NetAddressZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_NetAddressZ Function(
                  ffi.Pointer<LDKCOption_NetAddressZ>)>>(
      'COption_NetAddressZ_clone');
  late final _COption_NetAddressZ_clone =
      _COption_NetAddressZ_clonePtr.asFunction<
          LDKCOption_NetAddressZ Function(
              ffi.Pointer<LDKCOption_NetAddressZ>)>();

  /// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
  LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(
    LDKCVec_u8Z o,
  ) {
    return _CResult_CVec_u8ZPeerHandleErrorZ_ok(
      o,
    );
  }

  late final _CResult_CVec_u8ZPeerHandleErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
              LDKCVec_u8Z)>>('CResult_CVec_u8ZPeerHandleErrorZ_ok');
  late final _CResult_CVec_u8ZPeerHandleErrorZ_ok =
      _CResult_CVec_u8ZPeerHandleErrorZ_okPtr.asFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(LDKCVec_u8Z)>();

  /// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
  LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(
    LDKPeerHandleError e,
  ) {
    return _CResult_CVec_u8ZPeerHandleErrorZ_err(
      e,
    );
  }

  late final _CResult_CVec_u8ZPeerHandleErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
              LDKPeerHandleError)>>('CResult_CVec_u8ZPeerHandleErrorZ_err');
  late final _CResult_CVec_u8ZPeerHandleErrorZ_err =
      _CResult_CVec_u8ZPeerHandleErrorZ_errPtr.asFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(LDKPeerHandleError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ> o,
  ) {
    return _CResult_CVec_u8ZPeerHandleErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CVec_u8ZPeerHandleErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ>)>>(
      'CResult_CVec_u8ZPeerHandleErrorZ_is_ok');
  late final _CResult_CVec_u8ZPeerHandleErrorZ_is_ok =
      _CResult_CVec_u8ZPeerHandleErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ>)>();

  /// Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
  void CResult_CVec_u8ZPeerHandleErrorZ_free(
    LDKCResult_CVec_u8ZPeerHandleErrorZ _res,
  ) {
    return _CResult_CVec_u8ZPeerHandleErrorZ_free(
      _res,
    );
  }

  late final _CResult_CVec_u8ZPeerHandleErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_CVec_u8ZPeerHandleErrorZ)>>(
      'CResult_CVec_u8ZPeerHandleErrorZ_free');
  late final _CResult_CVec_u8ZPeerHandleErrorZ_free =
      _CResult_CVec_u8ZPeerHandleErrorZ_freePtr.asFunction<
          void Function(LDKCResult_CVec_u8ZPeerHandleErrorZ)>();

  /// Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(
    ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ> orig,
  ) {
    return _CResult_CVec_u8ZPeerHandleErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CVec_u8ZPeerHandleErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
                  ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ>)>>(
      'CResult_CVec_u8ZPeerHandleErrorZ_clone');
  late final _CResult_CVec_u8ZPeerHandleErrorZ_clone =
      _CResult_CVec_u8ZPeerHandleErrorZ_clonePtr.asFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
              ffi.Pointer<LDKCResult_CVec_u8ZPeerHandleErrorZ>)>();

  /// Creates a new CResult_NonePeerHandleErrorZ in the success state.
  LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok() {
    return _CResult_NonePeerHandleErrorZ_ok();
  }

  late final _CResult_NonePeerHandleErrorZ_okPtr =
      _lookup<ffi.NativeFunction<LDKCResult_NonePeerHandleErrorZ Function()>>(
          'CResult_NonePeerHandleErrorZ_ok');
  late final _CResult_NonePeerHandleErrorZ_ok =
      _CResult_NonePeerHandleErrorZ_okPtr.asFunction<
          LDKCResult_NonePeerHandleErrorZ Function()>();

  /// Creates a new CResult_NonePeerHandleErrorZ in the error state.
  LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(
    LDKPeerHandleError e,
  ) {
    return _CResult_NonePeerHandleErrorZ_err(
      e,
    );
  }

  late final _CResult_NonePeerHandleErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NonePeerHandleErrorZ Function(
              LDKPeerHandleError)>>('CResult_NonePeerHandleErrorZ_err');
  late final _CResult_NonePeerHandleErrorZ_err =
      _CResult_NonePeerHandleErrorZ_errPtr.asFunction<
          LDKCResult_NonePeerHandleErrorZ Function(LDKPeerHandleError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NonePeerHandleErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NonePeerHandleErrorZ> o,
  ) {
    return _CResult_NonePeerHandleErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NonePeerHandleErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_NonePeerHandleErrorZ>)>>(
      'CResult_NonePeerHandleErrorZ_is_ok');
  late final _CResult_NonePeerHandleErrorZ_is_ok =
      _CResult_NonePeerHandleErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NonePeerHandleErrorZ>)>();

  /// Frees any resources used by the CResult_NonePeerHandleErrorZ.
  void CResult_NonePeerHandleErrorZ_free(
    LDKCResult_NonePeerHandleErrorZ _res,
  ) {
    return _CResult_NonePeerHandleErrorZ_free(
      _res,
    );
  }

  late final _CResult_NonePeerHandleErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NonePeerHandleErrorZ)>>(
      'CResult_NonePeerHandleErrorZ_free');
  late final _CResult_NonePeerHandleErrorZ_free =
      _CResult_NonePeerHandleErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NonePeerHandleErrorZ)>();

  /// Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(
    ffi.Pointer<LDKCResult_NonePeerHandleErrorZ> orig,
  ) {
    return _CResult_NonePeerHandleErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NonePeerHandleErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NonePeerHandleErrorZ Function(
                  ffi.Pointer<LDKCResult_NonePeerHandleErrorZ>)>>(
      'CResult_NonePeerHandleErrorZ_clone');
  late final _CResult_NonePeerHandleErrorZ_clone =
      _CResult_NonePeerHandleErrorZ_clonePtr.asFunction<
          LDKCResult_NonePeerHandleErrorZ Function(
              ffi.Pointer<LDKCResult_NonePeerHandleErrorZ>)>();

  /// Creates a new CResult_boolPeerHandleErrorZ in the success state.
  LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(
    bool o,
  ) {
    return _CResult_boolPeerHandleErrorZ_ok(
      o,
    );
  }

  late final _CResult_boolPeerHandleErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_boolPeerHandleErrorZ Function(
              ffi.Bool)>>('CResult_boolPeerHandleErrorZ_ok');
  late final _CResult_boolPeerHandleErrorZ_ok =
      _CResult_boolPeerHandleErrorZ_okPtr.asFunction<
          LDKCResult_boolPeerHandleErrorZ Function(bool)>();

  /// Creates a new CResult_boolPeerHandleErrorZ in the error state.
  LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(
    LDKPeerHandleError e,
  ) {
    return _CResult_boolPeerHandleErrorZ_err(
      e,
    );
  }

  late final _CResult_boolPeerHandleErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_boolPeerHandleErrorZ Function(
              LDKPeerHandleError)>>('CResult_boolPeerHandleErrorZ_err');
  late final _CResult_boolPeerHandleErrorZ_err =
      _CResult_boolPeerHandleErrorZ_errPtr.asFunction<
          LDKCResult_boolPeerHandleErrorZ Function(LDKPeerHandleError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_boolPeerHandleErrorZ_is_ok(
    ffi.Pointer<LDKCResult_boolPeerHandleErrorZ> o,
  ) {
    return _CResult_boolPeerHandleErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_boolPeerHandleErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_boolPeerHandleErrorZ>)>>(
      'CResult_boolPeerHandleErrorZ_is_ok');
  late final _CResult_boolPeerHandleErrorZ_is_ok =
      _CResult_boolPeerHandleErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_boolPeerHandleErrorZ>)>();

  /// Frees any resources used by the CResult_boolPeerHandleErrorZ.
  void CResult_boolPeerHandleErrorZ_free(
    LDKCResult_boolPeerHandleErrorZ _res,
  ) {
    return _CResult_boolPeerHandleErrorZ_free(
      _res,
    );
  }

  late final _CResult_boolPeerHandleErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_boolPeerHandleErrorZ)>>(
      'CResult_boolPeerHandleErrorZ_free');
  late final _CResult_boolPeerHandleErrorZ_free =
      _CResult_boolPeerHandleErrorZ_freePtr.asFunction<
          void Function(LDKCResult_boolPeerHandleErrorZ)>();

  /// Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(
    ffi.Pointer<LDKCResult_boolPeerHandleErrorZ> orig,
  ) {
    return _CResult_boolPeerHandleErrorZ_clone(
      orig,
    );
  }

  late final _CResult_boolPeerHandleErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_boolPeerHandleErrorZ Function(
                  ffi.Pointer<LDKCResult_boolPeerHandleErrorZ>)>>(
      'CResult_boolPeerHandleErrorZ_clone');
  late final _CResult_boolPeerHandleErrorZ_clone =
      _CResult_boolPeerHandleErrorZ_clonePtr.asFunction<
          LDKCResult_boolPeerHandleErrorZ Function(
              ffi.Pointer<LDKCResult_boolPeerHandleErrorZ>)>();

  /// Creates a new CResult_u32GraphSyncErrorZ in the success state.
  LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_ok(
    int o,
  ) {
    return _CResult_u32GraphSyncErrorZ_ok(
      o,
    );
  }

  late final _CResult_u32GraphSyncErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              ffi.Uint32)>>('CResult_u32GraphSyncErrorZ_ok');
  late final _CResult_u32GraphSyncErrorZ_ok = _CResult_u32GraphSyncErrorZ_okPtr
      .asFunction<LDKCResult_u32GraphSyncErrorZ Function(int)>();

  /// Creates a new CResult_u32GraphSyncErrorZ in the error state.
  LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_err(
    LDKGraphSyncError e,
  ) {
    return _CResult_u32GraphSyncErrorZ_err(
      e,
    );
  }

  late final _CResult_u32GraphSyncErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              LDKGraphSyncError)>>('CResult_u32GraphSyncErrorZ_err');
  late final _CResult_u32GraphSyncErrorZ_err =
      _CResult_u32GraphSyncErrorZ_errPtr.asFunction<
          LDKCResult_u32GraphSyncErrorZ Function(LDKGraphSyncError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_u32GraphSyncErrorZ_is_ok(
    ffi.Pointer<LDKCResult_u32GraphSyncErrorZ> o,
  ) {
    return _CResult_u32GraphSyncErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_u32GraphSyncErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_u32GraphSyncErrorZ>)>>(
      'CResult_u32GraphSyncErrorZ_is_ok');
  late final _CResult_u32GraphSyncErrorZ_is_ok =
      _CResult_u32GraphSyncErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_u32GraphSyncErrorZ>)>();

  /// Frees any resources used by the CResult_u32GraphSyncErrorZ.
  void CResult_u32GraphSyncErrorZ_free(
    LDKCResult_u32GraphSyncErrorZ _res,
  ) {
    return _CResult_u32GraphSyncErrorZ_free(
      _res,
    );
  }

  late final _CResult_u32GraphSyncErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_u32GraphSyncErrorZ)>>(
      'CResult_u32GraphSyncErrorZ_free');
  late final _CResult_u32GraphSyncErrorZ_free =
      _CResult_u32GraphSyncErrorZ_freePtr.asFunction<
          void Function(LDKCResult_u32GraphSyncErrorZ)>();

  /// Creates a new CResult_NetAddressDecodeErrorZ in the success state.
  LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(
    LDKNetAddress o,
  ) {
    return _CResult_NetAddressDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NetAddressDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(
              LDKNetAddress)>>('CResult_NetAddressDecodeErrorZ_ok');
  late final _CResult_NetAddressDecodeErrorZ_ok =
      _CResult_NetAddressDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(LDKNetAddress)>();

  /// Creates a new CResult_NetAddressDecodeErrorZ in the error state.
  LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NetAddressDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NetAddressDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NetAddressDecodeErrorZ_err');
  late final _CResult_NetAddressDecodeErrorZ_err =
      _CResult_NetAddressDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NetAddressDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ> o,
  ) {
    return _CResult_NetAddressDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NetAddressDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ>)>>(
      'CResult_NetAddressDecodeErrorZ_is_ok');
  late final _CResult_NetAddressDecodeErrorZ_is_ok =
      _CResult_NetAddressDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NetAddressDecodeErrorZ.
  void CResult_NetAddressDecodeErrorZ_free(
    LDKCResult_NetAddressDecodeErrorZ _res,
  ) {
    return _CResult_NetAddressDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NetAddressDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NetAddressDecodeErrorZ)>>(
      'CResult_NetAddressDecodeErrorZ_free');
  late final _CResult_NetAddressDecodeErrorZ_free =
      _CResult_NetAddressDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NetAddressDecodeErrorZ)>();

  /// Creates a new CResult_NetAddressDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ> orig,
  ) {
    return _CResult_NetAddressDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NetAddressDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NetAddressDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ>)>>(
      'CResult_NetAddressDecodeErrorZ_clone');
  late final _CResult_NetAddressDecodeErrorZ_clone =
      _CResult_NetAddressDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NetAddressDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_UpdateAddHTLCZ_free(
    LDKCVec_UpdateAddHTLCZ _res,
  ) {
    return _CVec_UpdateAddHTLCZ_free(
      _res,
    );
  }

  late final _CVec_UpdateAddHTLCZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_UpdateAddHTLCZ)>>(
          'CVec_UpdateAddHTLCZ_free');
  late final _CVec_UpdateAddHTLCZ_free = _CVec_UpdateAddHTLCZ_freePtr
      .asFunction<void Function(LDKCVec_UpdateAddHTLCZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_UpdateFulfillHTLCZ_free(
    LDKCVec_UpdateFulfillHTLCZ _res,
  ) {
    return _CVec_UpdateFulfillHTLCZ_free(
      _res,
    );
  }

  late final _CVec_UpdateFulfillHTLCZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCVec_UpdateFulfillHTLCZ)>>(
      'CVec_UpdateFulfillHTLCZ_free');
  late final _CVec_UpdateFulfillHTLCZ_free = _CVec_UpdateFulfillHTLCZ_freePtr
      .asFunction<void Function(LDKCVec_UpdateFulfillHTLCZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_UpdateFailHTLCZ_free(
    LDKCVec_UpdateFailHTLCZ _res,
  ) {
    return _CVec_UpdateFailHTLCZ_free(
      _res,
    );
  }

  late final _CVec_UpdateFailHTLCZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_UpdateFailHTLCZ)>>(
          'CVec_UpdateFailHTLCZ_free');
  late final _CVec_UpdateFailHTLCZ_free = _CVec_UpdateFailHTLCZ_freePtr
      .asFunction<void Function(LDKCVec_UpdateFailHTLCZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_UpdateFailMalformedHTLCZ_free(
    LDKCVec_UpdateFailMalformedHTLCZ _res,
  ) {
    return _CVec_UpdateFailMalformedHTLCZ_free(
      _res,
    );
  }

  late final _CVec_UpdateFailMalformedHTLCZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCVec_UpdateFailMalformedHTLCZ)>>(
      'CVec_UpdateFailMalformedHTLCZ_free');
  late final _CVec_UpdateFailMalformedHTLCZ_free =
      _CVec_UpdateFailMalformedHTLCZ_freePtr.asFunction<
          void Function(LDKCVec_UpdateFailMalformedHTLCZ)>();

  /// Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
  LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(
    LDKAcceptChannel o,
  ) {
    return _CResult_AcceptChannelDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_AcceptChannelDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(
              LDKAcceptChannel)>>('CResult_AcceptChannelDecodeErrorZ_ok');
  late final _CResult_AcceptChannelDecodeErrorZ_ok =
      _CResult_AcceptChannelDecodeErrorZ_okPtr.asFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(LDKAcceptChannel)>();

  /// Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
  LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_AcceptChannelDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_AcceptChannelDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_AcceptChannelDecodeErrorZ_err');
  late final _CResult_AcceptChannelDecodeErrorZ_err =
      _CResult_AcceptChannelDecodeErrorZ_errPtr.asFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_AcceptChannelDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ> o,
  ) {
    return _CResult_AcceptChannelDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_AcceptChannelDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ>)>>(
      'CResult_AcceptChannelDecodeErrorZ_is_ok');
  late final _CResult_AcceptChannelDecodeErrorZ_is_ok =
      _CResult_AcceptChannelDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
  void CResult_AcceptChannelDecodeErrorZ_free(
    LDKCResult_AcceptChannelDecodeErrorZ _res,
  ) {
    return _CResult_AcceptChannelDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_AcceptChannelDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_AcceptChannelDecodeErrorZ)>>(
      'CResult_AcceptChannelDecodeErrorZ_free');
  late final _CResult_AcceptChannelDecodeErrorZ_free =
      _CResult_AcceptChannelDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_AcceptChannelDecodeErrorZ)>();

  /// Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ> orig,
  ) {
    return _CResult_AcceptChannelDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_AcceptChannelDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_AcceptChannelDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ>)>>(
      'CResult_AcceptChannelDecodeErrorZ_clone');
  late final _CResult_AcceptChannelDecodeErrorZ_clone =
      _CResult_AcceptChannelDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_AcceptChannelDecodeErrorZ>)>();

  /// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
  LDKCResult_AnnouncementSignaturesDecodeErrorZ
      CResult_AnnouncementSignaturesDecodeErrorZ_ok(
    LDKAnnouncementSignatures o,
  ) {
    return _CResult_AnnouncementSignaturesDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_AnnouncementSignaturesDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
                  LDKAnnouncementSignatures)>>(
      'CResult_AnnouncementSignaturesDecodeErrorZ_ok');
  late final _CResult_AnnouncementSignaturesDecodeErrorZ_ok =
      _CResult_AnnouncementSignaturesDecodeErrorZ_okPtr.asFunction<
          LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
              LDKAnnouncementSignatures)>();

  /// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
  LDKCResult_AnnouncementSignaturesDecodeErrorZ
      CResult_AnnouncementSignaturesDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_AnnouncementSignaturesDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_AnnouncementSignaturesDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_AnnouncementSignaturesDecodeErrorZ_err');
  late final _CResult_AnnouncementSignaturesDecodeErrorZ_err =
      _CResult_AnnouncementSignaturesDecodeErrorZ_errPtr.asFunction<
          LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ> o,
  ) {
    return _CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_AnnouncementSignaturesDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ>)>>(
      'CResult_AnnouncementSignaturesDecodeErrorZ_is_ok');
  late final _CResult_AnnouncementSignaturesDecodeErrorZ_is_ok =
      _CResult_AnnouncementSignaturesDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
  void CResult_AnnouncementSignaturesDecodeErrorZ_free(
    LDKCResult_AnnouncementSignaturesDecodeErrorZ _res,
  ) {
    return _CResult_AnnouncementSignaturesDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_AnnouncementSignaturesDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_AnnouncementSignaturesDecodeErrorZ)>>(
      'CResult_AnnouncementSignaturesDecodeErrorZ_free');
  late final _CResult_AnnouncementSignaturesDecodeErrorZ_free =
      _CResult_AnnouncementSignaturesDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_AnnouncementSignaturesDecodeErrorZ)>();

  /// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_AnnouncementSignaturesDecodeErrorZ
      CResult_AnnouncementSignaturesDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ> orig,
  ) {
    return _CResult_AnnouncementSignaturesDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_AnnouncementSignaturesDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ>)>>(
      'CResult_AnnouncementSignaturesDecodeErrorZ_clone');
  late final _CResult_AnnouncementSignaturesDecodeErrorZ_clone =
      _CResult_AnnouncementSignaturesDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_AnnouncementSignaturesDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
  LDKCResult_ChannelReestablishDecodeErrorZ
      CResult_ChannelReestablishDecodeErrorZ_ok(
    LDKChannelReestablish o,
  ) {
    return _CResult_ChannelReestablishDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelReestablishDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelReestablishDecodeErrorZ Function(
                  LDKChannelReestablish)>>(
      'CResult_ChannelReestablishDecodeErrorZ_ok');
  late final _CResult_ChannelReestablishDecodeErrorZ_ok =
      _CResult_ChannelReestablishDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelReestablishDecodeErrorZ Function(
              LDKChannelReestablish)>();

  /// Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
  LDKCResult_ChannelReestablishDecodeErrorZ
      CResult_ChannelReestablishDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelReestablishDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelReestablishDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelReestablishDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelReestablishDecodeErrorZ_err');
  late final _CResult_ChannelReestablishDecodeErrorZ_err =
      _CResult_ChannelReestablishDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelReestablishDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelReestablishDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ> o,
  ) {
    return _CResult_ChannelReestablishDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelReestablishDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ>)>>(
      'CResult_ChannelReestablishDecodeErrorZ_is_ok');
  late final _CResult_ChannelReestablishDecodeErrorZ_is_ok =
      _CResult_ChannelReestablishDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
  void CResult_ChannelReestablishDecodeErrorZ_free(
    LDKCResult_ChannelReestablishDecodeErrorZ _res,
  ) {
    return _CResult_ChannelReestablishDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelReestablishDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelReestablishDecodeErrorZ)>>(
      'CResult_ChannelReestablishDecodeErrorZ_free');
  late final _CResult_ChannelReestablishDecodeErrorZ_free =
      _CResult_ChannelReestablishDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelReestablishDecodeErrorZ)>();

  /// Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelReestablishDecodeErrorZ
      CResult_ChannelReestablishDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelReestablishDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelReestablishDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelReestablishDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ>)>>(
      'CResult_ChannelReestablishDecodeErrorZ_clone');
  late final _CResult_ChannelReestablishDecodeErrorZ_clone =
      _CResult_ChannelReestablishDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelReestablishDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelReestablishDecodeErrorZ>)>();

  /// Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
  LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(
    LDKClosingSigned o,
  ) {
    return _CResult_ClosingSignedDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ClosingSignedDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(
              LDKClosingSigned)>>('CResult_ClosingSignedDecodeErrorZ_ok');
  late final _CResult_ClosingSignedDecodeErrorZ_ok =
      _CResult_ClosingSignedDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(LDKClosingSigned)>();

  /// Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
  LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ClosingSignedDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ClosingSignedDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ClosingSignedDecodeErrorZ_err');
  late final _CResult_ClosingSignedDecodeErrorZ_err =
      _CResult_ClosingSignedDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ClosingSignedDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ> o,
  ) {
    return _CResult_ClosingSignedDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ClosingSignedDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ>)>>(
      'CResult_ClosingSignedDecodeErrorZ_is_ok');
  late final _CResult_ClosingSignedDecodeErrorZ_is_ok =
      _CResult_ClosingSignedDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
  void CResult_ClosingSignedDecodeErrorZ_free(
    LDKCResult_ClosingSignedDecodeErrorZ _res,
  ) {
    return _CResult_ClosingSignedDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ClosingSignedDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ClosingSignedDecodeErrorZ)>>(
      'CResult_ClosingSignedDecodeErrorZ_free');
  late final _CResult_ClosingSignedDecodeErrorZ_free =
      _CResult_ClosingSignedDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ClosingSignedDecodeErrorZ)>();

  /// Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ> orig,
  ) {
    return _CResult_ClosingSignedDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ClosingSignedDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ClosingSignedDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ>)>>(
      'CResult_ClosingSignedDecodeErrorZ_clone');
  late final _CResult_ClosingSignedDecodeErrorZ_clone =
      _CResult_ClosingSignedDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ClosingSignedDecodeErrorZ>)>();

  /// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
  LDKCResult_ClosingSignedFeeRangeDecodeErrorZ
      CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(
    LDKClosingSignedFeeRange o,
  ) {
    return _CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
                  LDKClosingSignedFeeRange)>>(
      'CResult_ClosingSignedFeeRangeDecodeErrorZ_ok');
  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_ok =
      _CResult_ClosingSignedFeeRangeDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
              LDKClosingSignedFeeRange)>();

  /// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
  LDKCResult_ClosingSignedFeeRangeDecodeErrorZ
      CResult_ClosingSignedFeeRangeDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ClosingSignedFeeRangeDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_ClosingSignedFeeRangeDecodeErrorZ_err');
  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_err =
      _CResult_ClosingSignedFeeRangeDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ> o,
  ) {
    return _CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ>)>>(
      'CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok');
  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok =
      _CResult_ClosingSignedFeeRangeDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
  void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(
    LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res,
  ) {
    return _CResult_ClosingSignedFeeRangeDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ)>>(
      'CResult_ClosingSignedFeeRangeDecodeErrorZ_free');
  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_free =
      _CResult_ClosingSignedFeeRangeDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ)>();

  /// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ClosingSignedFeeRangeDecodeErrorZ
      CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ> orig,
  ) {
    return _CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ>)>>(
      'CResult_ClosingSignedFeeRangeDecodeErrorZ_clone');
  late final _CResult_ClosingSignedFeeRangeDecodeErrorZ_clone =
      _CResult_ClosingSignedFeeRangeDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ClosingSignedFeeRangeDecodeErrorZ>)>();

  /// Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
  LDKCResult_CommitmentSignedDecodeErrorZ
      CResult_CommitmentSignedDecodeErrorZ_ok(
    LDKCommitmentSigned o,
  ) {
    return _CResult_CommitmentSignedDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_CommitmentSignedDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(
              LDKCommitmentSigned)>>('CResult_CommitmentSignedDecodeErrorZ_ok');
  late final _CResult_CommitmentSignedDecodeErrorZ_ok =
      _CResult_CommitmentSignedDecodeErrorZ_okPtr.asFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(
              LDKCommitmentSigned)>();

  /// Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
  LDKCResult_CommitmentSignedDecodeErrorZ
      CResult_CommitmentSignedDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_CommitmentSignedDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_CommitmentSignedDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_CommitmentSignedDecodeErrorZ_err');
  late final _CResult_CommitmentSignedDecodeErrorZ_err =
      _CResult_CommitmentSignedDecodeErrorZ_errPtr.asFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_CommitmentSignedDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ> o,
  ) {
    return _CResult_CommitmentSignedDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_CommitmentSignedDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ>)>>(
      'CResult_CommitmentSignedDecodeErrorZ_is_ok');
  late final _CResult_CommitmentSignedDecodeErrorZ_is_ok =
      _CResult_CommitmentSignedDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
  void CResult_CommitmentSignedDecodeErrorZ_free(
    LDKCResult_CommitmentSignedDecodeErrorZ _res,
  ) {
    return _CResult_CommitmentSignedDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_CommitmentSignedDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_CommitmentSignedDecodeErrorZ)>>(
      'CResult_CommitmentSignedDecodeErrorZ_free');
  late final _CResult_CommitmentSignedDecodeErrorZ_free =
      _CResult_CommitmentSignedDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_CommitmentSignedDecodeErrorZ)>();

  /// Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_CommitmentSignedDecodeErrorZ
      CResult_CommitmentSignedDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ> orig,
  ) {
    return _CResult_CommitmentSignedDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_CommitmentSignedDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CommitmentSignedDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ>)>>(
      'CResult_CommitmentSignedDecodeErrorZ_clone');
  late final _CResult_CommitmentSignedDecodeErrorZ_clone =
      _CResult_CommitmentSignedDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_CommitmentSignedDecodeErrorZ>)>();

  /// Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
  LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(
    LDKFundingCreated o,
  ) {
    return _CResult_FundingCreatedDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_FundingCreatedDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(
              LDKFundingCreated)>>('CResult_FundingCreatedDecodeErrorZ_ok');
  late final _CResult_FundingCreatedDecodeErrorZ_ok =
      _CResult_FundingCreatedDecodeErrorZ_okPtr.asFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(LDKFundingCreated)>();

  /// Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
  LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_FundingCreatedDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_FundingCreatedDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_FundingCreatedDecodeErrorZ_err');
  late final _CResult_FundingCreatedDecodeErrorZ_err =
      _CResult_FundingCreatedDecodeErrorZ_errPtr.asFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_FundingCreatedDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ> o,
  ) {
    return _CResult_FundingCreatedDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_FundingCreatedDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ>)>>(
      'CResult_FundingCreatedDecodeErrorZ_is_ok');
  late final _CResult_FundingCreatedDecodeErrorZ_is_ok =
      _CResult_FundingCreatedDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
  void CResult_FundingCreatedDecodeErrorZ_free(
    LDKCResult_FundingCreatedDecodeErrorZ _res,
  ) {
    return _CResult_FundingCreatedDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_FundingCreatedDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_FundingCreatedDecodeErrorZ)>>(
      'CResult_FundingCreatedDecodeErrorZ_free');
  late final _CResult_FundingCreatedDecodeErrorZ_free =
      _CResult_FundingCreatedDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_FundingCreatedDecodeErrorZ)>();

  /// Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_FundingCreatedDecodeErrorZ
      CResult_FundingCreatedDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ> orig,
  ) {
    return _CResult_FundingCreatedDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_FundingCreatedDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_FundingCreatedDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ>)>>(
      'CResult_FundingCreatedDecodeErrorZ_clone');
  late final _CResult_FundingCreatedDecodeErrorZ_clone =
      _CResult_FundingCreatedDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_FundingCreatedDecodeErrorZ>)>();

  /// Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
  LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(
    LDKFundingSigned o,
  ) {
    return _CResult_FundingSignedDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_FundingSignedDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(
              LDKFundingSigned)>>('CResult_FundingSignedDecodeErrorZ_ok');
  late final _CResult_FundingSignedDecodeErrorZ_ok =
      _CResult_FundingSignedDecodeErrorZ_okPtr.asFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(LDKFundingSigned)>();

  /// Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
  LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_FundingSignedDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_FundingSignedDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_FundingSignedDecodeErrorZ_err');
  late final _CResult_FundingSignedDecodeErrorZ_err =
      _CResult_FundingSignedDecodeErrorZ_errPtr.asFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_FundingSignedDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ> o,
  ) {
    return _CResult_FundingSignedDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_FundingSignedDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ>)>>(
      'CResult_FundingSignedDecodeErrorZ_is_ok');
  late final _CResult_FundingSignedDecodeErrorZ_is_ok =
      _CResult_FundingSignedDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
  void CResult_FundingSignedDecodeErrorZ_free(
    LDKCResult_FundingSignedDecodeErrorZ _res,
  ) {
    return _CResult_FundingSignedDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_FundingSignedDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_FundingSignedDecodeErrorZ)>>(
      'CResult_FundingSignedDecodeErrorZ_free');
  late final _CResult_FundingSignedDecodeErrorZ_free =
      _CResult_FundingSignedDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_FundingSignedDecodeErrorZ)>();

  /// Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ> orig,
  ) {
    return _CResult_FundingSignedDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_FundingSignedDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_FundingSignedDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ>)>>(
      'CResult_FundingSignedDecodeErrorZ_clone');
  late final _CResult_FundingSignedDecodeErrorZ_clone =
      _CResult_FundingSignedDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_FundingSignedDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelReadyDecodeErrorZ in the success state.
  LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_ok(
    LDKChannelReady o,
  ) {
    return _CResult_ChannelReadyDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelReadyDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(
              LDKChannelReady)>>('CResult_ChannelReadyDecodeErrorZ_ok');
  late final _CResult_ChannelReadyDecodeErrorZ_ok =
      _CResult_ChannelReadyDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(LDKChannelReady)>();

  /// Creates a new CResult_ChannelReadyDecodeErrorZ in the error state.
  LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelReadyDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelReadyDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelReadyDecodeErrorZ_err');
  late final _CResult_ChannelReadyDecodeErrorZ_err =
      _CResult_ChannelReadyDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelReadyDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ> o,
  ) {
    return _CResult_ChannelReadyDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelReadyDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ>)>>(
      'CResult_ChannelReadyDecodeErrorZ_is_ok');
  late final _CResult_ChannelReadyDecodeErrorZ_is_ok =
      _CResult_ChannelReadyDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelReadyDecodeErrorZ.
  void CResult_ChannelReadyDecodeErrorZ_free(
    LDKCResult_ChannelReadyDecodeErrorZ _res,
  ) {
    return _CResult_ChannelReadyDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelReadyDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelReadyDecodeErrorZ)>>(
      'CResult_ChannelReadyDecodeErrorZ_free');
  late final _CResult_ChannelReadyDecodeErrorZ_free =
      _CResult_ChannelReadyDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelReadyDecodeErrorZ)>();

  /// Creates a new CResult_ChannelReadyDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelReadyDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelReadyDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelReadyDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ>)>>(
      'CResult_ChannelReadyDecodeErrorZ_clone');
  late final _CResult_ChannelReadyDecodeErrorZ_clone =
      _CResult_ChannelReadyDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelReadyDecodeErrorZ>)>();

  /// Creates a new CResult_InitDecodeErrorZ in the success state.
  LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(
    LDKInit o,
  ) {
    return _CResult_InitDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_InitDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_InitDecodeErrorZ Function(LDKInit)>>(
      'CResult_InitDecodeErrorZ_ok');
  late final _CResult_InitDecodeErrorZ_ok = _CResult_InitDecodeErrorZ_okPtr
      .asFunction<LDKCResult_InitDecodeErrorZ Function(LDKInit)>();

  /// Creates a new CResult_InitDecodeErrorZ in the error state.
  LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_InitDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_InitDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InitDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_InitDecodeErrorZ_err');
  late final _CResult_InitDecodeErrorZ_err = _CResult_InitDecodeErrorZ_errPtr
      .asFunction<LDKCResult_InitDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InitDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InitDecodeErrorZ> o,
  ) {
    return _CResult_InitDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InitDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_InitDecodeErrorZ>)>>(
      'CResult_InitDecodeErrorZ_is_ok');
  late final _CResult_InitDecodeErrorZ_is_ok =
      _CResult_InitDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InitDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_InitDecodeErrorZ.
  void CResult_InitDecodeErrorZ_free(
    LDKCResult_InitDecodeErrorZ _res,
  ) {
    return _CResult_InitDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_InitDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_InitDecodeErrorZ)>>(
      'CResult_InitDecodeErrorZ_free');
  late final _CResult_InitDecodeErrorZ_free = _CResult_InitDecodeErrorZ_freePtr
      .asFunction<void Function(LDKCResult_InitDecodeErrorZ)>();

  /// Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_InitDecodeErrorZ> orig,
  ) {
    return _CResult_InitDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InitDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InitDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_InitDecodeErrorZ>)>>(
      'CResult_InitDecodeErrorZ_clone');
  late final _CResult_InitDecodeErrorZ_clone =
      _CResult_InitDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_InitDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_InitDecodeErrorZ>)>();

  /// Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
  LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(
    LDKOpenChannel o,
  ) {
    return _CResult_OpenChannelDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_OpenChannelDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(
              LDKOpenChannel)>>('CResult_OpenChannelDecodeErrorZ_ok');
  late final _CResult_OpenChannelDecodeErrorZ_ok =
      _CResult_OpenChannelDecodeErrorZ_okPtr.asFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(LDKOpenChannel)>();

  /// Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
  LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_OpenChannelDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_OpenChannelDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_OpenChannelDecodeErrorZ_err');
  late final _CResult_OpenChannelDecodeErrorZ_err =
      _CResult_OpenChannelDecodeErrorZ_errPtr.asFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_OpenChannelDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ> o,
  ) {
    return _CResult_OpenChannelDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_OpenChannelDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ>)>>(
      'CResult_OpenChannelDecodeErrorZ_is_ok');
  late final _CResult_OpenChannelDecodeErrorZ_is_ok =
      _CResult_OpenChannelDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
  void CResult_OpenChannelDecodeErrorZ_free(
    LDKCResult_OpenChannelDecodeErrorZ _res,
  ) {
    return _CResult_OpenChannelDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_OpenChannelDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_OpenChannelDecodeErrorZ)>>(
      'CResult_OpenChannelDecodeErrorZ_free');
  late final _CResult_OpenChannelDecodeErrorZ_free =
      _CResult_OpenChannelDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_OpenChannelDecodeErrorZ)>();

  /// Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ> orig,
  ) {
    return _CResult_OpenChannelDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_OpenChannelDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_OpenChannelDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ>)>>(
      'CResult_OpenChannelDecodeErrorZ_clone');
  late final _CResult_OpenChannelDecodeErrorZ_clone =
      _CResult_OpenChannelDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_OpenChannelDecodeErrorZ>)>();

  /// Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
  LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(
    LDKRevokeAndACK o,
  ) {
    return _CResult_RevokeAndACKDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_RevokeAndACKDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(
              LDKRevokeAndACK)>>('CResult_RevokeAndACKDecodeErrorZ_ok');
  late final _CResult_RevokeAndACKDecodeErrorZ_ok =
      _CResult_RevokeAndACKDecodeErrorZ_okPtr.asFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(LDKRevokeAndACK)>();

  /// Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
  LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_RevokeAndACKDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_RevokeAndACKDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_RevokeAndACKDecodeErrorZ_err');
  late final _CResult_RevokeAndACKDecodeErrorZ_err =
      _CResult_RevokeAndACKDecodeErrorZ_errPtr.asFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_RevokeAndACKDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ> o,
  ) {
    return _CResult_RevokeAndACKDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_RevokeAndACKDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ>)>>(
      'CResult_RevokeAndACKDecodeErrorZ_is_ok');
  late final _CResult_RevokeAndACKDecodeErrorZ_is_ok =
      _CResult_RevokeAndACKDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
  void CResult_RevokeAndACKDecodeErrorZ_free(
    LDKCResult_RevokeAndACKDecodeErrorZ _res,
  ) {
    return _CResult_RevokeAndACKDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_RevokeAndACKDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_RevokeAndACKDecodeErrorZ)>>(
      'CResult_RevokeAndACKDecodeErrorZ_free');
  late final _CResult_RevokeAndACKDecodeErrorZ_free =
      _CResult_RevokeAndACKDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_RevokeAndACKDecodeErrorZ)>();

  /// Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ> orig,
  ) {
    return _CResult_RevokeAndACKDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_RevokeAndACKDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_RevokeAndACKDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ>)>>(
      'CResult_RevokeAndACKDecodeErrorZ_clone');
  late final _CResult_RevokeAndACKDecodeErrorZ_clone =
      _CResult_RevokeAndACKDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_RevokeAndACKDecodeErrorZ>)>();

  /// Creates a new CResult_ShutdownDecodeErrorZ in the success state.
  LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(
    LDKShutdown o,
  ) {
    return _CResult_ShutdownDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ShutdownDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(
              LDKShutdown)>>('CResult_ShutdownDecodeErrorZ_ok');
  late final _CResult_ShutdownDecodeErrorZ_ok =
      _CResult_ShutdownDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(LDKShutdown)>();

  /// Creates a new CResult_ShutdownDecodeErrorZ in the error state.
  LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ShutdownDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ShutdownDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ShutdownDecodeErrorZ_err');
  late final _CResult_ShutdownDecodeErrorZ_err =
      _CResult_ShutdownDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ShutdownDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ> o,
  ) {
    return _CResult_ShutdownDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ShutdownDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ>)>>(
      'CResult_ShutdownDecodeErrorZ_is_ok');
  late final _CResult_ShutdownDecodeErrorZ_is_ok =
      _CResult_ShutdownDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ShutdownDecodeErrorZ.
  void CResult_ShutdownDecodeErrorZ_free(
    LDKCResult_ShutdownDecodeErrorZ _res,
  ) {
    return _CResult_ShutdownDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ShutdownDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ShutdownDecodeErrorZ)>>(
      'CResult_ShutdownDecodeErrorZ_free');
  late final _CResult_ShutdownDecodeErrorZ_free =
      _CResult_ShutdownDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ShutdownDecodeErrorZ)>();

  /// Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ> orig,
  ) {
    return _CResult_ShutdownDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ShutdownDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ShutdownDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ>)>>(
      'CResult_ShutdownDecodeErrorZ_clone');
  late final _CResult_ShutdownDecodeErrorZ_clone =
      _CResult_ShutdownDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ShutdownDecodeErrorZ>)>();

  /// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
  LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(
    LDKUpdateFailHTLC o,
  ) {
    return _CResult_UpdateFailHTLCDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UpdateFailHTLCDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(
              LDKUpdateFailHTLC)>>('CResult_UpdateFailHTLCDecodeErrorZ_ok');
  late final _CResult_UpdateFailHTLCDecodeErrorZ_ok =
      _CResult_UpdateFailHTLCDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(LDKUpdateFailHTLC)>();

  /// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
  LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UpdateFailHTLCDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UpdateFailHTLCDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_UpdateFailHTLCDecodeErrorZ_err');
  late final _CResult_UpdateFailHTLCDecodeErrorZ_err =
      _CResult_UpdateFailHTLCDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ> o,
  ) {
    return _CResult_UpdateFailHTLCDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UpdateFailHTLCDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFailHTLCDecodeErrorZ_is_ok');
  late final _CResult_UpdateFailHTLCDecodeErrorZ_is_ok =
      _CResult_UpdateFailHTLCDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
  void CResult_UpdateFailHTLCDecodeErrorZ_free(
    LDKCResult_UpdateFailHTLCDecodeErrorZ _res,
  ) {
    return _CResult_UpdateFailHTLCDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UpdateFailHTLCDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_UpdateFailHTLCDecodeErrorZ)>>(
      'CResult_UpdateFailHTLCDecodeErrorZ_free');
  late final _CResult_UpdateFailHTLCDecodeErrorZ_free =
      _CResult_UpdateFailHTLCDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UpdateFailHTLCDecodeErrorZ)>();

  /// Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UpdateFailHTLCDecodeErrorZ
      CResult_UpdateFailHTLCDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ> orig,
  ) {
    return _CResult_UpdateFailHTLCDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UpdateFailHTLCDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFailHTLCDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFailHTLCDecodeErrorZ_clone');
  late final _CResult_UpdateFailHTLCDecodeErrorZ_clone =
      _CResult_UpdateFailHTLCDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UpdateFailHTLCDecodeErrorZ>)>();

  /// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
  LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ
      CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(
    LDKUpdateFailMalformedHTLC o,
  ) {
    return _CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
                  LDKUpdateFailMalformedHTLC)>>(
      'CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok');
  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok =
      _CResult_UpdateFailMalformedHTLCDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
              LDKUpdateFailMalformedHTLC)>();

  /// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
  LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ
      CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_UpdateFailMalformedHTLCDecodeErrorZ_err');
  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_err =
      _CResult_UpdateFailMalformedHTLCDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ> o,
  ) {
    return _CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok');
  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok =
      _CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
  void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(
    LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res,
  ) {
    return _CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ)>>(
      'CResult_UpdateFailMalformedHTLCDecodeErrorZ_free');
  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_free =
      _CResult_UpdateFailMalformedHTLCDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ)>();

  /// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ
      CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ> orig,
  ) {
    return _CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone');
  late final _CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone =
      _CResult_UpdateFailMalformedHTLCDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ>)>();

  /// Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
  LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(
    LDKUpdateFee o,
  ) {
    return _CResult_UpdateFeeDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UpdateFeeDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(
              LDKUpdateFee)>>('CResult_UpdateFeeDecodeErrorZ_ok');
  late final _CResult_UpdateFeeDecodeErrorZ_ok =
      _CResult_UpdateFeeDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(LDKUpdateFee)>();

  /// Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
  LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UpdateFeeDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UpdateFeeDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_UpdateFeeDecodeErrorZ_err');
  late final _CResult_UpdateFeeDecodeErrorZ_err =
      _CResult_UpdateFeeDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UpdateFeeDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ> o,
  ) {
    return _CResult_UpdateFeeDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UpdateFeeDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ>)>>(
      'CResult_UpdateFeeDecodeErrorZ_is_ok');
  late final _CResult_UpdateFeeDecodeErrorZ_is_ok =
      _CResult_UpdateFeeDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
  void CResult_UpdateFeeDecodeErrorZ_free(
    LDKCResult_UpdateFeeDecodeErrorZ _res,
  ) {
    return _CResult_UpdateFeeDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UpdateFeeDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_UpdateFeeDecodeErrorZ)>>(
      'CResult_UpdateFeeDecodeErrorZ_free');
  late final _CResult_UpdateFeeDecodeErrorZ_free =
      _CResult_UpdateFeeDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UpdateFeeDecodeErrorZ)>();

  /// Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ> orig,
  ) {
    return _CResult_UpdateFeeDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UpdateFeeDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFeeDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ>)>>(
      'CResult_UpdateFeeDecodeErrorZ_clone');
  late final _CResult_UpdateFeeDecodeErrorZ_clone =
      _CResult_UpdateFeeDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UpdateFeeDecodeErrorZ>)>();

  /// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
  LDKCResult_UpdateFulfillHTLCDecodeErrorZ
      CResult_UpdateFulfillHTLCDecodeErrorZ_ok(
    LDKUpdateFulfillHTLC o,
  ) {
    return _CResult_UpdateFulfillHTLCDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
                  LDKUpdateFulfillHTLC)>>(
      'CResult_UpdateFulfillHTLCDecodeErrorZ_ok');
  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_ok =
      _CResult_UpdateFulfillHTLCDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
              LDKUpdateFulfillHTLC)>();

  /// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
  LDKCResult_UpdateFulfillHTLCDecodeErrorZ
      CResult_UpdateFulfillHTLCDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UpdateFulfillHTLCDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_UpdateFulfillHTLCDecodeErrorZ_err');
  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_err =
      _CResult_UpdateFulfillHTLCDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ> o,
  ) {
    return _CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok');
  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok =
      _CResult_UpdateFulfillHTLCDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
  void CResult_UpdateFulfillHTLCDecodeErrorZ_free(
    LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res,
  ) {
    return _CResult_UpdateFulfillHTLCDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_UpdateFulfillHTLCDecodeErrorZ)>>(
      'CResult_UpdateFulfillHTLCDecodeErrorZ_free');
  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_free =
      _CResult_UpdateFulfillHTLCDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UpdateFulfillHTLCDecodeErrorZ)>();

  /// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UpdateFulfillHTLCDecodeErrorZ
      CResult_UpdateFulfillHTLCDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ> orig,
  ) {
    return _CResult_UpdateFulfillHTLCDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ>)>>(
      'CResult_UpdateFulfillHTLCDecodeErrorZ_clone');
  late final _CResult_UpdateFulfillHTLCDecodeErrorZ_clone =
      _CResult_UpdateFulfillHTLCDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UpdateFulfillHTLCDecodeErrorZ>)>();

  /// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
  LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(
    LDKUpdateAddHTLC o,
  ) {
    return _CResult_UpdateAddHTLCDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UpdateAddHTLCDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(
              LDKUpdateAddHTLC)>>('CResult_UpdateAddHTLCDecodeErrorZ_ok');
  late final _CResult_UpdateAddHTLCDecodeErrorZ_ok =
      _CResult_UpdateAddHTLCDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(LDKUpdateAddHTLC)>();

  /// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
  LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UpdateAddHTLCDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UpdateAddHTLCDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_UpdateAddHTLCDecodeErrorZ_err');
  late final _CResult_UpdateAddHTLCDecodeErrorZ_err =
      _CResult_UpdateAddHTLCDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ> o,
  ) {
    return _CResult_UpdateAddHTLCDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UpdateAddHTLCDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ>)>>(
      'CResult_UpdateAddHTLCDecodeErrorZ_is_ok');
  late final _CResult_UpdateAddHTLCDecodeErrorZ_is_ok =
      _CResult_UpdateAddHTLCDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
  void CResult_UpdateAddHTLCDecodeErrorZ_free(
    LDKCResult_UpdateAddHTLCDecodeErrorZ _res,
  ) {
    return _CResult_UpdateAddHTLCDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UpdateAddHTLCDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_UpdateAddHTLCDecodeErrorZ)>>(
      'CResult_UpdateAddHTLCDecodeErrorZ_free');
  late final _CResult_UpdateAddHTLCDecodeErrorZ_free =
      _CResult_UpdateAddHTLCDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UpdateAddHTLCDecodeErrorZ)>();

  /// Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ> orig,
  ) {
    return _CResult_UpdateAddHTLCDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UpdateAddHTLCDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UpdateAddHTLCDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ>)>>(
      'CResult_UpdateAddHTLCDecodeErrorZ_clone');
  late final _CResult_UpdateAddHTLCDecodeErrorZ_clone =
      _CResult_UpdateAddHTLCDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UpdateAddHTLCDecodeErrorZ>)>();

  /// Creates a new CResult_PingDecodeErrorZ in the success state.
  LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(
    LDKPing o,
  ) {
    return _CResult_PingDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_PingDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PingDecodeErrorZ Function(LDKPing)>>(
      'CResult_PingDecodeErrorZ_ok');
  late final _CResult_PingDecodeErrorZ_ok = _CResult_PingDecodeErrorZ_okPtr
      .asFunction<LDKCResult_PingDecodeErrorZ Function(LDKPing)>();

  /// Creates a new CResult_PingDecodeErrorZ in the error state.
  LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_PingDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_PingDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PingDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_PingDecodeErrorZ_err');
  late final _CResult_PingDecodeErrorZ_err = _CResult_PingDecodeErrorZ_errPtr
      .asFunction<LDKCResult_PingDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PingDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PingDecodeErrorZ> o,
  ) {
    return _CResult_PingDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PingDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_PingDecodeErrorZ>)>>(
      'CResult_PingDecodeErrorZ_is_ok');
  late final _CResult_PingDecodeErrorZ_is_ok =
      _CResult_PingDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PingDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_PingDecodeErrorZ.
  void CResult_PingDecodeErrorZ_free(
    LDKCResult_PingDecodeErrorZ _res,
  ) {
    return _CResult_PingDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_PingDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_PingDecodeErrorZ)>>(
      'CResult_PingDecodeErrorZ_free');
  late final _CResult_PingDecodeErrorZ_free = _CResult_PingDecodeErrorZ_freePtr
      .asFunction<void Function(LDKCResult_PingDecodeErrorZ)>();

  /// Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_PingDecodeErrorZ> orig,
  ) {
    return _CResult_PingDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PingDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PingDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_PingDecodeErrorZ>)>>(
      'CResult_PingDecodeErrorZ_clone');
  late final _CResult_PingDecodeErrorZ_clone =
      _CResult_PingDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_PingDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_PingDecodeErrorZ>)>();

  /// Creates a new CResult_PongDecodeErrorZ in the success state.
  LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(
    LDKPong o,
  ) {
    return _CResult_PongDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_PongDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PongDecodeErrorZ Function(LDKPong)>>(
      'CResult_PongDecodeErrorZ_ok');
  late final _CResult_PongDecodeErrorZ_ok = _CResult_PongDecodeErrorZ_okPtr
      .asFunction<LDKCResult_PongDecodeErrorZ Function(LDKPong)>();

  /// Creates a new CResult_PongDecodeErrorZ in the error state.
  LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_PongDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_PongDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PongDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_PongDecodeErrorZ_err');
  late final _CResult_PongDecodeErrorZ_err = _CResult_PongDecodeErrorZ_errPtr
      .asFunction<LDKCResult_PongDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_PongDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_PongDecodeErrorZ> o,
  ) {
    return _CResult_PongDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_PongDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKCResult_PongDecodeErrorZ>)>>(
      'CResult_PongDecodeErrorZ_is_ok');
  late final _CResult_PongDecodeErrorZ_is_ok =
      _CResult_PongDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_PongDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_PongDecodeErrorZ.
  void CResult_PongDecodeErrorZ_free(
    LDKCResult_PongDecodeErrorZ _res,
  ) {
    return _CResult_PongDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_PongDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCResult_PongDecodeErrorZ)>>(
      'CResult_PongDecodeErrorZ_free');
  late final _CResult_PongDecodeErrorZ_free = _CResult_PongDecodeErrorZ_freePtr
      .asFunction<void Function(LDKCResult_PongDecodeErrorZ)>();

  /// Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_PongDecodeErrorZ> orig,
  ) {
    return _CResult_PongDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_PongDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PongDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_PongDecodeErrorZ>)>>(
      'CResult_PongDecodeErrorZ_clone');
  late final _CResult_PongDecodeErrorZ_clone =
      _CResult_PongDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_PongDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_PongDecodeErrorZ>)>();

  /// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ
      CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(
    LDKUnsignedChannelAnnouncement o,
  ) {
    return _CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
                  LDKUnsignedChannelAnnouncement)>>(
      'CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok');
  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok =
      _CResult_UnsignedChannelAnnouncementDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
              LDKUnsignedChannelAnnouncement)>();

  /// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ
      CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_UnsignedChannelAnnouncementDecodeErrorZ_err');
  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_err =
      _CResult_UnsignedChannelAnnouncementDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ> o,
  ) {
    return _CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ>)>>(
      'CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok');
  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok =
      _CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<
                  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
  void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(
    LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res,
  ) {
    return _CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ)>>(
      'CResult_UnsignedChannelAnnouncementDecodeErrorZ_free');
  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_free =
      _CResult_UnsignedChannelAnnouncementDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ)>();

  /// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ
      CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ> orig,
  ) {
    return _CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ>)>>(
      'CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone');
  late final _CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone =
      _CResult_UnsignedChannelAnnouncementDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
              ffi.Pointer<
                  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
  LDKCResult_ChannelAnnouncementDecodeErrorZ
      CResult_ChannelAnnouncementDecodeErrorZ_ok(
    LDKChannelAnnouncement o,
  ) {
    return _CResult_ChannelAnnouncementDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelAnnouncementDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
                  LDKChannelAnnouncement)>>(
      'CResult_ChannelAnnouncementDecodeErrorZ_ok');
  late final _CResult_ChannelAnnouncementDecodeErrorZ_ok =
      _CResult_ChannelAnnouncementDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
              LDKChannelAnnouncement)>();

  /// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
  LDKCResult_ChannelAnnouncementDecodeErrorZ
      CResult_ChannelAnnouncementDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelAnnouncementDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelAnnouncementDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelAnnouncementDecodeErrorZ_err');
  late final _CResult_ChannelAnnouncementDecodeErrorZ_err =
      _CResult_ChannelAnnouncementDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ> o,
  ) {
    return _CResult_ChannelAnnouncementDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelAnnouncementDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ>)>>(
      'CResult_ChannelAnnouncementDecodeErrorZ_is_ok');
  late final _CResult_ChannelAnnouncementDecodeErrorZ_is_ok =
      _CResult_ChannelAnnouncementDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
  void CResult_ChannelAnnouncementDecodeErrorZ_free(
    LDKCResult_ChannelAnnouncementDecodeErrorZ _res,
  ) {
    return _CResult_ChannelAnnouncementDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelAnnouncementDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelAnnouncementDecodeErrorZ)>>(
      'CResult_ChannelAnnouncementDecodeErrorZ_free');
  late final _CResult_ChannelAnnouncementDecodeErrorZ_free =
      _CResult_ChannelAnnouncementDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelAnnouncementDecodeErrorZ)>();

  /// Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelAnnouncementDecodeErrorZ
      CResult_ChannelAnnouncementDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelAnnouncementDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelAnnouncementDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ>)>>(
      'CResult_ChannelAnnouncementDecodeErrorZ_clone');
  late final _CResult_ChannelAnnouncementDecodeErrorZ_clone =
      _CResult_ChannelAnnouncementDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelAnnouncementDecodeErrorZ>)>();

  /// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
  LDKCResult_UnsignedChannelUpdateDecodeErrorZ
      CResult_UnsignedChannelUpdateDecodeErrorZ_ok(
    LDKUnsignedChannelUpdate o,
  ) {
    return _CResult_UnsignedChannelUpdateDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
                  LDKUnsignedChannelUpdate)>>(
      'CResult_UnsignedChannelUpdateDecodeErrorZ_ok');
  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_ok =
      _CResult_UnsignedChannelUpdateDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
              LDKUnsignedChannelUpdate)>();

  /// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
  LDKCResult_UnsignedChannelUpdateDecodeErrorZ
      CResult_UnsignedChannelUpdateDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UnsignedChannelUpdateDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_UnsignedChannelUpdateDecodeErrorZ_err');
  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_err =
      _CResult_UnsignedChannelUpdateDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ> o,
  ) {
    return _CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ>)>>(
      'CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok');
  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok =
      _CResult_UnsignedChannelUpdateDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
  void CResult_UnsignedChannelUpdateDecodeErrorZ_free(
    LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res,
  ) {
    return _CResult_UnsignedChannelUpdateDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_UnsignedChannelUpdateDecodeErrorZ)>>(
      'CResult_UnsignedChannelUpdateDecodeErrorZ_free');
  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_free =
      _CResult_UnsignedChannelUpdateDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UnsignedChannelUpdateDecodeErrorZ)>();

  /// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UnsignedChannelUpdateDecodeErrorZ
      CResult_UnsignedChannelUpdateDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ> orig,
  ) {
    return _CResult_UnsignedChannelUpdateDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ>)>>(
      'CResult_UnsignedChannelUpdateDecodeErrorZ_clone');
  late final _CResult_UnsignedChannelUpdateDecodeErrorZ_clone =
      _CResult_UnsignedChannelUpdateDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UnsignedChannelUpdateDecodeErrorZ>)>();

  /// Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
  LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(
    LDKChannelUpdate o,
  ) {
    return _CResult_ChannelUpdateDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ChannelUpdateDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(
              LDKChannelUpdate)>>('CResult_ChannelUpdateDecodeErrorZ_ok');
  late final _CResult_ChannelUpdateDecodeErrorZ_ok =
      _CResult_ChannelUpdateDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(LDKChannelUpdate)>();

  /// Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
  LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ChannelUpdateDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ChannelUpdateDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ChannelUpdateDecodeErrorZ_err');
  late final _CResult_ChannelUpdateDecodeErrorZ_err =
      _CResult_ChannelUpdateDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ChannelUpdateDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ> o,
  ) {
    return _CResult_ChannelUpdateDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ChannelUpdateDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ>)>>(
      'CResult_ChannelUpdateDecodeErrorZ_is_ok');
  late final _CResult_ChannelUpdateDecodeErrorZ_is_ok =
      _CResult_ChannelUpdateDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
  void CResult_ChannelUpdateDecodeErrorZ_free(
    LDKCResult_ChannelUpdateDecodeErrorZ _res,
  ) {
    return _CResult_ChannelUpdateDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ChannelUpdateDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ChannelUpdateDecodeErrorZ)>>(
      'CResult_ChannelUpdateDecodeErrorZ_free');
  late final _CResult_ChannelUpdateDecodeErrorZ_free =
      _CResult_ChannelUpdateDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ChannelUpdateDecodeErrorZ)>();

  /// Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ> orig,
  ) {
    return _CResult_ChannelUpdateDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ChannelUpdateDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ChannelUpdateDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ>)>>(
      'CResult_ChannelUpdateDecodeErrorZ_clone');
  late final _CResult_ChannelUpdateDecodeErrorZ_clone =
      _CResult_ChannelUpdateDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ChannelUpdateDecodeErrorZ>)>();

  /// Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
  LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(
    LDKErrorMessage o,
  ) {
    return _CResult_ErrorMessageDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ErrorMessageDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(
              LDKErrorMessage)>>('CResult_ErrorMessageDecodeErrorZ_ok');
  late final _CResult_ErrorMessageDecodeErrorZ_ok =
      _CResult_ErrorMessageDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(LDKErrorMessage)>();

  /// Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
  LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ErrorMessageDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ErrorMessageDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ErrorMessageDecodeErrorZ_err');
  late final _CResult_ErrorMessageDecodeErrorZ_err =
      _CResult_ErrorMessageDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ErrorMessageDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ> o,
  ) {
    return _CResult_ErrorMessageDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ErrorMessageDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ>)>>(
      'CResult_ErrorMessageDecodeErrorZ_is_ok');
  late final _CResult_ErrorMessageDecodeErrorZ_is_ok =
      _CResult_ErrorMessageDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
  void CResult_ErrorMessageDecodeErrorZ_free(
    LDKCResult_ErrorMessageDecodeErrorZ _res,
  ) {
    return _CResult_ErrorMessageDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ErrorMessageDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ErrorMessageDecodeErrorZ)>>(
      'CResult_ErrorMessageDecodeErrorZ_free');
  late final _CResult_ErrorMessageDecodeErrorZ_free =
      _CResult_ErrorMessageDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ErrorMessageDecodeErrorZ)>();

  /// Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ> orig,
  ) {
    return _CResult_ErrorMessageDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ErrorMessageDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ErrorMessageDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ>)>>(
      'CResult_ErrorMessageDecodeErrorZ_clone');
  late final _CResult_ErrorMessageDecodeErrorZ_clone =
      _CResult_ErrorMessageDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ErrorMessageDecodeErrorZ>)>();

  /// Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
  LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(
    LDKWarningMessage o,
  ) {
    return _CResult_WarningMessageDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_WarningMessageDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(
              LDKWarningMessage)>>('CResult_WarningMessageDecodeErrorZ_ok');
  late final _CResult_WarningMessageDecodeErrorZ_ok =
      _CResult_WarningMessageDecodeErrorZ_okPtr.asFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(LDKWarningMessage)>();

  /// Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
  LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_WarningMessageDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_WarningMessageDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_WarningMessageDecodeErrorZ_err');
  late final _CResult_WarningMessageDecodeErrorZ_err =
      _CResult_WarningMessageDecodeErrorZ_errPtr.asFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_WarningMessageDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ> o,
  ) {
    return _CResult_WarningMessageDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_WarningMessageDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ>)>>(
      'CResult_WarningMessageDecodeErrorZ_is_ok');
  late final _CResult_WarningMessageDecodeErrorZ_is_ok =
      _CResult_WarningMessageDecodeErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
  void CResult_WarningMessageDecodeErrorZ_free(
    LDKCResult_WarningMessageDecodeErrorZ _res,
  ) {
    return _CResult_WarningMessageDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_WarningMessageDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_WarningMessageDecodeErrorZ)>>(
      'CResult_WarningMessageDecodeErrorZ_free');
  late final _CResult_WarningMessageDecodeErrorZ_free =
      _CResult_WarningMessageDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_WarningMessageDecodeErrorZ)>();

  /// Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_WarningMessageDecodeErrorZ
      CResult_WarningMessageDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ> orig,
  ) {
    return _CResult_WarningMessageDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_WarningMessageDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_WarningMessageDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ>)>>(
      'CResult_WarningMessageDecodeErrorZ_clone');
  late final _CResult_WarningMessageDecodeErrorZ_clone =
      _CResult_WarningMessageDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_WarningMessageDecodeErrorZ>)>();

  /// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
  LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ
      CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(
    LDKUnsignedNodeAnnouncement o,
  ) {
    return _CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
                  LDKUnsignedNodeAnnouncement)>>(
      'CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok');
  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok =
      _CResult_UnsignedNodeAnnouncementDecodeErrorZ_okPtr.asFunction<
          LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
              LDKUnsignedNodeAnnouncement)>();

  /// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
  LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ
      CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_UnsignedNodeAnnouncementDecodeErrorZ_err');
  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_err =
      _CResult_UnsignedNodeAnnouncementDecodeErrorZ_errPtr.asFunction<
          LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ> o,
  ) {
    return _CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ>)>>(
      'CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok');
  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok =
      _CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
  void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(
    LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res,
  ) {
    return _CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ)>>(
      'CResult_UnsignedNodeAnnouncementDecodeErrorZ_free');
  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_free =
      _CResult_UnsignedNodeAnnouncementDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ)>();

  /// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ
      CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ> orig,
  ) {
    return _CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ>)>>(
      'CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone');
  late final _CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone =
      _CResult_UnsignedNodeAnnouncementDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ>)>();

  /// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
  LDKCResult_NodeAnnouncementDecodeErrorZ
      CResult_NodeAnnouncementDecodeErrorZ_ok(
    LDKNodeAnnouncement o,
  ) {
    return _CResult_NodeAnnouncementDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_NodeAnnouncementDecodeErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(
              LDKNodeAnnouncement)>>('CResult_NodeAnnouncementDecodeErrorZ_ok');
  late final _CResult_NodeAnnouncementDecodeErrorZ_ok =
      _CResult_NodeAnnouncementDecodeErrorZ_okPtr.asFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(
              LDKNodeAnnouncement)>();

  /// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
  LDKCResult_NodeAnnouncementDecodeErrorZ
      CResult_NodeAnnouncementDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_NodeAnnouncementDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_NodeAnnouncementDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_NodeAnnouncementDecodeErrorZ_err');
  late final _CResult_NodeAnnouncementDecodeErrorZ_err =
      _CResult_NodeAnnouncementDecodeErrorZ_errPtr.asFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ> o,
  ) {
    return _CResult_NodeAnnouncementDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_NodeAnnouncementDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ>)>>(
      'CResult_NodeAnnouncementDecodeErrorZ_is_ok');
  late final _CResult_NodeAnnouncementDecodeErrorZ_is_ok =
      _CResult_NodeAnnouncementDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
  void CResult_NodeAnnouncementDecodeErrorZ_free(
    LDKCResult_NodeAnnouncementDecodeErrorZ _res,
  ) {
    return _CResult_NodeAnnouncementDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_NodeAnnouncementDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_NodeAnnouncementDecodeErrorZ)>>(
      'CResult_NodeAnnouncementDecodeErrorZ_free');
  late final _CResult_NodeAnnouncementDecodeErrorZ_free =
      _CResult_NodeAnnouncementDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_NodeAnnouncementDecodeErrorZ)>();

  /// Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_NodeAnnouncementDecodeErrorZ
      CResult_NodeAnnouncementDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ> orig,
  ) {
    return _CResult_NodeAnnouncementDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_NodeAnnouncementDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NodeAnnouncementDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ>)>>(
      'CResult_NodeAnnouncementDecodeErrorZ_clone');
  late final _CResult_NodeAnnouncementDecodeErrorZ_clone =
      _CResult_NodeAnnouncementDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_NodeAnnouncementDecodeErrorZ>)>();

  /// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
  LDKCResult_QueryShortChannelIdsDecodeErrorZ
      CResult_QueryShortChannelIdsDecodeErrorZ_ok(
    LDKQueryShortChannelIds o,
  ) {
    return _CResult_QueryShortChannelIdsDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_QueryShortChannelIdsDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
                  LDKQueryShortChannelIds)>>(
      'CResult_QueryShortChannelIdsDecodeErrorZ_ok');
  late final _CResult_QueryShortChannelIdsDecodeErrorZ_ok =
      _CResult_QueryShortChannelIdsDecodeErrorZ_okPtr.asFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
              LDKQueryShortChannelIds)>();

  /// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
  LDKCResult_QueryShortChannelIdsDecodeErrorZ
      CResult_QueryShortChannelIdsDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_QueryShortChannelIdsDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_QueryShortChannelIdsDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_QueryShortChannelIdsDecodeErrorZ_err');
  late final _CResult_QueryShortChannelIdsDecodeErrorZ_err =
      _CResult_QueryShortChannelIdsDecodeErrorZ_errPtr.asFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ> o,
  ) {
    return _CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_QueryShortChannelIdsDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ>)>>(
      'CResult_QueryShortChannelIdsDecodeErrorZ_is_ok');
  late final _CResult_QueryShortChannelIdsDecodeErrorZ_is_ok =
      _CResult_QueryShortChannelIdsDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
  void CResult_QueryShortChannelIdsDecodeErrorZ_free(
    LDKCResult_QueryShortChannelIdsDecodeErrorZ _res,
  ) {
    return _CResult_QueryShortChannelIdsDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_QueryShortChannelIdsDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_QueryShortChannelIdsDecodeErrorZ)>>(
      'CResult_QueryShortChannelIdsDecodeErrorZ_free');
  late final _CResult_QueryShortChannelIdsDecodeErrorZ_free =
      _CResult_QueryShortChannelIdsDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_QueryShortChannelIdsDecodeErrorZ)>();

  /// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_QueryShortChannelIdsDecodeErrorZ
      CResult_QueryShortChannelIdsDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ> orig,
  ) {
    return _CResult_QueryShortChannelIdsDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_QueryShortChannelIdsDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ>)>>(
      'CResult_QueryShortChannelIdsDecodeErrorZ_clone');
  late final _CResult_QueryShortChannelIdsDecodeErrorZ_clone =
      _CResult_QueryShortChannelIdsDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_QueryShortChannelIdsDecodeErrorZ>)>();

  /// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
  LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ
      CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(
    LDKReplyShortChannelIdsEnd o,
  ) {
    return _CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
                  LDKReplyShortChannelIdsEnd)>>(
      'CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok');
  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok =
      _CResult_ReplyShortChannelIdsEndDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
              LDKReplyShortChannelIdsEnd)>();

  /// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
  LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ
      CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_ReplyShortChannelIdsEndDecodeErrorZ_err');
  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_err =
      _CResult_ReplyShortChannelIdsEndDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ> o,
  ) {
    return _CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<
                      LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ>)>>(
      'CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok');
  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok =
      _CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
  void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(
    LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res,
  ) {
    return _CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ)>>(
      'CResult_ReplyShortChannelIdsEndDecodeErrorZ_free');
  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_free =
      _CResult_ReplyShortChannelIdsEndDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ)>();

  /// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ
      CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ> orig,
  ) {
    return _CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
                  ffi.Pointer<
                      LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ>)>>(
      'CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone');
  late final _CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone =
      _CResult_ReplyShortChannelIdsEndDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ>)>();

  /// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
  LDKCResult_QueryChannelRangeDecodeErrorZ
      CResult_QueryChannelRangeDecodeErrorZ_ok(
    LDKQueryChannelRange o,
  ) {
    return _CResult_QueryChannelRangeDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_QueryChannelRangeDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_QueryChannelRangeDecodeErrorZ Function(
                  LDKQueryChannelRange)>>(
      'CResult_QueryChannelRangeDecodeErrorZ_ok');
  late final _CResult_QueryChannelRangeDecodeErrorZ_ok =
      _CResult_QueryChannelRangeDecodeErrorZ_okPtr.asFunction<
          LDKCResult_QueryChannelRangeDecodeErrorZ Function(
              LDKQueryChannelRange)>();

  /// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
  LDKCResult_QueryChannelRangeDecodeErrorZ
      CResult_QueryChannelRangeDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_QueryChannelRangeDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_QueryChannelRangeDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_QueryChannelRangeDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_QueryChannelRangeDecodeErrorZ_err');
  late final _CResult_QueryChannelRangeDecodeErrorZ_err =
      _CResult_QueryChannelRangeDecodeErrorZ_errPtr.asFunction<
          LDKCResult_QueryChannelRangeDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ> o,
  ) {
    return _CResult_QueryChannelRangeDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_QueryChannelRangeDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ>)>>(
      'CResult_QueryChannelRangeDecodeErrorZ_is_ok');
  late final _CResult_QueryChannelRangeDecodeErrorZ_is_ok =
      _CResult_QueryChannelRangeDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
  void CResult_QueryChannelRangeDecodeErrorZ_free(
    LDKCResult_QueryChannelRangeDecodeErrorZ _res,
  ) {
    return _CResult_QueryChannelRangeDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_QueryChannelRangeDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_QueryChannelRangeDecodeErrorZ)>>(
      'CResult_QueryChannelRangeDecodeErrorZ_free');
  late final _CResult_QueryChannelRangeDecodeErrorZ_free =
      _CResult_QueryChannelRangeDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_QueryChannelRangeDecodeErrorZ)>();

  /// Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_QueryChannelRangeDecodeErrorZ
      CResult_QueryChannelRangeDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ> orig,
  ) {
    return _CResult_QueryChannelRangeDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_QueryChannelRangeDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_QueryChannelRangeDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ>)>>(
      'CResult_QueryChannelRangeDecodeErrorZ_clone');
  late final _CResult_QueryChannelRangeDecodeErrorZ_clone =
      _CResult_QueryChannelRangeDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_QueryChannelRangeDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_QueryChannelRangeDecodeErrorZ>)>();

  /// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
  LDKCResult_ReplyChannelRangeDecodeErrorZ
      CResult_ReplyChannelRangeDecodeErrorZ_ok(
    LDKReplyChannelRange o,
  ) {
    return _CResult_ReplyChannelRangeDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_ReplyChannelRangeDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
                  LDKReplyChannelRange)>>(
      'CResult_ReplyChannelRangeDecodeErrorZ_ok');
  late final _CResult_ReplyChannelRangeDecodeErrorZ_ok =
      _CResult_ReplyChannelRangeDecodeErrorZ_okPtr.asFunction<
          LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
              LDKReplyChannelRange)>();

  /// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
  LDKCResult_ReplyChannelRangeDecodeErrorZ
      CResult_ReplyChannelRangeDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_ReplyChannelRangeDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_ReplyChannelRangeDecodeErrorZ_errPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
              LDKDecodeError)>>('CResult_ReplyChannelRangeDecodeErrorZ_err');
  late final _CResult_ReplyChannelRangeDecodeErrorZ_err =
      _CResult_ReplyChannelRangeDecodeErrorZ_errPtr.asFunction<
          LDKCResult_ReplyChannelRangeDecodeErrorZ Function(LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ> o,
  ) {
    return _CResult_ReplyChannelRangeDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_ReplyChannelRangeDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ>)>>(
      'CResult_ReplyChannelRangeDecodeErrorZ_is_ok');
  late final _CResult_ReplyChannelRangeDecodeErrorZ_is_ok =
      _CResult_ReplyChannelRangeDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
  void CResult_ReplyChannelRangeDecodeErrorZ_free(
    LDKCResult_ReplyChannelRangeDecodeErrorZ _res,
  ) {
    return _CResult_ReplyChannelRangeDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_ReplyChannelRangeDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_ReplyChannelRangeDecodeErrorZ)>>(
      'CResult_ReplyChannelRangeDecodeErrorZ_free');
  late final _CResult_ReplyChannelRangeDecodeErrorZ_free =
      _CResult_ReplyChannelRangeDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_ReplyChannelRangeDecodeErrorZ)>();

  /// Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_ReplyChannelRangeDecodeErrorZ
      CResult_ReplyChannelRangeDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ> orig,
  ) {
    return _CResult_ReplyChannelRangeDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_ReplyChannelRangeDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ>)>>(
      'CResult_ReplyChannelRangeDecodeErrorZ_clone');
  late final _CResult_ReplyChannelRangeDecodeErrorZ_clone =
      _CResult_ReplyChannelRangeDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_ReplyChannelRangeDecodeErrorZ>)>();

  /// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
  LDKCResult_GossipTimestampFilterDecodeErrorZ
      CResult_GossipTimestampFilterDecodeErrorZ_ok(
    LDKGossipTimestampFilter o,
  ) {
    return _CResult_GossipTimestampFilterDecodeErrorZ_ok(
      o,
    );
  }

  late final _CResult_GossipTimestampFilterDecodeErrorZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
                  LDKGossipTimestampFilter)>>(
      'CResult_GossipTimestampFilterDecodeErrorZ_ok');
  late final _CResult_GossipTimestampFilterDecodeErrorZ_ok =
      _CResult_GossipTimestampFilterDecodeErrorZ_okPtr.asFunction<
          LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
              LDKGossipTimestampFilter)>();

  /// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
  LDKCResult_GossipTimestampFilterDecodeErrorZ
      CResult_GossipTimestampFilterDecodeErrorZ_err(
    LDKDecodeError e,
  ) {
    return _CResult_GossipTimestampFilterDecodeErrorZ_err(
      e,
    );
  }

  late final _CResult_GossipTimestampFilterDecodeErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
                  LDKDecodeError)>>(
      'CResult_GossipTimestampFilterDecodeErrorZ_err');
  late final _CResult_GossipTimestampFilterDecodeErrorZ_err =
      _CResult_GossipTimestampFilterDecodeErrorZ_errPtr.asFunction<
          LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
              LDKDecodeError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(
    ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ> o,
  ) {
    return _CResult_GossipTimestampFilterDecodeErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_GossipTimestampFilterDecodeErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ>)>>(
      'CResult_GossipTimestampFilterDecodeErrorZ_is_ok');
  late final _CResult_GossipTimestampFilterDecodeErrorZ_is_ok =
      _CResult_GossipTimestampFilterDecodeErrorZ_is_okPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ>)>();

  /// Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
  void CResult_GossipTimestampFilterDecodeErrorZ_free(
    LDKCResult_GossipTimestampFilterDecodeErrorZ _res,
  ) {
    return _CResult_GossipTimestampFilterDecodeErrorZ_free(
      _res,
    );
  }

  late final _CResult_GossipTimestampFilterDecodeErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_GossipTimestampFilterDecodeErrorZ)>>(
      'CResult_GossipTimestampFilterDecodeErrorZ_free');
  late final _CResult_GossipTimestampFilterDecodeErrorZ_free =
      _CResult_GossipTimestampFilterDecodeErrorZ_freePtr.asFunction<
          void Function(LDKCResult_GossipTimestampFilterDecodeErrorZ)>();

  /// Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_GossipTimestampFilterDecodeErrorZ
      CResult_GossipTimestampFilterDecodeErrorZ_clone(
    ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ> orig,
  ) {
    return _CResult_GossipTimestampFilterDecodeErrorZ_clone(
      orig,
    );
  }

  late final _CResult_GossipTimestampFilterDecodeErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
                  ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ>)>>(
      'CResult_GossipTimestampFilterDecodeErrorZ_clone');
  late final _CResult_GossipTimestampFilterDecodeErrorZ_clone =
      _CResult_GossipTimestampFilterDecodeErrorZ_clonePtr.asFunction<
          LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
              ffi.Pointer<LDKCResult_GossipTimestampFilterDecodeErrorZ>)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_PhantomRouteHintsZ_free(
    LDKCVec_PhantomRouteHintsZ _res,
  ) {
    return _CVec_PhantomRouteHintsZ_free(
      _res,
    );
  }

  late final _CVec_PhantomRouteHintsZ_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCVec_PhantomRouteHintsZ)>>(
      'CVec_PhantomRouteHintsZ_free');
  late final _CVec_PhantomRouteHintsZ_free = _CVec_PhantomRouteHintsZ_freePtr
      .asFunction<void Function(LDKCVec_PhantomRouteHintsZ)>();

  /// Creates a new CResult_InvoiceSignOrCreationErrorZ in the success state.
  LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_ok(
    LDKInvoice o,
  ) {
    return _CResult_InvoiceSignOrCreationErrorZ_ok(
      o,
    );
  }

  late final _CResult_InvoiceSignOrCreationErrorZ_okPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              LDKInvoice)>>('CResult_InvoiceSignOrCreationErrorZ_ok');
  late final _CResult_InvoiceSignOrCreationErrorZ_ok =
      _CResult_InvoiceSignOrCreationErrorZ_okPtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(LDKInvoice)>();

  /// Creates a new CResult_InvoiceSignOrCreationErrorZ in the error state.
  LDKCResult_InvoiceSignOrCreationErrorZ
      CResult_InvoiceSignOrCreationErrorZ_err(
    LDKSignOrCreationError e,
  ) {
    return _CResult_InvoiceSignOrCreationErrorZ_err(
      e,
    );
  }

  late final _CResult_InvoiceSignOrCreationErrorZ_errPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceSignOrCreationErrorZ Function(
                  LDKSignOrCreationError)>>(
      'CResult_InvoiceSignOrCreationErrorZ_err');
  late final _CResult_InvoiceSignOrCreationErrorZ_err =
      _CResult_InvoiceSignOrCreationErrorZ_errPtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              LDKSignOrCreationError)>();

  /// Checks if the given object is currently in the success state
  bool CResult_InvoiceSignOrCreationErrorZ_is_ok(
    ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ> o,
  ) {
    return _CResult_InvoiceSignOrCreationErrorZ_is_ok(
      o,
    );
  }

  late final _CResult_InvoiceSignOrCreationErrorZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ>)>>(
      'CResult_InvoiceSignOrCreationErrorZ_is_ok');
  late final _CResult_InvoiceSignOrCreationErrorZ_is_ok =
      _CResult_InvoiceSignOrCreationErrorZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ>)>();

  /// Frees any resources used by the CResult_InvoiceSignOrCreationErrorZ.
  void CResult_InvoiceSignOrCreationErrorZ_free(
    LDKCResult_InvoiceSignOrCreationErrorZ _res,
  ) {
    return _CResult_InvoiceSignOrCreationErrorZ_free(
      _res,
    );
  }

  late final _CResult_InvoiceSignOrCreationErrorZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_InvoiceSignOrCreationErrorZ)>>(
      'CResult_InvoiceSignOrCreationErrorZ_free');
  late final _CResult_InvoiceSignOrCreationErrorZ_free =
      _CResult_InvoiceSignOrCreationErrorZ_freePtr.asFunction<
          void Function(LDKCResult_InvoiceSignOrCreationErrorZ)>();

  /// Creates a new CResult_InvoiceSignOrCreationErrorZ which has the same data as `orig`
  /// but with all dynamically-allocated buffers duplicated in new buffers.
  LDKCResult_InvoiceSignOrCreationErrorZ
      CResult_InvoiceSignOrCreationErrorZ_clone(
    ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ> orig,
  ) {
    return _CResult_InvoiceSignOrCreationErrorZ_clone(
      orig,
    );
  }

  late final _CResult_InvoiceSignOrCreationErrorZ_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_InvoiceSignOrCreationErrorZ Function(
                  ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ>)>>(
      'CResult_InvoiceSignOrCreationErrorZ_clone');
  late final _CResult_InvoiceSignOrCreationErrorZ_clone =
      _CResult_InvoiceSignOrCreationErrorZ_clonePtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              ffi.Pointer<LDKCResult_InvoiceSignOrCreationErrorZ>)>();

  /// Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
  LDKCOption_FilterZ COption_FilterZ_some(
    LDKFilter o,
  ) {
    return _COption_FilterZ_some(
      o,
    );
  }

  late final _COption_FilterZ_somePtr =
      _lookup<ffi.NativeFunction<LDKCOption_FilterZ Function(LDKFilter)>>(
          'COption_FilterZ_some');
  late final _COption_FilterZ_some = _COption_FilterZ_somePtr.asFunction<
      LDKCOption_FilterZ Function(LDKFilter)>();

  /// Constructs a new COption_FilterZ containing nothing
  LDKCOption_FilterZ COption_FilterZ_none() {
    return _COption_FilterZ_none();
  }

  late final _COption_FilterZ_nonePtr =
      _lookup<ffi.NativeFunction<LDKCOption_FilterZ Function()>>(
          'COption_FilterZ_none');
  late final _COption_FilterZ_none =
      _COption_FilterZ_nonePtr.asFunction<LDKCOption_FilterZ Function()>();

  /// Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
  void COption_FilterZ_free(
    LDKCOption_FilterZ _res,
  ) {
    return _COption_FilterZ_free(
      _res,
    );
  }

  late final _COption_FilterZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCOption_FilterZ)>>(
          'COption_FilterZ_free');
  late final _COption_FilterZ_free =
      _COption_FilterZ_freePtr.asFunction<void Function(LDKCOption_FilterZ)>();

  /// Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
  LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(
    LDKLockedChannelMonitor o,
  ) {
    return _CResult_LockedChannelMonitorNoneZ_ok(
      o,
    );
  }

  late final _CResult_LockedChannelMonitorNoneZ_okPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_LockedChannelMonitorNoneZ Function(
                  LDKLockedChannelMonitor)>>(
      'CResult_LockedChannelMonitorNoneZ_ok');
  late final _CResult_LockedChannelMonitorNoneZ_ok =
      _CResult_LockedChannelMonitorNoneZ_okPtr.asFunction<
          LDKCResult_LockedChannelMonitorNoneZ Function(
              LDKLockedChannelMonitor)>();

  /// Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
  LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err() {
    return _CResult_LockedChannelMonitorNoneZ_err();
  }

  late final _CResult_LockedChannelMonitorNoneZ_errPtr = _lookup<
          ffi.NativeFunction<LDKCResult_LockedChannelMonitorNoneZ Function()>>(
      'CResult_LockedChannelMonitorNoneZ_err');
  late final _CResult_LockedChannelMonitorNoneZ_err =
      _CResult_LockedChannelMonitorNoneZ_errPtr.asFunction<
          LDKCResult_LockedChannelMonitorNoneZ Function()>();

  /// Checks if the given object is currently in the success state
  bool CResult_LockedChannelMonitorNoneZ_is_ok(
    ffi.Pointer<LDKCResult_LockedChannelMonitorNoneZ> o,
  ) {
    return _CResult_LockedChannelMonitorNoneZ_is_ok(
      o,
    );
  }

  late final _CResult_LockedChannelMonitorNoneZ_is_okPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKCResult_LockedChannelMonitorNoneZ>)>>(
      'CResult_LockedChannelMonitorNoneZ_is_ok');
  late final _CResult_LockedChannelMonitorNoneZ_is_ok =
      _CResult_LockedChannelMonitorNoneZ_is_okPtr.asFunction<
          bool Function(ffi.Pointer<LDKCResult_LockedChannelMonitorNoneZ>)>();

  /// Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
  void CResult_LockedChannelMonitorNoneZ_free(
    LDKCResult_LockedChannelMonitorNoneZ _res,
  ) {
    return _CResult_LockedChannelMonitorNoneZ_free(
      _res,
    );
  }

  late final _CResult_LockedChannelMonitorNoneZ_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCResult_LockedChannelMonitorNoneZ)>>(
      'CResult_LockedChannelMonitorNoneZ_free');
  late final _CResult_LockedChannelMonitorNoneZ_free =
      _CResult_LockedChannelMonitorNoneZ_freePtr.asFunction<
          void Function(LDKCResult_LockedChannelMonitorNoneZ)>();

  /// Frees the buffer pointed to by `data` if `datalen` is non-0.
  void CVec_OutPointZ_free(
    LDKCVec_OutPointZ _res,
  ) {
    return _CVec_OutPointZ_free(
      _res,
    );
  }

  late final _CVec_OutPointZ_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCVec_OutPointZ)>>(
          'CVec_OutPointZ_free');
  late final _CVec_OutPointZ_free =
      _CVec_OutPointZ_freePtr.asFunction<void Function(LDKCVec_OutPointZ)>();

  /// Frees any resources used by the PaymentPurpose
  void PaymentPurpose_free(
    LDKPaymentPurpose this_ptr,
  ) {
    return _PaymentPurpose_free(
      this_ptr,
    );
  }

  late final _PaymentPurpose_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPaymentPurpose)>>(
          'PaymentPurpose_free');
  late final _PaymentPurpose_free =
      _PaymentPurpose_freePtr.asFunction<void Function(LDKPaymentPurpose)>();

  /// Creates a copy of the PaymentPurpose
  LDKPaymentPurpose PaymentPurpose_clone(
    ffi.Pointer<LDKPaymentPurpose> orig,
  ) {
    return _PaymentPurpose_clone(
      orig,
    );
  }

  late final _PaymentPurpose_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentPurpose Function(
              ffi.Pointer<LDKPaymentPurpose>)>>('PaymentPurpose_clone');
  late final _PaymentPurpose_clone = _PaymentPurpose_clonePtr.asFunction<
      LDKPaymentPurpose Function(ffi.Pointer<LDKPaymentPurpose>)>();

  /// Utility method to constructs a new InvoicePayment-variant PaymentPurpose
  LDKPaymentPurpose PaymentPurpose_invoice_payment(
    LDKThirtyTwoBytes payment_preimage,
    LDKThirtyTwoBytes payment_secret,
  ) {
    return _PaymentPurpose_invoice_payment(
      payment_preimage,
      payment_secret,
    );
  }

  late final _PaymentPurpose_invoice_paymentPtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentPurpose Function(LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>>('PaymentPurpose_invoice_payment');
  late final _PaymentPurpose_invoice_payment =
      _PaymentPurpose_invoice_paymentPtr.asFunction<
          LDKPaymentPurpose Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes)>();

  /// Utility method to constructs a new SpontaneousPayment-variant PaymentPurpose
  LDKPaymentPurpose PaymentPurpose_spontaneous_payment(
    LDKThirtyTwoBytes a,
  ) {
    return _PaymentPurpose_spontaneous_payment(
      a,
    );
  }

  late final _PaymentPurpose_spontaneous_paymentPtr = _lookup<
          ffi.NativeFunction<LDKPaymentPurpose Function(LDKThirtyTwoBytes)>>(
      'PaymentPurpose_spontaneous_payment');
  late final _PaymentPurpose_spontaneous_payment =
      _PaymentPurpose_spontaneous_paymentPtr.asFunction<
          LDKPaymentPurpose Function(LDKThirtyTwoBytes)>();

  /// Serialize the PaymentPurpose object into a byte array which can be read by PaymentPurpose_read
  LDKCVec_u8Z PaymentPurpose_write(
    ffi.Pointer<LDKPaymentPurpose> obj,
  ) {
    return _PaymentPurpose_write(
      obj,
    );
  }

  late final _PaymentPurpose_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKPaymentPurpose>)>>('PaymentPurpose_write');
  late final _PaymentPurpose_write = _PaymentPurpose_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKPaymentPurpose>)>();

  /// Read a PaymentPurpose from a byte array, created by PaymentPurpose_write
  LDKCResult_PaymentPurposeDecodeErrorZ PaymentPurpose_read(
    LDKu8slice ser,
  ) {
    return _PaymentPurpose_read(
      ser,
    );
  }

  late final _PaymentPurpose_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPurposeDecodeErrorZ Function(
              LDKu8slice)>>('PaymentPurpose_read');
  late final _PaymentPurpose_read = _PaymentPurpose_readPtr.asFunction<
      LDKCResult_PaymentPurposeDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the ClosureReason
  void ClosureReason_free(
    LDKClosureReason this_ptr,
  ) {
    return _ClosureReason_free(
      this_ptr,
    );
  }

  late final _ClosureReason_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKClosureReason)>>(
          'ClosureReason_free');
  late final _ClosureReason_free =
      _ClosureReason_freePtr.asFunction<void Function(LDKClosureReason)>();

  /// Creates a copy of the ClosureReason
  LDKClosureReason ClosureReason_clone(
    ffi.Pointer<LDKClosureReason> orig,
  ) {
    return _ClosureReason_clone(
      orig,
    );
  }

  late final _ClosureReason_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKClosureReason Function(
              ffi.Pointer<LDKClosureReason>)>>('ClosureReason_clone');
  late final _ClosureReason_clone = _ClosureReason_clonePtr.asFunction<
      LDKClosureReason Function(ffi.Pointer<LDKClosureReason>)>();

  /// Utility method to constructs a new CounterpartyForceClosed-variant ClosureReason
  LDKClosureReason ClosureReason_counterparty_force_closed(
    LDKStr peer_msg,
  ) {
    return _ClosureReason_counterparty_force_closed(
      peer_msg,
    );
  }

  late final _ClosureReason_counterparty_force_closedPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function(LDKStr)>>(
          'ClosureReason_counterparty_force_closed');
  late final _ClosureReason_counterparty_force_closed =
      _ClosureReason_counterparty_force_closedPtr.asFunction<
          LDKClosureReason Function(LDKStr)>();

  /// Utility method to constructs a new HolderForceClosed-variant ClosureReason
  LDKClosureReason ClosureReason_holder_force_closed() {
    return _ClosureReason_holder_force_closed();
  }

  late final _ClosureReason_holder_force_closedPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_holder_force_closed');
  late final _ClosureReason_holder_force_closed =
      _ClosureReason_holder_force_closedPtr.asFunction<
          LDKClosureReason Function()>();

  /// Utility method to constructs a new CooperativeClosure-variant ClosureReason
  LDKClosureReason ClosureReason_cooperative_closure() {
    return _ClosureReason_cooperative_closure();
  }

  late final _ClosureReason_cooperative_closurePtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_cooperative_closure');
  late final _ClosureReason_cooperative_closure =
      _ClosureReason_cooperative_closurePtr.asFunction<
          LDKClosureReason Function()>();

  /// Utility method to constructs a new CommitmentTxConfirmed-variant ClosureReason
  LDKClosureReason ClosureReason_commitment_tx_confirmed() {
    return _ClosureReason_commitment_tx_confirmed();
  }

  late final _ClosureReason_commitment_tx_confirmedPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_commitment_tx_confirmed');
  late final _ClosureReason_commitment_tx_confirmed =
      _ClosureReason_commitment_tx_confirmedPtr.asFunction<
          LDKClosureReason Function()>();

  /// Utility method to constructs a new FundingTimedOut-variant ClosureReason
  LDKClosureReason ClosureReason_funding_timed_out() {
    return _ClosureReason_funding_timed_out();
  }

  late final _ClosureReason_funding_timed_outPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_funding_timed_out');
  late final _ClosureReason_funding_timed_out =
      _ClosureReason_funding_timed_outPtr.asFunction<
          LDKClosureReason Function()>();

  /// Utility method to constructs a new ProcessingError-variant ClosureReason
  LDKClosureReason ClosureReason_processing_error(
    LDKStr err,
  ) {
    return _ClosureReason_processing_error(
      err,
    );
  }

  late final _ClosureReason_processing_errorPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function(LDKStr)>>(
          'ClosureReason_processing_error');
  late final _ClosureReason_processing_error =
      _ClosureReason_processing_errorPtr.asFunction<
          LDKClosureReason Function(LDKStr)>();

  /// Utility method to constructs a new DisconnectedPeer-variant ClosureReason
  LDKClosureReason ClosureReason_disconnected_peer() {
    return _ClosureReason_disconnected_peer();
  }

  late final _ClosureReason_disconnected_peerPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_disconnected_peer');
  late final _ClosureReason_disconnected_peer =
      _ClosureReason_disconnected_peerPtr.asFunction<
          LDKClosureReason Function()>();

  /// Utility method to constructs a new OutdatedChannelManager-variant ClosureReason
  LDKClosureReason ClosureReason_outdated_channel_manager() {
    return _ClosureReason_outdated_channel_manager();
  }

  late final _ClosureReason_outdated_channel_managerPtr =
      _lookup<ffi.NativeFunction<LDKClosureReason Function()>>(
          'ClosureReason_outdated_channel_manager');
  late final _ClosureReason_outdated_channel_manager =
      _ClosureReason_outdated_channel_managerPtr.asFunction<
          LDKClosureReason Function()>();

  /// Serialize the ClosureReason object into a byte array which can be read by ClosureReason_read
  LDKCVec_u8Z ClosureReason_write(
    ffi.Pointer<LDKClosureReason> obj,
  ) {
    return _ClosureReason_write(
      obj,
    );
  }

  late final _ClosureReason_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKClosureReason>)>>('ClosureReason_write');
  late final _ClosureReason_write = _ClosureReason_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKClosureReason>)>();

  /// Read a ClosureReason from a byte array, created by ClosureReason_write
  LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(
    LDKu8slice ser,
  ) {
    return _ClosureReason_read(
      ser,
    );
  }

  late final _ClosureReason_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(
              LDKu8slice)>>('ClosureReason_read');
  late final _ClosureReason_read = _ClosureReason_readPtr.asFunction<
      LDKCResult_COption_ClosureReasonZDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the HTLCDestination
  void HTLCDestination_free(
    LDKHTLCDestination this_ptr,
  ) {
    return _HTLCDestination_free(
      this_ptr,
    );
  }

  late final _HTLCDestination_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKHTLCDestination)>>(
          'HTLCDestination_free');
  late final _HTLCDestination_free =
      _HTLCDestination_freePtr.asFunction<void Function(LDKHTLCDestination)>();

  /// Creates a copy of the HTLCDestination
  LDKHTLCDestination HTLCDestination_clone(
    ffi.Pointer<LDKHTLCDestination> orig,
  ) {
    return _HTLCDestination_clone(
      orig,
    );
  }

  late final _HTLCDestination_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKHTLCDestination Function(
              ffi.Pointer<LDKHTLCDestination>)>>('HTLCDestination_clone');
  late final _HTLCDestination_clone = _HTLCDestination_clonePtr.asFunction<
      LDKHTLCDestination Function(ffi.Pointer<LDKHTLCDestination>)>();

  /// Utility method to constructs a new NextHopChannel-variant HTLCDestination
  LDKHTLCDestination HTLCDestination_next_hop_channel(
    LDKPublicKey node_id,
    LDKThirtyTwoBytes channel_id,
  ) {
    return _HTLCDestination_next_hop_channel(
      node_id,
      channel_id,
    );
  }

  late final _HTLCDestination_next_hop_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKHTLCDestination Function(LDKPublicKey,
              LDKThirtyTwoBytes)>>('HTLCDestination_next_hop_channel');
  late final _HTLCDestination_next_hop_channel =
      _HTLCDestination_next_hop_channelPtr.asFunction<
          LDKHTLCDestination Function(LDKPublicKey, LDKThirtyTwoBytes)>();

  /// Utility method to constructs a new UnknownNextHop-variant HTLCDestination
  LDKHTLCDestination HTLCDestination_unknown_next_hop(
    int requested_forward_scid,
  ) {
    return _HTLCDestination_unknown_next_hop(
      requested_forward_scid,
    );
  }

  late final _HTLCDestination_unknown_next_hopPtr =
      _lookup<ffi.NativeFunction<LDKHTLCDestination Function(ffi.Uint64)>>(
          'HTLCDestination_unknown_next_hop');
  late final _HTLCDestination_unknown_next_hop =
      _HTLCDestination_unknown_next_hopPtr.asFunction<
          LDKHTLCDestination Function(int)>();

  /// Utility method to constructs a new FailedPayment-variant HTLCDestination
  LDKHTLCDestination HTLCDestination_failed_payment(
    LDKThirtyTwoBytes payment_hash,
  ) {
    return _HTLCDestination_failed_payment(
      payment_hash,
    );
  }

  late final _HTLCDestination_failed_paymentPtr = _lookup<
          ffi.NativeFunction<LDKHTLCDestination Function(LDKThirtyTwoBytes)>>(
      'HTLCDestination_failed_payment');
  late final _HTLCDestination_failed_payment =
      _HTLCDestination_failed_paymentPtr.asFunction<
          LDKHTLCDestination Function(LDKThirtyTwoBytes)>();

  /// Serialize the HTLCDestination object into a byte array which can be read by HTLCDestination_read
  LDKCVec_u8Z HTLCDestination_write(
    ffi.Pointer<LDKHTLCDestination> obj,
  ) {
    return _HTLCDestination_write(
      obj,
    );
  }

  late final _HTLCDestination_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKHTLCDestination>)>>('HTLCDestination_write');
  late final _HTLCDestination_write = _HTLCDestination_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCDestination>)>();

  /// Read a HTLCDestination from a byte array, created by HTLCDestination_write
  LDKCResult_COption_HTLCDestinationZDecodeErrorZ HTLCDestination_read(
    LDKu8slice ser,
  ) {
    return _HTLCDestination_read(
      ser,
    );
  }

  late final _HTLCDestination_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(
              LDKu8slice)>>('HTLCDestination_read');
  late final _HTLCDestination_read = _HTLCDestination_readPtr.asFunction<
      LDKCResult_COption_HTLCDestinationZDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the Event
  void Event_free(
    LDKEvent this_ptr,
  ) {
    return _Event_free(
      this_ptr,
    );
  }

  late final _Event_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKEvent)>>('Event_free');
  late final _Event_free = _Event_freePtr.asFunction<void Function(LDKEvent)>();

  /// Creates a copy of the Event
  LDKEvent Event_clone(
    ffi.Pointer<LDKEvent> orig,
  ) {
    return _Event_clone(
      orig,
    );
  }

  late final _Event_clonePtr =
      _lookup<ffi.NativeFunction<LDKEvent Function(ffi.Pointer<LDKEvent>)>>(
          'Event_clone');
  late final _Event_clone =
      _Event_clonePtr.asFunction<LDKEvent Function(ffi.Pointer<LDKEvent>)>();

  /// Utility method to constructs a new FundingGenerationReady-variant Event
  LDKEvent Event_funding_generation_ready(
    LDKThirtyTwoBytes temporary_channel_id,
    LDKPublicKey counterparty_node_id,
    int channel_value_satoshis,
    LDKCVec_u8Z output_script,
    int user_channel_id,
  ) {
    return _Event_funding_generation_ready(
      temporary_channel_id,
      counterparty_node_id,
      channel_value_satoshis,
      output_script,
      user_channel_id,
    );
  }

  late final _Event_funding_generation_readyPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKPublicKey, ffi.Uint64,
              LDKCVec_u8Z, ffi.Uint64)>>('Event_funding_generation_ready');
  late final _Event_funding_generation_ready =
      _Event_funding_generation_readyPtr.asFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes, LDKPublicKey, int, LDKCVec_u8Z, int)>();

  /// Utility method to constructs a new PaymentReceived-variant Event
  LDKEvent Event_payment_received(
    LDKThirtyTwoBytes payment_hash,
    int amount_msat,
    LDKPaymentPurpose purpose,
  ) {
    return _Event_payment_received(
      payment_hash,
      amount_msat,
      purpose,
    );
  }

  late final _Event_payment_receivedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, ffi.Uint64,
              LDKPaymentPurpose)>>('Event_payment_received');
  late final _Event_payment_received = _Event_payment_receivedPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, int, LDKPaymentPurpose)>();

  /// Utility method to constructs a new PaymentClaimed-variant Event
  LDKEvent Event_payment_claimed(
    LDKThirtyTwoBytes payment_hash,
    int amount_msat,
    LDKPaymentPurpose purpose,
  ) {
    return _Event_payment_claimed(
      payment_hash,
      amount_msat,
      purpose,
    );
  }

  late final _Event_payment_claimedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, ffi.Uint64,
              LDKPaymentPurpose)>>('Event_payment_claimed');
  late final _Event_payment_claimed = _Event_payment_claimedPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, int, LDKPaymentPurpose)>();

  /// Utility method to constructs a new PaymentSent-variant Event
  LDKEvent Event_payment_sent(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_preimage,
    LDKThirtyTwoBytes payment_hash,
    LDKCOption_u64Z fee_paid_msat,
  ) {
    return _Event_payment_sent(
      payment_id,
      payment_preimage,
      payment_hash,
      fee_paid_msat,
    );
  }

  late final _Event_payment_sentPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKThirtyTwoBytes, LDKCOption_u64Z)>>('Event_payment_sent');
  late final _Event_payment_sent = _Event_payment_sentPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKThirtyTwoBytes,
          LDKCOption_u64Z)>();

  /// Utility method to constructs a new PaymentFailed-variant Event
  LDKEvent Event_payment_failed(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_hash,
  ) {
    return _Event_payment_failed(
      payment_id,
      payment_hash,
    );
  }

  late final _Event_payment_failedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes, LDKThirtyTwoBytes)>>('Event_payment_failed');
  late final _Event_payment_failed = _Event_payment_failedPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes)>();

  /// Utility method to constructs a new PaymentPathSuccessful-variant Event
  LDKEvent Event_payment_path_successful(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_hash,
    LDKCVec_RouteHopZ path,
  ) {
    return _Event_payment_path_successful(
      payment_id,
      payment_hash,
      path,
    );
  }

  late final _Event_payment_path_successfulPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKCVec_RouteHopZ)>>('Event_payment_path_successful');
  late final _Event_payment_path_successful =
      _Event_payment_path_successfulPtr.asFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKCVec_RouteHopZ)>();

  /// Utility method to constructs a new PaymentPathFailed-variant Event
  LDKEvent Event_payment_path_failed(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_hash,
    bool rejected_by_dest,
    LDKCOption_NetworkUpdateZ network_update,
    bool all_paths_failed,
    LDKCVec_RouteHopZ path,
    LDKCOption_u64Z short_channel_id,
    LDKRouteParameters retry,
  ) {
    return _Event_payment_path_failed(
      payment_id,
      payment_hash,
      rejected_by_dest,
      network_update,
      all_paths_failed,
      path,
      short_channel_id,
      retry,
    );
  }

  late final _Event_payment_path_failedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes,
              ffi.Bool,
              LDKCOption_NetworkUpdateZ,
              ffi.Bool,
              LDKCVec_RouteHopZ,
              LDKCOption_u64Z,
              LDKRouteParameters)>>('Event_payment_path_failed');
  late final _Event_payment_path_failed =
      _Event_payment_path_failedPtr.asFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes,
              bool,
              LDKCOption_NetworkUpdateZ,
              bool,
              LDKCVec_RouteHopZ,
              LDKCOption_u64Z,
              LDKRouteParameters)>();

  /// Utility method to constructs a new ProbeSuccessful-variant Event
  LDKEvent Event_probe_successful(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_hash,
    LDKCVec_RouteHopZ path,
  ) {
    return _Event_probe_successful(
      payment_id,
      payment_hash,
      path,
    );
  }

  late final _Event_probe_successfulPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKCVec_RouteHopZ)>>('Event_probe_successful');
  late final _Event_probe_successful = _Event_probe_successfulPtr.asFunction<
      LDKEvent Function(
          LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKCVec_RouteHopZ)>();

  /// Utility method to constructs a new ProbeFailed-variant Event
  LDKEvent Event_probe_failed(
    LDKThirtyTwoBytes payment_id,
    LDKThirtyTwoBytes payment_hash,
    LDKCVec_RouteHopZ path,
    LDKCOption_u64Z short_channel_id,
  ) {
    return _Event_probe_failed(
      payment_id,
      payment_hash,
      path,
      short_channel_id,
    );
  }

  late final _Event_probe_failedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKCVec_RouteHopZ, LDKCOption_u64Z)>>('Event_probe_failed');
  late final _Event_probe_failed = _Event_probe_failedPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKCVec_RouteHopZ,
          LDKCOption_u64Z)>();

  /// Utility method to constructs a new PendingHTLCsForwardable-variant Event
  LDKEvent Event_pending_htlcs_forwardable(
    int time_forwardable,
  ) {
    return _Event_pending_htlcs_forwardable(
      time_forwardable,
    );
  }

  late final _Event_pending_htlcs_forwardablePtr =
      _lookup<ffi.NativeFunction<LDKEvent Function(ffi.Uint64)>>(
          'Event_pending_htlcs_forwardable');
  late final _Event_pending_htlcs_forwardable =
      _Event_pending_htlcs_forwardablePtr.asFunction<LDKEvent Function(int)>();

  /// Utility method to constructs a new SpendableOutputs-variant Event
  LDKEvent Event_spendable_outputs(
    LDKCVec_SpendableOutputDescriptorZ outputs,
  ) {
    return _Event_spendable_outputs(
      outputs,
    );
  }

  late final _Event_spendable_outputsPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(
              LDKCVec_SpendableOutputDescriptorZ)>>('Event_spendable_outputs');
  late final _Event_spendable_outputs = _Event_spendable_outputsPtr.asFunction<
      LDKEvent Function(LDKCVec_SpendableOutputDescriptorZ)>();

  /// Utility method to constructs a new PaymentForwarded-variant Event
  LDKEvent Event_payment_forwarded(
    LDKThirtyTwoBytes prev_channel_id,
    LDKThirtyTwoBytes next_channel_id,
    LDKCOption_u64Z fee_earned_msat,
    bool claim_from_onchain_tx,
  ) {
    return _Event_payment_forwarded(
      prev_channel_id,
      next_channel_id,
      fee_earned_msat,
      claim_from_onchain_tx,
    );
  }

  late final _Event_payment_forwardedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKCOption_u64Z, ffi.Bool)>>('Event_payment_forwarded');
  late final _Event_payment_forwarded = _Event_payment_forwardedPtr.asFunction<
      LDKEvent Function(
          LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKCOption_u64Z, bool)>();

  /// Utility method to constructs a new ChannelClosed-variant Event
  LDKEvent Event_channel_closed(
    LDKThirtyTwoBytes channel_id,
    int user_channel_id,
    LDKClosureReason reason,
  ) {
    return _Event_channel_closed(
      channel_id,
      user_channel_id,
      reason,
    );
  }

  late final _Event_channel_closedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes, ffi.Uint64,
              LDKClosureReason)>>('Event_channel_closed');
  late final _Event_channel_closed = _Event_channel_closedPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, int, LDKClosureReason)>();

  /// Utility method to constructs a new DiscardFunding-variant Event
  LDKEvent Event_discard_funding(
    LDKThirtyTwoBytes channel_id,
    LDKTransaction transaction,
  ) {
    return _Event_discard_funding(
      channel_id,
      transaction,
    );
  }

  late final _Event_discard_fundingPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes, LDKTransaction)>>('Event_discard_funding');
  late final _Event_discard_funding = _Event_discard_fundingPtr.asFunction<
      LDKEvent Function(LDKThirtyTwoBytes, LDKTransaction)>();

  /// Utility method to constructs a new OpenChannelRequest-variant Event
  LDKEvent Event_open_channel_request(
    LDKThirtyTwoBytes temporary_channel_id,
    LDKPublicKey counterparty_node_id,
    int funding_satoshis,
    int push_msat,
    LDKChannelTypeFeatures channel_type,
  ) {
    return _Event_open_channel_request(
      temporary_channel_id,
      counterparty_node_id,
      funding_satoshis,
      push_msat,
      channel_type,
    );
  }

  late final _Event_open_channel_requestPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(
              LDKThirtyTwoBytes,
              LDKPublicKey,
              ffi.Uint64,
              ffi.Uint64,
              LDKChannelTypeFeatures)>>('Event_open_channel_request');
  late final _Event_open_channel_request =
      _Event_open_channel_requestPtr.asFunction<
          LDKEvent Function(LDKThirtyTwoBytes, LDKPublicKey, int, int,
              LDKChannelTypeFeatures)>();

  /// Utility method to constructs a new HTLCHandlingFailed-variant Event
  LDKEvent Event_htlchandling_failed(
    LDKThirtyTwoBytes prev_channel_id,
    LDKHTLCDestination failed_next_destination,
  ) {
    return _Event_htlchandling_failed(
      prev_channel_id,
      failed_next_destination,
    );
  }

  late final _Event_htlchandling_failedPtr = _lookup<
      ffi.NativeFunction<
          LDKEvent Function(LDKThirtyTwoBytes,
              LDKHTLCDestination)>>('Event_htlchandling_failed');
  late final _Event_htlchandling_failed = _Event_htlchandling_failedPtr
      .asFunction<LDKEvent Function(LDKThirtyTwoBytes, LDKHTLCDestination)>();

  /// Serialize the Event object into a byte array which can be read by Event_read
  LDKCVec_u8Z Event_write(
    ffi.Pointer<LDKEvent> obj,
  ) {
    return _Event_write(
      obj,
    );
  }

  late final _Event_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKEvent>)>>(
          'Event_write');
  late final _Event_write =
      _Event_writePtr.asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKEvent>)>();

  /// Read a Event from a byte array, created by Event_write
  LDKCResult_COption_EventZDecodeErrorZ Event_read(
    LDKu8slice ser,
  ) {
    return _Event_read(
      ser,
    );
  }

  late final _Event_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_EventZDecodeErrorZ Function(
              LDKu8slice)>>('Event_read');
  late final _Event_read = _Event_readPtr.asFunction<
      LDKCResult_COption_EventZDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the MessageSendEvent
  void MessageSendEvent_free(
    LDKMessageSendEvent this_ptr,
  ) {
    return _MessageSendEvent_free(
      this_ptr,
    );
  }

  late final _MessageSendEvent_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKMessageSendEvent)>>(
          'MessageSendEvent_free');
  late final _MessageSendEvent_free = _MessageSendEvent_freePtr.asFunction<
      void Function(LDKMessageSendEvent)>();

  /// Creates a copy of the MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_clone(
    ffi.Pointer<LDKMessageSendEvent> orig,
  ) {
    return _MessageSendEvent_clone(
      orig,
    );
  }

  late final _MessageSendEvent_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(
              ffi.Pointer<LDKMessageSendEvent>)>>('MessageSendEvent_clone');
  late final _MessageSendEvent_clone = _MessageSendEvent_clonePtr.asFunction<
      LDKMessageSendEvent Function(ffi.Pointer<LDKMessageSendEvent>)>();

  /// Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_accept_channel(
    LDKPublicKey node_id,
    LDKAcceptChannel msg,
  ) {
    return _MessageSendEvent_send_accept_channel(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_accept_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKAcceptChannel)>>('MessageSendEvent_send_accept_channel');
  late final _MessageSendEvent_send_accept_channel =
      _MessageSendEvent_send_accept_channelPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKAcceptChannel)>();

  /// Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_open_channel(
    LDKPublicKey node_id,
    LDKOpenChannel msg,
  ) {
    return _MessageSendEvent_send_open_channel(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_open_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKOpenChannel)>>('MessageSendEvent_send_open_channel');
  late final _MessageSendEvent_send_open_channel =
      _MessageSendEvent_send_open_channelPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKOpenChannel)>();

  /// Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_funding_created(
    LDKPublicKey node_id,
    LDKFundingCreated msg,
  ) {
    return _MessageSendEvent_send_funding_created(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_funding_createdPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKFundingCreated)>>('MessageSendEvent_send_funding_created');
  late final _MessageSendEvent_send_funding_created =
      _MessageSendEvent_send_funding_createdPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKFundingCreated)>();

  /// Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_funding_signed(
    LDKPublicKey node_id,
    LDKFundingSigned msg,
  ) {
    return _MessageSendEvent_send_funding_signed(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_funding_signedPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKFundingSigned)>>('MessageSendEvent_send_funding_signed');
  late final _MessageSendEvent_send_funding_signed =
      _MessageSendEvent_send_funding_signedPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKFundingSigned)>();

  /// Utility method to constructs a new SendChannelReady-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_channel_ready(
    LDKPublicKey node_id,
    LDKChannelReady msg,
  ) {
    return _MessageSendEvent_send_channel_ready(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_channel_readyPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKChannelReady)>>('MessageSendEvent_send_channel_ready');
  late final _MessageSendEvent_send_channel_ready =
      _MessageSendEvent_send_channel_readyPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKChannelReady)>();

  /// Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(
    LDKPublicKey node_id,
    LDKAnnouncementSignatures msg,
  ) {
    return _MessageSendEvent_send_announcement_signatures(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_announcement_signaturesPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKAnnouncementSignatures)>>(
      'MessageSendEvent_send_announcement_signatures');
  late final _MessageSendEvent_send_announcement_signatures =
      _MessageSendEvent_send_announcement_signaturesPtr.asFunction<
          LDKMessageSendEvent Function(
              LDKPublicKey, LDKAnnouncementSignatures)>();

  /// Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_update_htlcs(
    LDKPublicKey node_id,
    LDKCommitmentUpdate updates,
  ) {
    return _MessageSendEvent_update_htlcs(
      node_id,
      updates,
    );
  }

  late final _MessageSendEvent_update_htlcsPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKCommitmentUpdate)>>('MessageSendEvent_update_htlcs');
  late final _MessageSendEvent_update_htlcs =
      _MessageSendEvent_update_htlcsPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKCommitmentUpdate)>();

  /// Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(
    LDKPublicKey node_id,
    LDKRevokeAndACK msg,
  ) {
    return _MessageSendEvent_send_revoke_and_ack(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_revoke_and_ackPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKRevokeAndACK)>>('MessageSendEvent_send_revoke_and_ack');
  late final _MessageSendEvent_send_revoke_and_ack =
      _MessageSendEvent_send_revoke_and_ackPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKRevokeAndACK)>();

  /// Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_closing_signed(
    LDKPublicKey node_id,
    LDKClosingSigned msg,
  ) {
    return _MessageSendEvent_send_closing_signed(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_closing_signedPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKClosingSigned)>>('MessageSendEvent_send_closing_signed');
  late final _MessageSendEvent_send_closing_signed =
      _MessageSendEvent_send_closing_signedPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKClosingSigned)>();

  /// Utility method to constructs a new SendShutdown-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_shutdown(
    LDKPublicKey node_id,
    LDKShutdown msg,
  ) {
    return _MessageSendEvent_send_shutdown(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_shutdownPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(
              LDKPublicKey, LDKShutdown)>>('MessageSendEvent_send_shutdown');
  late final _MessageSendEvent_send_shutdown =
      _MessageSendEvent_send_shutdownPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKShutdown)>();

  /// Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(
    LDKPublicKey node_id,
    LDKChannelReestablish msg,
  ) {
    return _MessageSendEvent_send_channel_reestablish(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_channel_reestablishPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKChannelReestablish)>>(
      'MessageSendEvent_send_channel_reestablish');
  late final _MessageSendEvent_send_channel_reestablish =
      _MessageSendEvent_send_channel_reestablishPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKChannelReestablish)>();

  /// Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(
    LDKChannelAnnouncement msg,
    LDKChannelUpdate update_msg,
  ) {
    return _MessageSendEvent_broadcast_channel_announcement(
      msg,
      update_msg,
    );
  }

  late final _MessageSendEvent_broadcast_channel_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKChannelAnnouncement, LDKChannelUpdate)>>(
      'MessageSendEvent_broadcast_channel_announcement');
  late final _MessageSendEvent_broadcast_channel_announcement =
      _MessageSendEvent_broadcast_channel_announcementPtr.asFunction<
          LDKMessageSendEvent Function(
              LDKChannelAnnouncement, LDKChannelUpdate)>();

  /// Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(
    LDKNodeAnnouncement msg,
  ) {
    return _MessageSendEvent_broadcast_node_announcement(
      msg,
    );
  }

  late final _MessageSendEvent_broadcast_node_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(LDKNodeAnnouncement)>>(
      'MessageSendEvent_broadcast_node_announcement');
  late final _MessageSendEvent_broadcast_node_announcement =
      _MessageSendEvent_broadcast_node_announcementPtr.asFunction<
          LDKMessageSendEvent Function(LDKNodeAnnouncement)>();

  /// Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(
    LDKChannelUpdate msg,
  ) {
    return _MessageSendEvent_broadcast_channel_update(
      msg,
    );
  }

  late final _MessageSendEvent_broadcast_channel_updatePtr = _lookup<
          ffi.NativeFunction<LDKMessageSendEvent Function(LDKChannelUpdate)>>(
      'MessageSendEvent_broadcast_channel_update');
  late final _MessageSendEvent_broadcast_channel_update =
      _MessageSendEvent_broadcast_channel_updatePtr.asFunction<
          LDKMessageSendEvent Function(LDKChannelUpdate)>();

  /// Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_channel_update(
    LDKPublicKey node_id,
    LDKChannelUpdate msg,
  ) {
    return _MessageSendEvent_send_channel_update(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_channel_updatePtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(LDKPublicKey,
              LDKChannelUpdate)>>('MessageSendEvent_send_channel_update');
  late final _MessageSendEvent_send_channel_update =
      _MessageSendEvent_send_channel_updatePtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKChannelUpdate)>();

  /// Utility method to constructs a new HandleError-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_handle_error(
    LDKPublicKey node_id,
    LDKErrorAction action,
  ) {
    return _MessageSendEvent_handle_error(
      node_id,
      action,
    );
  }

  late final _MessageSendEvent_handle_errorPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageSendEvent Function(
              LDKPublicKey, LDKErrorAction)>>('MessageSendEvent_handle_error');
  late final _MessageSendEvent_handle_error = _MessageSendEvent_handle_errorPtr
      .asFunction<LDKMessageSendEvent Function(LDKPublicKey, LDKErrorAction)>();

  /// Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_channel_range_query(
    LDKPublicKey node_id,
    LDKQueryChannelRange msg,
  ) {
    return _MessageSendEvent_send_channel_range_query(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_channel_range_queryPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKQueryChannelRange)>>(
      'MessageSendEvent_send_channel_range_query');
  late final _MessageSendEvent_send_channel_range_query =
      _MessageSendEvent_send_channel_range_queryPtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKQueryChannelRange)>();

  /// Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_short_ids_query(
    LDKPublicKey node_id,
    LDKQueryShortChannelIds msg,
  ) {
    return _MessageSendEvent_send_short_ids_query(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_short_ids_queryPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKQueryShortChannelIds)>>(
      'MessageSendEvent_send_short_ids_query');
  late final _MessageSendEvent_send_short_ids_query =
      _MessageSendEvent_send_short_ids_queryPtr.asFunction<
          LDKMessageSendEvent Function(
              LDKPublicKey, LDKQueryShortChannelIds)>();

  /// Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(
    LDKPublicKey node_id,
    LDKReplyChannelRange msg,
  ) {
    return _MessageSendEvent_send_reply_channel_range(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_reply_channel_rangePtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKReplyChannelRange)>>(
      'MessageSendEvent_send_reply_channel_range');
  late final _MessageSendEvent_send_reply_channel_range =
      _MessageSendEvent_send_reply_channel_rangePtr.asFunction<
          LDKMessageSendEvent Function(LDKPublicKey, LDKReplyChannelRange)>();

  /// Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
  LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(
    LDKPublicKey node_id,
    LDKGossipTimestampFilter msg,
  ) {
    return _MessageSendEvent_send_gossip_timestamp_filter(
      node_id,
      msg,
    );
  }

  late final _MessageSendEvent_send_gossip_timestamp_filterPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEvent Function(
                  LDKPublicKey, LDKGossipTimestampFilter)>>(
      'MessageSendEvent_send_gossip_timestamp_filter');
  late final _MessageSendEvent_send_gossip_timestamp_filter =
      _MessageSendEvent_send_gossip_timestamp_filterPtr.asFunction<
          LDKMessageSendEvent Function(
              LDKPublicKey, LDKGossipTimestampFilter)>();

  /// Calls the free function if one is set
  void MessageSendEventsProvider_free(
    LDKMessageSendEventsProvider this_ptr,
  ) {
    return _MessageSendEventsProvider_free(
      this_ptr,
    );
  }

  late final _MessageSendEventsProvider_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKMessageSendEventsProvider)>>(
      'MessageSendEventsProvider_free');
  late final _MessageSendEventsProvider_free =
      _MessageSendEventsProvider_freePtr.asFunction<
          void Function(LDKMessageSendEventsProvider)>();

  /// Calls the free function if one is set
  void EventsProvider_free(
    LDKEventsProvider this_ptr,
  ) {
    return _EventsProvider_free(
      this_ptr,
    );
  }

  late final _EventsProvider_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKEventsProvider)>>(
          'EventsProvider_free');
  late final _EventsProvider_free =
      _EventsProvider_freePtr.asFunction<void Function(LDKEventsProvider)>();

  /// Calls the free function if one is set
  void EventHandler_free(
    LDKEventHandler this_ptr,
  ) {
    return _EventHandler_free(
      this_ptr,
    );
  }

  late final _EventHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKEventHandler)>>(
          'EventHandler_free');
  late final _EventHandler_free =
      _EventHandler_freePtr.asFunction<void Function(LDKEventHandler)>();

  /// Frees any resources used by the APIError
  void APIError_free(
    LDKAPIError this_ptr,
  ) {
    return _APIError_free(
      this_ptr,
    );
  }

  late final _APIError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKAPIError)>>(
          'APIError_free');
  late final _APIError_free =
      _APIError_freePtr.asFunction<void Function(LDKAPIError)>();

  /// Creates a copy of the APIError
  LDKAPIError APIError_clone(
    ffi.Pointer<LDKAPIError> orig,
  ) {
    return _APIError_clone(
      orig,
    );
  }

  late final _APIError_clonePtr = _lookup<
          ffi.NativeFunction<LDKAPIError Function(ffi.Pointer<LDKAPIError>)>>(
      'APIError_clone');
  late final _APIError_clone = _APIError_clonePtr.asFunction<
      LDKAPIError Function(ffi.Pointer<LDKAPIError>)>();

  /// Utility method to constructs a new APIMisuseError-variant APIError
  LDKAPIError APIError_apimisuse_error(
    LDKStr err,
  ) {
    return _APIError_apimisuse_error(
      err,
    );
  }

  late final _APIError_apimisuse_errorPtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function(LDKStr)>>(
          'APIError_apimisuse_error');
  late final _APIError_apimisuse_error =
      _APIError_apimisuse_errorPtr.asFunction<LDKAPIError Function(LDKStr)>();

  /// Utility method to constructs a new FeeRateTooHigh-variant APIError
  LDKAPIError APIError_fee_rate_too_high(
    LDKStr err,
    int feerate,
  ) {
    return _APIError_fee_rate_too_high(
      err,
      feerate,
    );
  }

  late final _APIError_fee_rate_too_highPtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function(LDKStr, ffi.Uint32)>>(
          'APIError_fee_rate_too_high');
  late final _APIError_fee_rate_too_high = _APIError_fee_rate_too_highPtr
      .asFunction<LDKAPIError Function(LDKStr, int)>();

  /// Utility method to constructs a new RouteError-variant APIError
  LDKAPIError APIError_route_error(
    LDKStr err,
  ) {
    return _APIError_route_error(
      err,
    );
  }

  late final _APIError_route_errorPtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function(LDKStr)>>(
          'APIError_route_error');
  late final _APIError_route_error =
      _APIError_route_errorPtr.asFunction<LDKAPIError Function(LDKStr)>();

  /// Utility method to constructs a new ChannelUnavailable-variant APIError
  LDKAPIError APIError_channel_unavailable(
    LDKStr err,
  ) {
    return _APIError_channel_unavailable(
      err,
    );
  }

  late final _APIError_channel_unavailablePtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function(LDKStr)>>(
          'APIError_channel_unavailable');
  late final _APIError_channel_unavailable = _APIError_channel_unavailablePtr
      .asFunction<LDKAPIError Function(LDKStr)>();

  /// Utility method to constructs a new MonitorUpdateFailed-variant APIError
  LDKAPIError APIError_monitor_update_failed() {
    return _APIError_monitor_update_failed();
  }

  late final _APIError_monitor_update_failedPtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function()>>(
          'APIError_monitor_update_failed');
  late final _APIError_monitor_update_failed =
      _APIError_monitor_update_failedPtr.asFunction<LDKAPIError Function()>();

  /// Utility method to constructs a new IncompatibleShutdownScript-variant APIError
  LDKAPIError APIError_incompatible_shutdown_script(
    LDKShutdownScript script,
  ) {
    return _APIError_incompatible_shutdown_script(
      script,
    );
  }

  late final _APIError_incompatible_shutdown_scriptPtr =
      _lookup<ffi.NativeFunction<LDKAPIError Function(LDKShutdownScript)>>(
          'APIError_incompatible_shutdown_script');
  late final _APIError_incompatible_shutdown_script =
      _APIError_incompatible_shutdown_scriptPtr.asFunction<
          LDKAPIError Function(LDKShutdownScript)>();

  /// Frees any resources used by the BigSize, if is_owned is set and inner is non-NULL.
  void BigSize_free(
    LDKBigSize this_obj,
  ) {
    return _BigSize_free(
      this_obj,
    );
  }

  late final _BigSize_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBigSize)>>(
          'BigSize_free');
  late final _BigSize_free =
      _BigSize_freePtr.asFunction<void Function(LDKBigSize)>();

  int BigSize_get_a(
    ffi.Pointer<LDKBigSize> this_ptr,
  ) {
    return _BigSize_get_a(
      this_ptr,
    );
  }

  late final _BigSize_get_aPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKBigSize>)>>(
          'BigSize_get_a');
  late final _BigSize_get_a =
      _BigSize_get_aPtr.asFunction<int Function(ffi.Pointer<LDKBigSize>)>();

  void BigSize_set_a(
    ffi.Pointer<LDKBigSize> this_ptr,
    int val,
  ) {
    return _BigSize_set_a(
      this_ptr,
      val,
    );
  }

  late final _BigSize_set_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKBigSize>, ffi.Uint64)>>('BigSize_set_a');
  late final _BigSize_set_a = _BigSize_set_aPtr.asFunction<
      void Function(ffi.Pointer<LDKBigSize>, int)>();

  /// Constructs a new BigSize given each field
  LDKBigSize BigSize_new(
    int a_arg,
  ) {
    return _BigSize_new(
      a_arg,
    );
  }

  late final _BigSize_newPtr =
      _lookup<ffi.NativeFunction<LDKBigSize Function(ffi.Uint64)>>(
          'BigSize_new');
  late final _BigSize_new =
      _BigSize_newPtr.asFunction<LDKBigSize Function(int)>();

  /// Frees any resources used by the Hostname, if is_owned is set and inner is non-NULL.
  void Hostname_free(
    LDKHostname this_obj,
  ) {
    return _Hostname_free(
      this_obj,
    );
  }

  late final _Hostname_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKHostname)>>(
          'Hostname_free');
  late final _Hostname_free =
      _Hostname_freePtr.asFunction<void Function(LDKHostname)>();

  /// Creates a copy of the Hostname
  LDKHostname Hostname_clone(
    ffi.Pointer<LDKHostname> orig,
  ) {
    return _Hostname_clone(
      orig,
    );
  }

  late final _Hostname_clonePtr = _lookup<
          ffi.NativeFunction<LDKHostname Function(ffi.Pointer<LDKHostname>)>>(
      'Hostname_clone');
  late final _Hostname_clone = _Hostname_clonePtr.asFunction<
      LDKHostname Function(ffi.Pointer<LDKHostname>)>();

  /// Returns the length of the hostname.
  int Hostname_len(
    ffi.Pointer<LDKHostname> this_arg,
  ) {
    return _Hostname_len(
      this_arg,
    );
  }

  late final _Hostname_lenPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<LDKHostname>)>>(
          'Hostname_len');
  late final _Hostname_len =
      _Hostname_lenPtr.asFunction<int Function(ffi.Pointer<LDKHostname>)>();

  /// Creates a digital signature of a message given a SecretKey, like the node's secret.
  /// A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
  /// Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
  LDKCResult_StringErrorZ sign(
    LDKu8slice msg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> sk,
  ) {
    return _sign(
      msg,
      sk,
    );
  }

  late final _signPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_StringErrorZ Function(
              LDKu8slice, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('sign');
  late final _sign = _signPtr.asFunction<
      LDKCResult_StringErrorZ Function(
          LDKu8slice, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Recovers the PublicKey of the signer of the message given the message and the signature.
  LDKCResult_PublicKeyErrorZ recover_pk(
    LDKu8slice msg,
    LDKStr sig,
  ) {
    return _recover_pk(
      msg,
      sig,
    );
  }

  late final _recover_pkPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PublicKeyErrorZ Function(
              LDKu8slice, LDKStr)>>('recover_pk');
  late final _recover_pk = _recover_pkPtr
      .asFunction<LDKCResult_PublicKeyErrorZ Function(LDKu8slice, LDKStr)>();

  /// Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
  /// and the PublicKey.
  bool verify(
    LDKu8slice msg,
    LDKStr sig,
    LDKPublicKey pk,
  ) {
    return _verify(
      msg,
      sig,
      pk,
    );
  }

  late final _verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(LDKu8slice, LDKStr, LDKPublicKey)>>('verify');
  late final _verify =
      _verifyPtr.asFunction<bool Function(LDKu8slice, LDKStr, LDKPublicKey)>();

  /// Construct the invoice's HRP and signatureless data into a preimage to be hashed.
  LDKCVec_u8Z construct_invoice_preimage(
    LDKu8slice hrp_bytes,
    LDKCVec_u5Z data_without_signature,
  ) {
    return _construct_invoice_preimage(
      hrp_bytes,
      data_without_signature,
    );
  }

  late final _construct_invoice_preimagePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(LDKu8slice, LDKCVec_u5Z)>>(
      'construct_invoice_preimage');
  late final _construct_invoice_preimage = _construct_invoice_preimagePtr
      .asFunction<LDKCVec_u8Z Function(LDKu8slice, LDKCVec_u5Z)>();

  /// Calls the free function if one is set
  void Persister_free(
    LDKPersister this_ptr,
  ) {
    return _Persister_free(
      this_ptr,
    );
  }

  late final _Persister_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPersister)>>(
          'Persister_free');
  late final _Persister_free =
      _Persister_freePtr.asFunction<void Function(LDKPersister)>();

  /// Creates a copy of the Level
  int Level_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _Level_clone(
      orig,
    );
  }

  late final _Level_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'Level_clone');
  late final _Level_clone =
      _Level_clonePtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new Gossip-variant Level
  int Level_gossip() {
    return _Level_gossip();
  }

  late final _Level_gossipPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_gossip');
  late final _Level_gossip = _Level_gossipPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Trace-variant Level
  int Level_trace() {
    return _Level_trace();
  }

  late final _Level_tracePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_trace');
  late final _Level_trace = _Level_tracePtr.asFunction<int Function()>();

  /// Utility method to constructs a new Debug-variant Level
  int Level_debug() {
    return _Level_debug();
  }

  late final _Level_debugPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_debug');
  late final _Level_debug = _Level_debugPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Info-variant Level
  int Level_info() {
    return _Level_info();
  }

  late final _Level_infoPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_info');
  late final _Level_info = _Level_infoPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Warn-variant Level
  int Level_warn() {
    return _Level_warn();
  }

  late final _Level_warnPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_warn');
  late final _Level_warn = _Level_warnPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Error-variant Level
  int Level_error() {
    return _Level_error();
  }

  late final _Level_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_error');
  late final _Level_error = _Level_errorPtr.asFunction<int Function()>();

  /// Checks if two Levels contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool Level_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _Level_eq(
      a,
      b,
    );
  }

  late final _Level_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>>('Level_eq');
  late final _Level_eq = _Level_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Checks if two Levels contain equal inner contents.
  int Level_hash(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _Level_hash(
      o,
    );
  }

  late final _Level_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<ffi.Int32>)>>(
          'Level_hash');
  late final _Level_hash =
      _Level_hashPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Returns the most verbose logging level.
  int Level_max() {
    return _Level_max();
  }

  late final _Level_maxPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Level_max');
  late final _Level_max = _Level_maxPtr.asFunction<int Function()>();

  /// Frees any resources used by the Record, if is_owned is set and inner is non-NULL.
  void Record_free(
    LDKRecord this_obj,
  ) {
    return _Record_free(
      this_obj,
    );
  }

  late final _Record_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRecord)>>('Record_free');
  late final _Record_free =
      _Record_freePtr.asFunction<void Function(LDKRecord)>();

  /// The verbosity level of the message.
  int Record_get_level(
    ffi.Pointer<LDKRecord> this_ptr,
  ) {
    return _Record_get_level(
      this_ptr,
    );
  }

  late final _Record_get_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<LDKRecord>)>>(
          'Record_get_level');
  late final _Record_get_level =
      _Record_get_levelPtr.asFunction<int Function(ffi.Pointer<LDKRecord>)>();

  /// The verbosity level of the message.
  void Record_set_level(
    ffi.Pointer<LDKRecord> this_ptr,
    int val,
  ) {
    return _Record_set_level(
      this_ptr,
      val,
    );
  }

  late final _Record_set_levelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRecord>, ffi.Int32)>>('Record_set_level');
  late final _Record_set_level = _Record_set_levelPtr.asFunction<
      void Function(ffi.Pointer<LDKRecord>, int)>();

  /// The message body.
  LDKStr Record_get_args(
    ffi.Pointer<LDKRecord> this_ptr,
  ) {
    return _Record_get_args(
      this_ptr,
    );
  }

  late final _Record_get_argsPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKRecord>)>>(
          'Record_get_args');
  late final _Record_get_args =
      _Record_get_argsPtr.asFunction<LDKStr Function(ffi.Pointer<LDKRecord>)>();

  /// The message body.
  void Record_set_args(
    ffi.Pointer<LDKRecord> this_ptr,
    LDKStr val,
  ) {
    return _Record_set_args(
      this_ptr,
      val,
    );
  }

  late final _Record_set_argsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRecord>, LDKStr)>>('Record_set_args');
  late final _Record_set_args = _Record_set_argsPtr.asFunction<
      void Function(ffi.Pointer<LDKRecord>, LDKStr)>();

  /// The module path of the message.
  LDKStr Record_get_module_path(
    ffi.Pointer<LDKRecord> this_ptr,
  ) {
    return _Record_get_module_path(
      this_ptr,
    );
  }

  late final _Record_get_module_pathPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKRecord>)>>(
          'Record_get_module_path');
  late final _Record_get_module_path = _Record_get_module_pathPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKRecord>)>();

  /// The module path of the message.
  void Record_set_module_path(
    ffi.Pointer<LDKRecord> this_ptr,
    LDKStr val,
  ) {
    return _Record_set_module_path(
      this_ptr,
      val,
    );
  }

  late final _Record_set_module_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRecord>, LDKStr)>>('Record_set_module_path');
  late final _Record_set_module_path = _Record_set_module_pathPtr.asFunction<
      void Function(ffi.Pointer<LDKRecord>, LDKStr)>();

  /// The source file containing the message.
  LDKStr Record_get_file(
    ffi.Pointer<LDKRecord> this_ptr,
  ) {
    return _Record_get_file(
      this_ptr,
    );
  }

  late final _Record_get_filePtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKRecord>)>>(
          'Record_get_file');
  late final _Record_get_file =
      _Record_get_filePtr.asFunction<LDKStr Function(ffi.Pointer<LDKRecord>)>();

  /// The source file containing the message.
  void Record_set_file(
    ffi.Pointer<LDKRecord> this_ptr,
    LDKStr val,
  ) {
    return _Record_set_file(
      this_ptr,
      val,
    );
  }

  late final _Record_set_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRecord>, LDKStr)>>('Record_set_file');
  late final _Record_set_file = _Record_set_filePtr.asFunction<
      void Function(ffi.Pointer<LDKRecord>, LDKStr)>();

  /// The line containing the message.
  int Record_get_line(
    ffi.Pointer<LDKRecord> this_ptr,
  ) {
    return _Record_get_line(
      this_ptr,
    );
  }

  late final _Record_get_linePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKRecord>)>>(
          'Record_get_line');
  late final _Record_get_line =
      _Record_get_linePtr.asFunction<int Function(ffi.Pointer<LDKRecord>)>();

  /// The line containing the message.
  void Record_set_line(
    ffi.Pointer<LDKRecord> this_ptr,
    int val,
  ) {
    return _Record_set_line(
      this_ptr,
      val,
    );
  }

  late final _Record_set_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRecord>, ffi.Uint32)>>('Record_set_line');
  late final _Record_set_line = _Record_set_linePtr.asFunction<
      void Function(ffi.Pointer<LDKRecord>, int)>();

  /// Creates a copy of the Record
  LDKRecord Record_clone(
    ffi.Pointer<LDKRecord> orig,
  ) {
    return _Record_clone(
      orig,
    );
  }

  late final _Record_clonePtr =
      _lookup<ffi.NativeFunction<LDKRecord Function(ffi.Pointer<LDKRecord>)>>(
          'Record_clone');
  late final _Record_clone =
      _Record_clonePtr.asFunction<LDKRecord Function(ffi.Pointer<LDKRecord>)>();

  /// Calls the free function if one is set
  void Logger_free(
    LDKLogger this_ptr,
  ) {
    return _Logger_free(
      this_ptr,
    );
  }

  late final _Logger_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKLogger)>>('Logger_free');
  late final _Logger_free =
      _Logger_freePtr.asFunction<void Function(LDKLogger)>();

  /// Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
  void ChannelHandshakeConfig_free(
    LDKChannelHandshakeConfig this_obj,
  ) {
    return _ChannelHandshakeConfig_free(
      this_obj,
    );
  }

  late final _ChannelHandshakeConfig_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelHandshakeConfig)>>(
          'ChannelHandshakeConfig_free');
  late final _ChannelHandshakeConfig_free = _ChannelHandshakeConfig_freePtr
      .asFunction<void Function(LDKChannelHandshakeConfig)>();

  /// Confirmations we will wait for before considering the channel locked in.
  /// Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
  /// equivalent limit applied to outbound channels).
  ///
  /// A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
  /// transaction before operation. If you wish to accept channels with zero confirmations, see
  /// [`UserConfig::manually_accept_inbound_channels`] and
  /// [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
  ///
  /// Default value: 6.
  ///
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
  int ChannelHandshakeConfig_get_minimum_depth(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_minimum_depth(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_minimum_depthPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_get_minimum_depth');
  late final _ChannelHandshakeConfig_get_minimum_depth =
      _ChannelHandshakeConfig_get_minimum_depthPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Confirmations we will wait for before considering the channel locked in.
  /// Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
  /// equivalent limit applied to outbound channels).
  ///
  /// A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
  /// transaction before operation. If you wish to accept channels with zero confirmations, see
  /// [`UserConfig::manually_accept_inbound_channels`] and
  /// [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
  ///
  /// Default value: 6.
  ///
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
  void ChannelHandshakeConfig_set_minimum_depth(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeConfig_set_minimum_depth(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_minimum_depthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeConfig>,
              ffi.Uint32)>>('ChannelHandshakeConfig_set_minimum_depth');
  late final _ChannelHandshakeConfig_set_minimum_depth =
      _ChannelHandshakeConfig_set_minimum_depthPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, int)>();

  /// Set to the number of blocks we require our counterparty to wait to claim their money (ie
  /// the number of blocks we have to punish our counterparty if they broadcast a revoked
  /// transaction).
  ///
  /// This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
  /// be online to check for revoked transactions on-chain at least once every our_to_self_delay
  /// blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
  /// possibly with time in between to RBF the spending transaction).
  ///
  /// Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
  /// case of an honest unilateral channel close, which implicitly decrease the economic value of
  /// our channel.
  ///
  /// Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
  /// can tweak config to ask for more security, not less.
  int ChannelHandshakeConfig_get_our_to_self_delay(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_our_to_self_delay(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_our_to_self_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_get_our_to_self_delay');
  late final _ChannelHandshakeConfig_get_our_to_self_delay =
      _ChannelHandshakeConfig_get_our_to_self_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Set to the number of blocks we require our counterparty to wait to claim their money (ie
  /// the number of blocks we have to punish our counterparty if they broadcast a revoked
  /// transaction).
  ///
  /// This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
  /// be online to check for revoked transactions on-chain at least once every our_to_self_delay
  /// blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
  /// possibly with time in between to RBF the spending transaction).
  ///
  /// Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
  /// case of an honest unilateral channel close, which implicitly decrease the economic value of
  /// our channel.
  ///
  /// Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
  /// can tweak config to ask for more security, not less.
  void ChannelHandshakeConfig_set_our_to_self_delay(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeConfig_set_our_to_self_delay(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_our_to_self_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeConfig>,
              ffi.Uint16)>>('ChannelHandshakeConfig_set_our_to_self_delay');
  late final _ChannelHandshakeConfig_set_our_to_self_delay =
      _ChannelHandshakeConfig_set_our_to_self_delayPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, int)>();

  /// Set to the smallest value HTLC we will accept to process.
  ///
  /// This value is sent to our counterparty on channel-open and we close the channel any time
  /// our counterparty misbehaves by sending us an HTLC with a value smaller than this.
  ///
  /// Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
  /// by the protocol.
  int ChannelHandshakeConfig_get_our_htlc_minimum_msat(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_our_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_our_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_get_our_htlc_minimum_msat');
  late final _ChannelHandshakeConfig_get_our_htlc_minimum_msat =
      _ChannelHandshakeConfig_get_our_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Set to the smallest value HTLC we will accept to process.
  ///
  /// This value is sent to our counterparty on channel-open and we close the channel any time
  /// our counterparty misbehaves by sending us an HTLC with a value smaller than this.
  ///
  /// Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
  /// by the protocol.
  void ChannelHandshakeConfig_set_our_htlc_minimum_msat(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeConfig_set_our_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_our_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeConfig>,
              ffi.Uint64)>>('ChannelHandshakeConfig_set_our_htlc_minimum_msat');
  late final _ChannelHandshakeConfig_set_our_htlc_minimum_msat =
      _ChannelHandshakeConfig_set_our_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, int)>();

  /// Sets the percentage of the channel value we will cap the total value of outstanding inbound
  /// HTLCs to.
  ///
  /// This can be set to a value between 1-100, where the value corresponds to the percent of the
  /// channel value in whole percentages.
  ///
  /// Note that:
  /// * If configured to another value than the default value 10, any new channels created with
  /// the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
  /// `ChannelManager`.
  ///
  /// * This caps the total value for inbound HTLCs in-flight only, and there's currently
  /// no way to configure the cap for the total value of outbound HTLCs in-flight.
  ///
  /// * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
  /// are different from the non-HTLC-encumbered funds. This makes this an important knob to
  /// restrict exposure to loss due to being offline for too long.
  /// See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
  /// for more information.
  ///
  /// Default value: 10.
  /// Minimum value: 1, any values less than 1 will be treated as 1 instead.
  /// Maximum value: 100, any values larger than 100 will be treated as 100 instead.
  int ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channelPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
          'ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel');
  late final _ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel =
      _ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channelPtr
          .asFunction<int Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Sets the percentage of the channel value we will cap the total value of outstanding inbound
  /// HTLCs to.
  ///
  /// This can be set to a value between 1-100, where the value corresponds to the percent of the
  /// channel value in whole percentages.
  ///
  /// Note that:
  /// * If configured to another value than the default value 10, any new channels created with
  /// the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
  /// `ChannelManager`.
  ///
  /// * This caps the total value for inbound HTLCs in-flight only, and there's currently
  /// no way to configure the cap for the total value of outbound HTLCs in-flight.
  ///
  /// * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
  /// are different from the non-HTLC-encumbered funds. This makes this an important knob to
  /// restrict exposure to loss due to being offline for too long.
  /// See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
  /// for more information.
  ///
  /// Default value: 10.
  /// Minimum value: 1, any values less than 1 will be treated as 1 instead.
  /// Maximum value: 100, any values larger than 100 will be treated as 100 instead.
  void
      ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channelPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelHandshakeConfig>, ffi.Uint8)>>(
          'ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel');
  late final _ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel =
      _ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channelPtr
          .asFunction<
              void Function(ffi.Pointer<LDKChannelHandshakeConfig>, int)>();

  /// If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
  /// BOLTs) option for outbound private channels. This provides better privacy by not including
  /// our real on-chain channel UTXO in each invoice and requiring that our counterparty only
  /// relay HTLCs to us using the channel's SCID alias.
  ///
  /// If this option is set, channels may be created that will not be readable by LDK versions
  /// prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
  /// [`DecodeError::InvalidValue`].
  ///
  /// Note that setting this to true does *not* prevent us from opening channels with
  /// counterparties that do not support the `scid_alias` option; we will simply fall back to a
  /// private channel without that option.
  ///
  /// Ignored if the channel is negotiated to be announced, see
  /// [`ChannelHandshakeConfig::announced_channel`] and
  /// [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
  ///
  /// Default value: false. This value is likely to change to true in the future.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  /// [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
  bool ChannelHandshakeConfig_get_negotiate_scid_privacy(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_negotiate_scid_privacy(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_negotiate_scid_privacyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_get_negotiate_scid_privacy');
  late final _ChannelHandshakeConfig_get_negotiate_scid_privacy =
      _ChannelHandshakeConfig_get_negotiate_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
  /// BOLTs) option for outbound private channels. This provides better privacy by not including
  /// our real on-chain channel UTXO in each invoice and requiring that our counterparty only
  /// relay HTLCs to us using the channel's SCID alias.
  ///
  /// If this option is set, channels may be created that will not be readable by LDK versions
  /// prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
  /// [`DecodeError::InvalidValue`].
  ///
  /// Note that setting this to true does *not* prevent us from opening channels with
  /// counterparties that do not support the `scid_alias` option; we will simply fall back to a
  /// private channel without that option.
  ///
  /// Ignored if the channel is negotiated to be announced, see
  /// [`ChannelHandshakeConfig::announced_channel`] and
  /// [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
  ///
  /// Default value: false. This value is likely to change to true in the future.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  /// [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
  void ChannelHandshakeConfig_set_negotiate_scid_privacy(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    bool val,
  ) {
    return _ChannelHandshakeConfig_set_negotiate_scid_privacy(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_negotiate_scid_privacyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeConfig>,
              ffi.Bool)>>('ChannelHandshakeConfig_set_negotiate_scid_privacy');
  late final _ChannelHandshakeConfig_set_negotiate_scid_privacy =
      _ChannelHandshakeConfig_set_negotiate_scid_privacyPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, bool)>();

  /// Set to announce the channel publicly and notify all nodes that they can route via this
  /// channel.
  ///
  /// This should only be set to true for nodes which expect to be online reliably.
  ///
  /// As the node which funds a channel picks this value this will only apply for new outbound
  /// channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
  ///
  /// Default value: false.
  bool ChannelHandshakeConfig_get_announced_channel(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_announced_channel(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_announced_channelPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_get_announced_channel');
  late final _ChannelHandshakeConfig_get_announced_channel =
      _ChannelHandshakeConfig_get_announced_channelPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Set to announce the channel publicly and notify all nodes that they can route via this
  /// channel.
  ///
  /// This should only be set to true for nodes which expect to be online reliably.
  ///
  /// As the node which funds a channel picks this value this will only apply for new outbound
  /// channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
  ///
  /// Default value: false.
  void ChannelHandshakeConfig_set_announced_channel(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    bool val,
  ) {
    return _ChannelHandshakeConfig_set_announced_channel(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_announced_channelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeConfig>,
              ffi.Bool)>>('ChannelHandshakeConfig_set_announced_channel');
  late final _ChannelHandshakeConfig_set_announced_channel =
      _ChannelHandshakeConfig_set_announced_channelPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, bool)>();

  /// When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
  /// supports it, they will then enforce the mutual-close output to us matches what we provided
  /// at intialization, preventing us from closing to an alternate pubkey.
  ///
  /// This is set to true by default to provide a slight increase in security, though ultimately
  /// any attacker who is able to take control of a channel can just as easily send the funds via
  /// lightning payments, so we never require that our counterparties support this option.
  ///
  /// The upfront key committed is provided from [`KeysInterface::get_shutdown_scriptpubkey`].
  ///
  /// Default value: true.
  ///
  /// [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
  bool ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
  ) {
    return _ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(
      this_ptr,
    );
  }

  late final _ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkeyPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>>(
          'ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey');
  late final _ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey =
      _ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkeyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
  /// supports it, they will then enforce the mutual-close output to us matches what we provided
  /// at intialization, preventing us from closing to an alternate pubkey.
  ///
  /// This is set to true by default to provide a slight increase in security, though ultimately
  /// any attacker who is able to take control of a channel can just as easily send the funds via
  /// lightning payments, so we never require that our counterparties support this option.
  ///
  /// The upfront key committed is provided from [`KeysInterface::get_shutdown_scriptpubkey`].
  ///
  /// Default value: true.
  ///
  /// [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
  void ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(
    ffi.Pointer<LDKChannelHandshakeConfig> this_ptr,
    bool val,
  ) {
    return _ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkeyPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelHandshakeConfig>, ffi.Bool)>>(
          'ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey');
  late final _ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey =
      _ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeConfig>, bool)>();

  /// Constructs a new ChannelHandshakeConfig given each field
  LDKChannelHandshakeConfig ChannelHandshakeConfig_new(
    int minimum_depth_arg,
    int our_to_self_delay_arg,
    int our_htlc_minimum_msat_arg,
    int max_inbound_htlc_value_in_flight_percent_of_channel_arg,
    bool negotiate_scid_privacy_arg,
    bool announced_channel_arg,
    bool commit_upfront_shutdown_pubkey_arg,
  ) {
    return _ChannelHandshakeConfig_new(
      minimum_depth_arg,
      our_to_self_delay_arg,
      our_htlc_minimum_msat_arg,
      max_inbound_htlc_value_in_flight_percent_of_channel_arg,
      negotiate_scid_privacy_arg,
      announced_channel_arg,
      commit_upfront_shutdown_pubkey_arg,
    );
  }

  late final _ChannelHandshakeConfig_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelHandshakeConfig Function(
              ffi.Uint32,
              ffi.Uint16,
              ffi.Uint64,
              ffi.Uint8,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool)>>('ChannelHandshakeConfig_new');
  late final _ChannelHandshakeConfig_new =
      _ChannelHandshakeConfig_newPtr.asFunction<
          LDKChannelHandshakeConfig Function(
              int, int, int, int, bool, bool, bool)>();

  /// Creates a copy of the ChannelHandshakeConfig
  LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(
    ffi.Pointer<LDKChannelHandshakeConfig> orig,
  ) {
    return _ChannelHandshakeConfig_clone(
      orig,
    );
  }

  late final _ChannelHandshakeConfig_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelHandshakeConfig Function(
                  ffi.Pointer<LDKChannelHandshakeConfig>)>>(
      'ChannelHandshakeConfig_clone');
  late final _ChannelHandshakeConfig_clone =
      _ChannelHandshakeConfig_clonePtr.asFunction<
          LDKChannelHandshakeConfig Function(
              ffi.Pointer<LDKChannelHandshakeConfig>)>();

  /// Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
  LDKChannelHandshakeConfig ChannelHandshakeConfig_default() {
    return _ChannelHandshakeConfig_default();
  }

  late final _ChannelHandshakeConfig_defaultPtr =
      _lookup<ffi.NativeFunction<LDKChannelHandshakeConfig Function()>>(
          'ChannelHandshakeConfig_default');
  late final _ChannelHandshakeConfig_default =
      _ChannelHandshakeConfig_defaultPtr.asFunction<
          LDKChannelHandshakeConfig Function()>();

  /// Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
  void ChannelHandshakeLimits_free(
    LDKChannelHandshakeLimits this_obj,
  ) {
    return _ChannelHandshakeLimits_free(
      this_obj,
    );
  }

  late final _ChannelHandshakeLimits_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelHandshakeLimits)>>(
          'ChannelHandshakeLimits_free');
  late final _ChannelHandshakeLimits_free = _ChannelHandshakeLimits_freePtr
      .asFunction<void Function(LDKChannelHandshakeLimits)>();

  /// Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
  /// only applies to inbound channels.
  ///
  /// Default value: 0.
  int ChannelHandshakeLimits_get_min_funding_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_min_funding_satoshis(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_min_funding_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_min_funding_satoshis');
  late final _ChannelHandshakeLimits_get_min_funding_satoshis =
      _ChannelHandshakeLimits_get_min_funding_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
  /// only applies to inbound channels.
  ///
  /// Default value: 0.
  void ChannelHandshakeLimits_set_min_funding_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_min_funding_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_min_funding_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Uint64)>>('ChannelHandshakeLimits_set_min_funding_satoshis');
  late final _ChannelHandshakeLimits_set_min_funding_satoshis =
      _ChannelHandshakeLimits_set_min_funding_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
  /// only applies to inbound channels.
  ///
  /// Default value: 2^24 - 1.
  int ChannelHandshakeLimits_get_max_funding_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_max_funding_satoshis(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_max_funding_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_max_funding_satoshis');
  late final _ChannelHandshakeLimits_get_max_funding_satoshis =
      _ChannelHandshakeLimits_get_max_funding_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
  /// only applies to inbound channels.
  ///
  /// Default value: 2^24 - 1.
  void ChannelHandshakeLimits_set_max_funding_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_max_funding_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_max_funding_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Uint64)>>('ChannelHandshakeLimits_set_max_funding_satoshis');
  late final _ChannelHandshakeLimits_set_max_funding_satoshis =
      _ChannelHandshakeLimits_set_max_funding_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
  /// you to limit the maximum minimum-size they can require.
  ///
  /// Default value: u64::max_value.
  int ChannelHandshakeLimits_get_max_htlc_minimum_msat(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_max_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_max_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_max_htlc_minimum_msat');
  late final _ChannelHandshakeLimits_get_max_htlc_minimum_msat =
      _ChannelHandshakeLimits_get_max_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
  /// you to limit the maximum minimum-size they can require.
  ///
  /// Default value: u64::max_value.
  void ChannelHandshakeLimits_set_max_htlc_minimum_msat(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_max_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_max_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Uint64)>>('ChannelHandshakeLimits_set_max_htlc_minimum_msat');
  late final _ChannelHandshakeLimits_set_max_htlc_minimum_msat =
      _ChannelHandshakeLimits_set_max_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// The remote node sets a limit on the maximum value of pending HTLCs to them at any given
  /// time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
  ///
  /// Default value: 0.
  int ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
          'ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat');
  late final _ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat =
      _ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msatPtr
          .asFunction<int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// The remote node sets a limit on the maximum value of pending HTLCs to them at any given
  /// time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
  ///
  /// Default value: 0.
  void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelHandshakeLimits>, ffi.Uint64)>>(
          'ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat');
  late final _ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat =
      _ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msatPtr
          .asFunction<
              void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// The remote node will require we keep a certain amount in direct payment to ourselves at all
  /// time, ensuring that we are able to be punished if we broadcast an old state. This allows to
  /// you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
  ///
  /// Default value: u64::max_value.
  int ChannelHandshakeLimits_get_max_channel_reserve_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_max_channel_reserve_satoshis(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_max_channel_reserve_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
          'ChannelHandshakeLimits_get_max_channel_reserve_satoshis');
  late final _ChannelHandshakeLimits_get_max_channel_reserve_satoshis =
      _ChannelHandshakeLimits_get_max_channel_reserve_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// The remote node will require we keep a certain amount in direct payment to ourselves at all
  /// time, ensuring that we are able to be punished if we broadcast an old state. This allows to
  /// you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
  ///
  /// Default value: u64::max_value.
  void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_max_channel_reserve_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_max_channel_reserve_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelHandshakeLimits>, ffi.Uint64)>>(
          'ChannelHandshakeLimits_set_max_channel_reserve_satoshis');
  late final _ChannelHandshakeLimits_set_max_channel_reserve_satoshis =
      _ChannelHandshakeLimits_set_max_channel_reserve_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// The remote node sets a limit on the maximum number of pending HTLCs to them at any given
  /// time. This allows you to set a minimum such value.
  ///
  /// Default value: 0.
  int ChannelHandshakeLimits_get_min_max_accepted_htlcs(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_min_max_accepted_htlcs(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_min_max_accepted_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_min_max_accepted_htlcs');
  late final _ChannelHandshakeLimits_get_min_max_accepted_htlcs =
      _ChannelHandshakeLimits_get_min_max_accepted_htlcsPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// The remote node sets a limit on the maximum number of pending HTLCs to them at any given
  /// time. This allows you to set a minimum such value.
  ///
  /// Default value: 0.
  void ChannelHandshakeLimits_set_min_max_accepted_htlcs(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_min_max_accepted_htlcs(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_min_max_accepted_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelHandshakeLimits>, ffi.Uint16)>>(
      'ChannelHandshakeLimits_set_min_max_accepted_htlcs');
  late final _ChannelHandshakeLimits_set_min_max_accepted_htlcs =
      _ChannelHandshakeLimits_set_min_max_accepted_htlcsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// Before a channel is usable the funding transaction will need to be confirmed by at least a
  /// certain number of blocks, specified by the node which is not the funder (as the funder can
  /// assume they aren't going to double-spend themselves).
  /// This config allows you to set a limit on the maximum amount of time to wait.
  ///
  /// Default value: 144, or roughly one day and only applies to outbound channels.
  int ChannelHandshakeLimits_get_max_minimum_depth(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_max_minimum_depth(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_max_minimum_depthPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_max_minimum_depth');
  late final _ChannelHandshakeLimits_get_max_minimum_depth =
      _ChannelHandshakeLimits_get_max_minimum_depthPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Before a channel is usable the funding transaction will need to be confirmed by at least a
  /// certain number of blocks, specified by the node which is not the funder (as the funder can
  /// assume they aren't going to double-spend themselves).
  /// This config allows you to set a limit on the maximum amount of time to wait.
  ///
  /// Default value: 144, or roughly one day and only applies to outbound channels.
  void ChannelHandshakeLimits_set_max_minimum_depth(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_max_minimum_depth(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_max_minimum_depthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Uint32)>>('ChannelHandshakeLimits_set_max_minimum_depth');
  late final _ChannelHandshakeLimits_set_max_minimum_depth =
      _ChannelHandshakeLimits_set_max_minimum_depthPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// Whether we implicitly trust funding transactions generated by us for our own outbound
  /// channels to not be double-spent.
  ///
  /// If this is set, we assume that our own funding transactions are *never* double-spent, and
  /// thus we can trust them without any confirmations. This is generally a reasonable
  /// assumption, given we're the only ones who could ever double-spend it (assuming we have sole
  /// control of the signing keys).
  ///
  /// You may wish to un-set this if you allow the user to (or do in an automated fashion)
  /// double-spend the funding transaction to RBF with an alternative channel open.
  ///
  /// This only applies if our counterparty set their confirmations-required value to 0, and we
  /// always trust our own funding transaction at 1 confirmation irrespective of this value.
  /// Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
  /// `true` (0) and `false` (1).
  ///
  /// Default value: true
  bool ChannelHandshakeLimits_get_trust_own_funding_0conf(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_trust_own_funding_0conf(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_trust_own_funding_0confPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_trust_own_funding_0conf');
  late final _ChannelHandshakeLimits_get_trust_own_funding_0conf =
      _ChannelHandshakeLimits_get_trust_own_funding_0confPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Whether we implicitly trust funding transactions generated by us for our own outbound
  /// channels to not be double-spent.
  ///
  /// If this is set, we assume that our own funding transactions are *never* double-spent, and
  /// thus we can trust them without any confirmations. This is generally a reasonable
  /// assumption, given we're the only ones who could ever double-spend it (assuming we have sole
  /// control of the signing keys).
  ///
  /// You may wish to un-set this if you allow the user to (or do in an automated fashion)
  /// double-spend the funding transaction to RBF with an alternative channel open.
  ///
  /// This only applies if our counterparty set their confirmations-required value to 0, and we
  /// always trust our own funding transaction at 1 confirmation irrespective of this value.
  /// Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
  /// `true` (0) and `false` (1).
  ///
  /// Default value: true
  void ChannelHandshakeLimits_set_trust_own_funding_0conf(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    bool val,
  ) {
    return _ChannelHandshakeLimits_set_trust_own_funding_0conf(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_trust_own_funding_0confPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Bool)>>('ChannelHandshakeLimits_set_trust_own_funding_0conf');
  late final _ChannelHandshakeLimits_set_trust_own_funding_0conf =
      _ChannelHandshakeLimits_set_trust_own_funding_0confPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, bool)>();

  /// Set to force an incoming channel to match our announced channel preference in
  /// [`ChannelHandshakeConfig::announced_channel`].
  ///
  /// For a node which is not online reliably, this should be set to true and
  /// [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
  /// channels will ever be opened.
  ///
  /// Default value: true.
  bool ChannelHandshakeLimits_get_force_announced_channel_preference(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_force_announced_channel_preference(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_force_announced_channel_preferencePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
          'ChannelHandshakeLimits_get_force_announced_channel_preference');
  late final _ChannelHandshakeLimits_get_force_announced_channel_preference =
      _ChannelHandshakeLimits_get_force_announced_channel_preferencePtr
          .asFunction<bool Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Set to force an incoming channel to match our announced channel preference in
  /// [`ChannelHandshakeConfig::announced_channel`].
  ///
  /// For a node which is not online reliably, this should be set to true and
  /// [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
  /// channels will ever be opened.
  ///
  /// Default value: true.
  void ChannelHandshakeLimits_set_force_announced_channel_preference(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    bool val,
  ) {
    return _ChannelHandshakeLimits_set_force_announced_channel_preference(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_force_announced_channel_preferencePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelHandshakeLimits>, ffi.Bool)>>(
          'ChannelHandshakeLimits_set_force_announced_channel_preference');
  late final _ChannelHandshakeLimits_set_force_announced_channel_preference =
      _ChannelHandshakeLimits_set_force_announced_channel_preferencePtr
          .asFunction<
              void Function(ffi.Pointer<LDKChannelHandshakeLimits>, bool)>();

  /// Set to the amount of time we're willing to wait to claim money back to us.
  ///
  /// Not checking this value would be a security issue, as our peer would be able to set it to
  /// max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
  ///
  /// Default value: 2016, which we also enforce as a maximum value so you can tweak config to
  /// reduce the loss of having useless locked funds (if your peer accepts)
  int ChannelHandshakeLimits_get_their_to_self_delay(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
  ) {
    return _ChannelHandshakeLimits_get_their_to_self_delay(
      this_ptr,
    );
  }

  late final _ChannelHandshakeLimits_get_their_to_self_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_get_their_to_self_delay');
  late final _ChannelHandshakeLimits_get_their_to_self_delay =
      _ChannelHandshakeLimits_get_their_to_self_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Set to the amount of time we're willing to wait to claim money back to us.
  ///
  /// Not checking this value would be a security issue, as our peer would be able to set it to
  /// max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
  ///
  /// Default value: 2016, which we also enforce as a maximum value so you can tweak config to
  /// reduce the loss of having useless locked funds (if your peer accepts)
  void ChannelHandshakeLimits_set_their_to_self_delay(
    ffi.Pointer<LDKChannelHandshakeLimits> this_ptr,
    int val,
  ) {
    return _ChannelHandshakeLimits_set_their_to_self_delay(
      this_ptr,
      val,
    );
  }

  late final _ChannelHandshakeLimits_set_their_to_self_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelHandshakeLimits>,
              ffi.Uint16)>>('ChannelHandshakeLimits_set_their_to_self_delay');
  late final _ChannelHandshakeLimits_set_their_to_self_delay =
      _ChannelHandshakeLimits_set_their_to_self_delayPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelHandshakeLimits>, int)>();

  /// Constructs a new ChannelHandshakeLimits given each field
  LDKChannelHandshakeLimits ChannelHandshakeLimits_new(
    int min_funding_satoshis_arg,
    int max_funding_satoshis_arg,
    int max_htlc_minimum_msat_arg,
    int min_max_htlc_value_in_flight_msat_arg,
    int max_channel_reserve_satoshis_arg,
    int min_max_accepted_htlcs_arg,
    int max_minimum_depth_arg,
    bool trust_own_funding_0conf_arg,
    bool force_announced_channel_preference_arg,
    int their_to_self_delay_arg,
  ) {
    return _ChannelHandshakeLimits_new(
      min_funding_satoshis_arg,
      max_funding_satoshis_arg,
      max_htlc_minimum_msat_arg,
      min_max_htlc_value_in_flight_msat_arg,
      max_channel_reserve_satoshis_arg,
      min_max_accepted_htlcs_arg,
      max_minimum_depth_arg,
      trust_own_funding_0conf_arg,
      force_announced_channel_preference_arg,
      their_to_self_delay_arg,
    );
  }

  late final _ChannelHandshakeLimits_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelHandshakeLimits Function(
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint16,
              ffi.Uint32,
              ffi.Bool,
              ffi.Bool,
              ffi.Uint16)>>('ChannelHandshakeLimits_new');
  late final _ChannelHandshakeLimits_new =
      _ChannelHandshakeLimits_newPtr.asFunction<
          LDKChannelHandshakeLimits Function(
              int, int, int, int, int, int, int, bool, bool, int)>();

  /// Creates a copy of the ChannelHandshakeLimits
  LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(
    ffi.Pointer<LDKChannelHandshakeLimits> orig,
  ) {
    return _ChannelHandshakeLimits_clone(
      orig,
    );
  }

  late final _ChannelHandshakeLimits_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelHandshakeLimits Function(
                  ffi.Pointer<LDKChannelHandshakeLimits>)>>(
      'ChannelHandshakeLimits_clone');
  late final _ChannelHandshakeLimits_clone =
      _ChannelHandshakeLimits_clonePtr.asFunction<
          LDKChannelHandshakeLimits Function(
              ffi.Pointer<LDKChannelHandshakeLimits>)>();

  /// Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
  LDKChannelHandshakeLimits ChannelHandshakeLimits_default() {
    return _ChannelHandshakeLimits_default();
  }

  late final _ChannelHandshakeLimits_defaultPtr =
      _lookup<ffi.NativeFunction<LDKChannelHandshakeLimits Function()>>(
          'ChannelHandshakeLimits_default');
  late final _ChannelHandshakeLimits_default =
      _ChannelHandshakeLimits_defaultPtr.asFunction<
          LDKChannelHandshakeLimits Function()>();

  /// Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
  void ChannelConfig_free(
    LDKChannelConfig this_obj,
  ) {
    return _ChannelConfig_free(
      this_obj,
    );
  }

  late final _ChannelConfig_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelConfig)>>(
          'ChannelConfig_free');
  late final _ChannelConfig_free =
      _ChannelConfig_freePtr.asFunction<void Function(LDKChannelConfig)>();

  /// Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
  /// over the channel.
  /// This may be allowed to change at runtime in a later update, however doing so must result in
  /// update messages sent to notify all nodes of our updated relay fee.
  ///
  /// Default value: 0.
  int ChannelConfig_get_forwarding_fee_proportional_millionths(
    ffi.Pointer<LDKChannelConfig> this_ptr,
  ) {
    return _ChannelConfig_get_forwarding_fee_proportional_millionths(
      this_ptr,
    );
  }

  late final _ChannelConfig_get_forwarding_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint32 Function(ffi.Pointer<LDKChannelConfig>)>>(
          'ChannelConfig_get_forwarding_fee_proportional_millionths');
  late final _ChannelConfig_get_forwarding_fee_proportional_millionths =
      _ChannelConfig_get_forwarding_fee_proportional_millionthsPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelConfig>)>();

  /// Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
  /// over the channel.
  /// This may be allowed to change at runtime in a later update, however doing so must result in
  /// update messages sent to notify all nodes of our updated relay fee.
  ///
  /// Default value: 0.
  void ChannelConfig_set_forwarding_fee_proportional_millionths(
    ffi.Pointer<LDKChannelConfig> this_ptr,
    int val,
  ) {
    return _ChannelConfig_set_forwarding_fee_proportional_millionths(
      this_ptr,
      val,
    );
  }

  late final _ChannelConfig_set_forwarding_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelConfig>, ffi.Uint32)>>(
          'ChannelConfig_set_forwarding_fee_proportional_millionths');
  late final _ChannelConfig_set_forwarding_fee_proportional_millionths =
      _ChannelConfig_set_forwarding_fee_proportional_millionthsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelConfig>, int)>();

  /// Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
  /// excess of [`forwarding_fee_proportional_millionths`].
  /// This may be allowed to change at runtime in a later update, however doing so must result in
  /// update messages sent to notify all nodes of our updated relay fee.
  ///
  /// The default value of a single satoshi roughly matches the market rate on many routing nodes
  /// as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
  /// this node.
  ///
  /// Default value: 1000.
  ///
  /// [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
  int ChannelConfig_get_forwarding_fee_base_msat(
    ffi.Pointer<LDKChannelConfig> this_ptr,
  ) {
    return _ChannelConfig_get_forwarding_fee_base_msat(
      this_ptr,
    );
  }

  late final _ChannelConfig_get_forwarding_fee_base_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKChannelConfig>)>>(
      'ChannelConfig_get_forwarding_fee_base_msat');
  late final _ChannelConfig_get_forwarding_fee_base_msat =
      _ChannelConfig_get_forwarding_fee_base_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelConfig>)>();

  /// Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
  /// excess of [`forwarding_fee_proportional_millionths`].
  /// This may be allowed to change at runtime in a later update, however doing so must result in
  /// update messages sent to notify all nodes of our updated relay fee.
  ///
  /// The default value of a single satoshi roughly matches the market rate on many routing nodes
  /// as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
  /// this node.
  ///
  /// Default value: 1000.
  ///
  /// [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
  void ChannelConfig_set_forwarding_fee_base_msat(
    ffi.Pointer<LDKChannelConfig> this_ptr,
    int val,
  ) {
    return _ChannelConfig_set_forwarding_fee_base_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelConfig_set_forwarding_fee_base_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelConfig>,
              ffi.Uint32)>>('ChannelConfig_set_forwarding_fee_base_msat');
  late final _ChannelConfig_set_forwarding_fee_base_msat =
      _ChannelConfig_set_forwarding_fee_base_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelConfig>, int)>();

  /// The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
  /// the channel this config applies to.
  ///
  /// This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
  /// HTLC balance when a channel appears on-chain whereas
  /// [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
  /// (non-HTLC-encumbered) balance.
  ///
  /// Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
  /// we (or one of our watchtowers) MUST be online to check for broadcast of the current
  /// commitment transaction at least once per this many blocks (minus some margin to allow us
  /// enough time to broadcast and confirm a transaction, possibly with time in between to RBF
  /// the spending transaction).
  ///
  /// Default value: 72 (12 hours at an average of 6 blocks/hour).
  /// Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
  /// [`MIN_CLTV_EXPIRY_DELTA`] instead.
  ///
  /// [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
  int ChannelConfig_get_cltv_expiry_delta(
    ffi.Pointer<LDKChannelConfig> this_ptr,
  ) {
    return _ChannelConfig_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _ChannelConfig_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKChannelConfig>)>>(
      'ChannelConfig_get_cltv_expiry_delta');
  late final _ChannelConfig_get_cltv_expiry_delta =
      _ChannelConfig_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelConfig>)>();

  /// The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
  /// the channel this config applies to.
  ///
  /// This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
  /// HTLC balance when a channel appears on-chain whereas
  /// [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
  /// (non-HTLC-encumbered) balance.
  ///
  /// Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
  /// we (or one of our watchtowers) MUST be online to check for broadcast of the current
  /// commitment transaction at least once per this many blocks (minus some margin to allow us
  /// enough time to broadcast and confirm a transaction, possibly with time in between to RBF
  /// the spending transaction).
  ///
  /// Default value: 72 (12 hours at an average of 6 blocks/hour).
  /// Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
  /// [`MIN_CLTV_EXPIRY_DELTA`] instead.
  ///
  /// [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
  void ChannelConfig_set_cltv_expiry_delta(
    ffi.Pointer<LDKChannelConfig> this_ptr,
    int val,
  ) {
    return _ChannelConfig_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _ChannelConfig_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelConfig>,
              ffi.Uint16)>>('ChannelConfig_set_cltv_expiry_delta');
  late final _ChannelConfig_set_cltv_expiry_delta =
      _ChannelConfig_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelConfig>, int)>();

  /// Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
  /// small to claim on-chain.
  ///
  /// When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
  /// not be claimable on-chain, instead being turned into additional miner fees if either
  /// party force-closes the channel. Because the threshold is per-HTLC, our total exposure
  /// to such payments may be sustantial if there are many dust HTLCs present when the
  /// channel is force-closed.
  ///
  /// This limit is applied for sent, forwarded, and received HTLCs and limits the total
  /// exposure across all three types per-channel. Setting this too low may prevent the
  /// sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
  /// important to prevent stealing of dust HTLCs by miners.
  ///
  /// Default value: 5_000_000 msat.
  int ChannelConfig_get_max_dust_htlc_exposure_msat(
    ffi.Pointer<LDKChannelConfig> this_ptr,
  ) {
    return _ChannelConfig_get_max_dust_htlc_exposure_msat(
      this_ptr,
    );
  }

  late final _ChannelConfig_get_max_dust_htlc_exposure_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelConfig>)>>(
      'ChannelConfig_get_max_dust_htlc_exposure_msat');
  late final _ChannelConfig_get_max_dust_htlc_exposure_msat =
      _ChannelConfig_get_max_dust_htlc_exposure_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelConfig>)>();

  /// Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
  /// small to claim on-chain.
  ///
  /// When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
  /// not be claimable on-chain, instead being turned into additional miner fees if either
  /// party force-closes the channel. Because the threshold is per-HTLC, our total exposure
  /// to such payments may be sustantial if there are many dust HTLCs present when the
  /// channel is force-closed.
  ///
  /// This limit is applied for sent, forwarded, and received HTLCs and limits the total
  /// exposure across all three types per-channel. Setting this too low may prevent the
  /// sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
  /// important to prevent stealing of dust HTLCs by miners.
  ///
  /// Default value: 5_000_000 msat.
  void ChannelConfig_set_max_dust_htlc_exposure_msat(
    ffi.Pointer<LDKChannelConfig> this_ptr,
    int val,
  ) {
    return _ChannelConfig_set_max_dust_htlc_exposure_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelConfig_set_max_dust_htlc_exposure_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelConfig>,
              ffi.Uint64)>>('ChannelConfig_set_max_dust_htlc_exposure_msat');
  late final _ChannelConfig_set_max_dust_htlc_exposure_msat =
      _ChannelConfig_set_max_dust_htlc_exposure_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelConfig>, int)>();

  /// The additional fee we're willing to pay to avoid waiting for the counterparty's
  /// `to_self_delay` to reclaim funds.
  ///
  /// When we close a channel cooperatively with our counterparty, we negotiate a fee for the
  /// closing transaction which both sides find acceptable, ultimately paid by the channel
  /// funder/initiator.
  ///
  /// When we are the funder, because we have to pay the channel closing fee, we bound the
  /// acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
  /// this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
  /// [`Normal`] feerate during normal operation, this value represents the additional fee we're
  /// willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
  /// funds.
  ///
  /// When we are not the funder, we require the closing transaction fee pay at least our
  /// [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
  /// Thus, this value is ignored when we are not the funder.
  ///
  /// Default value: 1000 satoshis.
  ///
  /// [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
  /// [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
  int ChannelConfig_get_force_close_avoidance_max_fee_satoshis(
    ffi.Pointer<LDKChannelConfig> this_ptr,
  ) {
    return _ChannelConfig_get_force_close_avoidance_max_fee_satoshis(
      this_ptr,
    );
  }

  late final _ChannelConfig_get_force_close_avoidance_max_fee_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(ffi.Pointer<LDKChannelConfig>)>>(
          'ChannelConfig_get_force_close_avoidance_max_fee_satoshis');
  late final _ChannelConfig_get_force_close_avoidance_max_fee_satoshis =
      _ChannelConfig_get_force_close_avoidance_max_fee_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelConfig>)>();

  /// The additional fee we're willing to pay to avoid waiting for the counterparty's
  /// `to_self_delay` to reclaim funds.
  ///
  /// When we close a channel cooperatively with our counterparty, we negotiate a fee for the
  /// closing transaction which both sides find acceptable, ultimately paid by the channel
  /// funder/initiator.
  ///
  /// When we are the funder, because we have to pay the channel closing fee, we bound the
  /// acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
  /// this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
  /// [`Normal`] feerate during normal operation, this value represents the additional fee we're
  /// willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
  /// funds.
  ///
  /// When we are not the funder, we require the closing transaction fee pay at least our
  /// [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
  /// Thus, this value is ignored when we are not the funder.
  ///
  /// Default value: 1000 satoshis.
  ///
  /// [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
  /// [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
  void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(
    ffi.Pointer<LDKChannelConfig> this_ptr,
    int val,
  ) {
    return _ChannelConfig_set_force_close_avoidance_max_fee_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ChannelConfig_set_force_close_avoidance_max_fee_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelConfig>, ffi.Uint64)>>(
          'ChannelConfig_set_force_close_avoidance_max_fee_satoshis');
  late final _ChannelConfig_set_force_close_avoidance_max_fee_satoshis =
      _ChannelConfig_set_force_close_avoidance_max_fee_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelConfig>, int)>();

  /// Constructs a new ChannelConfig given each field
  LDKChannelConfig ChannelConfig_new(
    int forwarding_fee_proportional_millionths_arg,
    int forwarding_fee_base_msat_arg,
    int cltv_expiry_delta_arg,
    int max_dust_htlc_exposure_msat_arg,
    int force_close_avoidance_max_fee_satoshis_arg,
  ) {
    return _ChannelConfig_new(
      forwarding_fee_proportional_millionths_arg,
      forwarding_fee_base_msat_arg,
      cltv_expiry_delta_arg,
      max_dust_htlc_exposure_msat_arg,
      force_close_avoidance_max_fee_satoshis_arg,
    );
  }

  late final _ChannelConfig_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelConfig Function(ffi.Uint32, ffi.Uint32, ffi.Uint16,
              ffi.Uint64, ffi.Uint64)>>('ChannelConfig_new');
  late final _ChannelConfig_new = _ChannelConfig_newPtr.asFunction<
      LDKChannelConfig Function(int, int, int, int, int)>();

  /// Creates a copy of the ChannelConfig
  LDKChannelConfig ChannelConfig_clone(
    ffi.Pointer<LDKChannelConfig> orig,
  ) {
    return _ChannelConfig_clone(
      orig,
    );
  }

  late final _ChannelConfig_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelConfig Function(
              ffi.Pointer<LDKChannelConfig>)>>('ChannelConfig_clone');
  late final _ChannelConfig_clone = _ChannelConfig_clonePtr.asFunction<
      LDKChannelConfig Function(ffi.Pointer<LDKChannelConfig>)>();

  /// Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
  LDKChannelConfig ChannelConfig_default() {
    return _ChannelConfig_default();
  }

  late final _ChannelConfig_defaultPtr =
      _lookup<ffi.NativeFunction<LDKChannelConfig Function()>>(
          'ChannelConfig_default');
  late final _ChannelConfig_default =
      _ChannelConfig_defaultPtr.asFunction<LDKChannelConfig Function()>();

  /// Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
  LDKCVec_u8Z ChannelConfig_write(
    ffi.Pointer<LDKChannelConfig> obj,
  ) {
    return _ChannelConfig_write(
      obj,
    );
  }

  late final _ChannelConfig_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelConfig>)>>('ChannelConfig_write');
  late final _ChannelConfig_write = _ChannelConfig_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelConfig>)>();

  /// Read a ChannelConfig from a byte array, created by ChannelConfig_write
  LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(
    LDKu8slice ser,
  ) {
    return _ChannelConfig_read(
      ser,
    );
  }

  late final _ChannelConfig_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelConfigDecodeErrorZ Function(
              LDKu8slice)>>('ChannelConfig_read');
  late final _ChannelConfig_read = _ChannelConfig_readPtr.asFunction<
      LDKCResult_ChannelConfigDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
  void UserConfig_free(
    LDKUserConfig this_obj,
  ) {
    return _UserConfig_free(
      this_obj,
    );
  }

  late final _UserConfig_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUserConfig)>>(
          'UserConfig_free');
  late final _UserConfig_free =
      _UserConfig_freePtr.asFunction<void Function(LDKUserConfig)>();

  /// Channel handshake config that we propose to our counterparty.
  LDKChannelHandshakeConfig UserConfig_get_channel_handshake_config(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_channel_handshake_config(
      this_ptr,
    );
  }

  late final _UserConfig_get_channel_handshake_configPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelHandshakeConfig Function(ffi.Pointer<LDKUserConfig>)>>(
      'UserConfig_get_channel_handshake_config');
  late final _UserConfig_get_channel_handshake_config =
      _UserConfig_get_channel_handshake_configPtr.asFunction<
          LDKChannelHandshakeConfig Function(ffi.Pointer<LDKUserConfig>)>();

  /// Channel handshake config that we propose to our counterparty.
  void UserConfig_set_channel_handshake_config(
    ffi.Pointer<LDKUserConfig> this_ptr,
    LDKChannelHandshakeConfig val,
  ) {
    return _UserConfig_set_channel_handshake_config(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_channel_handshake_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKUserConfig>, LDKChannelHandshakeConfig)>>(
      'UserConfig_set_channel_handshake_config');
  late final _UserConfig_set_channel_handshake_config =
      _UserConfig_set_channel_handshake_configPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUserConfig>, LDKChannelHandshakeConfig)>();

  /// Limits applied to our counterparty's proposed channel handshake config settings.
  LDKChannelHandshakeLimits UserConfig_get_channel_handshake_limits(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_channel_handshake_limits(
      this_ptr,
    );
  }

  late final _UserConfig_get_channel_handshake_limitsPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelHandshakeLimits Function(ffi.Pointer<LDKUserConfig>)>>(
      'UserConfig_get_channel_handshake_limits');
  late final _UserConfig_get_channel_handshake_limits =
      _UserConfig_get_channel_handshake_limitsPtr.asFunction<
          LDKChannelHandshakeLimits Function(ffi.Pointer<LDKUserConfig>)>();

  /// Limits applied to our counterparty's proposed channel handshake config settings.
  void UserConfig_set_channel_handshake_limits(
    ffi.Pointer<LDKUserConfig> this_ptr,
    LDKChannelHandshakeLimits val,
  ) {
    return _UserConfig_set_channel_handshake_limits(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_channel_handshake_limitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKUserConfig>, LDKChannelHandshakeLimits)>>(
      'UserConfig_set_channel_handshake_limits');
  late final _UserConfig_set_channel_handshake_limits =
      _UserConfig_set_channel_handshake_limitsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUserConfig>, LDKChannelHandshakeLimits)>();

  /// Channel config which affects behavior during channel lifetime.
  LDKChannelConfig UserConfig_get_channel_config(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_channel_config(
      this_ptr,
    );
  }

  late final _UserConfig_get_channel_configPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelConfig Function(
              ffi.Pointer<LDKUserConfig>)>>('UserConfig_get_channel_config');
  late final _UserConfig_get_channel_config = _UserConfig_get_channel_configPtr
      .asFunction<LDKChannelConfig Function(ffi.Pointer<LDKUserConfig>)>();

  /// Channel config which affects behavior during channel lifetime.
  void UserConfig_set_channel_config(
    ffi.Pointer<LDKUserConfig> this_ptr,
    LDKChannelConfig val,
  ) {
    return _UserConfig_set_channel_config(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_channel_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUserConfig>,
              LDKChannelConfig)>>('UserConfig_set_channel_config');
  late final _UserConfig_set_channel_config =
      _UserConfig_set_channel_configPtr.asFunction<
          void Function(ffi.Pointer<LDKUserConfig>, LDKChannelConfig)>();

  /// If this is set to false, we will reject any HTLCs which were to be forwarded over private
  /// channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
  /// node which is not online reliably.
  ///
  /// For nodes which are not online reliably, you should set all channels to *not* be announced
  /// (using [`ChannelHandshakeConfig::announced_channel`] and
  /// [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
  /// ensure you are not exposed to any forwarding risk.
  ///
  /// Note that because you cannot change a channel's announced state after creation, there is no
  /// way to disable forwarding on public channels retroactively. Thus, in order to change a node
  /// from a publicly-announced forwarding node to a private non-forwarding node you must close
  /// all your channels and open new ones. For privacy, you should also change your node_id
  /// (swapping all private and public key material for new ones) at that time.
  ///
  /// Default value: false.
  bool UserConfig_get_accept_forwards_to_priv_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_accept_forwards_to_priv_channels(
      this_ptr,
    );
  }

  late final _UserConfig_get_accept_forwards_to_priv_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKUserConfig>)>>(
      'UserConfig_get_accept_forwards_to_priv_channels');
  late final _UserConfig_get_accept_forwards_to_priv_channels =
      _UserConfig_get_accept_forwards_to_priv_channelsPtr.asFunction<
          bool Function(ffi.Pointer<LDKUserConfig>)>();

  /// If this is set to false, we will reject any HTLCs which were to be forwarded over private
  /// channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
  /// node which is not online reliably.
  ///
  /// For nodes which are not online reliably, you should set all channels to *not* be announced
  /// (using [`ChannelHandshakeConfig::announced_channel`] and
  /// [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
  /// ensure you are not exposed to any forwarding risk.
  ///
  /// Note that because you cannot change a channel's announced state after creation, there is no
  /// way to disable forwarding on public channels retroactively. Thus, in order to change a node
  /// from a publicly-announced forwarding node to a private non-forwarding node you must close
  /// all your channels and open new ones. For privacy, you should also change your node_id
  /// (swapping all private and public key material for new ones) at that time.
  ///
  /// Default value: false.
  void UserConfig_set_accept_forwards_to_priv_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
    bool val,
  ) {
    return _UserConfig_set_accept_forwards_to_priv_channels(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_accept_forwards_to_priv_channelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUserConfig>,
              ffi.Bool)>>('UserConfig_set_accept_forwards_to_priv_channels');
  late final _UserConfig_set_accept_forwards_to_priv_channels =
      _UserConfig_set_accept_forwards_to_priv_channelsPtr.asFunction<
          void Function(ffi.Pointer<LDKUserConfig>, bool)>();

  /// If this is set to false, we do not accept inbound requests to open a new channel.
  /// Default value: true.
  bool UserConfig_get_accept_inbound_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_accept_inbound_channels(
      this_ptr,
    );
  }

  late final _UserConfig_get_accept_inbound_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKUserConfig>)>>(
      'UserConfig_get_accept_inbound_channels');
  late final _UserConfig_get_accept_inbound_channels =
      _UserConfig_get_accept_inbound_channelsPtr.asFunction<
          bool Function(ffi.Pointer<LDKUserConfig>)>();

  /// If this is set to false, we do not accept inbound requests to open a new channel.
  /// Default value: true.
  void UserConfig_set_accept_inbound_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
    bool val,
  ) {
    return _UserConfig_set_accept_inbound_channels(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_accept_inbound_channelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUserConfig>,
              ffi.Bool)>>('UserConfig_set_accept_inbound_channels');
  late final _UserConfig_set_accept_inbound_channels =
      _UserConfig_set_accept_inbound_channelsPtr.asFunction<
          void Function(ffi.Pointer<LDKUserConfig>, bool)>();

  /// If this is set to true, the user needs to manually accept inbound requests to open a new
  /// channel.
  ///
  /// When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
  /// new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
  /// [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
  /// user explicitly chooses to accept the request.
  ///
  /// Default value: false.
  ///
  /// [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
  /// [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
  /// [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
  bool UserConfig_get_manually_accept_inbound_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
  ) {
    return _UserConfig_get_manually_accept_inbound_channels(
      this_ptr,
    );
  }

  late final _UserConfig_get_manually_accept_inbound_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKUserConfig>)>>(
      'UserConfig_get_manually_accept_inbound_channels');
  late final _UserConfig_get_manually_accept_inbound_channels =
      _UserConfig_get_manually_accept_inbound_channelsPtr.asFunction<
          bool Function(ffi.Pointer<LDKUserConfig>)>();

  /// If this is set to true, the user needs to manually accept inbound requests to open a new
  /// channel.
  ///
  /// When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
  /// new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
  /// [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
  /// user explicitly chooses to accept the request.
  ///
  /// Default value: false.
  ///
  /// [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
  /// [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
  /// [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
  void UserConfig_set_manually_accept_inbound_channels(
    ffi.Pointer<LDKUserConfig> this_ptr,
    bool val,
  ) {
    return _UserConfig_set_manually_accept_inbound_channels(
      this_ptr,
      val,
    );
  }

  late final _UserConfig_set_manually_accept_inbound_channelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUserConfig>,
              ffi.Bool)>>('UserConfig_set_manually_accept_inbound_channels');
  late final _UserConfig_set_manually_accept_inbound_channels =
      _UserConfig_set_manually_accept_inbound_channelsPtr.asFunction<
          void Function(ffi.Pointer<LDKUserConfig>, bool)>();

  /// Constructs a new UserConfig given each field
  LDKUserConfig UserConfig_new(
    LDKChannelHandshakeConfig channel_handshake_config_arg,
    LDKChannelHandshakeLimits channel_handshake_limits_arg,
    LDKChannelConfig channel_config_arg,
    bool accept_forwards_to_priv_channels_arg,
    bool accept_inbound_channels_arg,
    bool manually_accept_inbound_channels_arg,
  ) {
    return _UserConfig_new(
      channel_handshake_config_arg,
      channel_handshake_limits_arg,
      channel_config_arg,
      accept_forwards_to_priv_channels_arg,
      accept_inbound_channels_arg,
      manually_accept_inbound_channels_arg,
    );
  }

  late final _UserConfig_newPtr = _lookup<
      ffi.NativeFunction<
          LDKUserConfig Function(
              LDKChannelHandshakeConfig,
              LDKChannelHandshakeLimits,
              LDKChannelConfig,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool)>>('UserConfig_new');
  late final _UserConfig_new = _UserConfig_newPtr.asFunction<
      LDKUserConfig Function(LDKChannelHandshakeConfig,
          LDKChannelHandshakeLimits, LDKChannelConfig, bool, bool, bool)>();

  /// Creates a copy of the UserConfig
  LDKUserConfig UserConfig_clone(
    ffi.Pointer<LDKUserConfig> orig,
  ) {
    return _UserConfig_clone(
      orig,
    );
  }

  late final _UserConfig_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKUserConfig Function(
              ffi.Pointer<LDKUserConfig>)>>('UserConfig_clone');
  late final _UserConfig_clone = _UserConfig_clonePtr.asFunction<
      LDKUserConfig Function(ffi.Pointer<LDKUserConfig>)>();

  /// Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
  LDKUserConfig UserConfig_default() {
    return _UserConfig_default();
  }

  late final _UserConfig_defaultPtr =
      _lookup<ffi.NativeFunction<LDKUserConfig Function()>>(
          'UserConfig_default');
  late final _UserConfig_default =
      _UserConfig_defaultPtr.asFunction<LDKUserConfig Function()>();

  /// Frees any resources used by the BestBlock, if is_owned is set and inner is non-NULL.
  void BestBlock_free(
    LDKBestBlock this_obj,
  ) {
    return _BestBlock_free(
      this_obj,
    );
  }

  late final _BestBlock_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBestBlock)>>(
          'BestBlock_free');
  late final _BestBlock_free =
      _BestBlock_freePtr.asFunction<void Function(LDKBestBlock)>();

  /// Creates a copy of the BestBlock
  LDKBestBlock BestBlock_clone(
    ffi.Pointer<LDKBestBlock> orig,
  ) {
    return _BestBlock_clone(
      orig,
    );
  }

  late final _BestBlock_clonePtr = _lookup<
          ffi.NativeFunction<LDKBestBlock Function(ffi.Pointer<LDKBestBlock>)>>(
      'BestBlock_clone');
  late final _BestBlock_clone = _BestBlock_clonePtr.asFunction<
      LDKBestBlock Function(ffi.Pointer<LDKBestBlock>)>();

  /// Constructs a `BestBlock` that represents the genesis block at height 0 of the given
  /// network.
  LDKBestBlock BestBlock_from_genesis(
    int network,
  ) {
    return _BestBlock_from_genesis(
      network,
    );
  }

  late final _BestBlock_from_genesisPtr =
      _lookup<ffi.NativeFunction<LDKBestBlock Function(ffi.Int32)>>(
          'BestBlock_from_genesis');
  late final _BestBlock_from_genesis =
      _BestBlock_from_genesisPtr.asFunction<LDKBestBlock Function(int)>();

  /// Returns a `BestBlock` as identified by the given block hash and height.
  LDKBestBlock BestBlock_new(
    LDKThirtyTwoBytes block_hash,
    int height,
  ) {
    return _BestBlock_new(
      block_hash,
      height,
    );
  }

  late final _BestBlock_newPtr = _lookup<
      ffi.NativeFunction<
          LDKBestBlock Function(
              LDKThirtyTwoBytes, ffi.Uint32)>>('BestBlock_new');
  late final _BestBlock_new = _BestBlock_newPtr.asFunction<
      LDKBestBlock Function(LDKThirtyTwoBytes, int)>();

  /// Returns the best block hash.
  LDKThirtyTwoBytes BestBlock_block_hash(
    ffi.Pointer<LDKBestBlock> this_arg,
  ) {
    return _BestBlock_block_hash(
      this_arg,
    );
  }

  late final _BestBlock_block_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKBestBlock>)>>('BestBlock_block_hash');
  late final _BestBlock_block_hash = _BestBlock_block_hashPtr.asFunction<
      LDKThirtyTwoBytes Function(ffi.Pointer<LDKBestBlock>)>();

  /// Returns the best block height.
  int BestBlock_height(
    ffi.Pointer<LDKBestBlock> this_arg,
  ) {
    return _BestBlock_height(
      this_arg,
    );
  }

  late final _BestBlock_heightPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKBestBlock>)>>(
      'BestBlock_height');
  late final _BestBlock_height = _BestBlock_heightPtr.asFunction<
      int Function(ffi.Pointer<LDKBestBlock>)>();

  /// Creates a copy of the AccessError
  int AccessError_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _AccessError_clone(
      orig,
    );
  }

  late final _AccessError_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'AccessError_clone');
  late final _AccessError_clone =
      _AccessError_clonePtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new UnknownChain-variant AccessError
  int AccessError_unknown_chain() {
    return _AccessError_unknown_chain();
  }

  late final _AccessError_unknown_chainPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'AccessError_unknown_chain');
  late final _AccessError_unknown_chain =
      _AccessError_unknown_chainPtr.asFunction<int Function()>();

  /// Utility method to constructs a new UnknownTx-variant AccessError
  int AccessError_unknown_tx() {
    return _AccessError_unknown_tx();
  }

  late final _AccessError_unknown_txPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'AccessError_unknown_tx');
  late final _AccessError_unknown_tx =
      _AccessError_unknown_txPtr.asFunction<int Function()>();

  /// Calls the free function if one is set
  void Access_free(
    LDKAccess this_ptr,
  ) {
    return _Access_free(
      this_ptr,
    );
  }

  late final _Access_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKAccess)>>('Access_free');
  late final _Access_free =
      _Access_freePtr.asFunction<void Function(LDKAccess)>();

  /// Calls the free function if one is set
  void Listen_free(
    LDKListen this_ptr,
  ) {
    return _Listen_free(
      this_ptr,
    );
  }

  late final _Listen_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKListen)>>('Listen_free');
  late final _Listen_free =
      _Listen_freePtr.asFunction<void Function(LDKListen)>();

  /// Calls the free function if one is set
  void Confirm_free(
    LDKConfirm this_ptr,
  ) {
    return _Confirm_free(
      this_ptr,
    );
  }

  late final _Confirm_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKConfirm)>>(
          'Confirm_free');
  late final _Confirm_free =
      _Confirm_freePtr.asFunction<void Function(LDKConfirm)>();

  /// Creates a copy of the ChannelMonitorUpdateErr
  int ChannelMonitorUpdateErr_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _ChannelMonitorUpdateErr_clone(
      orig,
    );
  }

  late final _ChannelMonitorUpdateErr_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'ChannelMonitorUpdateErr_clone');
  late final _ChannelMonitorUpdateErr_clone = _ChannelMonitorUpdateErr_clonePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new TemporaryFailure-variant ChannelMonitorUpdateErr
  int ChannelMonitorUpdateErr_temporary_failure() {
    return _ChannelMonitorUpdateErr_temporary_failure();
  }

  late final _ChannelMonitorUpdateErr_temporary_failurePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'ChannelMonitorUpdateErr_temporary_failure');
  late final _ChannelMonitorUpdateErr_temporary_failure =
      _ChannelMonitorUpdateErr_temporary_failurePtr.asFunction<
          int Function()>();

  /// Utility method to constructs a new PermanentFailure-variant ChannelMonitorUpdateErr
  int ChannelMonitorUpdateErr_permanent_failure() {
    return _ChannelMonitorUpdateErr_permanent_failure();
  }

  late final _ChannelMonitorUpdateErr_permanent_failurePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'ChannelMonitorUpdateErr_permanent_failure');
  late final _ChannelMonitorUpdateErr_permanent_failure =
      _ChannelMonitorUpdateErr_permanent_failurePtr.asFunction<
          int Function()>();

  /// Calls the free function if one is set
  void Watch_free(
    LDKWatch this_ptr,
  ) {
    return _Watch_free(
      this_ptr,
    );
  }

  late final _Watch_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKWatch)>>('Watch_free');
  late final _Watch_free = _Watch_freePtr.asFunction<void Function(LDKWatch)>();

  /// Calls the free function if one is set
  void Filter_free(
    LDKFilter this_ptr,
  ) {
    return _Filter_free(
      this_ptr,
    );
  }

  late final _Filter_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFilter)>>('Filter_free');
  late final _Filter_free =
      _Filter_freePtr.asFunction<void Function(LDKFilter)>();

  /// Frees any resources used by the WatchedOutput, if is_owned is set and inner is non-NULL.
  void WatchedOutput_free(
    LDKWatchedOutput this_obj,
  ) {
    return _WatchedOutput_free(
      this_obj,
    );
  }

  late final _WatchedOutput_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKWatchedOutput)>>(
          'WatchedOutput_free');
  late final _WatchedOutput_free =
      _WatchedOutput_freePtr.asFunction<void Function(LDKWatchedOutput)>();

  /// First block where the transaction output may have been spent.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKThirtyTwoBytes WatchedOutput_get_block_hash(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
  ) {
    return _WatchedOutput_get_block_hash(
      this_ptr,
    );
  }

  late final _WatchedOutput_get_block_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKWatchedOutput>)>>('WatchedOutput_get_block_hash');
  late final _WatchedOutput_get_block_hash = _WatchedOutput_get_block_hashPtr
      .asFunction<LDKThirtyTwoBytes Function(ffi.Pointer<LDKWatchedOutput>)>();

  /// First block where the transaction output may have been spent.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void WatchedOutput_set_block_hash(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _WatchedOutput_set_block_hash(
      this_ptr,
      val,
    );
  }

  late final _WatchedOutput_set_block_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKWatchedOutput>,
              LDKThirtyTwoBytes)>>('WatchedOutput_set_block_hash');
  late final _WatchedOutput_set_block_hash =
      _WatchedOutput_set_block_hashPtr.asFunction<
          void Function(ffi.Pointer<LDKWatchedOutput>, LDKThirtyTwoBytes)>();

  /// Outpoint identifying the transaction output.
  LDKOutPoint WatchedOutput_get_outpoint(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
  ) {
    return _WatchedOutput_get_outpoint(
      this_ptr,
    );
  }

  late final _WatchedOutput_get_outpointPtr = _lookup<
      ffi.NativeFunction<
          LDKOutPoint Function(
              ffi.Pointer<LDKWatchedOutput>)>>('WatchedOutput_get_outpoint');
  late final _WatchedOutput_get_outpoint = _WatchedOutput_get_outpointPtr
      .asFunction<LDKOutPoint Function(ffi.Pointer<LDKWatchedOutput>)>();

  /// Outpoint identifying the transaction output.
  void WatchedOutput_set_outpoint(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
    LDKOutPoint val,
  ) {
    return _WatchedOutput_set_outpoint(
      this_ptr,
      val,
    );
  }

  late final _WatchedOutput_set_outpointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKWatchedOutput>,
              LDKOutPoint)>>('WatchedOutput_set_outpoint');
  late final _WatchedOutput_set_outpoint = _WatchedOutput_set_outpointPtr
      .asFunction<void Function(ffi.Pointer<LDKWatchedOutput>, LDKOutPoint)>();

  /// Spending condition of the transaction output.
  LDKu8slice WatchedOutput_get_script_pubkey(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
  ) {
    return _WatchedOutput_get_script_pubkey(
      this_ptr,
    );
  }

  late final _WatchedOutput_get_script_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKu8slice Function(ffi.Pointer<LDKWatchedOutput>)>>(
      'WatchedOutput_get_script_pubkey');
  late final _WatchedOutput_get_script_pubkey =
      _WatchedOutput_get_script_pubkeyPtr.asFunction<
          LDKu8slice Function(ffi.Pointer<LDKWatchedOutput>)>();

  /// Spending condition of the transaction output.
  void WatchedOutput_set_script_pubkey(
    ffi.Pointer<LDKWatchedOutput> this_ptr,
    LDKCVec_u8Z val,
  ) {
    return _WatchedOutput_set_script_pubkey(
      this_ptr,
      val,
    );
  }

  late final _WatchedOutput_set_script_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKWatchedOutput>,
              LDKCVec_u8Z)>>('WatchedOutput_set_script_pubkey');
  late final _WatchedOutput_set_script_pubkey =
      _WatchedOutput_set_script_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKWatchedOutput>, LDKCVec_u8Z)>();

  /// Constructs a new WatchedOutput given each field
  LDKWatchedOutput WatchedOutput_new(
    LDKThirtyTwoBytes block_hash_arg,
    LDKOutPoint outpoint_arg,
    LDKCVec_u8Z script_pubkey_arg,
  ) {
    return _WatchedOutput_new(
      block_hash_arg,
      outpoint_arg,
      script_pubkey_arg,
    );
  }

  late final _WatchedOutput_newPtr = _lookup<
      ffi.NativeFunction<
          LDKWatchedOutput Function(LDKThirtyTwoBytes, LDKOutPoint,
              LDKCVec_u8Z)>>('WatchedOutput_new');
  late final _WatchedOutput_new = _WatchedOutput_newPtr.asFunction<
      LDKWatchedOutput Function(LDKThirtyTwoBytes, LDKOutPoint, LDKCVec_u8Z)>();

  /// Creates a copy of the WatchedOutput
  LDKWatchedOutput WatchedOutput_clone(
    ffi.Pointer<LDKWatchedOutput> orig,
  ) {
    return _WatchedOutput_clone(
      orig,
    );
  }

  late final _WatchedOutput_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKWatchedOutput Function(
              ffi.Pointer<LDKWatchedOutput>)>>('WatchedOutput_clone');
  late final _WatchedOutput_clone = _WatchedOutput_clonePtr.asFunction<
      LDKWatchedOutput Function(ffi.Pointer<LDKWatchedOutput>)>();

  /// Checks if two WatchedOutputs contain equal inner contents.
  int WatchedOutput_hash(
    ffi.Pointer<LDKWatchedOutput> o,
  ) {
    return _WatchedOutput_hash(
      o,
    );
  }

  late final _WatchedOutput_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKWatchedOutput>)>>('WatchedOutput_hash');
  late final _WatchedOutput_hash = _WatchedOutput_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKWatchedOutput>)>();

  /// Calls the free function if one is set
  void BroadcasterInterface_free(
    LDKBroadcasterInterface this_ptr,
  ) {
    return _BroadcasterInterface_free(
      this_ptr,
    );
  }

  late final _BroadcasterInterface_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBroadcasterInterface)>>(
          'BroadcasterInterface_free');
  late final _BroadcasterInterface_free = _BroadcasterInterface_freePtr
      .asFunction<void Function(LDKBroadcasterInterface)>();

  /// Creates a copy of the ConfirmationTarget
  int ConfirmationTarget_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _ConfirmationTarget_clone(
      orig,
    );
  }

  late final _ConfirmationTarget_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'ConfirmationTarget_clone');
  late final _ConfirmationTarget_clone = _ConfirmationTarget_clonePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new Background-variant ConfirmationTarget
  int ConfirmationTarget_background() {
    return _ConfirmationTarget_background();
  }

  late final _ConfirmationTarget_backgroundPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'ConfirmationTarget_background');
  late final _ConfirmationTarget_background =
      _ConfirmationTarget_backgroundPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Normal-variant ConfirmationTarget
  int ConfirmationTarget_normal() {
    return _ConfirmationTarget_normal();
  }

  late final _ConfirmationTarget_normalPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'ConfirmationTarget_normal');
  late final _ConfirmationTarget_normal =
      _ConfirmationTarget_normalPtr.asFunction<int Function()>();

  /// Utility method to constructs a new HighPriority-variant ConfirmationTarget
  int ConfirmationTarget_high_priority() {
    return _ConfirmationTarget_high_priority();
  }

  late final _ConfirmationTarget_high_priorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'ConfirmationTarget_high_priority');
  late final _ConfirmationTarget_high_priority =
      _ConfirmationTarget_high_priorityPtr.asFunction<int Function()>();

  /// Checks if two ConfirmationTargets contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool ConfirmationTarget_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _ConfirmationTarget_eq(
      a,
      b,
    );
  }

  late final _ConfirmationTarget_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('ConfirmationTarget_eq');
  late final _ConfirmationTarget_eq = _ConfirmationTarget_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Calls the free function if one is set
  void FeeEstimator_free(
    LDKFeeEstimator this_ptr,
  ) {
    return _FeeEstimator_free(
      this_ptr,
    );
  }

  late final _FeeEstimator_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFeeEstimator)>>(
          'FeeEstimator_free');
  late final _FeeEstimator_free =
      _FeeEstimator_freePtr.asFunction<void Function(LDKFeeEstimator)>();

  /// Frees any resources used by the MonitorUpdateId, if is_owned is set and inner is non-NULL.
  void MonitorUpdateId_free(
    LDKMonitorUpdateId this_obj,
  ) {
    return _MonitorUpdateId_free(
      this_obj,
    );
  }

  late final _MonitorUpdateId_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKMonitorUpdateId)>>(
          'MonitorUpdateId_free');
  late final _MonitorUpdateId_free =
      _MonitorUpdateId_freePtr.asFunction<void Function(LDKMonitorUpdateId)>();

  /// Creates a copy of the MonitorUpdateId
  LDKMonitorUpdateId MonitorUpdateId_clone(
    ffi.Pointer<LDKMonitorUpdateId> orig,
  ) {
    return _MonitorUpdateId_clone(
      orig,
    );
  }

  late final _MonitorUpdateId_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKMonitorUpdateId Function(
              ffi.Pointer<LDKMonitorUpdateId>)>>('MonitorUpdateId_clone');
  late final _MonitorUpdateId_clone = _MonitorUpdateId_clonePtr.asFunction<
      LDKMonitorUpdateId Function(ffi.Pointer<LDKMonitorUpdateId>)>();

  /// Checks if two MonitorUpdateIds contain equal inner contents.
  int MonitorUpdateId_hash(
    ffi.Pointer<LDKMonitorUpdateId> o,
  ) {
    return _MonitorUpdateId_hash(
      o,
    );
  }

  late final _MonitorUpdateId_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKMonitorUpdateId>)>>('MonitorUpdateId_hash');
  late final _MonitorUpdateId_hash = _MonitorUpdateId_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKMonitorUpdateId>)>();

  /// Checks if two MonitorUpdateIds contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool MonitorUpdateId_eq(
    ffi.Pointer<LDKMonitorUpdateId> a,
    ffi.Pointer<LDKMonitorUpdateId> b,
  ) {
    return _MonitorUpdateId_eq(
      a,
      b,
    );
  }

  late final _MonitorUpdateId_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKMonitorUpdateId>,
              ffi.Pointer<LDKMonitorUpdateId>)>>('MonitorUpdateId_eq');
  late final _MonitorUpdateId_eq = _MonitorUpdateId_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKMonitorUpdateId>, ffi.Pointer<LDKMonitorUpdateId>)>();

  /// Calls the free function if one is set
  void Persist_free(
    LDKPersist this_ptr,
  ) {
    return _Persist_free(
      this_ptr,
    );
  }

  late final _Persist_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPersist)>>(
          'Persist_free');
  late final _Persist_free =
      _Persist_freePtr.asFunction<void Function(LDKPersist)>();

  /// Frees any resources used by the LockedChannelMonitor, if is_owned is set and inner is non-NULL.
  void LockedChannelMonitor_free(
    LDKLockedChannelMonitor this_obj,
  ) {
    return _LockedChannelMonitor_free(
      this_obj,
    );
  }

  late final _LockedChannelMonitor_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKLockedChannelMonitor)>>(
          'LockedChannelMonitor_free');
  late final _LockedChannelMonitor_free = _LockedChannelMonitor_freePtr
      .asFunction<void Function(LDKLockedChannelMonitor)>();

  /// Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
  void ChainMonitor_free(
    LDKChainMonitor this_obj,
  ) {
    return _ChainMonitor_free(
      this_obj,
    );
  }

  late final _ChainMonitor_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChainMonitor)>>(
          'ChainMonitor_free');
  late final _ChainMonitor_free =
      _ChainMonitor_freePtr.asFunction<void Function(LDKChainMonitor)>();

  /// Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
  ///
  /// When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
  /// will call back to it indicating transactions and outputs of interest. This allows clients to
  /// pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
  /// always need to fetch full blocks absent another means for determining which blocks contain
  /// transactions relevant to the watched channels.
  LDKChainMonitor ChainMonitor_new(
    LDKCOption_FilterZ chain_source,
    LDKBroadcasterInterface broadcaster,
    LDKLogger logger,
    LDKFeeEstimator feeest,
    LDKPersist persister,
  ) {
    return _ChainMonitor_new(
      chain_source,
      broadcaster,
      logger,
      feeest,
      persister,
    );
  }

  late final _ChainMonitor_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChainMonitor Function(LDKCOption_FilterZ, LDKBroadcasterInterface,
              LDKLogger, LDKFeeEstimator, LDKPersist)>>('ChainMonitor_new');
  late final _ChainMonitor_new = _ChainMonitor_newPtr.asFunction<
      LDKChainMonitor Function(LDKCOption_FilterZ, LDKBroadcasterInterface,
          LDKLogger, LDKFeeEstimator, LDKPersist)>();

  /// Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
  /// claims which are awaiting confirmation.
  ///
  /// Includes the balances from each [`ChannelMonitor`] *except* those included in
  /// `ignored_channels`, allowing you to filter out balances from channels which are still open
  /// (and whose balance should likely be pulled from the [`ChannelDetails`]).
  ///
  /// See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
  /// inclusion in the return value.
  LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(
    ffi.Pointer<LDKChainMonitor> this_arg,
    LDKCVec_ChannelDetailsZ ignored_channels,
  ) {
    return _ChainMonitor_get_claimable_balances(
      this_arg,
      ignored_channels,
    );
  }

  late final _ChainMonitor_get_claimable_balancesPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_BalanceZ Function(ffi.Pointer<LDKChainMonitor>,
              LDKCVec_ChannelDetailsZ)>>('ChainMonitor_get_claimable_balances');
  late final _ChainMonitor_get_claimable_balances =
      _ChainMonitor_get_claimable_balancesPtr.asFunction<
          LDKCVec_BalanceZ Function(
              ffi.Pointer<LDKChainMonitor>, LDKCVec_ChannelDetailsZ)>();

  /// Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
  /// such [`ChannelMonitor`] is currently being monitored for.
  ///
  /// Note that the result holds a mutex over our monitor set, and should not be held
  /// indefinitely.
  LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(
    ffi.Pointer<LDKChainMonitor> this_arg,
    LDKOutPoint funding_txo,
  ) {
    return _ChainMonitor_get_monitor(
      this_arg,
      funding_txo,
    );
  }

  late final _ChainMonitor_get_monitorPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_LockedChannelMonitorNoneZ Function(
              ffi.Pointer<LDKChainMonitor>,
              LDKOutPoint)>>('ChainMonitor_get_monitor');
  late final _ChainMonitor_get_monitor =
      _ChainMonitor_get_monitorPtr.asFunction<
          LDKCResult_LockedChannelMonitorNoneZ Function(
              ffi.Pointer<LDKChainMonitor>, LDKOutPoint)>();

  /// Lists the funding outpoint of each [`ChannelMonitor`] being monitored.
  ///
  /// Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
  /// monitoring for on-chain state resolutions.
  LDKCVec_OutPointZ ChainMonitor_list_monitors(
    ffi.Pointer<LDKChainMonitor> this_arg,
  ) {
    return _ChainMonitor_list_monitors(
      this_arg,
    );
  }

  late final _ChainMonitor_list_monitorsPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_OutPointZ Function(
              ffi.Pointer<LDKChainMonitor>)>>('ChainMonitor_list_monitors');
  late final _ChainMonitor_list_monitors = _ChainMonitor_list_monitorsPtr
      .asFunction<LDKCVec_OutPointZ Function(ffi.Pointer<LDKChainMonitor>)>();

  /// Indicates the persistence of a [`ChannelMonitor`] has completed after
  /// [`ChannelMonitorUpdateErr::TemporaryFailure`] was returned from an update operation.
  ///
  /// Thus, the anticipated use is, at a high level:
  /// 1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
  /// update to disk and begins updating any remote (e.g. watchtower/backup) copies,
  /// returning [`ChannelMonitorUpdateErr::TemporaryFailure`],
  /// 2) once all remote copies are updated, you call this function with the
  /// `completed_update_id` that completed, and once all pending updates have completed the
  /// channel will be re-enabled.
  ///
  /// Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
  /// registered [`ChannelMonitor`]s.
  LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(
    ffi.Pointer<LDKChainMonitor> this_arg,
    LDKOutPoint funding_txo,
    LDKMonitorUpdateId completed_update_id,
  ) {
    return _ChainMonitor_channel_monitor_updated(
      this_arg,
      funding_txo,
      completed_update_id,
    );
  }

  late final _ChainMonitor_channel_monitor_updatedPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChainMonitor>,
              LDKOutPoint,
              LDKMonitorUpdateId)>>('ChainMonitor_channel_monitor_updated');
  late final _ChainMonitor_channel_monitor_updated =
      _ChainMonitor_channel_monitor_updatedPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChainMonitor>, LDKOutPoint, LDKMonitorUpdateId)>();

  /// Constructs a new Listen which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
  LDKListen ChainMonitor_as_Listen(
    ffi.Pointer<LDKChainMonitor> this_arg,
  ) {
    return _ChainMonitor_as_Listen(
      this_arg,
    );
  }

  late final _ChainMonitor_as_ListenPtr = _lookup<
          ffi.NativeFunction<LDKListen Function(ffi.Pointer<LDKChainMonitor>)>>(
      'ChainMonitor_as_Listen');
  late final _ChainMonitor_as_Listen = _ChainMonitor_as_ListenPtr.asFunction<
      LDKListen Function(ffi.Pointer<LDKChainMonitor>)>();

  /// Constructs a new Confirm which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
  LDKConfirm ChainMonitor_as_Confirm(
    ffi.Pointer<LDKChainMonitor> this_arg,
  ) {
    return _ChainMonitor_as_Confirm(
      this_arg,
    );
  }

  late final _ChainMonitor_as_ConfirmPtr = _lookup<
      ffi.NativeFunction<
          LDKConfirm Function(
              ffi.Pointer<LDKChainMonitor>)>>('ChainMonitor_as_Confirm');
  late final _ChainMonitor_as_Confirm = _ChainMonitor_as_ConfirmPtr.asFunction<
      LDKConfirm Function(ffi.Pointer<LDKChainMonitor>)>();

  /// Constructs a new Watch which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
  LDKWatch ChainMonitor_as_Watch(
    ffi.Pointer<LDKChainMonitor> this_arg,
  ) {
    return _ChainMonitor_as_Watch(
      this_arg,
    );
  }

  late final _ChainMonitor_as_WatchPtr = _lookup<
          ffi.NativeFunction<LDKWatch Function(ffi.Pointer<LDKChainMonitor>)>>(
      'ChainMonitor_as_Watch');
  late final _ChainMonitor_as_Watch = _ChainMonitor_as_WatchPtr.asFunction<
      LDKWatch Function(ffi.Pointer<LDKChainMonitor>)>();

  /// Constructs a new EventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
  LDKEventsProvider ChainMonitor_as_EventsProvider(
    ffi.Pointer<LDKChainMonitor> this_arg,
  ) {
    return _ChainMonitor_as_EventsProvider(
      this_arg,
    );
  }

  late final _ChainMonitor_as_EventsProviderPtr = _lookup<
      ffi.NativeFunction<
          LDKEventsProvider Function(
              ffi.Pointer<LDKChainMonitor>)>>('ChainMonitor_as_EventsProvider');
  late final _ChainMonitor_as_EventsProvider =
      _ChainMonitor_as_EventsProviderPtr.asFunction<
          LDKEventsProvider Function(ffi.Pointer<LDKChainMonitor>)>();

  /// Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
  void ChannelMonitorUpdate_free(
    LDKChannelMonitorUpdate this_obj,
  ) {
    return _ChannelMonitorUpdate_free(
      this_obj,
    );
  }

  late final _ChannelMonitorUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelMonitorUpdate)>>(
          'ChannelMonitorUpdate_free');
  late final _ChannelMonitorUpdate_free = _ChannelMonitorUpdate_freePtr
      .asFunction<void Function(LDKChannelMonitorUpdate)>();

  /// The sequence number of this update. Updates *must* be replayed in-order according to this
  /// sequence number (and updates may panic if they are not). The update_id values are strictly
  /// increasing and increase by one for each new update, with one exception specified below.
  ///
  /// This sequence number is also used to track up to which points updates which returned
  /// ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
  /// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
  ///
  /// The only instance where update_id values are not strictly increasing is the case where we
  /// allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
  /// its docs for more details.
  int ChannelMonitorUpdate_get_update_id(
    ffi.Pointer<LDKChannelMonitorUpdate> this_ptr,
  ) {
    return _ChannelMonitorUpdate_get_update_id(
      this_ptr,
    );
  }

  late final _ChannelMonitorUpdate_get_update_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelMonitorUpdate>)>>(
      'ChannelMonitorUpdate_get_update_id');
  late final _ChannelMonitorUpdate_get_update_id =
      _ChannelMonitorUpdate_get_update_idPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelMonitorUpdate>)>();

  /// The sequence number of this update. Updates *must* be replayed in-order according to this
  /// sequence number (and updates may panic if they are not). The update_id values are strictly
  /// increasing and increase by one for each new update, with one exception specified below.
  ///
  /// This sequence number is also used to track up to which points updates which returned
  /// ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
  /// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
  ///
  /// The only instance where update_id values are not strictly increasing is the case where we
  /// allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
  /// its docs for more details.
  void ChannelMonitorUpdate_set_update_id(
    ffi.Pointer<LDKChannelMonitorUpdate> this_ptr,
    int val,
  ) {
    return _ChannelMonitorUpdate_set_update_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelMonitorUpdate_set_update_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelMonitorUpdate>,
              ffi.Uint64)>>('ChannelMonitorUpdate_set_update_id');
  late final _ChannelMonitorUpdate_set_update_id =
      _ChannelMonitorUpdate_set_update_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelMonitorUpdate>, int)>();

  /// Creates a copy of the ChannelMonitorUpdate
  LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(
    ffi.Pointer<LDKChannelMonitorUpdate> orig,
  ) {
    return _ChannelMonitorUpdate_clone(
      orig,
    );
  }

  late final _ChannelMonitorUpdate_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelMonitorUpdate Function(
                  ffi.Pointer<LDKChannelMonitorUpdate>)>>(
      'ChannelMonitorUpdate_clone');
  late final _ChannelMonitorUpdate_clone =
      _ChannelMonitorUpdate_clonePtr.asFunction<
          LDKChannelMonitorUpdate Function(
              ffi.Pointer<LDKChannelMonitorUpdate>)>();

  /// Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
  LDKCVec_u8Z ChannelMonitorUpdate_write(
    ffi.Pointer<LDKChannelMonitorUpdate> obj,
  ) {
    return _ChannelMonitorUpdate_write(
      obj,
    );
  }

  late final _ChannelMonitorUpdate_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKChannelMonitorUpdate>)>>(
      'ChannelMonitorUpdate_write');
  late final _ChannelMonitorUpdate_write = _ChannelMonitorUpdate_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKChannelMonitorUpdate>)>();

  /// Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
  LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(
    LDKu8slice ser,
  ) {
    return _ChannelMonitorUpdate_read(
      ser,
    );
  }

  late final _ChannelMonitorUpdate_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(
              LDKu8slice)>>('ChannelMonitorUpdate_read');
  late final _ChannelMonitorUpdate_read =
      _ChannelMonitorUpdate_readPtr.asFunction<
          LDKCResult_ChannelMonitorUpdateDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the MonitorEvent
  void MonitorEvent_free(
    LDKMonitorEvent this_ptr,
  ) {
    return _MonitorEvent_free(
      this_ptr,
    );
  }

  late final _MonitorEvent_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKMonitorEvent)>>(
          'MonitorEvent_free');
  late final _MonitorEvent_free =
      _MonitorEvent_freePtr.asFunction<void Function(LDKMonitorEvent)>();

  /// Creates a copy of the MonitorEvent
  LDKMonitorEvent MonitorEvent_clone(
    ffi.Pointer<LDKMonitorEvent> orig,
  ) {
    return _MonitorEvent_clone(
      orig,
    );
  }

  late final _MonitorEvent_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKMonitorEvent Function(
              ffi.Pointer<LDKMonitorEvent>)>>('MonitorEvent_clone');
  late final _MonitorEvent_clone = _MonitorEvent_clonePtr.asFunction<
      LDKMonitorEvent Function(ffi.Pointer<LDKMonitorEvent>)>();

  /// Utility method to constructs a new HTLCEvent-variant MonitorEvent
  LDKMonitorEvent MonitorEvent_htlcevent(
    LDKHTLCUpdate a,
  ) {
    return _MonitorEvent_htlcevent(
      a,
    );
  }

  late final _MonitorEvent_htlceventPtr =
      _lookup<ffi.NativeFunction<LDKMonitorEvent Function(LDKHTLCUpdate)>>(
          'MonitorEvent_htlcevent');
  late final _MonitorEvent_htlcevent = _MonitorEvent_htlceventPtr.asFunction<
      LDKMonitorEvent Function(LDKHTLCUpdate)>();

  /// Utility method to constructs a new CommitmentTxConfirmed-variant MonitorEvent
  LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(
    LDKOutPoint a,
  ) {
    return _MonitorEvent_commitment_tx_confirmed(
      a,
    );
  }

  late final _MonitorEvent_commitment_tx_confirmedPtr =
      _lookup<ffi.NativeFunction<LDKMonitorEvent Function(LDKOutPoint)>>(
          'MonitorEvent_commitment_tx_confirmed');
  late final _MonitorEvent_commitment_tx_confirmed =
      _MonitorEvent_commitment_tx_confirmedPtr.asFunction<
          LDKMonitorEvent Function(LDKOutPoint)>();

  /// Utility method to constructs a new UpdateCompleted-variant MonitorEvent
  LDKMonitorEvent MonitorEvent_update_completed(
    LDKOutPoint funding_txo,
    int monitor_update_id,
  ) {
    return _MonitorEvent_update_completed(
      funding_txo,
      monitor_update_id,
    );
  }

  late final _MonitorEvent_update_completedPtr = _lookup<
      ffi.NativeFunction<
          LDKMonitorEvent Function(
              LDKOutPoint, ffi.Uint64)>>('MonitorEvent_update_completed');
  late final _MonitorEvent_update_completed = _MonitorEvent_update_completedPtr
      .asFunction<LDKMonitorEvent Function(LDKOutPoint, int)>();

  /// Utility method to constructs a new UpdateFailed-variant MonitorEvent
  LDKMonitorEvent MonitorEvent_update_failed(
    LDKOutPoint a,
  ) {
    return _MonitorEvent_update_failed(
      a,
    );
  }

  late final _MonitorEvent_update_failedPtr =
      _lookup<ffi.NativeFunction<LDKMonitorEvent Function(LDKOutPoint)>>(
          'MonitorEvent_update_failed');
  late final _MonitorEvent_update_failed = _MonitorEvent_update_failedPtr
      .asFunction<LDKMonitorEvent Function(LDKOutPoint)>();

  /// Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
  LDKCVec_u8Z MonitorEvent_write(
    ffi.Pointer<LDKMonitorEvent> obj,
  ) {
    return _MonitorEvent_write(
      obj,
    );
  }

  late final _MonitorEvent_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKMonitorEvent>)>>('MonitorEvent_write');
  late final _MonitorEvent_write = _MonitorEvent_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKMonitorEvent>)>();

  /// Read a MonitorEvent from a byte array, created by MonitorEvent_write
  LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(
    LDKu8slice ser,
  ) {
    return _MonitorEvent_read(
      ser,
    );
  }

  late final _MonitorEvent_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_MonitorEventZDecodeErrorZ Function(
              LDKu8slice)>>('MonitorEvent_read');
  late final _MonitorEvent_read = _MonitorEvent_readPtr.asFunction<
      LDKCResult_COption_MonitorEventZDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
  void HTLCUpdate_free(
    LDKHTLCUpdate this_obj,
  ) {
    return _HTLCUpdate_free(
      this_obj,
    );
  }

  late final _HTLCUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKHTLCUpdate)>>(
          'HTLCUpdate_free');
  late final _HTLCUpdate_free =
      _HTLCUpdate_freePtr.asFunction<void Function(LDKHTLCUpdate)>();

  /// Creates a copy of the HTLCUpdate
  LDKHTLCUpdate HTLCUpdate_clone(
    ffi.Pointer<LDKHTLCUpdate> orig,
  ) {
    return _HTLCUpdate_clone(
      orig,
    );
  }

  late final _HTLCUpdate_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKHTLCUpdate Function(
              ffi.Pointer<LDKHTLCUpdate>)>>('HTLCUpdate_clone');
  late final _HTLCUpdate_clone = _HTLCUpdate_clonePtr.asFunction<
      LDKHTLCUpdate Function(ffi.Pointer<LDKHTLCUpdate>)>();

  /// Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
  LDKCVec_u8Z HTLCUpdate_write(
    ffi.Pointer<LDKHTLCUpdate> obj,
  ) {
    return _HTLCUpdate_write(
      obj,
    );
  }

  late final _HTLCUpdate_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCUpdate>)>>(
      'HTLCUpdate_write');
  late final _HTLCUpdate_write = _HTLCUpdate_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCUpdate>)>();

  /// Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
  LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(
    LDKu8slice ser,
  ) {
    return _HTLCUpdate_read(
      ser,
    );
  }

  late final _HTLCUpdate_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_HTLCUpdateDecodeErrorZ Function(
              LDKu8slice)>>('HTLCUpdate_read');
  late final _HTLCUpdate_read = _HTLCUpdate_readPtr.asFunction<
      LDKCResult_HTLCUpdateDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the Balance
  void Balance_free(
    LDKBalance this_ptr,
  ) {
    return _Balance_free(
      this_ptr,
    );
  }

  late final _Balance_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBalance)>>(
          'Balance_free');
  late final _Balance_free =
      _Balance_freePtr.asFunction<void Function(LDKBalance)>();

  /// Creates a copy of the Balance
  LDKBalance Balance_clone(
    ffi.Pointer<LDKBalance> orig,
  ) {
    return _Balance_clone(
      orig,
    );
  }

  late final _Balance_clonePtr =
      _lookup<ffi.NativeFunction<LDKBalance Function(ffi.Pointer<LDKBalance>)>>(
          'Balance_clone');
  late final _Balance_clone = _Balance_clonePtr.asFunction<
      LDKBalance Function(ffi.Pointer<LDKBalance>)>();

  /// Utility method to constructs a new ClaimableOnChannelClose-variant Balance
  LDKBalance Balance_claimable_on_channel_close(
    int claimable_amount_satoshis,
  ) {
    return _Balance_claimable_on_channel_close(
      claimable_amount_satoshis,
    );
  }

  late final _Balance_claimable_on_channel_closePtr =
      _lookup<ffi.NativeFunction<LDKBalance Function(ffi.Uint64)>>(
          'Balance_claimable_on_channel_close');
  late final _Balance_claimable_on_channel_close =
      _Balance_claimable_on_channel_closePtr.asFunction<
          LDKBalance Function(int)>();

  /// Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
  LDKBalance Balance_claimable_awaiting_confirmations(
    int claimable_amount_satoshis,
    int confirmation_height,
  ) {
    return _Balance_claimable_awaiting_confirmations(
      claimable_amount_satoshis,
      confirmation_height,
    );
  }

  late final _Balance_claimable_awaiting_confirmationsPtr =
      _lookup<ffi.NativeFunction<LDKBalance Function(ffi.Uint64, ffi.Uint32)>>(
          'Balance_claimable_awaiting_confirmations');
  late final _Balance_claimable_awaiting_confirmations =
      _Balance_claimable_awaiting_confirmationsPtr.asFunction<
          LDKBalance Function(int, int)>();

  /// Utility method to constructs a new ContentiousClaimable-variant Balance
  LDKBalance Balance_contentious_claimable(
    int claimable_amount_satoshis,
    int timeout_height,
  ) {
    return _Balance_contentious_claimable(
      claimable_amount_satoshis,
      timeout_height,
    );
  }

  late final _Balance_contentious_claimablePtr =
      _lookup<ffi.NativeFunction<LDKBalance Function(ffi.Uint64, ffi.Uint32)>>(
          'Balance_contentious_claimable');
  late final _Balance_contentious_claimable = _Balance_contentious_claimablePtr
      .asFunction<LDKBalance Function(int, int)>();

  /// Utility method to constructs a new MaybeClaimableHTLCAwaitingTimeout-variant Balance
  LDKBalance Balance_maybe_claimable_htlcawaiting_timeout(
    int claimable_amount_satoshis,
    int claimable_height,
  ) {
    return _Balance_maybe_claimable_htlcawaiting_timeout(
      claimable_amount_satoshis,
      claimable_height,
    );
  }

  late final _Balance_maybe_claimable_htlcawaiting_timeoutPtr =
      _lookup<ffi.NativeFunction<LDKBalance Function(ffi.Uint64, ffi.Uint32)>>(
          'Balance_maybe_claimable_htlcawaiting_timeout');
  late final _Balance_maybe_claimable_htlcawaiting_timeout =
      _Balance_maybe_claimable_htlcawaiting_timeoutPtr.asFunction<
          LDKBalance Function(int, int)>();

  /// Checks if two Balances contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool Balance_eq(
    ffi.Pointer<LDKBalance> a,
    ffi.Pointer<LDKBalance> b,
  ) {
    return _Balance_eq(
      a,
      b,
    );
  }

  late final _Balance_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKBalance>, ffi.Pointer<LDKBalance>)>>('Balance_eq');
  late final _Balance_eq = _Balance_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKBalance>, ffi.Pointer<LDKBalance>)>();

  /// Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
  void ChannelMonitor_free(
    LDKChannelMonitor this_obj,
  ) {
    return _ChannelMonitor_free(
      this_obj,
    );
  }

  late final _ChannelMonitor_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelMonitor)>>(
          'ChannelMonitor_free');
  late final _ChannelMonitor_free =
      _ChannelMonitor_freePtr.asFunction<void Function(LDKChannelMonitor)>();

  /// Creates a copy of the ChannelMonitor
  LDKChannelMonitor ChannelMonitor_clone(
    ffi.Pointer<LDKChannelMonitor> orig,
  ) {
    return _ChannelMonitor_clone(
      orig,
    );
  }

  late final _ChannelMonitor_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelMonitor Function(
              ffi.Pointer<LDKChannelMonitor>)>>('ChannelMonitor_clone');
  late final _ChannelMonitor_clone = _ChannelMonitor_clonePtr.asFunction<
      LDKChannelMonitor Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
  LDKCVec_u8Z ChannelMonitor_write(
    ffi.Pointer<LDKChannelMonitor> obj,
  ) {
    return _ChannelMonitor_write(
      obj,
    );
  }

  late final _ChannelMonitor_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelMonitor>)>>('ChannelMonitor_write');
  late final _ChannelMonitor_write = _ChannelMonitor_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Updates a ChannelMonitor on the basis of some new information provided by the Channel
  /// itself.
  ///
  /// panics if the given update is not the next update by update_id.
  LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<LDKChannelMonitorUpdate> updates,
    ffi.Pointer<LDKBroadcasterInterface> broadcaster,
    LDKFeeEstimator fee_estimator,
    ffi.Pointer<LDKLogger> logger,
  ) {
    return _ChannelMonitor_update_monitor(
      this_arg,
      updates,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_update_monitorPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneNoneZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<LDKChannelMonitorUpdate>,
              ffi.Pointer<LDKBroadcasterInterface>,
              LDKFeeEstimator,
              ffi.Pointer<LDKLogger>)>>('ChannelMonitor_update_monitor');
  late final _ChannelMonitor_update_monitor =
      _ChannelMonitor_update_monitorPtr.asFunction<
          LDKCResult_NoneNoneZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<LDKChannelMonitorUpdate>,
              ffi.Pointer<LDKBroadcasterInterface>,
              LDKFeeEstimator,
              ffi.Pointer<LDKLogger>)>();

  /// Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
  /// ChannelMonitor.
  int ChannelMonitor_get_latest_update_id(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_latest_update_id(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_latest_update_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_latest_update_id');
  late final _ChannelMonitor_get_latest_update_id =
      _ChannelMonitor_get_latest_update_idPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
  LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_funding_txo(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_funding_txoPtr = _lookup<
          ffi.NativeFunction<
              LDKC2Tuple_OutPointScriptZ Function(
                  ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_funding_txo');
  late final _ChannelMonitor_get_funding_txo =
      _ChannelMonitor_get_funding_txoPtr.asFunction<
          LDKC2Tuple_OutPointScriptZ Function(
              ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets a list of txids, with their output scripts (in the order they appear in the
  /// transaction), which we must learn about spends of via block_connected().
  LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ
      ChannelMonitor_get_outputs_to_watch(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_outputs_to_watch(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_outputs_to_watchPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ Function(
                  ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_outputs_to_watch');
  late final _ChannelMonitor_get_outputs_to_watch =
      _ChannelMonitor_get_outputs_to_watchPtr.asFunction<
          LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ Function(
              ffi.Pointer<LDKChannelMonitor>)>();

  /// Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
  /// calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
  /// have been registered.
  void ChannelMonitor_load_outputs_to_watch(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<LDKFilter> filter,
  ) {
    return _ChannelMonitor_load_outputs_to_watch(
      this_arg,
      filter,
    );
  }

  late final _ChannelMonitor_load_outputs_to_watchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<LDKFilter>)>>('ChannelMonitor_load_outputs_to_watch');
  late final _ChannelMonitor_load_outputs_to_watch =
      _ChannelMonitor_load_outputs_to_watchPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelMonitor>, ffi.Pointer<LDKFilter>)>();

  /// Get the list of HTLCs who's status has been updated on chain. This should be called by
  /// ChannelManager via [`chain::Watch::release_pending_monitor_events`].
  LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_and_clear_pending_monitor_events(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_and_clear_pending_monitor_eventsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_MonitorEventZ Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_and_clear_pending_monitor_events');
  late final _ChannelMonitor_get_and_clear_pending_monitor_events =
      _ChannelMonitor_get_and_clear_pending_monitor_eventsPtr.asFunction<
          LDKCVec_MonitorEventZ Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets the list of pending events which were generated by previous actions, clearing the list
  /// in the process.
  ///
  /// This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
  /// EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
  /// no internal locking in ChannelMonitors.
  LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_and_clear_pending_events(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_and_clear_pending_eventsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_EventZ Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_and_clear_pending_events');
  late final _ChannelMonitor_get_and_clear_pending_events =
      _ChannelMonitor_get_and_clear_pending_eventsPtr.asFunction<
          LDKCVec_EventZ Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets the `node_id` of the counterparty for this channel.
  ///
  /// Will be `None` for channels constructed on LDK versions prior to 0.0.110 and always `Some`
  /// otherwise.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKPublicKey ChannelMonitor_get_counterparty_node_id(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_counterparty_node_id(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_counterparty_node_idPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_counterparty_node_id');
  late final _ChannelMonitor_get_counterparty_node_id =
      _ChannelMonitor_get_counterparty_node_idPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
  /// the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
  /// fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
  /// a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
  /// transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
  /// broadcast them if counterparty don't close channel with his higher commitment transaction after a
  /// substantial amount of time (a month or even a year) to get back funds. Best may be to contact
  /// out-of-band the other node operator to coordinate with him if option is available to you.
  /// In any-case, choice is up to the user.
  LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<LDKLogger> logger,
  ) {
    return _ChannelMonitor_get_latest_holder_commitment_txn(
      this_arg,
      logger,
    );
  }

  late final _ChannelMonitor_get_latest_holder_commitment_txnPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_TransactionZ Function(
                  ffi.Pointer<LDKChannelMonitor>, ffi.Pointer<LDKLogger>)>>(
      'ChannelMonitor_get_latest_holder_commitment_txn');
  late final _ChannelMonitor_get_latest_holder_commitment_txn =
      _ChannelMonitor_get_latest_holder_commitment_txnPtr.asFunction<
          LDKCVec_TransactionZ Function(
              ffi.Pointer<LDKChannelMonitor>, ffi.Pointer<LDKLogger>)>();

  /// Processes transactions in a newly connected block, which may result in any of the following:
  /// - update the monitor's state against resolved HTLCs
  /// - punish the counterparty in the case of seeing a revoked commitment transaction
  /// - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
  /// - detect settled outputs for later spending
  /// - schedule and bump any in-flight claims
  ///
  /// Returns any new outputs to watch from `txdata`; after called, these are also included in
  /// [`get_outputs_to_watch`].
  ///
  /// [`get_outputs_to_watch`]: #method.get_outputs_to_watch
  LDKCVec_TransactionOutputsZ ChannelMonitor_block_connected(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> header,
    LDKCVec_C2Tuple_usizeTransactionZZ txdata,
    int height,
    LDKBroadcasterInterface broadcaster,
    LDKFeeEstimator fee_estimator,
    LDKLogger logger,
  ) {
    return _ChannelMonitor_block_connected(
      this_arg,
      header,
      txdata,
      height,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_block_connectedPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              ffi.Uint32,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>>('ChannelMonitor_block_connected');
  late final _ChannelMonitor_block_connected =
      _ChannelMonitor_block_connectedPtr.asFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              int,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>();

  /// Determines if the disconnected block contained any transactions of interest and updates
  /// appropriately.
  void ChannelMonitor_block_disconnected(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> header,
    int height,
    LDKBroadcasterInterface broadcaster,
    LDKFeeEstimator fee_estimator,
    LDKLogger logger,
  ) {
    return _ChannelMonitor_block_disconnected(
      this_arg,
      header,
      height,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_block_disconnectedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint32,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>>('ChannelMonitor_block_disconnected');
  late final _ChannelMonitor_block_disconnected =
      _ChannelMonitor_block_disconnectedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              int,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>();

  /// Processes transactions confirmed in a block with the given header and height, returning new
  /// outputs to watch. See [`block_connected`] for details.
  ///
  /// Used instead of [`block_connected`] by clients that are notified of transactions rather than
  /// blocks. See [`chain::Confirm`] for calling expectations.
  ///
  /// [`block_connected`]: Self::block_connected
  LDKCVec_TransactionOutputsZ ChannelMonitor_transactions_confirmed(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> header,
    LDKCVec_C2Tuple_usizeTransactionZZ txdata,
    int height,
    LDKBroadcasterInterface broadcaster,
    LDKFeeEstimator fee_estimator,
    LDKLogger logger,
  ) {
    return _ChannelMonitor_transactions_confirmed(
      this_arg,
      header,
      txdata,
      height,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_transactions_confirmedPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              ffi.Uint32,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>>('ChannelMonitor_transactions_confirmed');
  late final _ChannelMonitor_transactions_confirmed =
      _ChannelMonitor_transactions_confirmedPtr.asFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              int,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>();

  /// Processes a transaction that was reorganized out of the chain.
  ///
  /// Used instead of [`block_disconnected`] by clients that are notified of transactions rather
  /// than blocks. See [`chain::Confirm`] for calling expectations.
  ///
  /// [`block_disconnected`]: Self::block_disconnected
  void ChannelMonitor_transaction_unconfirmed(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> txid,
    LDKBroadcasterInterface broadcaster,
    LDKFeeEstimator fee_estimator,
    LDKLogger logger,
  ) {
    return _ChannelMonitor_transaction_unconfirmed(
      this_arg,
      txid,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_transaction_unconfirmedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>>('ChannelMonitor_transaction_unconfirmed');
  late final _ChannelMonitor_transaction_unconfirmed =
      _ChannelMonitor_transaction_unconfirmedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>();

  /// Updates the monitor with the current best chain tip, returning new outputs to watch. See
  /// [`block_connected`] for details.
  ///
  /// Used instead of [`block_connected`] by clients that are notified of transactions rather than
  /// blocks. See [`chain::Confirm`] for calling expectations.
  ///
  /// [`block_connected`]: Self::block_connected
  LDKCVec_TransactionOutputsZ ChannelMonitor_best_block_updated(
    ffi.Pointer<LDKChannelMonitor> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> header,
    int height,
    LDKBroadcasterInterface broadcaster,
    LDKFeeEstimator fee_estimator,
    LDKLogger logger,
  ) {
    return _ChannelMonitor_best_block_updated(
      this_arg,
      header,
      height,
      broadcaster,
      fee_estimator,
      logger,
    );
  }

  late final _ChannelMonitor_best_block_updatedPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint32,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>>('ChannelMonitor_best_block_updated');
  late final _ChannelMonitor_best_block_updated =
      _ChannelMonitor_best_block_updatedPtr.asFunction<
          LDKCVec_TransactionOutputsZ Function(
              ffi.Pointer<LDKChannelMonitor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              int,
              LDKBroadcasterInterface,
              LDKFeeEstimator,
              LDKLogger)>();

  /// Returns the set of txids that should be monitored for re-organization out of the chain.
  LDKCVec_TxidZ ChannelMonitor_get_relevant_txids(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_relevant_txids(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_relevant_txidsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_TxidZ Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_relevant_txids');
  late final _ChannelMonitor_get_relevant_txids =
      _ChannelMonitor_get_relevant_txidsPtr.asFunction<
          LDKCVec_TxidZ Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets the latest best block which was connected either via the [`chain::Listen`] or
  /// [`chain::Confirm`] interfaces.
  LDKBestBlock ChannelMonitor_current_best_block(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_current_best_block(
      this_arg,
    );
  }

  late final _ChannelMonitor_current_best_blockPtr = _lookup<
          ffi.NativeFunction<
              LDKBestBlock Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_current_best_block');
  late final _ChannelMonitor_current_best_block =
      _ChannelMonitor_current_best_blockPtr.asFunction<
          LDKBestBlock Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Gets the balances in this channel which are either claimable by us if we were to
  /// force-close the channel now or which are claimable on-chain (possibly awaiting
  /// confirmation).
  ///
  /// Any balances in the channel which are available on-chain (excluding on-chain fees) are
  /// included here until an [`Event::SpendableOutputs`] event has been generated for the
  /// balance, or until our counterparty has claimed the balance and accrued several
  /// confirmations on the claim transaction.
  ///
  /// Note that the balances available when you or your counterparty have broadcasted revoked
  /// state(s) may not be fully captured here.
  ///
  /// See [`Balance`] for additional details on the types of claimable balances which
  /// may be returned here and their meanings.
  LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(
    ffi.Pointer<LDKChannelMonitor> this_arg,
  ) {
    return _ChannelMonitor_get_claimable_balances(
      this_arg,
    );
  }

  late final _ChannelMonitor_get_claimable_balancesPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_BalanceZ Function(ffi.Pointer<LDKChannelMonitor>)>>(
      'ChannelMonitor_get_claimable_balances');
  late final _ChannelMonitor_get_claimable_balances =
      _ChannelMonitor_get_claimable_balancesPtr.asFunction<
          LDKCVec_BalanceZ Function(ffi.Pointer<LDKChannelMonitor>)>();

  /// Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
  LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
      C2Tuple_BlockHashChannelMonitorZ_read(
    LDKu8slice ser,
    ffi.Pointer<LDKKeysInterface> arg,
  ) {
    return _C2Tuple_BlockHashChannelMonitorZ_read(
      ser,
      arg,
    );
  }

  late final _C2Tuple_BlockHashChannelMonitorZ_readPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
                  LDKu8slice, ffi.Pointer<LDKKeysInterface>)>>(
      'C2Tuple_BlockHashChannelMonitorZ_read');
  late final _C2Tuple_BlockHashChannelMonitorZ_read =
      _C2Tuple_BlockHashChannelMonitorZ_readPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ Function(
              LDKu8slice, ffi.Pointer<LDKKeysInterface>)>();

  /// Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
  void OutPoint_free(
    LDKOutPoint this_obj,
  ) {
    return _OutPoint_free(
      this_obj,
    );
  }

  late final _OutPoint_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKOutPoint)>>(
          'OutPoint_free');
  late final _OutPoint_free =
      _OutPoint_freePtr.asFunction<void Function(LDKOutPoint)>();

  /// The referenced transaction's txid.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> OutPoint_get_txid(
    ffi.Pointer<LDKOutPoint> this_ptr,
  ) {
    return _OutPoint_get_txid(
      this_ptr,
    );
  }

  late final _OutPoint_get_txidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKOutPoint>)>>('OutPoint_get_txid');
  late final _OutPoint_get_txid = _OutPoint_get_txidPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(ffi.Pointer<LDKOutPoint>)>();

  /// The referenced transaction's txid.
  void OutPoint_set_txid(
    ffi.Pointer<LDKOutPoint> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _OutPoint_set_txid(
      this_ptr,
      val,
    );
  }

  late final _OutPoint_set_txidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOutPoint>,
              LDKThirtyTwoBytes)>>('OutPoint_set_txid');
  late final _OutPoint_set_txid = _OutPoint_set_txidPtr.asFunction<
      void Function(ffi.Pointer<LDKOutPoint>, LDKThirtyTwoBytes)>();

  /// The index of the referenced output in its transaction's vout.
  int OutPoint_get_index(
    ffi.Pointer<LDKOutPoint> this_ptr,
  ) {
    return _OutPoint_get_index(
      this_ptr,
    );
  }

  late final _OutPoint_get_indexPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKOutPoint>)>>(
      'OutPoint_get_index');
  late final _OutPoint_get_index = _OutPoint_get_indexPtr.asFunction<
      int Function(ffi.Pointer<LDKOutPoint>)>();

  /// The index of the referenced output in its transaction's vout.
  void OutPoint_set_index(
    ffi.Pointer<LDKOutPoint> this_ptr,
    int val,
  ) {
    return _OutPoint_set_index(
      this_ptr,
      val,
    );
  }

  late final _OutPoint_set_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKOutPoint>, ffi.Uint16)>>('OutPoint_set_index');
  late final _OutPoint_set_index = _OutPoint_set_indexPtr.asFunction<
      void Function(ffi.Pointer<LDKOutPoint>, int)>();

  /// Constructs a new OutPoint given each field
  LDKOutPoint OutPoint_new(
    LDKThirtyTwoBytes txid_arg,
    int index_arg,
  ) {
    return _OutPoint_new(
      txid_arg,
      index_arg,
    );
  }

  late final _OutPoint_newPtr = _lookup<
      ffi.NativeFunction<
          LDKOutPoint Function(LDKThirtyTwoBytes, ffi.Uint16)>>('OutPoint_new');
  late final _OutPoint_new = _OutPoint_newPtr.asFunction<
      LDKOutPoint Function(LDKThirtyTwoBytes, int)>();

  /// Creates a copy of the OutPoint
  LDKOutPoint OutPoint_clone(
    ffi.Pointer<LDKOutPoint> orig,
  ) {
    return _OutPoint_clone(
      orig,
    );
  }

  late final _OutPoint_clonePtr = _lookup<
          ffi.NativeFunction<LDKOutPoint Function(ffi.Pointer<LDKOutPoint>)>>(
      'OutPoint_clone');
  late final _OutPoint_clone = _OutPoint_clonePtr.asFunction<
      LDKOutPoint Function(ffi.Pointer<LDKOutPoint>)>();

  /// Checks if two OutPoints contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool OutPoint_eq(
    ffi.Pointer<LDKOutPoint> a,
    ffi.Pointer<LDKOutPoint> b,
  ) {
    return _OutPoint_eq(
      a,
      b,
    );
  }

  late final _OutPoint_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKOutPoint>,
              ffi.Pointer<LDKOutPoint>)>>('OutPoint_eq');
  late final _OutPoint_eq = _OutPoint_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKOutPoint>, ffi.Pointer<LDKOutPoint>)>();

  /// Checks if two OutPoints contain equal inner contents.
  int OutPoint_hash(
    ffi.Pointer<LDKOutPoint> o,
  ) {
    return _OutPoint_hash(
      o,
    );
  }

  late final _OutPoint_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOutPoint>)>>(
      'OutPoint_hash');
  late final _OutPoint_hash =
      _OutPoint_hashPtr.asFunction<int Function(ffi.Pointer<LDKOutPoint>)>();

  /// Convert an `OutPoint` to a lightning channel id.
  LDKThirtyTwoBytes OutPoint_to_channel_id(
    ffi.Pointer<LDKOutPoint> this_arg,
  ) {
    return _OutPoint_to_channel_id(
      this_arg,
    );
  }

  late final _OutPoint_to_channel_idPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKOutPoint>)>>('OutPoint_to_channel_id');
  late final _OutPoint_to_channel_id = _OutPoint_to_channel_idPtr.asFunction<
      LDKThirtyTwoBytes Function(ffi.Pointer<LDKOutPoint>)>();

  /// Serialize the OutPoint object into a byte array which can be read by OutPoint_read
  LDKCVec_u8Z OutPoint_write(
    ffi.Pointer<LDKOutPoint> obj,
  ) {
    return _OutPoint_write(
      obj,
    );
  }

  late final _OutPoint_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKOutPoint>)>>(
      'OutPoint_write');
  late final _OutPoint_write = _OutPoint_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKOutPoint>)>();

  /// Read a OutPoint from a byte array, created by OutPoint_write
  LDKCResult_OutPointDecodeErrorZ OutPoint_read(
    LDKu8slice ser,
  ) {
    return _OutPoint_read(
      ser,
    );
  }

  late final _OutPoint_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OutPointDecodeErrorZ Function(
              LDKu8slice)>>('OutPoint_read');
  late final _OutPoint_read = _OutPoint_readPtr.asFunction<
      LDKCResult_OutPointDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
  void DelayedPaymentOutputDescriptor_free(
    LDKDelayedPaymentOutputDescriptor this_obj,
  ) {
    return _DelayedPaymentOutputDescriptor_free(
      this_obj,
    );
  }

  late final _DelayedPaymentOutputDescriptor_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKDelayedPaymentOutputDescriptor)>>(
      'DelayedPaymentOutputDescriptor_free');
  late final _DelayedPaymentOutputDescriptor_free =
      _DelayedPaymentOutputDescriptor_freePtr.asFunction<
          void Function(LDKDelayedPaymentOutputDescriptor)>();

  /// The outpoint which is spendable
  LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_outpoint(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_outpointPtr = _lookup<
          ffi.NativeFunction<
              LDKOutPoint Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_get_outpoint');
  late final _DelayedPaymentOutputDescriptor_get_outpoint =
      _DelayedPaymentOutputDescriptor_get_outpointPtr.asFunction<
          LDKOutPoint Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// The outpoint which is spendable
  void DelayedPaymentOutputDescriptor_set_outpoint(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    LDKOutPoint val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_outpoint(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_outpointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
              LDKOutPoint)>>('DelayedPaymentOutputDescriptor_set_outpoint');
  late final _DelayedPaymentOutputDescriptor_set_outpoint =
      _DelayedPaymentOutputDescriptor_set_outpointPtr.asFunction<
          void Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, LDKOutPoint)>();

  /// Per commitment point to derive delayed_payment_key by key holder
  LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_per_commitment_point(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_per_commitment_pointPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKPublicKey Function(
                      ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
          'DelayedPaymentOutputDescriptor_get_per_commitment_point');
  late final _DelayedPaymentOutputDescriptor_get_per_commitment_point =
      _DelayedPaymentOutputDescriptor_get_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// Per commitment point to derive delayed_payment_key by key holder
  void DelayedPaymentOutputDescriptor_set_per_commitment_point(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    LDKPublicKey val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_per_commitment_pointPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
                      LDKPublicKey)>>(
          'DelayedPaymentOutputDescriptor_set_per_commitment_point');
  late final _DelayedPaymentOutputDescriptor_set_per_commitment_point =
      _DelayedPaymentOutputDescriptor_set_per_commitment_pointPtr.asFunction<
          void Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, LDKPublicKey)>();

  /// The nSequence value which must be set in the spending input to satisfy the OP_CSV in
  /// the witness_script.
  int DelayedPaymentOutputDescriptor_get_to_self_delay(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_to_self_delay(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_to_self_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_get_to_self_delay');
  late final _DelayedPaymentOutputDescriptor_get_to_self_delay =
      _DelayedPaymentOutputDescriptor_get_to_self_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// The nSequence value which must be set in the spending input to satisfy the OP_CSV in
  /// the witness_script.
  void DelayedPaymentOutputDescriptor_set_to_self_delay(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    int val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_to_self_delay(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_to_self_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
              ffi.Uint16)>>('DelayedPaymentOutputDescriptor_set_to_self_delay');
  late final _DelayedPaymentOutputDescriptor_set_to_self_delay =
      _DelayedPaymentOutputDescriptor_set_to_self_delayPtr.asFunction<
          void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, int)>();

  /// The output which is referenced by the given outpoint
  ///
  /// Returns a copy of the field.
  LDKTxOut DelayedPaymentOutputDescriptor_get_output(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_output(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_outputPtr = _lookup<
          ffi.NativeFunction<
              LDKTxOut Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_get_output');
  late final _DelayedPaymentOutputDescriptor_get_output =
      _DelayedPaymentOutputDescriptor_get_outputPtr.asFunction<
          LDKTxOut Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// The output which is referenced by the given outpoint
  void DelayedPaymentOutputDescriptor_set_output(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    LDKTxOut val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_output(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
              LDKTxOut)>>('DelayedPaymentOutputDescriptor_set_output');
  late final _DelayedPaymentOutputDescriptor_set_output =
      _DelayedPaymentOutputDescriptor_set_outputPtr.asFunction<
          void Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, LDKTxOut)>();

  /// The revocation point specific to the commitment transaction which was broadcast. Used to
  /// derive the witnessScript for this output.
  LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_revocation_pubkey(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_revocation_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_get_revocation_pubkey');
  late final _DelayedPaymentOutputDescriptor_get_revocation_pubkey =
      _DelayedPaymentOutputDescriptor_get_revocation_pubkeyPtr.asFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// The revocation point specific to the commitment transaction which was broadcast. Used to
  /// derive the witnessScript for this output.
  void DelayedPaymentOutputDescriptor_set_revocation_pubkey(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    LDKPublicKey val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_revocation_pubkey(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_revocation_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
                  LDKPublicKey)>>(
      'DelayedPaymentOutputDescriptor_set_revocation_pubkey');
  late final _DelayedPaymentOutputDescriptor_set_revocation_pubkey =
      _DelayedPaymentOutputDescriptor_set_revocation_pubkeyPtr.asFunction<
          void Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, LDKPublicKey)>();

  /// Arbitrary identification information returned by a call to
  /// `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
  /// the channel to spend the output.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>
      DelayedPaymentOutputDescriptor_get_channel_keys_id(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_channel_keys_id(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_channel_keys_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_get_channel_keys_id');
  late final _DelayedPaymentOutputDescriptor_get_channel_keys_id =
      _DelayedPaymentOutputDescriptor_get_channel_keys_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// Arbitrary identification information returned by a call to
  /// `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
  /// the channel to spend the output.
  void DelayedPaymentOutputDescriptor_set_channel_keys_id(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_channel_keys_id(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_channel_keys_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
                  LDKThirtyTwoBytes)>>(
      'DelayedPaymentOutputDescriptor_set_channel_keys_id');
  late final _DelayedPaymentOutputDescriptor_set_channel_keys_id =
      _DelayedPaymentOutputDescriptor_set_channel_keys_idPtr.asFunction<
          void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
              LDKThirtyTwoBytes)>();

  /// The value of the channel which this output originated from, possibly indirectly.
  int DelayedPaymentOutputDescriptor_get_channel_value_satoshis(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
  ) {
    return _DelayedPaymentOutputDescriptor_get_channel_value_satoshis(
      this_ptr,
    );
  }

  late final _DelayedPaymentOutputDescriptor_get_channel_value_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
          'DelayedPaymentOutputDescriptor_get_channel_value_satoshis');
  late final _DelayedPaymentOutputDescriptor_get_channel_value_satoshis =
      _DelayedPaymentOutputDescriptor_get_channel_value_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// The value of the channel which this output originated from, possibly indirectly.
  void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> this_ptr,
    int val,
  ) {
    return _DelayedPaymentOutputDescriptor_set_channel_value_satoshis(
      this_ptr,
      val,
    );
  }

  late final _DelayedPaymentOutputDescriptor_set_channel_value_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKDelayedPaymentOutputDescriptor>,
                      ffi.Uint64)>>(
          'DelayedPaymentOutputDescriptor_set_channel_value_satoshis');
  late final _DelayedPaymentOutputDescriptor_set_channel_value_satoshis =
      _DelayedPaymentOutputDescriptor_set_channel_value_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKDelayedPaymentOutputDescriptor>, int)>();

  /// Constructs a new DelayedPaymentOutputDescriptor given each field
  LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(
    LDKOutPoint outpoint_arg,
    LDKPublicKey per_commitment_point_arg,
    int to_self_delay_arg,
    LDKTxOut output_arg,
    LDKPublicKey revocation_pubkey_arg,
    LDKThirtyTwoBytes channel_keys_id_arg,
    int channel_value_satoshis_arg,
  ) {
    return _DelayedPaymentOutputDescriptor_new(
      outpoint_arg,
      per_commitment_point_arg,
      to_self_delay_arg,
      output_arg,
      revocation_pubkey_arg,
      channel_keys_id_arg,
      channel_value_satoshis_arg,
    );
  }

  late final _DelayedPaymentOutputDescriptor_newPtr = _lookup<
      ffi.NativeFunction<
          LDKDelayedPaymentOutputDescriptor Function(
              LDKOutPoint,
              LDKPublicKey,
              ffi.Uint16,
              LDKTxOut,
              LDKPublicKey,
              LDKThirtyTwoBytes,
              ffi.Uint64)>>('DelayedPaymentOutputDescriptor_new');
  late final _DelayedPaymentOutputDescriptor_new =
      _DelayedPaymentOutputDescriptor_newPtr.asFunction<
          LDKDelayedPaymentOutputDescriptor Function(LDKOutPoint, LDKPublicKey,
              int, LDKTxOut, LDKPublicKey, LDKThirtyTwoBytes, int)>();

  /// Creates a copy of the DelayedPaymentOutputDescriptor
  LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> orig,
  ) {
    return _DelayedPaymentOutputDescriptor_clone(
      orig,
    );
  }

  late final _DelayedPaymentOutputDescriptor_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKDelayedPaymentOutputDescriptor Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_clone');
  late final _DelayedPaymentOutputDescriptor_clone =
      _DelayedPaymentOutputDescriptor_clonePtr.asFunction<
          LDKDelayedPaymentOutputDescriptor Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
  LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> obj,
  ) {
    return _DelayedPaymentOutputDescriptor_write(
      obj,
    );
  }

  late final _DelayedPaymentOutputDescriptor_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'DelayedPaymentOutputDescriptor_write');
  late final _DelayedPaymentOutputDescriptor_write =
      _DelayedPaymentOutputDescriptor_writePtr.asFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
  LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ
      DelayedPaymentOutputDescriptor_read(
    LDKu8slice ser,
  ) {
    return _DelayedPaymentOutputDescriptor_read(
      ser,
    );
  }

  late final _DelayedPaymentOutputDescriptor_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>>('DelayedPaymentOutputDescriptor_read');
  late final _DelayedPaymentOutputDescriptor_read =
      _DelayedPaymentOutputDescriptor_readPtr.asFunction<
          LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>();

  /// Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
  void StaticPaymentOutputDescriptor_free(
    LDKStaticPaymentOutputDescriptor this_obj,
  ) {
    return _StaticPaymentOutputDescriptor_free(
      this_obj,
    );
  }

  late final _StaticPaymentOutputDescriptor_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKStaticPaymentOutputDescriptor)>>(
      'StaticPaymentOutputDescriptor_free');
  late final _StaticPaymentOutputDescriptor_free =
      _StaticPaymentOutputDescriptor_freePtr.asFunction<
          void Function(LDKStaticPaymentOutputDescriptor)>();

  /// The outpoint which is spendable
  LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
  ) {
    return _StaticPaymentOutputDescriptor_get_outpoint(
      this_ptr,
    );
  }

  late final _StaticPaymentOutputDescriptor_get_outpointPtr = _lookup<
          ffi.NativeFunction<
              LDKOutPoint Function(
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'StaticPaymentOutputDescriptor_get_outpoint');
  late final _StaticPaymentOutputDescriptor_get_outpoint =
      _StaticPaymentOutputDescriptor_get_outpointPtr.asFunction<
          LDKOutPoint Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// The outpoint which is spendable
  void StaticPaymentOutputDescriptor_set_outpoint(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
    LDKOutPoint val,
  ) {
    return _StaticPaymentOutputDescriptor_set_outpoint(
      this_ptr,
      val,
    );
  }

  late final _StaticPaymentOutputDescriptor_set_outpointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>,
              LDKOutPoint)>>('StaticPaymentOutputDescriptor_set_outpoint');
  late final _StaticPaymentOutputDescriptor_set_outpoint =
      _StaticPaymentOutputDescriptor_set_outpointPtr.asFunction<
          void Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>, LDKOutPoint)>();

  /// The output which is referenced by the given outpoint
  ///
  /// Returns a copy of the field.
  LDKTxOut StaticPaymentOutputDescriptor_get_output(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
  ) {
    return _StaticPaymentOutputDescriptor_get_output(
      this_ptr,
    );
  }

  late final _StaticPaymentOutputDescriptor_get_outputPtr = _lookup<
          ffi.NativeFunction<
              LDKTxOut Function(
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'StaticPaymentOutputDescriptor_get_output');
  late final _StaticPaymentOutputDescriptor_get_output =
      _StaticPaymentOutputDescriptor_get_outputPtr.asFunction<
          LDKTxOut Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// The output which is referenced by the given outpoint
  void StaticPaymentOutputDescriptor_set_output(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
    LDKTxOut val,
  ) {
    return _StaticPaymentOutputDescriptor_set_output(
      this_ptr,
      val,
    );
  }

  late final _StaticPaymentOutputDescriptor_set_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>,
              LDKTxOut)>>('StaticPaymentOutputDescriptor_set_output');
  late final _StaticPaymentOutputDescriptor_set_output =
      _StaticPaymentOutputDescriptor_set_outputPtr.asFunction<
          void Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>, LDKTxOut)>();

  /// Arbitrary identification information returned by a call to
  /// `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
  /// the channel to spend the output.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>
      StaticPaymentOutputDescriptor_get_channel_keys_id(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
  ) {
    return _StaticPaymentOutputDescriptor_get_channel_keys_id(
      this_ptr,
    );
  }

  late final _StaticPaymentOutputDescriptor_get_channel_keys_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'StaticPaymentOutputDescriptor_get_channel_keys_id');
  late final _StaticPaymentOutputDescriptor_get_channel_keys_id =
      _StaticPaymentOutputDescriptor_get_channel_keys_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// Arbitrary identification information returned by a call to
  /// `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
  /// the channel to spend the output.
  void StaticPaymentOutputDescriptor_set_channel_keys_id(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _StaticPaymentOutputDescriptor_set_channel_keys_id(
      this_ptr,
      val,
    );
  }

  late final _StaticPaymentOutputDescriptor_set_channel_keys_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>,
                  LDKThirtyTwoBytes)>>(
      'StaticPaymentOutputDescriptor_set_channel_keys_id');
  late final _StaticPaymentOutputDescriptor_set_channel_keys_id =
      _StaticPaymentOutputDescriptor_set_channel_keys_idPtr.asFunction<
          void Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>,
              LDKThirtyTwoBytes)>();

  /// The value of the channel which this transactions spends.
  int StaticPaymentOutputDescriptor_get_channel_value_satoshis(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
  ) {
    return _StaticPaymentOutputDescriptor_get_channel_value_satoshis(
      this_ptr,
    );
  }

  late final _StaticPaymentOutputDescriptor_get_channel_value_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
          'StaticPaymentOutputDescriptor_get_channel_value_satoshis');
  late final _StaticPaymentOutputDescriptor_get_channel_value_satoshis =
      _StaticPaymentOutputDescriptor_get_channel_value_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// The value of the channel which this transactions spends.
  void StaticPaymentOutputDescriptor_set_channel_value_satoshis(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> this_ptr,
    int val,
  ) {
    return _StaticPaymentOutputDescriptor_set_channel_value_satoshis(
      this_ptr,
      val,
    );
  }

  late final _StaticPaymentOutputDescriptor_set_channel_value_satoshisPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKStaticPaymentOutputDescriptor>,
                      ffi.Uint64)>>(
          'StaticPaymentOutputDescriptor_set_channel_value_satoshis');
  late final _StaticPaymentOutputDescriptor_set_channel_value_satoshis =
      _StaticPaymentOutputDescriptor_set_channel_value_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKStaticPaymentOutputDescriptor>, int)>();

  /// Constructs a new StaticPaymentOutputDescriptor given each field
  LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(
    LDKOutPoint outpoint_arg,
    LDKTxOut output_arg,
    LDKThirtyTwoBytes channel_keys_id_arg,
    int channel_value_satoshis_arg,
  ) {
    return _StaticPaymentOutputDescriptor_new(
      outpoint_arg,
      output_arg,
      channel_keys_id_arg,
      channel_value_satoshis_arg,
    );
  }

  late final _StaticPaymentOutputDescriptor_newPtr = _lookup<
      ffi.NativeFunction<
          LDKStaticPaymentOutputDescriptor Function(
              LDKOutPoint,
              LDKTxOut,
              LDKThirtyTwoBytes,
              ffi.Uint64)>>('StaticPaymentOutputDescriptor_new');
  late final _StaticPaymentOutputDescriptor_new =
      _StaticPaymentOutputDescriptor_newPtr.asFunction<
          LDKStaticPaymentOutputDescriptor Function(
              LDKOutPoint, LDKTxOut, LDKThirtyTwoBytes, int)>();

  /// Creates a copy of the StaticPaymentOutputDescriptor
  LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> orig,
  ) {
    return _StaticPaymentOutputDescriptor_clone(
      orig,
    );
  }

  late final _StaticPaymentOutputDescriptor_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKStaticPaymentOutputDescriptor Function(
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'StaticPaymentOutputDescriptor_clone');
  late final _StaticPaymentOutputDescriptor_clone =
      _StaticPaymentOutputDescriptor_clonePtr.asFunction<
          LDKStaticPaymentOutputDescriptor Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
  LDKCVec_u8Z StaticPaymentOutputDescriptor_write(
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> obj,
  ) {
    return _StaticPaymentOutputDescriptor_write(
      obj,
    );
  }

  late final _StaticPaymentOutputDescriptor_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'StaticPaymentOutputDescriptor_write');
  late final _StaticPaymentOutputDescriptor_write =
      _StaticPaymentOutputDescriptor_writePtr.asFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
  LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ
      StaticPaymentOutputDescriptor_read(
    LDKu8slice ser,
  ) {
    return _StaticPaymentOutputDescriptor_read(
      ser,
    );
  }

  late final _StaticPaymentOutputDescriptor_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>>('StaticPaymentOutputDescriptor_read');
  late final _StaticPaymentOutputDescriptor_read =
      _StaticPaymentOutputDescriptor_readPtr.asFunction<
          LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>();

  /// Frees any resources used by the SpendableOutputDescriptor
  void SpendableOutputDescriptor_free(
    LDKSpendableOutputDescriptor this_ptr,
  ) {
    return _SpendableOutputDescriptor_free(
      this_ptr,
    );
  }

  late final _SpendableOutputDescriptor_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKSpendableOutputDescriptor)>>(
      'SpendableOutputDescriptor_free');
  late final _SpendableOutputDescriptor_free =
      _SpendableOutputDescriptor_freePtr.asFunction<
          void Function(LDKSpendableOutputDescriptor)>();

  /// Creates a copy of the SpendableOutputDescriptor
  LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(
    ffi.Pointer<LDKSpendableOutputDescriptor> orig,
  ) {
    return _SpendableOutputDescriptor_clone(
      orig,
    );
  }

  late final _SpendableOutputDescriptor_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKSpendableOutputDescriptor Function(
                  ffi.Pointer<LDKSpendableOutputDescriptor>)>>(
      'SpendableOutputDescriptor_clone');
  late final _SpendableOutputDescriptor_clone =
      _SpendableOutputDescriptor_clonePtr.asFunction<
          LDKSpendableOutputDescriptor Function(
              ffi.Pointer<LDKSpendableOutputDescriptor>)>();

  /// Utility method to constructs a new StaticOutput-variant SpendableOutputDescriptor
  LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(
    LDKOutPoint outpoint,
    LDKTxOut output,
  ) {
    return _SpendableOutputDescriptor_static_output(
      outpoint,
      output,
    );
  }

  late final _SpendableOutputDescriptor_static_outputPtr = _lookup<
      ffi.NativeFunction<
          LDKSpendableOutputDescriptor Function(LDKOutPoint,
              LDKTxOut)>>('SpendableOutputDescriptor_static_output');
  late final _SpendableOutputDescriptor_static_output =
      _SpendableOutputDescriptor_static_outputPtr.asFunction<
          LDKSpendableOutputDescriptor Function(LDKOutPoint, LDKTxOut)>();

  /// Utility method to constructs a new DelayedPaymentOutput-variant SpendableOutputDescriptor
  LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(
    LDKDelayedPaymentOutputDescriptor a,
  ) {
    return _SpendableOutputDescriptor_delayed_payment_output(
      a,
    );
  }

  late final _SpendableOutputDescriptor_delayed_payment_outputPtr = _lookup<
          ffi.NativeFunction<
              LDKSpendableOutputDescriptor Function(
                  LDKDelayedPaymentOutputDescriptor)>>(
      'SpendableOutputDescriptor_delayed_payment_output');
  late final _SpendableOutputDescriptor_delayed_payment_output =
      _SpendableOutputDescriptor_delayed_payment_outputPtr.asFunction<
          LDKSpendableOutputDescriptor Function(
              LDKDelayedPaymentOutputDescriptor)>();

  /// Utility method to constructs a new StaticPaymentOutput-variant SpendableOutputDescriptor
  LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(
    LDKStaticPaymentOutputDescriptor a,
  ) {
    return _SpendableOutputDescriptor_static_payment_output(
      a,
    );
  }

  late final _SpendableOutputDescriptor_static_payment_outputPtr = _lookup<
          ffi.NativeFunction<
              LDKSpendableOutputDescriptor Function(
                  LDKStaticPaymentOutputDescriptor)>>(
      'SpendableOutputDescriptor_static_payment_output');
  late final _SpendableOutputDescriptor_static_payment_output =
      _SpendableOutputDescriptor_static_payment_outputPtr.asFunction<
          LDKSpendableOutputDescriptor Function(
              LDKStaticPaymentOutputDescriptor)>();

  /// Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
  LDKCVec_u8Z SpendableOutputDescriptor_write(
    ffi.Pointer<LDKSpendableOutputDescriptor> obj,
  ) {
    return _SpendableOutputDescriptor_write(
      obj,
    );
  }

  late final _SpendableOutputDescriptor_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKSpendableOutputDescriptor>)>>(
      'SpendableOutputDescriptor_write');
  late final _SpendableOutputDescriptor_write =
      _SpendableOutputDescriptor_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKSpendableOutputDescriptor>)>();

  /// Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
  LDKCResult_SpendableOutputDescriptorDecodeErrorZ
      SpendableOutputDescriptor_read(
    LDKu8slice ser,
  ) {
    return _SpendableOutputDescriptor_read(
      ser,
    );
  }

  late final _SpendableOutputDescriptor_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>>('SpendableOutputDescriptor_read');
  late final _SpendableOutputDescriptor_read =
      _SpendableOutputDescriptor_readPtr.asFunction<
          LDKCResult_SpendableOutputDescriptorDecodeErrorZ Function(
              LDKu8slice)>();

  /// Calls the free function if one is set
  void BaseSign_free(
    LDKBaseSign this_ptr,
  ) {
    return _BaseSign_free(
      this_ptr,
    );
  }

  late final _BaseSign_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBaseSign)>>(
          'BaseSign_free');
  late final _BaseSign_free =
      _BaseSign_freePtr.asFunction<void Function(LDKBaseSign)>();

  /// Creates a copy of a Sign
  LDKSign Sign_clone(
    ffi.Pointer<LDKSign> orig,
  ) {
    return _Sign_clone(
      orig,
    );
  }

  late final _Sign_clonePtr =
      _lookup<ffi.NativeFunction<LDKSign Function(ffi.Pointer<LDKSign>)>>(
          'Sign_clone');
  late final _Sign_clone =
      _Sign_clonePtr.asFunction<LDKSign Function(ffi.Pointer<LDKSign>)>();

  /// Calls the free function if one is set
  void Sign_free(
    LDKSign this_ptr,
  ) {
    return _Sign_free(
      this_ptr,
    );
  }

  late final _Sign_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKSign)>>('Sign_free');
  late final _Sign_free = _Sign_freePtr.asFunction<void Function(LDKSign)>();

  /// Creates a copy of the Recipient
  int Recipient_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _Recipient_clone(
      orig,
    );
  }

  late final _Recipient_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'Recipient_clone');
  late final _Recipient_clone =
      _Recipient_clonePtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new Node-variant Recipient
  int Recipient_node() {
    return _Recipient_node();
  }

  late final _Recipient_nodePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Recipient_node');
  late final _Recipient_node = _Recipient_nodePtr.asFunction<int Function()>();

  /// Utility method to constructs a new PhantomNode-variant Recipient
  int Recipient_phantom_node() {
    return _Recipient_phantom_node();
  }

  late final _Recipient_phantom_nodePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'Recipient_phantom_node');
  late final _Recipient_phantom_node =
      _Recipient_phantom_nodePtr.asFunction<int Function()>();

  /// Calls the free function if one is set
  void KeysInterface_free(
    LDKKeysInterface this_ptr,
  ) {
    return _KeysInterface_free(
      this_ptr,
    );
  }

  late final _KeysInterface_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKKeysInterface)>>(
          'KeysInterface_free');
  late final _KeysInterface_free =
      _KeysInterface_freePtr.asFunction<void Function(LDKKeysInterface)>();

  /// Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
  void InMemorySigner_free(
    LDKInMemorySigner this_obj,
  ) {
    return _InMemorySigner_free(
      this_obj,
    );
  }

  late final _InMemorySigner_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInMemorySigner)>>(
          'InMemorySigner_free');
  late final _InMemorySigner_free =
      _InMemorySigner_freePtr.asFunction<void Function(LDKInMemorySigner)>();

  /// Private key of anchor tx
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> InMemorySigner_get_funding_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_funding_key(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_funding_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_funding_key');
  late final _InMemorySigner_get_funding_key =
      _InMemorySigner_get_funding_keyPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Private key of anchor tx
  void InMemorySigner_set_funding_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKSecretKey val,
  ) {
    return _InMemorySigner_set_funding_key(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_funding_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKSecretKey)>>('InMemorySigner_set_funding_key');
  late final _InMemorySigner_set_funding_key =
      _InMemorySigner_set_funding_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKSecretKey)>();

  /// Holder secret key for blinded revocation pubkey
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> InMemorySigner_get_revocation_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_revocation_base_key(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_revocation_base_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_revocation_base_key');
  late final _InMemorySigner_get_revocation_base_key =
      _InMemorySigner_get_revocation_base_keyPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Holder secret key for blinded revocation pubkey
  void InMemorySigner_set_revocation_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKSecretKey val,
  ) {
    return _InMemorySigner_set_revocation_base_key(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_revocation_base_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKSecretKey)>>('InMemorySigner_set_revocation_base_key');
  late final _InMemorySigner_set_revocation_base_key =
      _InMemorySigner_set_revocation_base_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKSecretKey)>();

  /// Holder secret key used for our balance in counterparty-broadcasted commitment transactions
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> InMemorySigner_get_payment_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_payment_key(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_payment_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_payment_key');
  late final _InMemorySigner_get_payment_key =
      _InMemorySigner_get_payment_keyPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Holder secret key used for our balance in counterparty-broadcasted commitment transactions
  void InMemorySigner_set_payment_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKSecretKey val,
  ) {
    return _InMemorySigner_set_payment_key(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_payment_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKSecretKey)>>('InMemorySigner_set_payment_key');
  late final _InMemorySigner_set_payment_key =
      _InMemorySigner_set_payment_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKSecretKey)>();

  /// Holder secret key used in HTLC tx
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>
      InMemorySigner_get_delayed_payment_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_delayed_payment_base_key(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_delayed_payment_base_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_delayed_payment_base_key');
  late final _InMemorySigner_get_delayed_payment_base_key =
      _InMemorySigner_get_delayed_payment_base_keyPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Holder secret key used in HTLC tx
  void InMemorySigner_set_delayed_payment_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKSecretKey val,
  ) {
    return _InMemorySigner_set_delayed_payment_base_key(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_delayed_payment_base_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKSecretKey)>>('InMemorySigner_set_delayed_payment_base_key');
  late final _InMemorySigner_set_delayed_payment_base_key =
      _InMemorySigner_set_delayed_payment_base_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKSecretKey)>();

  /// Holder htlc secret key used in commitment tx htlc outputs
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> InMemorySigner_get_htlc_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_htlc_base_key(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_htlc_base_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_htlc_base_key');
  late final _InMemorySigner_get_htlc_base_key =
      _InMemorySigner_get_htlc_base_keyPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Holder htlc secret key used in commitment tx htlc outputs
  void InMemorySigner_set_htlc_base_key(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKSecretKey val,
  ) {
    return _InMemorySigner_set_htlc_base_key(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_htlc_base_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKSecretKey)>>('InMemorySigner_set_htlc_base_key');
  late final _InMemorySigner_set_htlc_base_key =
      _InMemorySigner_set_htlc_base_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKSecretKey)>();

  /// Commitment seed
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> InMemorySigner_get_commitment_seed(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
  ) {
    return _InMemorySigner_get_commitment_seed(
      this_ptr,
    );
  }

  late final _InMemorySigner_get_commitment_seedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_commitment_seed');
  late final _InMemorySigner_get_commitment_seed =
      _InMemorySigner_get_commitment_seedPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Commitment seed
  void InMemorySigner_set_commitment_seed(
    ffi.Pointer<LDKInMemorySigner> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _InMemorySigner_set_commitment_seed(
      this_ptr,
      val,
    );
  }

  late final _InMemorySigner_set_commitment_seedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInMemorySigner>,
              LDKThirtyTwoBytes)>>('InMemorySigner_set_commitment_seed');
  late final _InMemorySigner_set_commitment_seed =
      _InMemorySigner_set_commitment_seedPtr.asFunction<
          void Function(ffi.Pointer<LDKInMemorySigner>, LDKThirtyTwoBytes)>();

  /// Creates a copy of the InMemorySigner
  LDKInMemorySigner InMemorySigner_clone(
    ffi.Pointer<LDKInMemorySigner> orig,
  ) {
    return _InMemorySigner_clone(
      orig,
    );
  }

  late final _InMemorySigner_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKInMemorySigner Function(
              ffi.Pointer<LDKInMemorySigner>)>>('InMemorySigner_clone');
  late final _InMemorySigner_clone = _InMemorySigner_clonePtr.asFunction<
      LDKInMemorySigner Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Create a new InMemorySigner
  LDKInMemorySigner InMemorySigner_new(
    LDKSecretKey node_secret,
    LDKSecretKey funding_key,
    LDKSecretKey revocation_base_key,
    LDKSecretKey payment_key,
    LDKSecretKey delayed_payment_base_key,
    LDKSecretKey htlc_base_key,
    LDKThirtyTwoBytes commitment_seed,
    int channel_value_satoshis,
    LDKThirtyTwoBytes channel_keys_id,
  ) {
    return _InMemorySigner_new(
      node_secret,
      funding_key,
      revocation_base_key,
      payment_key,
      delayed_payment_base_key,
      htlc_base_key,
      commitment_seed,
      channel_value_satoshis,
      channel_keys_id,
    );
  }

  late final _InMemorySigner_newPtr = _lookup<
      ffi.NativeFunction<
          LDKInMemorySigner Function(
              LDKSecretKey,
              LDKSecretKey,
              LDKSecretKey,
              LDKSecretKey,
              LDKSecretKey,
              LDKSecretKey,
              LDKThirtyTwoBytes,
              ffi.Uint64,
              LDKThirtyTwoBytes)>>('InMemorySigner_new');
  late final _InMemorySigner_new = _InMemorySigner_newPtr.asFunction<
      LDKInMemorySigner Function(
          LDKSecretKey,
          LDKSecretKey,
          LDKSecretKey,
          LDKSecretKey,
          LDKSecretKey,
          LDKSecretKey,
          LDKThirtyTwoBytes,
          int,
          LDKThirtyTwoBytes)>();

  /// Counterparty pubkeys.
  /// Will panic if ready_channel wasn't called.
  LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_counterparty_pubkeys(
      this_arg,
    );
  }

  late final _InMemorySigner_counterparty_pubkeysPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelPublicKeys Function(ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_counterparty_pubkeys');
  late final _InMemorySigner_counterparty_pubkeys =
      _InMemorySigner_counterparty_pubkeysPtr.asFunction<
          LDKChannelPublicKeys Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// The contest_delay value specified by our counterparty and applied on holder-broadcastable
  /// transactions, ie the amount of time that we have to wait to recover our funds if we
  /// broadcast a transaction.
  /// Will panic if ready_channel wasn't called.
  int InMemorySigner_counterparty_selected_contest_delay(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_counterparty_selected_contest_delay(
      this_arg,
    );
  }

  late final _InMemorySigner_counterparty_selected_contest_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_counterparty_selected_contest_delay');
  late final _InMemorySigner_counterparty_selected_contest_delay =
      _InMemorySigner_counterparty_selected_contest_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// The contest_delay value specified by us and applied on transactions broadcastable
  /// by our counterparty, ie the amount of time that they have to wait to recover their funds
  /// if they broadcast a transaction.
  /// Will panic if ready_channel wasn't called.
  int InMemorySigner_holder_selected_contest_delay(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_holder_selected_contest_delay(
      this_arg,
    );
  }

  late final _InMemorySigner_holder_selected_contest_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_holder_selected_contest_delay');
  late final _InMemorySigner_holder_selected_contest_delay =
      _InMemorySigner_holder_selected_contest_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Whether the holder is the initiator
  /// Will panic if ready_channel wasn't called.
  bool InMemorySigner_is_outbound(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_is_outbound(
      this_arg,
    );
  }

  late final _InMemorySigner_is_outboundPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKInMemorySigner>)>>('InMemorySigner_is_outbound');
  late final _InMemorySigner_is_outbound = _InMemorySigner_is_outboundPtr
      .asFunction<bool Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Funding outpoint
  /// Will panic if ready_channel wasn't called.
  LDKOutPoint InMemorySigner_funding_outpoint(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_funding_outpoint(
      this_arg,
    );
  }

  late final _InMemorySigner_funding_outpointPtr = _lookup<
          ffi.NativeFunction<
              LDKOutPoint Function(ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_funding_outpoint');
  late final _InMemorySigner_funding_outpoint =
      _InMemorySigner_funding_outpointPtr.asFunction<
          LDKOutPoint Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Obtain a ChannelTransactionParameters for this channel, to be used when verifying or
  /// building transactions.
  ///
  /// Will panic if ready_channel wasn't called.
  LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_get_channel_parameters(
      this_arg,
    );
  }

  late final _InMemorySigner_get_channel_parametersPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelTransactionParameters Function(
                  ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_get_channel_parameters');
  late final _InMemorySigner_get_channel_parameters =
      _InMemorySigner_get_channel_parametersPtr.asFunction<
          LDKChannelTransactionParameters Function(
              ffi.Pointer<LDKInMemorySigner>)>();

  /// Whether anchors should be used.
  /// Will panic if ready_channel wasn't called.
  bool InMemorySigner_opt_anchors(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_opt_anchors(
      this_arg,
    );
  }

  late final _InMemorySigner_opt_anchorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKInMemorySigner>)>>('InMemorySigner_opt_anchors');
  late final _InMemorySigner_opt_anchors = _InMemorySigner_opt_anchorsPtr
      .asFunction<bool Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Sign the single input of spend_tx at index `input_idx` which spends the output
  /// described by descriptor, returning the witness stack for the input.
  ///
  /// Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
  /// is not spending the outpoint described by `descriptor.outpoint`,
  /// or if an output descriptor script_pubkey does not match the one we can spend.
  LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(
    ffi.Pointer<LDKInMemorySigner> this_arg,
    LDKTransaction spend_tx,
    int input_idx,
    ffi.Pointer<LDKStaticPaymentOutputDescriptor> descriptor,
  ) {
    return _InMemorySigner_sign_counterparty_payment_input(
      this_arg,
      spend_tx,
      input_idx,
      descriptor,
    );
  }

  late final _InMemorySigner_sign_counterparty_payment_inputPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_CVec_u8ZZNoneZ Function(
                  ffi.Pointer<LDKInMemorySigner>,
                  LDKTransaction,
                  uintptr_t,
                  ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>>(
      'InMemorySigner_sign_counterparty_payment_input');
  late final _InMemorySigner_sign_counterparty_payment_input =
      _InMemorySigner_sign_counterparty_payment_inputPtr.asFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function(
              ffi.Pointer<LDKInMemorySigner>,
              LDKTransaction,
              int,
              ffi.Pointer<LDKStaticPaymentOutputDescriptor>)>();

  /// Sign the single input of spend_tx at index `input_idx` which spends the output
  /// described by descriptor, returning the witness stack for the input.
  ///
  /// Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
  /// is not spending the outpoint described by `descriptor.outpoint`, does not have a
  /// sequence set to `descriptor.to_self_delay`, or if an output descriptor
  /// script_pubkey does not match the one we can spend.
  LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(
    ffi.Pointer<LDKInMemorySigner> this_arg,
    LDKTransaction spend_tx,
    int input_idx,
    ffi.Pointer<LDKDelayedPaymentOutputDescriptor> descriptor,
  ) {
    return _InMemorySigner_sign_dynamic_p2wsh_input(
      this_arg,
      spend_tx,
      input_idx,
      descriptor,
    );
  }

  late final _InMemorySigner_sign_dynamic_p2wsh_inputPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_CVec_u8ZZNoneZ Function(
                  ffi.Pointer<LDKInMemorySigner>,
                  LDKTransaction,
                  uintptr_t,
                  ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>>(
      'InMemorySigner_sign_dynamic_p2wsh_input');
  late final _InMemorySigner_sign_dynamic_p2wsh_input =
      _InMemorySigner_sign_dynamic_p2wsh_inputPtr.asFunction<
          LDKCResult_CVec_CVec_u8ZZNoneZ Function(
              ffi.Pointer<LDKInMemorySigner>,
              LDKTransaction,
              int,
              ffi.Pointer<LDKDelayedPaymentOutputDescriptor>)>();

  /// Constructs a new BaseSign which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned BaseSign must be freed before this_arg is
  LDKBaseSign InMemorySigner_as_BaseSign(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_as_BaseSign(
      this_arg,
    );
  }

  late final _InMemorySigner_as_BaseSignPtr = _lookup<
      ffi.NativeFunction<
          LDKBaseSign Function(
              ffi.Pointer<LDKInMemorySigner>)>>('InMemorySigner_as_BaseSign');
  late final _InMemorySigner_as_BaseSign = _InMemorySigner_as_BaseSignPtr
      .asFunction<LDKBaseSign Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Constructs a new Sign which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
  LDKSign InMemorySigner_as_Sign(
    ffi.Pointer<LDKInMemorySigner> this_arg,
  ) {
    return _InMemorySigner_as_Sign(
      this_arg,
    );
  }

  late final _InMemorySigner_as_SignPtr = _lookup<
          ffi.NativeFunction<LDKSign Function(ffi.Pointer<LDKInMemorySigner>)>>(
      'InMemorySigner_as_Sign');
  late final _InMemorySigner_as_Sign = _InMemorySigner_as_SignPtr.asFunction<
      LDKSign Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
  LDKCVec_u8Z InMemorySigner_write(
    ffi.Pointer<LDKInMemorySigner> obj,
  ) {
    return _InMemorySigner_write(
      obj,
    );
  }

  late final _InMemorySigner_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKInMemorySigner>)>>('InMemorySigner_write');
  late final _InMemorySigner_write = _InMemorySigner_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKInMemorySigner>)>();

  /// Read a InMemorySigner from a byte array, created by InMemorySigner_write
  LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(
    LDKu8slice ser,
    LDKSecretKey arg,
  ) {
    return _InMemorySigner_read(
      ser,
      arg,
    );
  }

  late final _InMemorySigner_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InMemorySignerDecodeErrorZ Function(
              LDKu8slice, LDKSecretKey)>>('InMemorySigner_read');
  late final _InMemorySigner_read = _InMemorySigner_readPtr.asFunction<
      LDKCResult_InMemorySignerDecodeErrorZ Function(
          LDKu8slice, LDKSecretKey)>();

  /// Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
  void KeysManager_free(
    LDKKeysManager this_obj,
  ) {
    return _KeysManager_free(
      this_obj,
    );
  }

  late final _KeysManager_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKKeysManager)>>(
          'KeysManager_free');
  late final _KeysManager_free =
      _KeysManager_freePtr.asFunction<void Function(LDKKeysManager)>();

  /// Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
  /// CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
  /// starting_time isn't strictly required to actually be a time, but it must absolutely,
  /// without a doubt, be unique to this instance. ie if you start multiple times with the same
  /// seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
  /// simply use the current time (with very high precision).
  ///
  /// The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
  /// obviously, starting_time should be unique every time you reload the library - it is only
  /// used to generate new ephemeral key data (which will be stored by the individual channel if
  /// necessary).
  ///
  /// Note that the seed is required to recover certain on-chain funds independent of
  /// ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
  /// channel, and some on-chain during-closing funds.
  ///
  /// Note that until the 0.1 release there is no guarantee of backward compatibility between
  /// versions. Once the library is more fully supported, the docs will be updated to include a
  /// detailed description of the guarantee.
  LDKKeysManager KeysManager_new(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> seed,
    int starting_time_secs,
    int starting_time_nanos,
  ) {
    return _KeysManager_new(
      seed,
      starting_time_secs,
      starting_time_nanos,
    );
  }

  late final _KeysManager_newPtr = _lookup<
      ffi.NativeFunction<
          LDKKeysManager Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint64, ffi.Uint32)>>('KeysManager_new');
  late final _KeysManager_new = _KeysManager_newPtr.asFunction<
      LDKKeysManager Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int, int)>();

  /// Derive an old Sign containing per-channel secrets based on a key derivation parameters.
  ///
  /// Key derivation parameters are accessible through a per-channel secrets
  /// Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
  /// onchain output detection for which a corresponding delayed_payment_key must be derived.
  LDKInMemorySigner KeysManager_derive_channel_keys(
    ffi.Pointer<LDKKeysManager> this_arg,
    int channel_value_satoshis,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> params,
  ) {
    return _KeysManager_derive_channel_keys(
      this_arg,
      channel_value_satoshis,
      params,
    );
  }

  late final _KeysManager_derive_channel_keysPtr = _lookup<
          ffi.NativeFunction<
              LDKInMemorySigner Function(ffi.Pointer<LDKKeysManager>,
                  ffi.Uint64, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'KeysManager_derive_channel_keys');
  late final _KeysManager_derive_channel_keys =
      _KeysManager_derive_channel_keysPtr.asFunction<
          LDKInMemorySigner Function(ffi.Pointer<LDKKeysManager>, int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Creates a Transaction which spends the given descriptors to the given outputs, plus an
  /// output to the given change destination (if sufficient change value remains). The
  /// transaction will have a feerate, at least, of the given value.
  ///
  /// Returns `Err(())` if the output value is greater than the input value minus required fee,
  /// if a descriptor was duplicated, or if an output descriptor `script_pubkey`
  /// does not match the one we can spend.
  ///
  /// We do not enforce that outputs meet the dust limit or that any output scripts are standard.
  ///
  /// May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
  /// this KeysManager or one of the `InMemorySigner` created by this KeysManager.
  LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(
    ffi.Pointer<LDKKeysManager> this_arg,
    LDKCVec_SpendableOutputDescriptorZ descriptors,
    LDKCVec_TxOutZ outputs,
    LDKCVec_u8Z change_destination_script,
    int feerate_sat_per_1000_weight,
  ) {
    return _KeysManager_spend_spendable_outputs(
      this_arg,
      descriptors,
      outputs,
      change_destination_script,
      feerate_sat_per_1000_weight,
    );
  }

  late final _KeysManager_spend_spendable_outputsPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TransactionNoneZ Function(
              ffi.Pointer<LDKKeysManager>,
              LDKCVec_SpendableOutputDescriptorZ,
              LDKCVec_TxOutZ,
              LDKCVec_u8Z,
              ffi.Uint32)>>('KeysManager_spend_spendable_outputs');
  late final _KeysManager_spend_spendable_outputs =
      _KeysManager_spend_spendable_outputsPtr.asFunction<
          LDKCResult_TransactionNoneZ Function(
              ffi.Pointer<LDKKeysManager>,
              LDKCVec_SpendableOutputDescriptorZ,
              LDKCVec_TxOutZ,
              LDKCVec_u8Z,
              int)>();

  /// Constructs a new KeysInterface which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
  LDKKeysInterface KeysManager_as_KeysInterface(
    ffi.Pointer<LDKKeysManager> this_arg,
  ) {
    return _KeysManager_as_KeysInterface(
      this_arg,
    );
  }

  late final _KeysManager_as_KeysInterfacePtr = _lookup<
      ffi.NativeFunction<
          LDKKeysInterface Function(
              ffi.Pointer<LDKKeysManager>)>>('KeysManager_as_KeysInterface');
  late final _KeysManager_as_KeysInterface = _KeysManager_as_KeysInterfacePtr
      .asFunction<LDKKeysInterface Function(ffi.Pointer<LDKKeysManager>)>();

  /// Frees any resources used by the PhantomKeysManager, if is_owned is set and inner is non-NULL.
  void PhantomKeysManager_free(
    LDKPhantomKeysManager this_obj,
  ) {
    return _PhantomKeysManager_free(
      this_obj,
    );
  }

  late final _PhantomKeysManager_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPhantomKeysManager)>>(
          'PhantomKeysManager_free');
  late final _PhantomKeysManager_free = _PhantomKeysManager_freePtr.asFunction<
      void Function(LDKPhantomKeysManager)>();

  /// Constructs a new KeysInterface which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
  LDKKeysInterface PhantomKeysManager_as_KeysInterface(
    ffi.Pointer<LDKPhantomKeysManager> this_arg,
  ) {
    return _PhantomKeysManager_as_KeysInterface(
      this_arg,
    );
  }

  late final _PhantomKeysManager_as_KeysInterfacePtr = _lookup<
          ffi.NativeFunction<
              LDKKeysInterface Function(ffi.Pointer<LDKPhantomKeysManager>)>>(
      'PhantomKeysManager_as_KeysInterface');
  late final _PhantomKeysManager_as_KeysInterface =
      _PhantomKeysManager_as_KeysInterfacePtr.asFunction<
          LDKKeysInterface Function(ffi.Pointer<LDKPhantomKeysManager>)>();

  /// Constructs a `PhantomKeysManager` given a 32-byte seed and an additional `cross_node_seed`
  /// that is shared across all nodes that intend to participate in [phantom node payments] together.
  ///
  /// See [`KeysManager::new`] for more information on `seed`, `starting_time_secs`, and
  /// `starting_time_nanos`.
  ///
  /// `cross_node_seed` must be the same across all phantom payment-receiving nodes and also the
  /// same across restarts, or else inbound payments may fail.
  ///
  /// [phantom node payments]: PhantomKeysManager
  LDKPhantomKeysManager PhantomKeysManager_new(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> seed,
    int starting_time_secs,
    int starting_time_nanos,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> cross_node_seed,
  ) {
    return _PhantomKeysManager_new(
      seed,
      starting_time_secs,
      starting_time_nanos,
      cross_node_seed,
    );
  }

  late final _PhantomKeysManager_newPtr = _lookup<
      ffi.NativeFunction<
          LDKPhantomKeysManager Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint64,
              ffi.Uint32,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('PhantomKeysManager_new');
  late final _PhantomKeysManager_new = _PhantomKeysManager_newPtr.asFunction<
      LDKPhantomKeysManager Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int,
          int, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// See [`KeysManager::spend_spendable_outputs`] for documentation on this method.
  LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(
    ffi.Pointer<LDKPhantomKeysManager> this_arg,
    LDKCVec_SpendableOutputDescriptorZ descriptors,
    LDKCVec_TxOutZ outputs,
    LDKCVec_u8Z change_destination_script,
    int feerate_sat_per_1000_weight,
  ) {
    return _PhantomKeysManager_spend_spendable_outputs(
      this_arg,
      descriptors,
      outputs,
      change_destination_script,
      feerate_sat_per_1000_weight,
    );
  }

  late final _PhantomKeysManager_spend_spendable_outputsPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TransactionNoneZ Function(
              ffi.Pointer<LDKPhantomKeysManager>,
              LDKCVec_SpendableOutputDescriptorZ,
              LDKCVec_TxOutZ,
              LDKCVec_u8Z,
              ffi.Uint32)>>('PhantomKeysManager_spend_spendable_outputs');
  late final _PhantomKeysManager_spend_spendable_outputs =
      _PhantomKeysManager_spend_spendable_outputsPtr.asFunction<
          LDKCResult_TransactionNoneZ Function(
              ffi.Pointer<LDKPhantomKeysManager>,
              LDKCVec_SpendableOutputDescriptorZ,
              LDKCVec_TxOutZ,
              LDKCVec_u8Z,
              int)>();

  /// See [`KeysManager::derive_channel_keys`] for documentation on this method.
  LDKInMemorySigner PhantomKeysManager_derive_channel_keys(
    ffi.Pointer<LDKPhantomKeysManager> this_arg,
    int channel_value_satoshis,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> params,
  ) {
    return _PhantomKeysManager_derive_channel_keys(
      this_arg,
      channel_value_satoshis,
      params,
    );
  }

  late final _PhantomKeysManager_derive_channel_keysPtr = _lookup<
          ffi.NativeFunction<
              LDKInMemorySigner Function(ffi.Pointer<LDKPhantomKeysManager>,
                  ffi.Uint64, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'PhantomKeysManager_derive_channel_keys');
  late final _PhantomKeysManager_derive_channel_keys =
      _PhantomKeysManager_derive_channel_keysPtr.asFunction<
          LDKInMemorySigner Function(ffi.Pointer<LDKPhantomKeysManager>, int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
  void ChannelManager_free(
    LDKChannelManager this_obj,
  ) {
    return _ChannelManager_free(
      this_obj,
    );
  }

  late final _ChannelManager_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelManager)>>(
          'ChannelManager_free');
  late final _ChannelManager_free =
      _ChannelManager_freePtr.asFunction<void Function(LDKChannelManager)>();

  /// Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
  void ChainParameters_free(
    LDKChainParameters this_obj,
  ) {
    return _ChainParameters_free(
      this_obj,
    );
  }

  late final _ChainParameters_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChainParameters)>>(
          'ChainParameters_free');
  late final _ChainParameters_free =
      _ChainParameters_freePtr.asFunction<void Function(LDKChainParameters)>();

  /// The network for determining the `chain_hash` in Lightning messages.
  int ChainParameters_get_network(
    ffi.Pointer<LDKChainParameters> this_ptr,
  ) {
    return _ChainParameters_get_network(
      this_ptr,
    );
  }

  late final _ChainParameters_get_networkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<LDKChainParameters>)>>('ChainParameters_get_network');
  late final _ChainParameters_get_network = _ChainParameters_get_networkPtr
      .asFunction<int Function(ffi.Pointer<LDKChainParameters>)>();

  /// The network for determining the `chain_hash` in Lightning messages.
  void ChainParameters_set_network(
    ffi.Pointer<LDKChainParameters> this_ptr,
    int val,
  ) {
    return _ChainParameters_set_network(
      this_ptr,
      val,
    );
  }

  late final _ChainParameters_set_networkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChainParameters>,
              ffi.Int32)>>('ChainParameters_set_network');
  late final _ChainParameters_set_network = _ChainParameters_set_networkPtr
      .asFunction<void Function(ffi.Pointer<LDKChainParameters>, int)>();

  /// The hash and height of the latest block successfully connected.
  ///
  /// Used to track on-chain channel funding outputs and send payments with reliable timelocks.
  LDKBestBlock ChainParameters_get_best_block(
    ffi.Pointer<LDKChainParameters> this_ptr,
  ) {
    return _ChainParameters_get_best_block(
      this_ptr,
    );
  }

  late final _ChainParameters_get_best_blockPtr = _lookup<
          ffi.NativeFunction<
              LDKBestBlock Function(ffi.Pointer<LDKChainParameters>)>>(
      'ChainParameters_get_best_block');
  late final _ChainParameters_get_best_block =
      _ChainParameters_get_best_blockPtr.asFunction<
          LDKBestBlock Function(ffi.Pointer<LDKChainParameters>)>();

  /// The hash and height of the latest block successfully connected.
  ///
  /// Used to track on-chain channel funding outputs and send payments with reliable timelocks.
  void ChainParameters_set_best_block(
    ffi.Pointer<LDKChainParameters> this_ptr,
    LDKBestBlock val,
  ) {
    return _ChainParameters_set_best_block(
      this_ptr,
      val,
    );
  }

  late final _ChainParameters_set_best_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChainParameters>,
              LDKBestBlock)>>('ChainParameters_set_best_block');
  late final _ChainParameters_set_best_block =
      _ChainParameters_set_best_blockPtr.asFunction<
          void Function(ffi.Pointer<LDKChainParameters>, LDKBestBlock)>();

  /// Constructs a new ChainParameters given each field
  LDKChainParameters ChainParameters_new(
    int network_arg,
    LDKBestBlock best_block_arg,
  ) {
    return _ChainParameters_new(
      network_arg,
      best_block_arg,
    );
  }

  late final _ChainParameters_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChainParameters Function(
              ffi.Int32, LDKBestBlock)>>('ChainParameters_new');
  late final _ChainParameters_new = _ChainParameters_newPtr.asFunction<
      LDKChainParameters Function(int, LDKBestBlock)>();

  /// Creates a copy of the ChainParameters
  LDKChainParameters ChainParameters_clone(
    ffi.Pointer<LDKChainParameters> orig,
  ) {
    return _ChainParameters_clone(
      orig,
    );
  }

  late final _ChainParameters_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChainParameters Function(
              ffi.Pointer<LDKChainParameters>)>>('ChainParameters_clone');
  late final _ChainParameters_clone = _ChainParameters_clonePtr.asFunction<
      LDKChainParameters Function(ffi.Pointer<LDKChainParameters>)>();

  /// Frees any resources used by the CounterpartyForwardingInfo, if is_owned is set and inner is non-NULL.
  void CounterpartyForwardingInfo_free(
    LDKCounterpartyForwardingInfo this_obj,
  ) {
    return _CounterpartyForwardingInfo_free(
      this_obj,
    );
  }

  late final _CounterpartyForwardingInfo_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKCounterpartyForwardingInfo)>>(
      'CounterpartyForwardingInfo_free');
  late final _CounterpartyForwardingInfo_free =
      _CounterpartyForwardingInfo_freePtr.asFunction<
          void Function(LDKCounterpartyForwardingInfo)>();

  /// Base routing fee in millisatoshis.
  int CounterpartyForwardingInfo_get_fee_base_msat(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
  ) {
    return _CounterpartyForwardingInfo_get_fee_base_msat(
      this_ptr,
    );
  }

  late final _CounterpartyForwardingInfo_get_fee_base_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>>(
      'CounterpartyForwardingInfo_get_fee_base_msat');
  late final _CounterpartyForwardingInfo_get_fee_base_msat =
      _CounterpartyForwardingInfo_get_fee_base_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>();

  /// Base routing fee in millisatoshis.
  void CounterpartyForwardingInfo_set_fee_base_msat(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
    int val,
  ) {
    return _CounterpartyForwardingInfo_set_fee_base_msat(
      this_ptr,
      val,
    );
  }

  late final _CounterpartyForwardingInfo_set_fee_base_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCounterpartyForwardingInfo>,
              ffi.Uint32)>>('CounterpartyForwardingInfo_set_fee_base_msat');
  late final _CounterpartyForwardingInfo_set_fee_base_msat =
      _CounterpartyForwardingInfo_set_fee_base_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKCounterpartyForwardingInfo>, int)>();

  /// Amount in millionths of a satoshi the channel will charge per transferred satoshi.
  int CounterpartyForwardingInfo_get_fee_proportional_millionths(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
  ) {
    return _CounterpartyForwardingInfo_get_fee_proportional_millionths(
      this_ptr,
    );
  }

  late final _CounterpartyForwardingInfo_get_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint32 Function(
                      ffi.Pointer<LDKCounterpartyForwardingInfo>)>>(
          'CounterpartyForwardingInfo_get_fee_proportional_millionths');
  late final _CounterpartyForwardingInfo_get_fee_proportional_millionths =
      _CounterpartyForwardingInfo_get_fee_proportional_millionthsPtr.asFunction<
          int Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>();

  /// Amount in millionths of a satoshi the channel will charge per transferred satoshi.
  void CounterpartyForwardingInfo_set_fee_proportional_millionths(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
    int val,
  ) {
    return _CounterpartyForwardingInfo_set_fee_proportional_millionths(
      this_ptr,
      val,
    );
  }

  late final _CounterpartyForwardingInfo_set_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKCounterpartyForwardingInfo>, ffi.Uint32)>>(
          'CounterpartyForwardingInfo_set_fee_proportional_millionths');
  late final _CounterpartyForwardingInfo_set_fee_proportional_millionths =
      _CounterpartyForwardingInfo_set_fee_proportional_millionthsPtr.asFunction<
          void Function(ffi.Pointer<LDKCounterpartyForwardingInfo>, int)>();

  /// The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
  /// such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
  /// `cltv_expiry_delta` for more details.
  int CounterpartyForwardingInfo_get_cltv_expiry_delta(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
  ) {
    return _CounterpartyForwardingInfo_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _CounterpartyForwardingInfo_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>>(
      'CounterpartyForwardingInfo_get_cltv_expiry_delta');
  late final _CounterpartyForwardingInfo_get_cltv_expiry_delta =
      _CounterpartyForwardingInfo_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>();

  /// The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
  /// such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
  /// `cltv_expiry_delta` for more details.
  void CounterpartyForwardingInfo_set_cltv_expiry_delta(
    ffi.Pointer<LDKCounterpartyForwardingInfo> this_ptr,
    int val,
  ) {
    return _CounterpartyForwardingInfo_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _CounterpartyForwardingInfo_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCounterpartyForwardingInfo>,
              ffi.Uint16)>>('CounterpartyForwardingInfo_set_cltv_expiry_delta');
  late final _CounterpartyForwardingInfo_set_cltv_expiry_delta =
      _CounterpartyForwardingInfo_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKCounterpartyForwardingInfo>, int)>();

  /// Constructs a new CounterpartyForwardingInfo given each field
  LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(
    int fee_base_msat_arg,
    int fee_proportional_millionths_arg,
    int cltv_expiry_delta_arg,
  ) {
    return _CounterpartyForwardingInfo_new(
      fee_base_msat_arg,
      fee_proportional_millionths_arg,
      cltv_expiry_delta_arg,
    );
  }

  late final _CounterpartyForwardingInfo_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCounterpartyForwardingInfo Function(ffi.Uint32, ffi.Uint32,
              ffi.Uint16)>>('CounterpartyForwardingInfo_new');
  late final _CounterpartyForwardingInfo_new =
      _CounterpartyForwardingInfo_newPtr.asFunction<
          LDKCounterpartyForwardingInfo Function(int, int, int)>();

  /// Creates a copy of the CounterpartyForwardingInfo
  LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(
    ffi.Pointer<LDKCounterpartyForwardingInfo> orig,
  ) {
    return _CounterpartyForwardingInfo_clone(
      orig,
    );
  }

  late final _CounterpartyForwardingInfo_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCounterpartyForwardingInfo Function(
                  ffi.Pointer<LDKCounterpartyForwardingInfo>)>>(
      'CounterpartyForwardingInfo_clone');
  late final _CounterpartyForwardingInfo_clone =
      _CounterpartyForwardingInfo_clonePtr.asFunction<
          LDKCounterpartyForwardingInfo Function(
              ffi.Pointer<LDKCounterpartyForwardingInfo>)>();

  /// Frees any resources used by the ChannelCounterparty, if is_owned is set and inner is non-NULL.
  void ChannelCounterparty_free(
    LDKChannelCounterparty this_obj,
  ) {
    return _ChannelCounterparty_free(
      this_obj,
    );
  }

  late final _ChannelCounterparty_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelCounterparty)>>(
          'ChannelCounterparty_free');
  late final _ChannelCounterparty_free = _ChannelCounterparty_freePtr
      .asFunction<void Function(LDKChannelCounterparty)>();

  /// The node_id of our counterparty
  LDKPublicKey ChannelCounterparty_get_node_id(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_node_id(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_node_idPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_get_node_id');
  late final _ChannelCounterparty_get_node_id =
      _ChannelCounterparty_get_node_idPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// The node_id of our counterparty
  void ChannelCounterparty_set_node_id(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelCounterparty_set_node_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_node_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelCounterparty>,
              LDKPublicKey)>>('ChannelCounterparty_set_node_id');
  late final _ChannelCounterparty_set_node_id =
      _ChannelCounterparty_set_node_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelCounterparty>, LDKPublicKey)>();

  /// The Features the channel counterparty provided upon last connection.
  /// Useful for routing as it is the most up-to-date copy of the counterparty's features and
  /// many routing-relevant features are present in the init context.
  LDKInitFeatures ChannelCounterparty_get_features(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_features(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_featuresPtr = _lookup<
          ffi.NativeFunction<
              LDKInitFeatures Function(ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_get_features');
  late final _ChannelCounterparty_get_features =
      _ChannelCounterparty_get_featuresPtr.asFunction<
          LDKInitFeatures Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// The Features the channel counterparty provided upon last connection.
  /// Useful for routing as it is the most up-to-date copy of the counterparty's features and
  /// many routing-relevant features are present in the init context.
  void ChannelCounterparty_set_features(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    LDKInitFeatures val,
  ) {
    return _ChannelCounterparty_set_features(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelCounterparty>,
              LDKInitFeatures)>>('ChannelCounterparty_set_features');
  late final _ChannelCounterparty_set_features =
      _ChannelCounterparty_set_featuresPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelCounterparty>, LDKInitFeatures)>();

  /// The value, in satoshis, that must always be held in the channel for our counterparty. This
  /// value ensures that if our counterparty broadcasts a revoked state, we can punish them by
  /// claiming at least this value on chain.
  ///
  /// This value is not included in [`inbound_capacity_msat`] as it can never be spent.
  ///
  /// [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
  int ChannelCounterparty_get_unspendable_punishment_reserve(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_unspendable_punishment_reserve(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_unspendable_punishment_reservePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(ffi.Pointer<LDKChannelCounterparty>)>>(
          'ChannelCounterparty_get_unspendable_punishment_reserve');
  late final _ChannelCounterparty_get_unspendable_punishment_reserve =
      _ChannelCounterparty_get_unspendable_punishment_reservePtr.asFunction<
          int Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// The value, in satoshis, that must always be held in the channel for our counterparty. This
  /// value ensures that if our counterparty broadcasts a revoked state, we can punish them by
  /// claiming at least this value on chain.
  ///
  /// This value is not included in [`inbound_capacity_msat`] as it can never be spent.
  ///
  /// [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
  void ChannelCounterparty_set_unspendable_punishment_reserve(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    int val,
  ) {
    return _ChannelCounterparty_set_unspendable_punishment_reserve(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_unspendable_punishment_reservePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelCounterparty>, ffi.Uint64)>>(
          'ChannelCounterparty_set_unspendable_punishment_reserve');
  late final _ChannelCounterparty_set_unspendable_punishment_reserve =
      _ChannelCounterparty_set_unspendable_punishment_reservePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelCounterparty>, int)>();

  /// Information on the fees and requirements that the counterparty requires when forwarding
  /// payments to us through this channel.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_forwarding_info(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_forwarding_infoPtr = _lookup<
          ffi.NativeFunction<
              LDKCounterpartyForwardingInfo Function(
                  ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_get_forwarding_info');
  late final _ChannelCounterparty_get_forwarding_info =
      _ChannelCounterparty_get_forwarding_infoPtr.asFunction<
          LDKCounterpartyForwardingInfo Function(
              ffi.Pointer<LDKChannelCounterparty>)>();

  /// Information on the fees and requirements that the counterparty requires when forwarding
  /// payments to us through this channel.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelCounterparty_set_forwarding_info(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    LDKCounterpartyForwardingInfo val,
  ) {
    return _ChannelCounterparty_set_forwarding_info(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_forwarding_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelCounterparty>,
                  LDKCounterpartyForwardingInfo)>>(
      'ChannelCounterparty_set_forwarding_info');
  late final _ChannelCounterparty_set_forwarding_info =
      _ChannelCounterparty_set_forwarding_infoPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelCounterparty>,
              LDKCounterpartyForwardingInfo)>();

  /// The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
  /// is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
  /// from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
  LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_minimum_msat(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_outbound_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_outbound_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_get_outbound_htlc_minimum_msat');
  late final _ChannelCounterparty_get_outbound_htlc_minimum_msat =
      _ChannelCounterparty_get_outbound_htlc_minimum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
  /// is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
  /// from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
  void ChannelCounterparty_set_outbound_htlc_minimum_msat(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelCounterparty_set_outbound_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_outbound_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelCounterparty>, LDKCOption_u64Z)>>(
      'ChannelCounterparty_set_outbound_htlc_minimum_msat');
  late final _ChannelCounterparty_set_outbound_htlc_minimum_msat =
      _ChannelCounterparty_set_outbound_htlc_minimum_msatPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelCounterparty>, LDKCOption_u64Z)>();

  /// The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
  LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_maximum_msat(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
  ) {
    return _ChannelCounterparty_get_outbound_htlc_maximum_msat(
      this_ptr,
    );
  }

  late final _ChannelCounterparty_get_outbound_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_get_outbound_htlc_maximum_msat');
  late final _ChannelCounterparty_get_outbound_htlc_maximum_msat =
      _ChannelCounterparty_get_outbound_htlc_maximum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
  void ChannelCounterparty_set_outbound_htlc_maximum_msat(
    ffi.Pointer<LDKChannelCounterparty> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelCounterparty_set_outbound_htlc_maximum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelCounterparty_set_outbound_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelCounterparty>, LDKCOption_u64Z)>>(
      'ChannelCounterparty_set_outbound_htlc_maximum_msat');
  late final _ChannelCounterparty_set_outbound_htlc_maximum_msat =
      _ChannelCounterparty_set_outbound_htlc_maximum_msatPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelCounterparty>, LDKCOption_u64Z)>();

  /// Constructs a new ChannelCounterparty given each field
  LDKChannelCounterparty ChannelCounterparty_new(
    LDKPublicKey node_id_arg,
    LDKInitFeatures features_arg,
    int unspendable_punishment_reserve_arg,
    LDKCounterpartyForwardingInfo forwarding_info_arg,
    LDKCOption_u64Z outbound_htlc_minimum_msat_arg,
    LDKCOption_u64Z outbound_htlc_maximum_msat_arg,
  ) {
    return _ChannelCounterparty_new(
      node_id_arg,
      features_arg,
      unspendable_punishment_reserve_arg,
      forwarding_info_arg,
      outbound_htlc_minimum_msat_arg,
      outbound_htlc_maximum_msat_arg,
    );
  }

  late final _ChannelCounterparty_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelCounterparty Function(
              LDKPublicKey,
              LDKInitFeatures,
              ffi.Uint64,
              LDKCounterpartyForwardingInfo,
              LDKCOption_u64Z,
              LDKCOption_u64Z)>>('ChannelCounterparty_new');
  late final _ChannelCounterparty_new = _ChannelCounterparty_newPtr.asFunction<
      LDKChannelCounterparty Function(LDKPublicKey, LDKInitFeatures, int,
          LDKCounterpartyForwardingInfo, LDKCOption_u64Z, LDKCOption_u64Z)>();

  /// Creates a copy of the ChannelCounterparty
  LDKChannelCounterparty ChannelCounterparty_clone(
    ffi.Pointer<LDKChannelCounterparty> orig,
  ) {
    return _ChannelCounterparty_clone(
      orig,
    );
  }

  late final _ChannelCounterparty_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelCounterparty Function(
                  ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_clone');
  late final _ChannelCounterparty_clone =
      _ChannelCounterparty_clonePtr.asFunction<
          LDKChannelCounterparty Function(
              ffi.Pointer<LDKChannelCounterparty>)>();

  /// Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
  void ChannelDetails_free(
    LDKChannelDetails this_obj,
  ) {
    return _ChannelDetails_free(
      this_obj,
    );
  }

  late final _ChannelDetails_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelDetails)>>(
          'ChannelDetails_free');
  late final _ChannelDetails_free =
      _ChannelDetails_freePtr.asFunction<void Function(LDKChannelDetails)>();

  /// The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
  /// thereafter this is the txid of the funding transaction xor the funding transaction output).
  /// Note that this means this value is *not* persistent - it can change once during the
  /// lifetime of the channel.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ChannelDetails_get_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_channel_id(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_channel_id');
  late final _ChannelDetails_get_channel_id =
      _ChannelDetails_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKChannelDetails>)>();

  /// The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
  /// thereafter this is the txid of the funding transaction xor the funding transaction output).
  /// Note that this means this value is *not* persistent - it can change once during the
  /// lifetime of the channel.
  void ChannelDetails_set_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ChannelDetails_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKThirtyTwoBytes)>>('ChannelDetails_set_channel_id');
  late final _ChannelDetails_set_channel_id =
      _ChannelDetails_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKThirtyTwoBytes)>();

  /// Parameters which apply to our counterparty. See individual fields for more information.
  LDKChannelCounterparty ChannelDetails_get_counterparty(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_counterparty(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_counterpartyPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelCounterparty Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_counterparty');
  late final _ChannelDetails_get_counterparty =
      _ChannelDetails_get_counterpartyPtr.asFunction<
          LDKChannelCounterparty Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Parameters which apply to our counterparty. See individual fields for more information.
  void ChannelDetails_set_counterparty(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKChannelCounterparty val,
  ) {
    return _ChannelDetails_set_counterparty(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_counterpartyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKChannelCounterparty)>>('ChannelDetails_set_counterparty');
  late final _ChannelDetails_set_counterparty =
      _ChannelDetails_set_counterpartyPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelDetails>, LDKChannelCounterparty)>();

  /// The Channel's funding transaction output, if we've negotiated the funding transaction with
  /// our counterparty already.
  ///
  /// Note that, if this has been set, `channel_id` will be equivalent to
  /// `funding_txo.unwrap().to_channel_id()`.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKOutPoint ChannelDetails_get_funding_txo(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_funding_txo(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_funding_txoPtr = _lookup<
          ffi.NativeFunction<
              LDKOutPoint Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_funding_txo');
  late final _ChannelDetails_get_funding_txo =
      _ChannelDetails_get_funding_txoPtr.asFunction<
          LDKOutPoint Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The Channel's funding transaction output, if we've negotiated the funding transaction with
  /// our counterparty already.
  ///
  /// Note that, if this has been set, `channel_id` will be equivalent to
  /// `funding_txo.unwrap().to_channel_id()`.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelDetails_set_funding_txo(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKOutPoint val,
  ) {
    return _ChannelDetails_set_funding_txo(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_funding_txoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKOutPoint)>>('ChannelDetails_set_funding_txo');
  late final _ChannelDetails_set_funding_txo =
      _ChannelDetails_set_funding_txoPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKOutPoint)>();

  /// The features which this channel operates with. See individual features for more info.
  ///
  /// `None` until negotiation completes and the channel type is finalized.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelTypeFeatures ChannelDetails_get_channel_type(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_channel_type(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_channel_typePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelTypeFeatures Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_channel_type');
  late final _ChannelDetails_get_channel_type =
      _ChannelDetails_get_channel_typePtr.asFunction<
          LDKChannelTypeFeatures Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The features which this channel operates with. See individual features for more info.
  ///
  /// `None` until negotiation completes and the channel type is finalized.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelDetails_set_channel_type(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKChannelTypeFeatures val,
  ) {
    return _ChannelDetails_set_channel_type(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_channel_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKChannelTypeFeatures)>>('ChannelDetails_set_channel_type');
  late final _ChannelDetails_set_channel_type =
      _ChannelDetails_set_channel_typePtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelDetails>, LDKChannelTypeFeatures)>();

  /// The position of the funding transaction in the chain. None if the funding transaction has
  /// not yet been confirmed and the channel fully opened.
  ///
  /// Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
  /// payments instead of this. See [`get_inbound_payment_scid`].
  ///
  /// For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
  /// be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
  ///
  /// [`inbound_scid_alias`]: Self::inbound_scid_alias
  /// [`outbound_scid_alias`]: Self::outbound_scid_alias
  /// [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
  /// [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
  /// [`confirmations_required`]: Self::confirmations_required
  LDKCOption_u64Z ChannelDetails_get_short_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_short_channel_id(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_short_channel_id');
  late final _ChannelDetails_get_short_channel_id =
      _ChannelDetails_get_short_channel_idPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The position of the funding transaction in the chain. None if the funding transaction has
  /// not yet been confirmed and the channel fully opened.
  ///
  /// Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
  /// payments instead of this. See [`get_inbound_payment_scid`].
  ///
  /// For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
  /// be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
  ///
  /// [`inbound_scid_alias`]: Self::inbound_scid_alias
  /// [`outbound_scid_alias`]: Self::outbound_scid_alias
  /// [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
  /// [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
  /// [`confirmations_required`]: Self::confirmations_required
  void ChannelDetails_set_short_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKCOption_u64Z)>>('ChannelDetails_set_short_channel_id');
  late final _ChannelDetails_set_short_channel_id =
      _ChannelDetails_set_short_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// An optional [`short_channel_id`] alias for this channel, randomly generated by us and
  /// usable in place of [`short_channel_id`] to reference the channel in outbound routes when
  /// the channel has not yet been confirmed (as long as [`confirmations_required`] is
  /// `Some(0)`).
  ///
  /// This will be `None` as long as the channel is not available for routing outbound payments.
  ///
  /// [`short_channel_id`]: Self::short_channel_id
  /// [`confirmations_required`]: Self::confirmations_required
  LDKCOption_u64Z ChannelDetails_get_outbound_scid_alias(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_outbound_scid_alias(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_outbound_scid_aliasPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_outbound_scid_alias');
  late final _ChannelDetails_get_outbound_scid_alias =
      _ChannelDetails_get_outbound_scid_aliasPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// An optional [`short_channel_id`] alias for this channel, randomly generated by us and
  /// usable in place of [`short_channel_id`] to reference the channel in outbound routes when
  /// the channel has not yet been confirmed (as long as [`confirmations_required`] is
  /// `Some(0)`).
  ///
  /// This will be `None` as long as the channel is not available for routing outbound payments.
  ///
  /// [`short_channel_id`]: Self::short_channel_id
  /// [`confirmations_required`]: Self::confirmations_required
  void ChannelDetails_set_outbound_scid_alias(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_outbound_scid_alias(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_outbound_scid_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKCOption_u64Z)>>('ChannelDetails_set_outbound_scid_alias');
  late final _ChannelDetails_set_outbound_scid_alias =
      _ChannelDetails_set_outbound_scid_aliasPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// An optional [`short_channel_id`] alias for this channel, randomly generated by our
  /// counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
  /// counterparty will recognize the alias provided here in place of the [`short_channel_id`]
  /// when they see a payment to be routed to us.
  ///
  /// Our counterparty may choose to rotate this value at any time, though will always recognize
  /// previous values for inbound payment forwarding.
  ///
  /// [`short_channel_id`]: Self::short_channel_id
  LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_inbound_scid_alias(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_inbound_scid_aliasPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_inbound_scid_alias');
  late final _ChannelDetails_get_inbound_scid_alias =
      _ChannelDetails_get_inbound_scid_aliasPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// An optional [`short_channel_id`] alias for this channel, randomly generated by our
  /// counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
  /// counterparty will recognize the alias provided here in place of the [`short_channel_id`]
  /// when they see a payment to be routed to us.
  ///
  /// Our counterparty may choose to rotate this value at any time, though will always recognize
  /// previous values for inbound payment forwarding.
  ///
  /// [`short_channel_id`]: Self::short_channel_id
  void ChannelDetails_set_inbound_scid_alias(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_inbound_scid_alias(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_inbound_scid_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKCOption_u64Z)>>('ChannelDetails_set_inbound_scid_alias');
  late final _ChannelDetails_set_inbound_scid_alias =
      _ChannelDetails_set_inbound_scid_aliasPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// The value, in satoshis, of this channel as appears in the funding output
  int ChannelDetails_get_channel_value_satoshis(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_channel_value_satoshis(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_channel_value_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_channel_value_satoshis');
  late final _ChannelDetails_get_channel_value_satoshis =
      _ChannelDetails_get_channel_value_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The value, in satoshis, of this channel as appears in the funding output
  void ChannelDetails_set_channel_value_satoshis(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_channel_value_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_channel_value_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_channel_value_satoshis');
  late final _ChannelDetails_set_channel_value_satoshis =
      _ChannelDetails_set_channel_value_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// The value, in satoshis, that must always be held in the channel for us. This value ensures
  /// that if we broadcast a revoked state, our counterparty can punish us by claiming at least
  /// this value on chain.
  ///
  /// This value is not included in [`outbound_capacity_msat`] as it can never be spent.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  ///
  /// [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
  LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_unspendable_punishment_reserve(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_unspendable_punishment_reservePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_unspendable_punishment_reserve');
  late final _ChannelDetails_get_unspendable_punishment_reserve =
      _ChannelDetails_get_unspendable_punishment_reservePtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The value, in satoshis, that must always be held in the channel for us. This value ensures
  /// that if we broadcast a revoked state, our counterparty can punish us by claiming at least
  /// this value on chain.
  ///
  /// This value is not included in [`outbound_capacity_msat`] as it can never be spent.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  ///
  /// [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
  void ChannelDetails_set_unspendable_punishment_reserve(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_unspendable_punishment_reserve(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_unspendable_punishment_reservePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>>(
      'ChannelDetails_set_unspendable_punishment_reserve');
  late final _ChannelDetails_set_unspendable_punishment_reserve =
      _ChannelDetails_set_unspendable_punishment_reservePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
  int ChannelDetails_get_user_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_user_channel_id(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_user_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_user_channel_id');
  late final _ChannelDetails_get_user_channel_id =
      _ChannelDetails_get_user_channel_idPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
  void ChannelDetails_set_user_channel_id(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_user_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_user_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_user_channel_id');
  late final _ChannelDetails_set_user_channel_id =
      _ChannelDetails_set_user_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// Our total balance.  This is the amount we would get if we close the channel.
  /// This value is not exact. Due to various in-flight changes and feerate changes, exactly this
  /// amount is not likely to be recoverable on close.
  ///
  /// This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
  /// balance is not available for inclusion in new outbound HTLCs). This further does not include
  /// any pending outgoing HTLCs which are awaiting some other resolution to be sent.
  /// This does not consider any on-chain fees.
  ///
  /// See also [`ChannelDetails::outbound_capacity_msat`]
  int ChannelDetails_get_balance_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_balance_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_balance_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_balance_msat');
  late final _ChannelDetails_get_balance_msat =
      _ChannelDetails_get_balance_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Our total balance.  This is the amount we would get if we close the channel.
  /// This value is not exact. Due to various in-flight changes and feerate changes, exactly this
  /// amount is not likely to be recoverable on close.
  ///
  /// This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
  /// balance is not available for inclusion in new outbound HTLCs). This further does not include
  /// any pending outgoing HTLCs which are awaiting some other resolution to be sent.
  /// This does not consider any on-chain fees.
  ///
  /// See also [`ChannelDetails::outbound_capacity_msat`]
  void ChannelDetails_set_balance_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_balance_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_balance_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_balance_msat');
  late final _ChannelDetails_set_balance_msat =
      _ChannelDetails_set_balance_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// The available outbound capacity for sending HTLCs to the remote peer. This does not include
  /// any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new outbound HTLCs). This further does not include any pending
  /// outgoing HTLCs which are awaiting some other resolution to be sent.
  ///
  /// See also [`ChannelDetails::balance_msat`]
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
  /// should be able to spend nearly this amount.
  int ChannelDetails_get_outbound_capacity_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_outbound_capacity_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_outbound_capacity_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_outbound_capacity_msat');
  late final _ChannelDetails_get_outbound_capacity_msat =
      _ChannelDetails_get_outbound_capacity_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The available outbound capacity for sending HTLCs to the remote peer. This does not include
  /// any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new outbound HTLCs). This further does not include any pending
  /// outgoing HTLCs which are awaiting some other resolution to be sent.
  ///
  /// See also [`ChannelDetails::balance_msat`]
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
  /// should be able to spend nearly this amount.
  void ChannelDetails_set_outbound_capacity_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_outbound_capacity_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_outbound_capacity_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_outbound_capacity_msat');
  late final _ChannelDetails_set_outbound_capacity_msat =
      _ChannelDetails_set_outbound_capacity_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// The available outbound capacity for sending a single HTLC to the remote peer. This is
  /// similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
  /// the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
  /// to use a limit as close as possible to the HTLC limit we can currently send.
  ///
  /// See also [`ChannelDetails::balance_msat`] and [`ChannelDetails::outbound_capacity_msat`].
  int ChannelDetails_get_next_outbound_htlc_limit_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_next_outbound_htlc_limit_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_next_outbound_htlc_limit_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_next_outbound_htlc_limit_msat');
  late final _ChannelDetails_get_next_outbound_htlc_limit_msat =
      _ChannelDetails_get_next_outbound_htlc_limit_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The available outbound capacity for sending a single HTLC to the remote peer. This is
  /// similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
  /// the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
  /// to use a limit as close as possible to the HTLC limit we can currently send.
  ///
  /// See also [`ChannelDetails::balance_msat`] and [`ChannelDetails::outbound_capacity_msat`].
  void ChannelDetails_set_next_outbound_htlc_limit_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_next_outbound_htlc_limit_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_next_outbound_htlc_limit_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_next_outbound_htlc_limit_msat');
  late final _ChannelDetails_set_next_outbound_htlc_limit_msat =
      _ChannelDetails_set_next_outbound_htlc_limit_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// The available inbound capacity for the remote peer to send HTLCs to us. This does not
  /// include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new inbound HTLCs).
  /// Note that there are some corner cases not fully handled here, so the actual available
  /// inbound capacity may be slightly higher than this.
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
  /// However, our counterparty should be able to spend nearly this amount.
  int ChannelDetails_get_inbound_capacity_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_inbound_capacity_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_inbound_capacity_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_inbound_capacity_msat');
  late final _ChannelDetails_get_inbound_capacity_msat =
      _ChannelDetails_get_inbound_capacity_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The available inbound capacity for the remote peer to send HTLCs to us. This does not
  /// include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
  /// available for inclusion in new inbound HTLCs).
  /// Note that there are some corner cases not fully handled here, so the actual available
  /// inbound capacity may be slightly higher than this.
  ///
  /// This value is not exact. Due to various in-flight changes, feerate changes, and our
  /// counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
  /// However, our counterparty should be able to spend nearly this amount.
  void ChannelDetails_set_inbound_capacity_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    int val,
  ) {
    return _ChannelDetails_set_inbound_capacity_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_inbound_capacity_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Uint64)>>('ChannelDetails_set_inbound_capacity_msat');
  late final _ChannelDetails_set_inbound_capacity_msat =
      _ChannelDetails_set_inbound_capacity_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, int)>();

  /// The number of required confirmations on the funding transaction before the funding will be
  /// considered \"locked\". This number is selected by the channel fundee (i.e. us if
  /// [`is_outbound`] is *not* set), and can be selected for inbound channels with
  /// [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
  /// [`ChannelHandshakeLimits::max_minimum_depth`].
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  ///
  /// [`is_outbound`]: ChannelDetails::is_outbound
  /// [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
  /// [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
  LDKCOption_u32Z ChannelDetails_get_confirmations_required(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_confirmations_required(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_confirmations_requiredPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u32Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_confirmations_required');
  late final _ChannelDetails_get_confirmations_required =
      _ChannelDetails_get_confirmations_requiredPtr.asFunction<
          LDKCOption_u32Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The number of required confirmations on the funding transaction before the funding will be
  /// considered \"locked\". This number is selected by the channel fundee (i.e. us if
  /// [`is_outbound`] is *not* set), and can be selected for inbound channels with
  /// [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
  /// [`ChannelHandshakeLimits::max_minimum_depth`].
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  ///
  /// [`is_outbound`]: ChannelDetails::is_outbound
  /// [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
  /// [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
  void ChannelDetails_set_confirmations_required(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u32Z val,
  ) {
    return _ChannelDetails_set_confirmations_required(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_confirmations_requiredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKCOption_u32Z)>>('ChannelDetails_set_confirmations_required');
  late final _ChannelDetails_set_confirmations_required =
      _ChannelDetails_set_confirmations_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u32Z)>();

  /// The number of blocks (after our commitment transaction confirms) that we will need to wait
  /// until we can claim our funds after we force-close the channel. During this time our
  /// counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
  /// force-closes the channel and broadcasts a commitment transaction we do not have to wait any
  /// time to claim our non-HTLC-encumbered funds.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_force_close_spend_delay(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_force_close_spend_delayPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u16Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_force_close_spend_delay');
  late final _ChannelDetails_get_force_close_spend_delay =
      _ChannelDetails_get_force_close_spend_delayPtr.asFunction<
          LDKCOption_u16Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The number of blocks (after our commitment transaction confirms) that we will need to wait
  /// until we can claim our funds after we force-close the channel. During this time our
  /// counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
  /// force-closes the channel and broadcasts a commitment transaction we do not have to wait any
  /// time to claim our non-HTLC-encumbered funds.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  void ChannelDetails_set_force_close_spend_delay(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u16Z val,
  ) {
    return _ChannelDetails_set_force_close_spend_delay(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_force_close_spend_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKCOption_u16Z)>>('ChannelDetails_set_force_close_spend_delay');
  late final _ChannelDetails_set_force_close_spend_delay =
      _ChannelDetails_set_force_close_spend_delayPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u16Z)>();

  /// True if the channel was initiated (and thus funded) by us.
  bool ChannelDetails_get_is_outbound(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_is_outbound(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_is_outboundPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_is_outbound');
  late final _ChannelDetails_get_is_outbound =
      _ChannelDetails_get_is_outboundPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelDetails>)>();

  /// True if the channel was initiated (and thus funded) by us.
  void ChannelDetails_set_is_outbound(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    bool val,
  ) {
    return _ChannelDetails_set_is_outbound(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_is_outboundPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Bool)>>('ChannelDetails_set_is_outbound');
  late final _ChannelDetails_set_is_outbound =
      _ChannelDetails_set_is_outboundPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, bool)>();

  /// True if the channel is confirmed, channel_ready messages have been exchanged, and the
  /// channel is not currently being shut down. `channel_ready` message exchange implies the
  /// required confirmation count has been reached (and we were connected to the peer at some
  /// point after the funding transaction received enough confirmations). The required
  /// confirmation count is provided in [`confirmations_required`].
  ///
  /// [`confirmations_required`]: ChannelDetails::confirmations_required
  bool ChannelDetails_get_is_channel_ready(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_is_channel_ready(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_is_channel_readyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_is_channel_ready');
  late final _ChannelDetails_get_is_channel_ready =
      _ChannelDetails_get_is_channel_readyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelDetails>)>();

  /// True if the channel is confirmed, channel_ready messages have been exchanged, and the
  /// channel is not currently being shut down. `channel_ready` message exchange implies the
  /// required confirmation count has been reached (and we were connected to the peer at some
  /// point after the funding transaction received enough confirmations). The required
  /// confirmation count is provided in [`confirmations_required`].
  ///
  /// [`confirmations_required`]: ChannelDetails::confirmations_required
  void ChannelDetails_set_is_channel_ready(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    bool val,
  ) {
    return _ChannelDetails_set_is_channel_ready(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_is_channel_readyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Bool)>>('ChannelDetails_set_is_channel_ready');
  late final _ChannelDetails_set_is_channel_ready =
      _ChannelDetails_set_is_channel_readyPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, bool)>();

  /// True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
  /// the peer is connected, and (c) the channel is not currently negotiating a shutdown.
  ///
  /// This is a strict superset of `is_channel_ready`.
  bool ChannelDetails_get_is_usable(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_is_usable(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_is_usablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKChannelDetails>)>>('ChannelDetails_get_is_usable');
  late final _ChannelDetails_get_is_usable = _ChannelDetails_get_is_usablePtr
      .asFunction<bool Function(ffi.Pointer<LDKChannelDetails>)>();

  /// True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
  /// the peer is connected, and (c) the channel is not currently negotiating a shutdown.
  ///
  /// This is a strict superset of `is_channel_ready`.
  void ChannelDetails_set_is_usable(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    bool val,
  ) {
    return _ChannelDetails_set_is_usable(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_is_usablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Bool)>>('ChannelDetails_set_is_usable');
  late final _ChannelDetails_set_is_usable = _ChannelDetails_set_is_usablePtr
      .asFunction<void Function(ffi.Pointer<LDKChannelDetails>, bool)>();

  /// True if this channel is (or will be) publicly-announced.
  bool ChannelDetails_get_is_public(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_is_public(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_is_publicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKChannelDetails>)>>('ChannelDetails_get_is_public');
  late final _ChannelDetails_get_is_public = _ChannelDetails_get_is_publicPtr
      .asFunction<bool Function(ffi.Pointer<LDKChannelDetails>)>();

  /// True if this channel is (or will be) publicly-announced.
  void ChannelDetails_set_is_public(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    bool val,
  ) {
    return _ChannelDetails_set_is_public(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_is_publicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              ffi.Bool)>>('ChannelDetails_set_is_public');
  late final _ChannelDetails_set_is_public = _ChannelDetails_set_is_publicPtr
      .asFunction<void Function(ffi.Pointer<LDKChannelDetails>, bool)>();

  /// The smallest value HTLC (in msat) we will accept, for this channel. This field
  /// is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
  LDKCOption_u64Z ChannelDetails_get_inbound_htlc_minimum_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_inbound_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_inbound_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_inbound_htlc_minimum_msat');
  late final _ChannelDetails_get_inbound_htlc_minimum_msat =
      _ChannelDetails_get_inbound_htlc_minimum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The smallest value HTLC (in msat) we will accept, for this channel. This field
  /// is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
  void ChannelDetails_set_inbound_htlc_minimum_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_inbound_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_inbound_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>>(
      'ChannelDetails_set_inbound_htlc_minimum_msat');
  late final _ChannelDetails_set_inbound_htlc_minimum_msat =
      _ChannelDetails_set_inbound_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// The largest value HTLC (in msat) we currently will accept, for this channel.
  LDKCOption_u64Z ChannelDetails_get_inbound_htlc_maximum_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_inbound_htlc_maximum_msat(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_inbound_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_inbound_htlc_maximum_msat');
  late final _ChannelDetails_get_inbound_htlc_maximum_msat =
      _ChannelDetails_get_inbound_htlc_maximum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// The largest value HTLC (in msat) we currently will accept, for this channel.
  void ChannelDetails_set_inbound_htlc_maximum_msat(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelDetails_set_inbound_htlc_maximum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_inbound_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>>(
      'ChannelDetails_set_inbound_htlc_maximum_msat');
  late final _ChannelDetails_set_inbound_htlc_maximum_msat =
      _ChannelDetails_set_inbound_htlc_maximum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKCOption_u64Z)>();

  /// Set of configurable parameters that affect channel operation.
  ///
  /// This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelConfig ChannelDetails_get_config(
    ffi.Pointer<LDKChannelDetails> this_ptr,
  ) {
    return _ChannelDetails_get_config(
      this_ptr,
    );
  }

  late final _ChannelDetails_get_configPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelConfig Function(
              ffi.Pointer<LDKChannelDetails>)>>('ChannelDetails_get_config');
  late final _ChannelDetails_get_config = _ChannelDetails_get_configPtr
      .asFunction<LDKChannelConfig Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Set of configurable parameters that affect channel operation.
  ///
  /// This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelDetails_set_config(
    ffi.Pointer<LDKChannelDetails> this_ptr,
    LDKChannelConfig val,
  ) {
    return _ChannelDetails_set_config(
      this_ptr,
      val,
    );
  }

  late final _ChannelDetails_set_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelDetails>,
              LDKChannelConfig)>>('ChannelDetails_set_config');
  late final _ChannelDetails_set_config =
      _ChannelDetails_set_configPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelDetails>, LDKChannelConfig)>();

  /// Constructs a new ChannelDetails given each field
  LDKChannelDetails ChannelDetails_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKChannelCounterparty counterparty_arg,
    LDKOutPoint funding_txo_arg,
    LDKChannelTypeFeatures channel_type_arg,
    LDKCOption_u64Z short_channel_id_arg,
    LDKCOption_u64Z outbound_scid_alias_arg,
    LDKCOption_u64Z inbound_scid_alias_arg,
    int channel_value_satoshis_arg,
    LDKCOption_u64Z unspendable_punishment_reserve_arg,
    int user_channel_id_arg,
    int balance_msat_arg,
    int outbound_capacity_msat_arg,
    int next_outbound_htlc_limit_msat_arg,
    int inbound_capacity_msat_arg,
    LDKCOption_u32Z confirmations_required_arg,
    LDKCOption_u16Z force_close_spend_delay_arg,
    bool is_outbound_arg,
    bool is_channel_ready_arg,
    bool is_usable_arg,
    bool is_public_arg,
    LDKCOption_u64Z inbound_htlc_minimum_msat_arg,
    LDKCOption_u64Z inbound_htlc_maximum_msat_arg,
    LDKChannelConfig config_arg,
  ) {
    return _ChannelDetails_new(
      channel_id_arg,
      counterparty_arg,
      funding_txo_arg,
      channel_type_arg,
      short_channel_id_arg,
      outbound_scid_alias_arg,
      inbound_scid_alias_arg,
      channel_value_satoshis_arg,
      unspendable_punishment_reserve_arg,
      user_channel_id_arg,
      balance_msat_arg,
      outbound_capacity_msat_arg,
      next_outbound_htlc_limit_msat_arg,
      inbound_capacity_msat_arg,
      confirmations_required_arg,
      force_close_spend_delay_arg,
      is_outbound_arg,
      is_channel_ready_arg,
      is_usable_arg,
      is_public_arg,
      inbound_htlc_minimum_msat_arg,
      inbound_htlc_maximum_msat_arg,
      config_arg,
    );
  }

  late final _ChannelDetails_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelDetails Function(
              LDKThirtyTwoBytes,
              LDKChannelCounterparty,
              LDKOutPoint,
              LDKChannelTypeFeatures,
              LDKCOption_u64Z,
              LDKCOption_u64Z,
              LDKCOption_u64Z,
              ffi.Uint64,
              LDKCOption_u64Z,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              LDKCOption_u32Z,
              LDKCOption_u16Z,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool,
              ffi.Bool,
              LDKCOption_u64Z,
              LDKCOption_u64Z,
              LDKChannelConfig)>>('ChannelDetails_new');
  late final _ChannelDetails_new = _ChannelDetails_newPtr.asFunction<
      LDKChannelDetails Function(
          LDKThirtyTwoBytes,
          LDKChannelCounterparty,
          LDKOutPoint,
          LDKChannelTypeFeatures,
          LDKCOption_u64Z,
          LDKCOption_u64Z,
          LDKCOption_u64Z,
          int,
          LDKCOption_u64Z,
          int,
          int,
          int,
          int,
          int,
          LDKCOption_u32Z,
          LDKCOption_u16Z,
          bool,
          bool,
          bool,
          bool,
          LDKCOption_u64Z,
          LDKCOption_u64Z,
          LDKChannelConfig)>();

  /// Creates a copy of the ChannelDetails
  LDKChannelDetails ChannelDetails_clone(
    ffi.Pointer<LDKChannelDetails> orig,
  ) {
    return _ChannelDetails_clone(
      orig,
    );
  }

  late final _ChannelDetails_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelDetails Function(
              ffi.Pointer<LDKChannelDetails>)>>('ChannelDetails_clone');
  late final _ChannelDetails_clone = _ChannelDetails_clonePtr.asFunction<
      LDKChannelDetails Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Gets the current SCID which should be used to identify this channel for inbound payments.
  /// This should be used for providing invoice hints or in any other context where our
  /// counterparty will forward a payment to us.
  ///
  /// This is either the [`ChannelDetails::inbound_scid_alias`], if set, or the
  /// [`ChannelDetails::short_channel_id`]. See those for more information.
  LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(
    ffi.Pointer<LDKChannelDetails> this_arg,
  ) {
    return _ChannelDetails_get_inbound_payment_scid(
      this_arg,
    );
  }

  late final _ChannelDetails_get_inbound_payment_scidPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_inbound_payment_scid');
  late final _ChannelDetails_get_inbound_payment_scid =
      _ChannelDetails_get_inbound_payment_scidPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Gets the current SCID which should be used to identify this channel for outbound payments.
  /// This should be used in [`Route`]s to describe the first hop or in other contexts where
  /// we're sending or forwarding a payment outbound over this channel.
  ///
  /// This is either the [`ChannelDetails::short_channel_id`], if set, or the
  /// [`ChannelDetails::outbound_scid_alias`]. See those for more information.
  LDKCOption_u64Z ChannelDetails_get_outbound_payment_scid(
    ffi.Pointer<LDKChannelDetails> this_arg,
  ) {
    return _ChannelDetails_get_outbound_payment_scid(
      this_arg,
    );
  }

  late final _ChannelDetails_get_outbound_payment_scidPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>>(
      'ChannelDetails_get_outbound_payment_scid');
  late final _ChannelDetails_get_outbound_payment_scid =
      _ChannelDetails_get_outbound_payment_scidPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Frees any resources used by the PaymentSendFailure
  void PaymentSendFailure_free(
    LDKPaymentSendFailure this_ptr,
  ) {
    return _PaymentSendFailure_free(
      this_ptr,
    );
  }

  late final _PaymentSendFailure_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPaymentSendFailure)>>(
          'PaymentSendFailure_free');
  late final _PaymentSendFailure_free = _PaymentSendFailure_freePtr.asFunction<
      void Function(LDKPaymentSendFailure)>();

  /// Creates a copy of the PaymentSendFailure
  LDKPaymentSendFailure PaymentSendFailure_clone(
    ffi.Pointer<LDKPaymentSendFailure> orig,
  ) {
    return _PaymentSendFailure_clone(
      orig,
    );
  }

  late final _PaymentSendFailure_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentSendFailure Function(
              ffi.Pointer<LDKPaymentSendFailure>)>>('PaymentSendFailure_clone');
  late final _PaymentSendFailure_clone =
      _PaymentSendFailure_clonePtr.asFunction<
          LDKPaymentSendFailure Function(ffi.Pointer<LDKPaymentSendFailure>)>();

  /// Utility method to constructs a new ParameterError-variant PaymentSendFailure
  LDKPaymentSendFailure PaymentSendFailure_parameter_error(
    LDKAPIError a,
  ) {
    return _PaymentSendFailure_parameter_error(
      a,
    );
  }

  late final _PaymentSendFailure_parameter_errorPtr =
      _lookup<ffi.NativeFunction<LDKPaymentSendFailure Function(LDKAPIError)>>(
          'PaymentSendFailure_parameter_error');
  late final _PaymentSendFailure_parameter_error =
      _PaymentSendFailure_parameter_errorPtr.asFunction<
          LDKPaymentSendFailure Function(LDKAPIError)>();

  /// Utility method to constructs a new PathParameterError-variant PaymentSendFailure
  LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(
    LDKCVec_CResult_NoneAPIErrorZZ a,
  ) {
    return _PaymentSendFailure_path_parameter_error(
      a,
    );
  }

  late final _PaymentSendFailure_path_parameter_errorPtr = _lookup<
          ffi.NativeFunction<
              LDKPaymentSendFailure Function(LDKCVec_CResult_NoneAPIErrorZZ)>>(
      'PaymentSendFailure_path_parameter_error');
  late final _PaymentSendFailure_path_parameter_error =
      _PaymentSendFailure_path_parameter_errorPtr.asFunction<
          LDKPaymentSendFailure Function(LDKCVec_CResult_NoneAPIErrorZZ)>();

  /// Utility method to constructs a new AllFailedRetrySafe-variant PaymentSendFailure
  LDKPaymentSendFailure PaymentSendFailure_all_failed_retry_safe(
    LDKCVec_APIErrorZ a,
  ) {
    return _PaymentSendFailure_all_failed_retry_safe(
      a,
    );
  }

  late final _PaymentSendFailure_all_failed_retry_safePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentSendFailure Function(
              LDKCVec_APIErrorZ)>>('PaymentSendFailure_all_failed_retry_safe');
  late final _PaymentSendFailure_all_failed_retry_safe =
      _PaymentSendFailure_all_failed_retry_safePtr.asFunction<
          LDKPaymentSendFailure Function(LDKCVec_APIErrorZ)>();

  /// Utility method to constructs a new PartialFailure-variant PaymentSendFailure
  LDKPaymentSendFailure PaymentSendFailure_partial_failure(
    LDKCVec_CResult_NoneAPIErrorZZ results,
    LDKRouteParameters failed_paths_retry,
    LDKThirtyTwoBytes payment_id,
  ) {
    return _PaymentSendFailure_partial_failure(
      results,
      failed_paths_retry,
      payment_id,
    );
  }

  late final _PaymentSendFailure_partial_failurePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentSendFailure Function(
              LDKCVec_CResult_NoneAPIErrorZZ,
              LDKRouteParameters,
              LDKThirtyTwoBytes)>>('PaymentSendFailure_partial_failure');
  late final _PaymentSendFailure_partial_failure =
      _PaymentSendFailure_partial_failurePtr.asFunction<
          LDKPaymentSendFailure Function(LDKCVec_CResult_NoneAPIErrorZZ,
              LDKRouteParameters, LDKThirtyTwoBytes)>();

  /// Frees any resources used by the PhantomRouteHints, if is_owned is set and inner is non-NULL.
  void PhantomRouteHints_free(
    LDKPhantomRouteHints this_obj,
  ) {
    return _PhantomRouteHints_free(
      this_obj,
    );
  }

  late final _PhantomRouteHints_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPhantomRouteHints)>>(
          'PhantomRouteHints_free');
  late final _PhantomRouteHints_free = _PhantomRouteHints_freePtr.asFunction<
      void Function(LDKPhantomRouteHints)>();

  /// The list of channels to be included in the invoice route hints.
  LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
  ) {
    return _PhantomRouteHints_get_channels(
      this_ptr,
    );
  }

  late final _PhantomRouteHints_get_channelsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_ChannelDetailsZ Function(
                  ffi.Pointer<LDKPhantomRouteHints>)>>(
      'PhantomRouteHints_get_channels');
  late final _PhantomRouteHints_get_channels =
      _PhantomRouteHints_get_channelsPtr.asFunction<
          LDKCVec_ChannelDetailsZ Function(
              ffi.Pointer<LDKPhantomRouteHints>)>();

  /// The list of channels to be included in the invoice route hints.
  void PhantomRouteHints_set_channels(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
    LDKCVec_ChannelDetailsZ val,
  ) {
    return _PhantomRouteHints_set_channels(
      this_ptr,
      val,
    );
  }

  late final _PhantomRouteHints_set_channelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPhantomRouteHints>,
              LDKCVec_ChannelDetailsZ)>>('PhantomRouteHints_set_channels');
  late final _PhantomRouteHints_set_channels =
      _PhantomRouteHints_set_channelsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKPhantomRouteHints>, LDKCVec_ChannelDetailsZ)>();

  /// A fake scid used for representing the phantom node's fake channel in generating the invoice
  /// route hints.
  int PhantomRouteHints_get_phantom_scid(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
  ) {
    return _PhantomRouteHints_get_phantom_scid(
      this_ptr,
    );
  }

  late final _PhantomRouteHints_get_phantom_scidPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKPhantomRouteHints>)>>(
      'PhantomRouteHints_get_phantom_scid');
  late final _PhantomRouteHints_get_phantom_scid =
      _PhantomRouteHints_get_phantom_scidPtr.asFunction<
          int Function(ffi.Pointer<LDKPhantomRouteHints>)>();

  /// A fake scid used for representing the phantom node's fake channel in generating the invoice
  /// route hints.
  void PhantomRouteHints_set_phantom_scid(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
    int val,
  ) {
    return _PhantomRouteHints_set_phantom_scid(
      this_ptr,
      val,
    );
  }

  late final _PhantomRouteHints_set_phantom_scidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPhantomRouteHints>,
              ffi.Uint64)>>('PhantomRouteHints_set_phantom_scid');
  late final _PhantomRouteHints_set_phantom_scid =
      _PhantomRouteHints_set_phantom_scidPtr.asFunction<
          void Function(ffi.Pointer<LDKPhantomRouteHints>, int)>();

  /// The pubkey of the real backing node that would ultimately receive the payment.
  LDKPublicKey PhantomRouteHints_get_real_node_pubkey(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
  ) {
    return _PhantomRouteHints_get_real_node_pubkey(
      this_ptr,
    );
  }

  late final _PhantomRouteHints_get_real_node_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKPhantomRouteHints>)>>(
      'PhantomRouteHints_get_real_node_pubkey');
  late final _PhantomRouteHints_get_real_node_pubkey =
      _PhantomRouteHints_get_real_node_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKPhantomRouteHints>)>();

  /// The pubkey of the real backing node that would ultimately receive the payment.
  void PhantomRouteHints_set_real_node_pubkey(
    ffi.Pointer<LDKPhantomRouteHints> this_ptr,
    LDKPublicKey val,
  ) {
    return _PhantomRouteHints_set_real_node_pubkey(
      this_ptr,
      val,
    );
  }

  late final _PhantomRouteHints_set_real_node_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPhantomRouteHints>,
              LDKPublicKey)>>('PhantomRouteHints_set_real_node_pubkey');
  late final _PhantomRouteHints_set_real_node_pubkey =
      _PhantomRouteHints_set_real_node_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKPhantomRouteHints>, LDKPublicKey)>();

  /// Constructs a new PhantomRouteHints given each field
  LDKPhantomRouteHints PhantomRouteHints_new(
    LDKCVec_ChannelDetailsZ channels_arg,
    int phantom_scid_arg,
    LDKPublicKey real_node_pubkey_arg,
  ) {
    return _PhantomRouteHints_new(
      channels_arg,
      phantom_scid_arg,
      real_node_pubkey_arg,
    );
  }

  late final _PhantomRouteHints_newPtr = _lookup<
      ffi.NativeFunction<
          LDKPhantomRouteHints Function(LDKCVec_ChannelDetailsZ, ffi.Uint64,
              LDKPublicKey)>>('PhantomRouteHints_new');
  late final _PhantomRouteHints_new = _PhantomRouteHints_newPtr.asFunction<
      LDKPhantomRouteHints Function(
          LDKCVec_ChannelDetailsZ, int, LDKPublicKey)>();

  /// Creates a copy of the PhantomRouteHints
  LDKPhantomRouteHints PhantomRouteHints_clone(
    ffi.Pointer<LDKPhantomRouteHints> orig,
  ) {
    return _PhantomRouteHints_clone(
      orig,
    );
  }

  late final _PhantomRouteHints_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPhantomRouteHints Function(
              ffi.Pointer<LDKPhantomRouteHints>)>>('PhantomRouteHints_clone');
  late final _PhantomRouteHints_clone = _PhantomRouteHints_clonePtr.asFunction<
      LDKPhantomRouteHints Function(ffi.Pointer<LDKPhantomRouteHints>)>();

  /// Constructs a new ChannelManager to hold several channels and route between them.
  ///
  /// This is the main \"logic hub\" for all channel-related actions, and implements
  /// ChannelMessageHandler.
  ///
  /// Non-proportional fees are fixed according to our risk using the provided fee estimator.
  ///
  /// Users need to notify the new ChannelManager when a new block is connected or
  /// disconnected using its `block_connected` and `block_disconnected` methods, starting
  /// from after `params.latest_hash`.
  LDKChannelManager ChannelManager_new(
    LDKFeeEstimator fee_est,
    LDKWatch chain_monitor,
    LDKBroadcasterInterface tx_broadcaster,
    LDKLogger logger,
    LDKKeysInterface keys_manager,
    LDKUserConfig config,
    LDKChainParameters params,
  ) {
    return _ChannelManager_new(
      fee_est,
      chain_monitor,
      tx_broadcaster,
      logger,
      keys_manager,
      config,
      params,
    );
  }

  late final _ChannelManager_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelManager Function(
              LDKFeeEstimator,
              LDKWatch,
              LDKBroadcasterInterface,
              LDKLogger,
              LDKKeysInterface,
              LDKUserConfig,
              LDKChainParameters)>>('ChannelManager_new');
  late final _ChannelManager_new = _ChannelManager_newPtr.asFunction<
      LDKChannelManager Function(
          LDKFeeEstimator,
          LDKWatch,
          LDKBroadcasterInterface,
          LDKLogger,
          LDKKeysInterface,
          LDKUserConfig,
          LDKChainParameters)>();

  /// Gets the current configuration applied to all new channels,  as
  LDKUserConfig ChannelManager_get_current_default_configuration(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_get_current_default_configuration(
      this_arg,
    );
  }

  late final _ChannelManager_get_current_default_configurationPtr = _lookup<
          ffi.NativeFunction<
              LDKUserConfig Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_get_current_default_configuration');
  late final _ChannelManager_get_current_default_configuration =
      _ChannelManager_get_current_default_configurationPtr.asFunction<
          LDKUserConfig Function(ffi.Pointer<LDKChannelManager>)>();

  /// Creates a new outbound channel to the given remote node and with the given value.
  ///
  /// `user_channel_id` will be provided back as in
  /// [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
  /// correspond with which `create_channel` call. Note that the `user_channel_id` defaults to 0
  /// for inbound channels, so you may wish to avoid using 0 for `user_channel_id` here.
  /// `user_channel_id` has no meaning inside of LDK, it is simply copied to events and otherwise
  /// ignored.
  ///
  /// Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
  /// greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
  ///
  /// Note that we do not check if you are currently connected to the given peer. If no
  /// connection is available, the outbound `open_channel` message may fail to send, resulting in
  /// the channel eventually being silently forgotten (dropped on reload).
  ///
  /// Returns the new Channel's temporary `channel_id`. This ID will appear as
  /// [`Event::FundingGenerationReady::temporary_channel_id`] and in
  /// [`ChannelDetails::channel_id`] until after
  /// [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
  /// one derived from the funding transaction's TXID. If the counterparty rejects the channel
  /// immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
  ///
  /// [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
  /// [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
  /// [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
  ///
  /// Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult__u832APIErrorZ ChannelManager_create_channel(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKPublicKey their_network_key,
    int channel_value_satoshis,
    int push_msat,
    int user_channel_id,
    LDKUserConfig override_config,
  ) {
    return _ChannelManager_create_channel(
      this_arg,
      their_network_key,
      channel_value_satoshis,
      push_msat,
      user_channel_id,
      override_config,
    );
  }

  late final _ChannelManager_create_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult__u832APIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKPublicKey,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint64,
              LDKUserConfig)>>('ChannelManager_create_channel');
  late final _ChannelManager_create_channel =
      _ChannelManager_create_channelPtr.asFunction<
          LDKCResult__u832APIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              LDKPublicKey, int, int, int, LDKUserConfig)>();

  /// Gets the list of open channels, in random order. See ChannelDetail field documentation for
  /// more information.
  LDKCVec_ChannelDetailsZ ChannelManager_list_channels(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_list_channels(
      this_arg,
    );
  }

  late final _ChannelManager_list_channelsPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_ChannelDetailsZ Function(
              ffi.Pointer<LDKChannelManager>)>>('ChannelManager_list_channels');
  late final _ChannelManager_list_channels =
      _ChannelManager_list_channelsPtr.asFunction<
          LDKCVec_ChannelDetailsZ Function(ffi.Pointer<LDKChannelManager>)>();

  /// Gets the list of usable channels, in random order. Useful as an argument to [`find_route`]
  /// to ensure non-announced channels are used.
  ///
  /// These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
  /// documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
  /// are.
  ///
  /// [`find_route`]: crate::routing::router::find_route
  LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_list_usable_channels(
      this_arg,
    );
  }

  late final _ChannelManager_list_usable_channelsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_ChannelDetailsZ Function(
                  ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_list_usable_channels');
  late final _ChannelManager_list_usable_channels =
      _ChannelManager_list_usable_channelsPtr.asFunction<
          LDKCVec_ChannelDetailsZ Function(ffi.Pointer<LDKChannelManager>)>();

  /// Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
  /// will be accepted on the given channel, and after additional timeout/the closing of all
  /// pending HTLCs, the channel will be closed on chain.
  ///
  /// * If we are the channel initiator, we will pay between our [`Background`] and
  /// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
  /// estimate.
  /// * If our counterparty is the channel initiator, we will require a channel closing
  /// transaction feerate of at least our [`Background`] feerate or the feerate which
  /// would appear on a force-closure transaction, whichever is lower. We will allow our
  /// counterparty to pay as much fee as they'd like, however.
  ///
  /// May generate a SendShutdown message event on success, which should be relayed.
  ///
  /// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
  /// [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
  /// [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
  LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> channel_id,
    LDKPublicKey counterparty_node_id,
  ) {
    return _ChannelManager_close_channel(
      this_arg,
      channel_id,
      counterparty_node_id,
    );
  }

  late final _ChannelManager_close_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKPublicKey)>>('ChannelManager_close_channel');
  late final _ChannelManager_close_channel =
      _ChannelManager_close_channelPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey)>();

  /// Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
  /// will be accepted on the given channel, and after additional timeout/the closing of all
  /// pending HTLCs, the channel will be closed on chain.
  ///
  /// `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
  /// the channel being closed or not:
  /// * If we are the channel initiator, we will pay at least this feerate on the closing
  /// transaction. The upper-bound is set by
  /// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
  /// estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
  /// * If our counterparty is the channel initiator, we will refuse to accept a channel closure
  /// transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
  /// will appear on a force-closure transaction, whichever is lower).
  ///
  /// May generate a SendShutdown message event on success, which should be relayed.
  ///
  /// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
  /// [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
  /// [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
  LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_target_feerate(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> channel_id,
    LDKPublicKey counterparty_node_id,
    int target_feerate_sats_per_1000_weight,
  ) {
    return _ChannelManager_close_channel_with_target_feerate(
      this_arg,
      channel_id,
      counterparty_node_id,
      target_feerate_sats_per_1000_weight,
    );
  }

  late final _ChannelManager_close_channel_with_target_feeratePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKPublicKey,
              ffi.Uint32)>>('ChannelManager_close_channel_with_target_feerate');
  late final _ChannelManager_close_channel_with_target_feerate =
      _ChannelManager_close_channel_with_target_feeratePtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey, int)>();

  /// Force closes a channel, immediately broadcasting the latest local transaction(s) and
  /// rejecting new HTLCs on the given channel. Fails if `channel_id` is unknown to
  /// the manager, or if the `counterparty_node_id` isn't the counterparty of the corresponding
  /// channel.
  LDKCResult_NoneAPIErrorZ ChannelManager_force_close_broadcasting_latest_txn(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> channel_id,
    LDKPublicKey counterparty_node_id,
  ) {
    return _ChannelManager_force_close_broadcasting_latest_txn(
      this_arg,
      channel_id,
      counterparty_node_id,
    );
  }

  late final _ChannelManager_force_close_broadcasting_latest_txnPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey)>>(
      'ChannelManager_force_close_broadcasting_latest_txn');
  late final _ChannelManager_force_close_broadcasting_latest_txn =
      _ChannelManager_force_close_broadcasting_latest_txnPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey)>();

  /// Force closes a channel, rejecting new HTLCs on the given channel but skips broadcasting
  /// the latest local transaction(s). Fails if `channel_id` is unknown to the manager, or if the
  /// `counterparty_node_id` isn't the counterparty of the corresponding channel.
  ///
  /// You can always get the latest local transaction(s) to broadcast from
  /// [`ChannelMonitor::get_latest_holder_commitment_txn`].
  LDKCResult_NoneAPIErrorZ ChannelManager_force_close_without_broadcasting_txn(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> channel_id,
    LDKPublicKey counterparty_node_id,
  ) {
    return _ChannelManager_force_close_without_broadcasting_txn(
      this_arg,
      channel_id,
      counterparty_node_id,
    );
  }

  late final _ChannelManager_force_close_without_broadcasting_txnPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey)>>(
      'ChannelManager_force_close_without_broadcasting_txn');
  late final _ChannelManager_force_close_without_broadcasting_txn =
      _ChannelManager_force_close_without_broadcasting_txnPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey)>();

  /// Force close all channels, immediately broadcasting the latest local commitment transaction
  /// for each to the chain and rejecting new HTLCs on each.
  void ChannelManager_force_close_all_channels_broadcasting_latest_txn(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_force_close_all_channels_broadcasting_latest_txn(
      this_arg,
    );
  }

  late final _ChannelManager_force_close_all_channels_broadcasting_latest_txnPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<LDKChannelManager>)>>(
          'ChannelManager_force_close_all_channels_broadcasting_latest_txn');
  late final _ChannelManager_force_close_all_channels_broadcasting_latest_txn =
      _ChannelManager_force_close_all_channels_broadcasting_latest_txnPtr
          .asFunction<void Function(ffi.Pointer<LDKChannelManager>)>();

  /// Force close all channels rejecting new HTLCs on each but without broadcasting the latest
  /// local transaction(s).
  void ChannelManager_force_close_all_channels_without_broadcasting_txn(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_force_close_all_channels_without_broadcasting_txn(
      this_arg,
    );
  }

  late final _ChannelManager_force_close_all_channels_without_broadcasting_txnPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<LDKChannelManager>)>>(
          'ChannelManager_force_close_all_channels_without_broadcasting_txn');
  late final _ChannelManager_force_close_all_channels_without_broadcasting_txn =
      _ChannelManager_force_close_all_channels_without_broadcasting_txnPtr
          .asFunction<void Function(ffi.Pointer<LDKChannelManager>)>();

  /// Sends a payment along a given route.
  ///
  /// Value parameters are provided via the last hop in route, see documentation for RouteHop
  /// fields for more info.
  ///
  /// Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative
  /// payment), we don't do anything to stop you! We always try to ensure that if the provided
  /// next hop knows the preimage to payment_hash they can claim an additional amount as
  /// specified in the last hop in the route! Thus, you should probably do your own
  /// payment_preimage tracking (which you should already be doing as they represent \"proof of
  /// payment\") and prevent double-sends yourself.
  ///
  /// May generate SendHTLCs message(s) event on success, which should be relayed.
  ///
  /// Each path may have a different return value, and PaymentSendValue may return a Vec with
  /// each entry matching the corresponding-index entry in the route paths, see
  /// PaymentSendFailure for more info.
  ///
  /// In general, a path may raise:
  /// * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,
  /// node public key) is specified.
  /// * APIError::ChannelUnavailable if the next-hop channel is not available for updates
  /// (including due to previous monitor update failure or new permanent monitor update
  /// failure).
  /// * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the
  /// relevant updates.
  ///
  /// Note that depending on the type of the PaymentSendFailure the HTLC may have been
  /// irrevocably committed to on our end. In such a case, do NOT retry the payment with a
  /// different route unless you intend to pay twice!
  ///
  /// payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
  /// the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
  /// newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
  /// must not contain multiple paths as multi-path payments require a recipient-provided
  /// payment_secret.
  /// If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
  /// bit set (either as required or as available). If multiple paths are present in the Route,
  /// we assume the invoice had the basic_mpp feature set.
  ///
  /// Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult_PaymentIdPaymentSendFailureZ ChannelManager_send_payment(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<LDKRoute> route,
    LDKThirtyTwoBytes payment_hash,
    LDKThirtyTwoBytes payment_secret,
  ) {
    return _ChannelManager_send_payment(
      this_arg,
      route,
      payment_hash,
      payment_secret,
    );
  }

  late final _ChannelManager_send_paymentPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>>('ChannelManager_send_payment');
  late final _ChannelManager_send_payment =
      _ChannelManager_send_paymentPtr.asFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>();

  /// Retries a payment along the given [`Route`].
  ///
  /// Errors returned are a superset of those returned from [`send_payment`], so see
  /// [`send_payment`] documentation for more details on errors. This method will also error if the
  /// retry amount puts the payment more than 10% over the payment's total amount, if the payment
  /// for the given `payment_id` cannot be found (likely due to timeout or success), or if
  /// further retries have been disabled with [`abandon_payment`].
  ///
  /// [`send_payment`]: [`ChannelManager::send_payment`]
  /// [`abandon_payment`]: [`ChannelManager::abandon_payment`]
  LDKCResult_NonePaymentSendFailureZ ChannelManager_retry_payment(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<LDKRoute> route,
    LDKThirtyTwoBytes payment_id,
  ) {
    return _ChannelManager_retry_payment(
      this_arg,
      route,
      payment_id,
    );
  }

  late final _ChannelManager_retry_paymentPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NonePaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes)>>('ChannelManager_retry_payment');
  late final _ChannelManager_retry_payment =
      _ChannelManager_retry_paymentPtr.asFunction<
          LDKCResult_NonePaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes)>();

  /// Signals that no further retries for the given payment will occur.
  ///
  /// After this method returns, any future calls to [`retry_payment`] for the given `payment_id`
  /// will fail with [`PaymentSendFailure::ParameterError`]. If no such event has been generated,
  /// an [`Event::PaymentFailed`] event will be generated as soon as there are no remaining
  /// pending HTLCs for this payment.
  ///
  /// Note that calling this method does *not* prevent a payment from succeeding. You must still
  /// wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
  /// determine the ultimate status of a payment.
  ///
  /// [`retry_payment`]: Self::retry_payment
  /// [`Event::PaymentFailed`]: events::Event::PaymentFailed
  /// [`Event::PaymentSent`]: events::Event::PaymentSent
  void ChannelManager_abandon_payment(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThirtyTwoBytes payment_id,
  ) {
    return _ChannelManager_abandon_payment(
      this_arg,
      payment_id,
    );
  }

  late final _ChannelManager_abandon_paymentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes)>>('ChannelManager_abandon_payment');
  late final _ChannelManager_abandon_payment =
      _ChannelManager_abandon_paymentPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>, LDKThirtyTwoBytes)>();

  /// Send a spontaneous payment, which is a payment that does not require the recipient to have
  /// generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
  /// the preimage, it must be a cryptographically secure random value that no intermediate node
  /// would be able to guess -- otherwise, an intermediate node may claim the payment and it will
  /// never reach the recipient.
  ///
  /// See [`send_payment`] documentation for more details on the return value of this function.
  ///
  /// Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
  /// [`send_payment`] for more information about the risks of duplicate preimage usage.
  ///
  /// Note that `route` must have exactly one path.
  ///
  /// [`send_payment`]: Self::send_payment
  ///
  /// Note that payment_preimage (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
      ChannelManager_send_spontaneous_payment(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<LDKRoute> route,
    LDKThirtyTwoBytes payment_preimage,
  ) {
    return _ChannelManager_send_spontaneous_payment(
      this_arg,
      route,
      payment_preimage,
    );
  }

  late final _ChannelManager_send_spontaneous_paymentPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes)>>('ChannelManager_send_spontaneous_payment');
  late final _ChannelManager_send_spontaneous_payment =
      _ChannelManager_send_spontaneous_paymentPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes)>();

  /// Send a payment that is probing the given route for liquidity. We calculate the
  /// [`PaymentHash`] of probes based on a static secret and a random [`PaymentId`], which allows
  /// us to easily discern them from real payments.
  LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
      ChannelManager_send_probe(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKCVec_RouteHopZ hops,
  ) {
    return _ChannelManager_send_probe(
      this_arg,
      hops,
    );
  }

  late final _ChannelManager_send_probePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKCVec_RouteHopZ)>>('ChannelManager_send_probe');
  late final _ChannelManager_send_probe =
      _ChannelManager_send_probePtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ Function(
              ffi.Pointer<LDKChannelManager>, LDKCVec_RouteHopZ)>();

  /// Call this upon creation of a funding transaction for the given channel.
  ///
  /// Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
  /// or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
  ///
  /// Returns [`APIError::APIMisuseError`] if the funding transaction is not final for propagation
  /// across the p2p network.
  ///
  /// Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
  /// for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
  ///
  /// May panic if the output found in the funding transaction is duplicative with some other
  /// channel (note that this should be trivially prevented by using unique funding transaction
  /// keys per-channel).
  ///
  /// Do NOT broadcast the funding transaction yourself. When we have safely received our
  /// counterparty's signature the funding transaction will automatically be broadcast via the
  /// [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
  ///
  /// Note that this includes RBF or similar transaction replacement strategies - lightning does
  /// not currently support replacing a funding transaction on an existing channel. Instead,
  /// create a new channel with a conflicting funding transaction.
  ///
  /// Note to keep the miner incentives aligned in moving the blockchain forward, we recommend
  /// the wallet software generating the funding transaction to apply anti-fee sniping as
  /// implemented by Bitcoin Core wallet. See <https://bitcoinops.org/en/topics/fee-sniping/>
  /// for more details.
  ///
  /// [`Event::FundingGenerationReady`]: crate::util::events::Event::FundingGenerationReady
  /// [`Event::ChannelClosed`]: crate::util::events::Event::ChannelClosed
  LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> temporary_channel_id,
    LDKPublicKey counterparty_node_id,
    LDKTransaction funding_transaction,
  ) {
    return _ChannelManager_funding_transaction_generated(
      this_arg,
      temporary_channel_id,
      counterparty_node_id,
      funding_transaction,
    );
  }

  late final _ChannelManager_funding_transaction_generatedPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKPublicKey,
              LDKTransaction)>>('ChannelManager_funding_transaction_generated');
  late final _ChannelManager_funding_transaction_generated =
      _ChannelManager_funding_transaction_generatedPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKPublicKey,
              LDKTransaction)>();

  /// Regenerates channel_announcements and generates a signed node_announcement from the given
  /// arguments, providing them in corresponding events via
  /// [`get_and_clear_pending_msg_events`], if at least one public channel has been confirmed
  /// on-chain. This effectively re-broadcasts all channel announcements and sends our node
  /// announcement to ensure that the lightning P2P network is aware of the channels we have and
  /// our network addresses.
  ///
  /// `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
  /// node to humans. They carry no in-protocol meaning.
  ///
  /// `addresses` represent the set (possibly empty) of socket addresses on which this node
  /// accepts incoming connections. These will be included in the node_announcement, publicly
  /// tying these addresses together and to this node. If you wish to preserve user privacy,
  /// addresses should likely contain only Tor Onion addresses.
  ///
  /// Panics if `addresses` is absurdly large (more than 100).
  ///
  /// [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
  void ChannelManager_broadcast_node_announcement(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThreeBytes rgb,
    LDKThirtyTwoBytes alias,
    LDKCVec_NetAddressZ addresses,
  ) {
    return _ChannelManager_broadcast_node_announcement(
      this_arg,
      rgb,
      alias,
      addresses,
    );
  }

  late final _ChannelManager_broadcast_node_announcementPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManager>, LDKThreeBytes,
                  LDKThirtyTwoBytes, LDKCVec_NetAddressZ)>>(
      'ChannelManager_broadcast_node_announcement');
  late final _ChannelManager_broadcast_node_announcement =
      _ChannelManager_broadcast_node_announcementPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>, LDKThreeBytes,
              LDKThirtyTwoBytes, LDKCVec_NetAddressZ)>();

  /// Atomically updates the [`ChannelConfig`] for the given channels.
  ///
  /// Once the updates are applied, each eligible channel (advertised with a known short channel
  /// ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
  /// or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
  /// containing the new [`ChannelUpdate`] message which should be broadcast to the network.
  ///
  /// Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
  /// `counterparty_node_id` is provided.
  ///
  /// Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
  /// below [`MIN_CLTV_EXPIRY_DELTA`].
  ///
  /// If an error is returned, none of the updates should be considered applied.
  ///
  /// [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
  /// [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
  /// [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
  /// [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
  /// [`ChannelUpdate`]: msgs::ChannelUpdate
  /// [`ChannelUnavailable`]: APIError::ChannelUnavailable
  /// [`APIMisuseError`]: APIError::APIMisuseError
  LDKCResult_NoneAPIErrorZ ChannelManager_update_channel_config(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKPublicKey counterparty_node_id,
    LDKCVec_ThirtyTwoBytesZ channel_ids,
    ffi.Pointer<LDKChannelConfig> config,
  ) {
    return _ChannelManager_update_channel_config(
      this_arg,
      counterparty_node_id,
      channel_ids,
      config,
    );
  }

  late final _ChannelManager_update_channel_configPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneAPIErrorZ Function(
                  ffi.Pointer<LDKChannelManager>,
                  LDKPublicKey,
                  LDKCVec_ThirtyTwoBytesZ,
                  ffi.Pointer<LDKChannelConfig>)>>(
      'ChannelManager_update_channel_config');
  late final _ChannelManager_update_channel_config =
      _ChannelManager_update_channel_configPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKPublicKey,
              LDKCVec_ThirtyTwoBytesZ,
              ffi.Pointer<LDKChannelConfig>)>();

  /// Processes HTLCs which are pending waiting on random forward delay.
  ///
  /// Should only really ever be called in response to a PendingHTLCsForwardable event.
  /// Will likely generate further events.
  void ChannelManager_process_pending_htlc_forwards(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_process_pending_htlc_forwards(
      this_arg,
    );
  }

  late final _ChannelManager_process_pending_htlc_forwardsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_process_pending_htlc_forwards');
  late final _ChannelManager_process_pending_htlc_forwards =
      _ChannelManager_process_pending_htlc_forwardsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>)>();

  /// Performs actions which should happen on startup and roughly once per minute thereafter.
  ///
  /// This currently includes:
  /// * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
  /// * Broadcasting `ChannelUpdate` messages if we've been disconnected from our peer for more
  /// than a minute, informing the network that they should no longer attempt to route over
  /// the channel.
  /// * Expiring a channel's previous `ChannelConfig` if necessary to only allow forwarding HTLCs
  /// with the current `ChannelConfig`.
  ///
  /// Note that this may cause reentrancy through `chain::Watch::update_channel` calls or feerate
  /// estimate fetches.
  void ChannelManager_timer_tick_occurred(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_timer_tick_occurred(
      this_arg,
    );
  }

  late final _ChannelManager_timer_tick_occurredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_timer_tick_occurred');
  late final _ChannelManager_timer_tick_occurred =
      _ChannelManager_timer_tick_occurredPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>)>();

  /// Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
  /// after a PaymentReceived event, failing the HTLC back to its origin and freeing resources
  /// along the path (including in our own channel on which we received it).
  ///
  /// Note that in some cases around unclean shutdown, it is possible the payment may have
  /// already been claimed by you via [`ChannelManager::claim_funds`] prior to you seeing (a
  /// second copy of) the [`events::Event::PaymentReceived`] event. Alternatively, the payment
  /// may have already been failed automatically by LDK if it was nearing its expiration time.
  ///
  /// While LDK will never claim a payment automatically on your behalf (i.e. without you calling
  /// [`ChannelManager::claim_funds`]), you should still monitor for
  /// [`events::Event::PaymentClaimed`] events even for payments you intend to fail, especially on
  /// startup during which time claims that were in-progress at shutdown may be replayed.
  void ChannelManager_fail_htlc_backwards(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> payment_hash,
  ) {
    return _ChannelManager_fail_htlc_backwards(
      this_arg,
      payment_hash,
    );
  }

  late final _ChannelManager_fail_htlc_backwardsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManager>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'ChannelManager_fail_htlc_backwards');
  late final _ChannelManager_fail_htlc_backwards =
      _ChannelManager_fail_htlc_backwardsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Provides a payment preimage in response to [`Event::PaymentReceived`], generating any
  /// [`MessageSendEvent`]s needed to claim the payment.
  ///
  /// Note that calling this method does *not* guarantee that the payment has been claimed. You
  /// *must* wait for an [`Event::PaymentClaimed`] event which upon a successful claim will be
  /// provided to your [`EventHandler`] when [`process_pending_events`] is next called.
  ///
  /// Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
  /// [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentReceived`
  /// event matches your expectation. If you fail to do so and call this method, you may provide
  /// the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
  ///
  /// [`Event::PaymentReceived`]: crate::util::events::Event::PaymentReceived
  /// [`Event::PaymentClaimed`]: crate::util::events::Event::PaymentClaimed
  /// [`process_pending_events`]: EventsProvider::process_pending_events
  /// [`create_inbound_payment`]: Self::create_inbound_payment
  /// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
  /// [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
  void ChannelManager_claim_funds(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThirtyTwoBytes payment_preimage,
  ) {
    return _ChannelManager_claim_funds(
      this_arg,
      payment_preimage,
    );
  }

  late final _ChannelManager_claim_fundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes)>>('ChannelManager_claim_funds');
  late final _ChannelManager_claim_funds =
      _ChannelManager_claim_fundsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>, LDKThirtyTwoBytes)>();

  /// Gets the node_id held by this ChannelManager
  LDKPublicKey ChannelManager_get_our_node_id(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_get_our_node_id(
      this_arg,
    );
  }

  late final _ChannelManager_get_our_node_idPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_get_our_node_id');
  late final _ChannelManager_get_our_node_id =
      _ChannelManager_get_our_node_idPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelManager>)>();

  /// Accepts a request to open a channel after a [`Event::OpenChannelRequest`].
  ///
  /// The `temporary_channel_id` parameter indicates which inbound channel should be accepted,
  /// and the `counterparty_node_id` parameter is the id of the peer which has requested to open
  /// the channel.
  ///
  /// The `user_channel_id` parameter will be provided back in
  /// [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
  /// with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
  ///
  /// Note that this method will return an error and reject the channel, if it requires support
  /// for zero confirmations. Instead, `accept_inbound_channel_from_trusted_peer_0conf` must be
  /// used to accept such channels.
  ///
  /// [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
  /// [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
  LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> temporary_channel_id,
    LDKPublicKey counterparty_node_id,
    int user_channel_id,
  ) {
    return _ChannelManager_accept_inbound_channel(
      this_arg,
      temporary_channel_id,
      counterparty_node_id,
      user_channel_id,
    );
  }

  late final _ChannelManager_accept_inbound_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKPublicKey,
              ffi.Uint64)>>('ChannelManager_accept_inbound_channel');
  late final _ChannelManager_accept_inbound_channel =
      _ChannelManager_accept_inbound_channelPtr.asFunction<
          LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey, int)>();

  /// Accepts a request to open a channel after a [`events::Event::OpenChannelRequest`], treating
  /// it as confirmed immediately.
  ///
  /// The `user_channel_id` parameter will be provided back in
  /// [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
  /// with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
  ///
  /// Unlike [`ChannelManager::accept_inbound_channel`], this method accepts the incoming channel
  /// and (if the counterparty agrees), enables forwarding of payments immediately.
  ///
  /// This fully trusts that the counterparty has honestly and correctly constructed the funding
  /// transaction and blindly assumes that it will eventually confirm.
  ///
  /// If it does not confirm before we decide to close the channel, or if the funding transaction
  /// does not pay to the correct script the correct amount, *you will lose funds*.
  ///
  /// [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
  /// [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
  LDKCResult_NoneAPIErrorZ
      ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(
    ffi.Pointer<LDKChannelManager> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> temporary_channel_id,
    LDKPublicKey counterparty_node_id,
    int user_channel_id,
  ) {
    return _ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(
      this_arg,
      temporary_channel_id,
      counterparty_node_id,
      user_channel_id,
    );
  }

  late final _ChannelManager_accept_inbound_channel_from_trusted_peer_0confPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_NoneAPIErrorZ Function(
                      ffi.Pointer<LDKChannelManager>,
                      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                      LDKPublicKey,
                      ffi.Uint64)>>(
          'ChannelManager_accept_inbound_channel_from_trusted_peer_0conf');
  late final _ChannelManager_accept_inbound_channel_from_trusted_peer_0conf =
      _ChannelManager_accept_inbound_channel_from_trusted_peer_0confPtr
          .asFunction<
              LDKCResult_NoneAPIErrorZ Function(ffi.Pointer<LDKChannelManager>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKPublicKey, int)>();

  /// Gets a payment secret and payment hash for use in an invoice given to a third party wishing
  /// to pay us.
  ///
  /// This differs from [`create_inbound_payment_for_hash`] only in that it generates the
  /// [`PaymentHash`] and [`PaymentPreimage`] for you.
  ///
  /// The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentReceived`], which
  /// will have the [`PaymentReceived::payment_preimage`] field filled in. That should then be
  /// passed directly to [`claim_funds`].
  ///
  /// See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
  ///
  /// Note that a malicious eavesdropper can intuit whether an inbound payment was created by
  /// `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
  ///
  /// # Note
  ///
  /// If you register an inbound payment with this method, then serialize the `ChannelManager`, then
  /// deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
  ///
  /// Errors if `min_value_msat` is greater than total bitcoin supply.
  ///
  /// [`claim_funds`]: Self::claim_funds
  /// [`PaymentReceived`]: events::Event::PaymentReceived
  /// [`PaymentReceived::payment_preimage`]: events::Event::PaymentReceived::payment_preimage
  /// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
      ChannelManager_create_inbound_payment(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKCOption_u64Z min_value_msat,
    int invoice_expiry_delta_secs,
  ) {
    return _ChannelManager_create_inbound_payment(
      this_arg,
      min_value_msat,
      invoice_expiry_delta_secs,
    );
  }

  late final _ChannelManager_create_inbound_paymentPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKCOption_u64Z,
              ffi.Uint32)>>('ChannelManager_create_inbound_payment');
  late final _ChannelManager_create_inbound_payment =
      _ChannelManager_create_inbound_paymentPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
              ffi.Pointer<LDKChannelManager>, LDKCOption_u64Z, int)>();

  /// Legacy version of [`create_inbound_payment`]. Use this method if you wish to share
  /// serialized state with LDK node(s) running 0.0.103 and earlier.
  ///
  /// May panic if `invoice_expiry_delta_secs` is greater than one year.
  ///
  /// # Note
  /// This method is deprecated and will be removed soon.
  ///
  /// [`create_inbound_payment`]: Self::create_inbound_payment
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
      ChannelManager_create_inbound_payment_legacy(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKCOption_u64Z min_value_msat,
    int invoice_expiry_delta_secs,
  ) {
    return _ChannelManager_create_inbound_payment_legacy(
      this_arg,
      min_value_msat,
      invoice_expiry_delta_secs,
    );
  }

  late final _ChannelManager_create_inbound_payment_legacyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKCOption_u64Z,
              ffi.Uint32)>>('ChannelManager_create_inbound_payment_legacy');
  late final _ChannelManager_create_inbound_payment_legacy =
      _ChannelManager_create_inbound_payment_legacyPtr.asFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>, LDKCOption_u64Z, int)>();

  /// Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
  /// stored external to LDK.
  ///
  /// A [`PaymentReceived`] event will only be generated if the [`PaymentSecret`] matches a
  /// payment secret fetched via this method or [`create_inbound_payment`], and which is at least
  /// the `min_value_msat` provided here, if one is provided.
  ///
  /// The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
  /// note that LDK will not stop you from registering duplicate payment hashes for inbound
  /// payments.
  ///
  /// `min_value_msat` should be set if the invoice being generated contains a value. Any payment
  /// received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
  /// before a [`PaymentReceived`] event will be generated, ensuring that we do not provide the
  /// sender \"proof-of-payment\" unless they have paid the required amount.
  ///
  /// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
  /// in excess of the current time. This should roughly match the expiry time set in the invoice.
  /// After this many seconds, we will remove the inbound payment, resulting in any attempts to
  /// pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
  /// invoices when no timeout is set.
  ///
  /// Note that we use block header time to time-out pending inbound payments (with some margin
  /// to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
  /// accept a payment and generate a [`PaymentReceived`] event for some time after the expiry.
  /// If you need exact expiry semantics, you should enforce them upon receipt of
  /// [`PaymentReceived`].
  ///
  /// Note that invoices generated for inbound payments should have their `min_final_cltv_expiry`
  /// set to at least [`MIN_FINAL_CLTV_EXPIRY`].
  ///
  /// Note that a malicious eavesdropper can intuit whether an inbound payment was created by
  /// `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
  ///
  /// # Note
  ///
  /// If you register an inbound payment with this method, then serialize the `ChannelManager`, then
  /// deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
  ///
  /// Errors if `min_value_msat` is greater than total bitcoin supply.
  ///
  /// [`create_inbound_payment`]: Self::create_inbound_payment
  /// [`PaymentReceived`]: events::Event::PaymentReceived
  LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThirtyTwoBytes payment_hash,
    LDKCOption_u64Z min_value_msat,
    int invoice_expiry_delta_secs,
  ) {
    return _ChannelManager_create_inbound_payment_for_hash(
      this_arg,
      payment_hash,
      min_value_msat,
      invoice_expiry_delta_secs,
    );
  }

  late final _ChannelManager_create_inbound_payment_for_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentSecretNoneZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes,
              LDKCOption_u64Z,
              ffi.Uint32)>>('ChannelManager_create_inbound_payment_for_hash');
  late final _ChannelManager_create_inbound_payment_for_hash =
      _ChannelManager_create_inbound_payment_for_hashPtr.asFunction<
          LDKCResult_PaymentSecretNoneZ Function(ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes, LDKCOption_u64Z, int)>();

  /// Legacy version of [`create_inbound_payment_for_hash`]. Use this method if you wish to share
  /// serialized state with LDK node(s) running 0.0.103 and earlier.
  ///
  /// May panic if `invoice_expiry_delta_secs` is greater than one year.
  ///
  /// # Note
  /// This method is deprecated and will be removed soon.
  ///
  /// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
  LDKCResult_PaymentSecretAPIErrorZ
      ChannelManager_create_inbound_payment_for_hash_legacy(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThirtyTwoBytes payment_hash,
    LDKCOption_u64Z min_value_msat,
    int invoice_expiry_delta_secs,
  ) {
    return _ChannelManager_create_inbound_payment_for_hash_legacy(
      this_arg,
      payment_hash,
      min_value_msat,
      invoice_expiry_delta_secs,
    );
  }

  late final _ChannelManager_create_inbound_payment_for_hash_legacyPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_PaymentSecretAPIErrorZ Function(
                      ffi.Pointer<LDKChannelManager>,
                      LDKThirtyTwoBytes,
                      LDKCOption_u64Z,
                      ffi.Uint32)>>(
          'ChannelManager_create_inbound_payment_for_hash_legacy');
  late final _ChannelManager_create_inbound_payment_for_hash_legacy =
      _ChannelManager_create_inbound_payment_for_hash_legacyPtr.asFunction<
          LDKCResult_PaymentSecretAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes,
              LDKCOption_u64Z,
              int)>();

  /// Gets an LDK-generated payment preimage from a payment hash and payment secret that were
  /// previously returned from [`create_inbound_payment`].
  ///
  /// [`create_inbound_payment`]: Self::create_inbound_payment
  LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(
    ffi.Pointer<LDKChannelManager> this_arg,
    LDKThirtyTwoBytes payment_hash,
    LDKThirtyTwoBytes payment_secret,
  ) {
    return _ChannelManager_get_payment_preimage(
      this_arg,
      payment_hash,
      payment_secret,
    );
  }

  late final _ChannelManager_get_payment_preimagePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>>('ChannelManager_get_payment_preimage');
  late final _ChannelManager_get_payment_preimage =
      _ChannelManager_get_payment_preimagePtr.asFunction<
          LDKCResult_PaymentPreimageAPIErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>();

  /// Gets a fake short channel id for use in receiving [phantom node payments]. These fake scids
  /// are used when constructing the phantom invoice's route hints.
  ///
  /// [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
  int ChannelManager_get_phantom_scid(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_get_phantom_scid(
      this_arg,
    );
  }

  late final _ChannelManager_get_phantom_scidPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_get_phantom_scid');
  late final _ChannelManager_get_phantom_scid =
      _ChannelManager_get_phantom_scidPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelManager>)>();

  /// Gets route hints for use in receiving [phantom node payments].
  ///
  /// [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
  LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_get_phantom_route_hints(
      this_arg,
    );
  }

  late final _ChannelManager_get_phantom_route_hintsPtr = _lookup<
          ffi.NativeFunction<
              LDKPhantomRouteHints Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_get_phantom_route_hints');
  late final _ChannelManager_get_phantom_route_hints =
      _ChannelManager_get_phantom_route_hintsPtr.asFunction<
          LDKPhantomRouteHints Function(ffi.Pointer<LDKChannelManager>)>();

  /// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
  LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_MessageSendEventsProvider(
      this_arg,
    );
  }

  late final _ChannelManager_as_MessageSendEventsProviderPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEventsProvider Function(
                  ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_as_MessageSendEventsProvider');
  late final _ChannelManager_as_MessageSendEventsProvider =
      _ChannelManager_as_MessageSendEventsProviderPtr.asFunction<
          LDKMessageSendEventsProvider Function(
              ffi.Pointer<LDKChannelManager>)>();

  /// Constructs a new EventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
  LDKEventsProvider ChannelManager_as_EventsProvider(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_EventsProvider(
      this_arg,
    );
  }

  late final _ChannelManager_as_EventsProviderPtr = _lookup<
          ffi.NativeFunction<
              LDKEventsProvider Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_as_EventsProvider');
  late final _ChannelManager_as_EventsProvider =
      _ChannelManager_as_EventsProviderPtr.asFunction<
          LDKEventsProvider Function(ffi.Pointer<LDKChannelManager>)>();

  /// Constructs a new Listen which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
  LDKListen ChannelManager_as_Listen(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_Listen(
      this_arg,
    );
  }

  late final _ChannelManager_as_ListenPtr = _lookup<
      ffi.NativeFunction<
          LDKListen Function(
              ffi.Pointer<LDKChannelManager>)>>('ChannelManager_as_Listen');
  late final _ChannelManager_as_Listen = _ChannelManager_as_ListenPtr
      .asFunction<LDKListen Function(ffi.Pointer<LDKChannelManager>)>();

  /// Constructs a new Confirm which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
  LDKConfirm ChannelManager_as_Confirm(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_Confirm(
      this_arg,
    );
  }

  late final _ChannelManager_as_ConfirmPtr = _lookup<
      ffi.NativeFunction<
          LDKConfirm Function(
              ffi.Pointer<LDKChannelManager>)>>('ChannelManager_as_Confirm');
  late final _ChannelManager_as_Confirm = _ChannelManager_as_ConfirmPtr
      .asFunction<LDKConfirm Function(ffi.Pointer<LDKChannelManager>)>();

  /// Blocks until ChannelManager needs to be persisted or a timeout is reached. It returns a bool
  /// indicating whether persistence is necessary. Only one listener on
  /// `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
  /// up.
  ///
  /// Note that this method is not available with the `no-std` feature.
  bool ChannelManager_await_persistable_update_timeout(
    ffi.Pointer<LDKChannelManager> this_arg,
    int max_wait,
  ) {
    return _ChannelManager_await_persistable_update_timeout(
      this_arg,
      max_wait,
    );
  }

  late final _ChannelManager_await_persistable_update_timeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKChannelManager>,
              ffi.Uint64)>>('ChannelManager_await_persistable_update_timeout');
  late final _ChannelManager_await_persistable_update_timeout =
      _ChannelManager_await_persistable_update_timeoutPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelManager>, int)>();

  /// Blocks until ChannelManager needs to be persisted. Only one listener on
  /// `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
  /// up.
  void ChannelManager_await_persistable_update(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_await_persistable_update(
      this_arg,
    );
  }

  late final _ChannelManager_await_persistable_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_await_persistable_update');
  late final _ChannelManager_await_persistable_update =
      _ChannelManager_await_persistable_updatePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManager>)>();

  /// Gets the latest best block which was connected either via the [`chain::Listen`] or
  /// [`chain::Confirm`] interfaces.
  LDKBestBlock ChannelManager_current_best_block(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_current_best_block(
      this_arg,
    );
  }

  late final _ChannelManager_current_best_blockPtr = _lookup<
          ffi.NativeFunction<
              LDKBestBlock Function(ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_current_best_block');
  late final _ChannelManager_current_best_block =
      _ChannelManager_current_best_blockPtr.asFunction<
          LDKBestBlock Function(ffi.Pointer<LDKChannelManager>)>();

  /// Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
  LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_ChannelMessageHandler(
      this_arg,
    );
  }

  late final _ChannelManager_as_ChannelMessageHandlerPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelMessageHandler Function(
                  ffi.Pointer<LDKChannelManager>)>>(
      'ChannelManager_as_ChannelMessageHandler');
  late final _ChannelManager_as_ChannelMessageHandler =
      _ChannelManager_as_ChannelMessageHandlerPtr.asFunction<
          LDKChannelMessageHandler Function(ffi.Pointer<LDKChannelManager>)>();

  /// Serialize the CounterpartyForwardingInfo object into a byte array which can be read by CounterpartyForwardingInfo_read
  LDKCVec_u8Z CounterpartyForwardingInfo_write(
    ffi.Pointer<LDKCounterpartyForwardingInfo> obj,
  ) {
    return _CounterpartyForwardingInfo_write(
      obj,
    );
  }

  late final _CounterpartyForwardingInfo_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKCounterpartyForwardingInfo>)>>(
      'CounterpartyForwardingInfo_write');
  late final _CounterpartyForwardingInfo_write =
      _CounterpartyForwardingInfo_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKCounterpartyForwardingInfo>)>();

  /// Read a CounterpartyForwardingInfo from a byte array, created by CounterpartyForwardingInfo_write
  LDKCResult_CounterpartyForwardingInfoDecodeErrorZ
      CounterpartyForwardingInfo_read(
    LDKu8slice ser,
  ) {
    return _CounterpartyForwardingInfo_read(
      ser,
    );
  }

  late final _CounterpartyForwardingInfo_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
              LDKu8slice)>>('CounterpartyForwardingInfo_read');
  late final _CounterpartyForwardingInfo_read =
      _CounterpartyForwardingInfo_readPtr.asFunction<
          LDKCResult_CounterpartyForwardingInfoDecodeErrorZ Function(
              LDKu8slice)>();

  /// Serialize the ChannelCounterparty object into a byte array which can be read by ChannelCounterparty_read
  LDKCVec_u8Z ChannelCounterparty_write(
    ffi.Pointer<LDKChannelCounterparty> obj,
  ) {
    return _ChannelCounterparty_write(
      obj,
    );
  }

  late final _ChannelCounterparty_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKChannelCounterparty>)>>(
      'ChannelCounterparty_write');
  late final _ChannelCounterparty_write = _ChannelCounterparty_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKChannelCounterparty>)>();

  /// Read a ChannelCounterparty from a byte array, created by ChannelCounterparty_write
  LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(
    LDKu8slice ser,
  ) {
    return _ChannelCounterparty_read(
      ser,
    );
  }

  late final _ChannelCounterparty_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(
              LDKu8slice)>>('ChannelCounterparty_read');
  late final _ChannelCounterparty_read =
      _ChannelCounterparty_readPtr.asFunction<
          LDKCResult_ChannelCounterpartyDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelDetails object into a byte array which can be read by ChannelDetails_read
  LDKCVec_u8Z ChannelDetails_write(
    ffi.Pointer<LDKChannelDetails> obj,
  ) {
    return _ChannelDetails_write(
      obj,
    );
  }

  late final _ChannelDetails_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelDetails>)>>('ChannelDetails_write');
  late final _ChannelDetails_write = _ChannelDetails_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelDetails>)>();

  /// Read a ChannelDetails from a byte array, created by ChannelDetails_write
  LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(
    LDKu8slice ser,
  ) {
    return _ChannelDetails_read(
      ser,
    );
  }

  late final _ChannelDetails_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelDetailsDecodeErrorZ Function(
              LDKu8slice)>>('ChannelDetails_read');
  late final _ChannelDetails_read = _ChannelDetails_readPtr.asFunction<
      LDKCResult_ChannelDetailsDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the PhantomRouteHints object into a byte array which can be read by PhantomRouteHints_read
  LDKCVec_u8Z PhantomRouteHints_write(
    ffi.Pointer<LDKPhantomRouteHints> obj,
  ) {
    return _PhantomRouteHints_write(
      obj,
    );
  }

  late final _PhantomRouteHints_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKPhantomRouteHints>)>>('PhantomRouteHints_write');
  late final _PhantomRouteHints_write = _PhantomRouteHints_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKPhantomRouteHints>)>();

  /// Read a PhantomRouteHints from a byte array, created by PhantomRouteHints_write
  LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(
    LDKu8slice ser,
  ) {
    return _PhantomRouteHints_read(
      ser,
    );
  }

  late final _PhantomRouteHints_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PhantomRouteHintsDecodeErrorZ Function(
              LDKu8slice)>>('PhantomRouteHints_read');
  late final _PhantomRouteHints_read = _PhantomRouteHints_readPtr.asFunction<
      LDKCResult_PhantomRouteHintsDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
  LDKCVec_u8Z ChannelManager_write(
    ffi.Pointer<LDKChannelManager> obj,
  ) {
    return _ChannelManager_write(
      obj,
    );
  }

  late final _ChannelManager_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelManager>)>>('ChannelManager_write');
  late final _ChannelManager_write = _ChannelManager_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelManager>)>();

  /// Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
  void ChannelManagerReadArgs_free(
    LDKChannelManagerReadArgs this_obj,
  ) {
    return _ChannelManagerReadArgs_free(
      this_obj,
    );
  }

  late final _ChannelManagerReadArgs_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelManagerReadArgs)>>(
          'ChannelManagerReadArgs_free');
  late final _ChannelManagerReadArgs_free = _ChannelManagerReadArgs_freePtr
      .asFunction<void Function(LDKChannelManagerReadArgs)>();

  /// The keys provider which will give us relevant keys. Some keys will be loaded during
  /// deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
  /// signing data.
  ffi.Pointer<LDKKeysInterface> ChannelManagerReadArgs_get_keys_manager(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_keys_manager(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_keys_managerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKKeysInterface> Function(
                  ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_keys_manager');
  late final _ChannelManagerReadArgs_get_keys_manager =
      _ChannelManagerReadArgs_get_keys_managerPtr.asFunction<
          ffi.Pointer<LDKKeysInterface> Function(
              ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// The keys provider which will give us relevant keys. Some keys will be loaded during
  /// deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
  /// signing data.
  void ChannelManagerReadArgs_set_keys_manager(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKKeysInterface val,
  ) {
    return _ChannelManagerReadArgs_set_keys_manager(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_keys_managerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKKeysInterface)>>('ChannelManagerReadArgs_set_keys_manager');
  late final _ChannelManagerReadArgs_set_keys_manager =
      _ChannelManagerReadArgs_set_keys_managerPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelManagerReadArgs>, LDKKeysInterface)>();

  /// The fee_estimator for use in the ChannelManager in the future.
  ///
  /// No calls to the FeeEstimator will be made during deserialization.
  ffi.Pointer<LDKFeeEstimator> ChannelManagerReadArgs_get_fee_estimator(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_fee_estimator(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_fee_estimatorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKFeeEstimator> Function(
                  ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_fee_estimator');
  late final _ChannelManagerReadArgs_get_fee_estimator =
      _ChannelManagerReadArgs_get_fee_estimatorPtr.asFunction<
          ffi.Pointer<LDKFeeEstimator> Function(
              ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// The fee_estimator for use in the ChannelManager in the future.
  ///
  /// No calls to the FeeEstimator will be made during deserialization.
  void ChannelManagerReadArgs_set_fee_estimator(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKFeeEstimator val,
  ) {
    return _ChannelManagerReadArgs_set_fee_estimator(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_fee_estimatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKFeeEstimator)>>('ChannelManagerReadArgs_set_fee_estimator');
  late final _ChannelManagerReadArgs_set_fee_estimator =
      _ChannelManagerReadArgs_set_fee_estimatorPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelManagerReadArgs>, LDKFeeEstimator)>();

  /// The chain::Watch for use in the ChannelManager in the future.
  ///
  /// No calls to the chain::Watch will be made during deserialization. It is assumed that
  /// you have deserialized ChannelMonitors separately and will add them to your
  /// chain::Watch after deserializing this ChannelManager.
  ffi.Pointer<LDKWatch> ChannelManagerReadArgs_get_chain_monitor(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_chain_monitor(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_chain_monitorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKWatch> Function(
                  ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_chain_monitor');
  late final _ChannelManagerReadArgs_get_chain_monitor =
      _ChannelManagerReadArgs_get_chain_monitorPtr.asFunction<
          ffi.Pointer<LDKWatch> Function(
              ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// The chain::Watch for use in the ChannelManager in the future.
  ///
  /// No calls to the chain::Watch will be made during deserialization. It is assumed that
  /// you have deserialized ChannelMonitors separately and will add them to your
  /// chain::Watch after deserializing this ChannelManager.
  void ChannelManagerReadArgs_set_chain_monitor(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKWatch val,
  ) {
    return _ChannelManagerReadArgs_set_chain_monitor(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_chain_monitorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKWatch)>>('ChannelManagerReadArgs_set_chain_monitor');
  late final _ChannelManagerReadArgs_set_chain_monitor =
      _ChannelManagerReadArgs_set_chain_monitorPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManagerReadArgs>, LDKWatch)>();

  /// The BroadcasterInterface which will be used in the ChannelManager in the future and may be
  /// used to broadcast the latest local commitment transactions of channels which must be
  /// force-closed during deserialization.
  ffi.Pointer<LDKBroadcasterInterface>
      ChannelManagerReadArgs_get_tx_broadcaster(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_tx_broadcaster(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_tx_broadcasterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKBroadcasterInterface> Function(
                  ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_tx_broadcaster');
  late final _ChannelManagerReadArgs_get_tx_broadcaster =
      _ChannelManagerReadArgs_get_tx_broadcasterPtr.asFunction<
          ffi.Pointer<LDKBroadcasterInterface> Function(
              ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// The BroadcasterInterface which will be used in the ChannelManager in the future and may be
  /// used to broadcast the latest local commitment transactions of channels which must be
  /// force-closed during deserialization.
  void ChannelManagerReadArgs_set_tx_broadcaster(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKBroadcasterInterface val,
  ) {
    return _ChannelManagerReadArgs_set_tx_broadcaster(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_tx_broadcasterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
                  LDKBroadcasterInterface)>>(
      'ChannelManagerReadArgs_set_tx_broadcaster');
  late final _ChannelManagerReadArgs_set_tx_broadcaster =
      _ChannelManagerReadArgs_set_tx_broadcasterPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKBroadcasterInterface)>();

  /// The Logger for use in the ChannelManager and which may be used to log information during
  /// deserialization.
  ffi.Pointer<LDKLogger> ChannelManagerReadArgs_get_logger(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_logger(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_loggerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKLogger> Function(
                  ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_logger');
  late final _ChannelManagerReadArgs_get_logger =
      _ChannelManagerReadArgs_get_loggerPtr.asFunction<
          ffi.Pointer<LDKLogger> Function(
              ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// The Logger for use in the ChannelManager and which may be used to log information during
  /// deserialization.
  void ChannelManagerReadArgs_set_logger(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKLogger val,
  ) {
    return _ChannelManagerReadArgs_set_logger(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_loggerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKLogger)>>('ChannelManagerReadArgs_set_logger');
  late final _ChannelManagerReadArgs_set_logger =
      _ChannelManagerReadArgs_set_loggerPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelManagerReadArgs>, LDKLogger)>();

  /// Default settings used for new channels. Any existing channels will continue to use the
  /// runtime settings which were stored when the ChannelManager was serialized.
  LDKUserConfig ChannelManagerReadArgs_get_default_config(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
  ) {
    return _ChannelManagerReadArgs_get_default_config(
      this_ptr,
    );
  }

  late final _ChannelManagerReadArgs_get_default_configPtr = _lookup<
          ffi.NativeFunction<
              LDKUserConfig Function(ffi.Pointer<LDKChannelManagerReadArgs>)>>(
      'ChannelManagerReadArgs_get_default_config');
  late final _ChannelManagerReadArgs_get_default_config =
      _ChannelManagerReadArgs_get_default_configPtr.asFunction<
          LDKUserConfig Function(ffi.Pointer<LDKChannelManagerReadArgs>)>();

  /// Default settings used for new channels. Any existing channels will continue to use the
  /// runtime settings which were stored when the ChannelManager was serialized.
  void ChannelManagerReadArgs_set_default_config(
    ffi.Pointer<LDKChannelManagerReadArgs> this_ptr,
    LDKUserConfig val,
  ) {
    return _ChannelManagerReadArgs_set_default_config(
      this_ptr,
      val,
    );
  }

  late final _ChannelManagerReadArgs_set_default_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelManagerReadArgs>,
              LDKUserConfig)>>('ChannelManagerReadArgs_set_default_config');
  late final _ChannelManagerReadArgs_set_default_config =
      _ChannelManagerReadArgs_set_default_configPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelManagerReadArgs>, LDKUserConfig)>();

  /// Simple utility function to create a ChannelManagerReadArgs which creates the monitor
  /// HashMap for you. This is primarily useful for C bindings where it is not practical to
  /// populate a HashMap directly from C.
  LDKChannelManagerReadArgs ChannelManagerReadArgs_new(
    LDKKeysInterface keys_manager,
    LDKFeeEstimator fee_estimator,
    LDKWatch chain_monitor,
    LDKBroadcasterInterface tx_broadcaster,
    LDKLogger logger,
    LDKUserConfig default_config,
    LDKCVec_ChannelMonitorZ channel_monitors,
  ) {
    return _ChannelManagerReadArgs_new(
      keys_manager,
      fee_estimator,
      chain_monitor,
      tx_broadcaster,
      logger,
      default_config,
      channel_monitors,
    );
  }

  late final _ChannelManagerReadArgs_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelManagerReadArgs Function(
              LDKKeysInterface,
              LDKFeeEstimator,
              LDKWatch,
              LDKBroadcasterInterface,
              LDKLogger,
              LDKUserConfig,
              LDKCVec_ChannelMonitorZ)>>('ChannelManagerReadArgs_new');
  late final _ChannelManagerReadArgs_new =
      _ChannelManagerReadArgs_newPtr.asFunction<
          LDKChannelManagerReadArgs Function(
              LDKKeysInterface,
              LDKFeeEstimator,
              LDKWatch,
              LDKBroadcasterInterface,
              LDKLogger,
              LDKUserConfig,
              LDKCVec_ChannelMonitorZ)>();

  /// Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
  LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
      C2Tuple_BlockHashChannelManagerZ_read(
    LDKu8slice ser,
    LDKChannelManagerReadArgs arg,
  ) {
    return _C2Tuple_BlockHashChannelManagerZ_read(
      ser,
      arg,
    );
  }

  late final _C2Tuple_BlockHashChannelManagerZ_readPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ Function(
                  LDKu8slice, LDKChannelManagerReadArgs)>>(
      'C2Tuple_BlockHashChannelManagerZ_read');
  late final _C2Tuple_BlockHashChannelManagerZ_read =
      _C2Tuple_BlockHashChannelManagerZ_readPtr.asFunction<
          LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ Function(
              LDKu8slice, LDKChannelManagerReadArgs)>();

  /// Frees any resources used by the ExpandedKey, if is_owned is set and inner is non-NULL.
  void ExpandedKey_free(
    LDKExpandedKey this_obj,
  ) {
    return _ExpandedKey_free(
      this_obj,
    );
  }

  late final _ExpandedKey_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKExpandedKey)>>(
          'ExpandedKey_free');
  late final _ExpandedKey_free =
      _ExpandedKey_freePtr.asFunction<void Function(LDKExpandedKey)>();

  /// Create a  new [`ExpandedKey`] for generating an inbound payment hash and secret.
  ///
  /// It is recommended to cache this value and not regenerate it for each new inbound payment.
  LDKExpandedKey ExpandedKey_new(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> key_material,
  ) {
    return _ExpandedKey_new(
      key_material,
    );
  }

  late final _ExpandedKey_newPtr = _lookup<
      ffi.NativeFunction<
          LDKExpandedKey Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('ExpandedKey_new');
  late final _ExpandedKey_new = _ExpandedKey_newPtr.asFunction<
      LDKExpandedKey Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment`], but no
  /// `ChannelManager` is required. Useful for generating invoices for [phantom node payments] without
  /// a `ChannelManager`.
  ///
  /// `keys` is generated by calling [`KeysInterface::get_inbound_payment_key_material`] and then
  /// calling [`ExpandedKey::new`] with its result. It is recommended to cache this value and not
  /// regenerate it for each new inbound payment.
  ///
  /// `current_time` is a Unix timestamp representing the current time.
  ///
  /// [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
  LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ create(
    ffi.Pointer<LDKExpandedKey> keys,
    LDKCOption_u64Z min_value_msat,
    int invoice_expiry_delta_secs,
    ffi.Pointer<LDKKeysInterface> keys_manager,
    int current_time,
  ) {
    return _create(
      keys,
      min_value_msat,
      invoice_expiry_delta_secs,
      keys_manager,
      current_time,
    );
  }

  late final _createPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
              ffi.Pointer<LDKExpandedKey>,
              LDKCOption_u64Z,
              ffi.Uint32,
              ffi.Pointer<LDKKeysInterface>,
              ffi.Uint64)>>('create');
  late final _create = _createPtr.asFunction<
      LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ Function(
          ffi.Pointer<LDKExpandedKey>,
          LDKCOption_u64Z,
          int,
          ffi.Pointer<LDKKeysInterface>,
          int)>();

  /// Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash`],
  /// but no `ChannelManager` is required. Useful for generating invoices for [phantom node payments]
  /// without a `ChannelManager`.
  ///
  /// See [`create`] for information on the `keys` and `current_time` parameters.
  ///
  /// [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
  LDKCResult_PaymentSecretNoneZ create_from_hash(
    ffi.Pointer<LDKExpandedKey> keys,
    LDKCOption_u64Z min_value_msat,
    LDKThirtyTwoBytes payment_hash,
    int invoice_expiry_delta_secs,
    int current_time,
  ) {
    return _create_from_hash(
      keys,
      min_value_msat,
      payment_hash,
      invoice_expiry_delta_secs,
      current_time,
    );
  }

  late final _create_from_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentSecretNoneZ Function(
              ffi.Pointer<LDKExpandedKey>,
              LDKCOption_u64Z,
              LDKThirtyTwoBytes,
              ffi.Uint32,
              ffi.Uint64)>>('create_from_hash');
  late final _create_from_hash = _create_from_hashPtr.asFunction<
      LDKCResult_PaymentSecretNoneZ Function(ffi.Pointer<LDKExpandedKey>,
          LDKCOption_u64Z, LDKThirtyTwoBytes, int, int)>();

  /// Frees any resources used by the DecodeError, if is_owned is set and inner is non-NULL.
  void DecodeError_free(
    LDKDecodeError this_obj,
  ) {
    return _DecodeError_free(
      this_obj,
    );
  }

  late final _DecodeError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKDecodeError)>>(
          'DecodeError_free');
  late final _DecodeError_free =
      _DecodeError_freePtr.asFunction<void Function(LDKDecodeError)>();

  /// Creates a copy of the DecodeError
  LDKDecodeError DecodeError_clone(
    ffi.Pointer<LDKDecodeError> orig,
  ) {
    return _DecodeError_clone(
      orig,
    );
  }

  late final _DecodeError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKDecodeError Function(
              ffi.Pointer<LDKDecodeError>)>>('DecodeError_clone');
  late final _DecodeError_clone = _DecodeError_clonePtr.asFunction<
      LDKDecodeError Function(ffi.Pointer<LDKDecodeError>)>();

  /// Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
  void Init_free(
    LDKInit this_obj,
  ) {
    return _Init_free(
      this_obj,
    );
  }

  late final _Init_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInit)>>('Init_free');
  late final _Init_free = _Init_freePtr.asFunction<void Function(LDKInit)>();

  /// The relevant features which the sender supports
  LDKInitFeatures Init_get_features(
    ffi.Pointer<LDKInit> this_ptr,
  ) {
    return _Init_get_features(
      this_ptr,
    );
  }

  late final _Init_get_featuresPtr = _lookup<
          ffi.NativeFunction<LDKInitFeatures Function(ffi.Pointer<LDKInit>)>>(
      'Init_get_features');
  late final _Init_get_features = _Init_get_featuresPtr.asFunction<
      LDKInitFeatures Function(ffi.Pointer<LDKInit>)>();

  /// The relevant features which the sender supports
  void Init_set_features(
    ffi.Pointer<LDKInit> this_ptr,
    LDKInitFeatures val,
  ) {
    return _Init_set_features(
      this_ptr,
      val,
    );
  }

  late final _Init_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKInit>, LDKInitFeatures)>>('Init_set_features');
  late final _Init_set_features = _Init_set_featuresPtr.asFunction<
      void Function(ffi.Pointer<LDKInit>, LDKInitFeatures)>();

  /// The receipient's network address. This adds the option to report a remote IP address
  /// back to a connecting peer using the init message. A node can decide to use that information
  /// to discover a potential update to its public IPv4 address (NAT) and use
  /// that for a node_announcement update message containing the new address.
  LDKCOption_NetAddressZ Init_get_remote_network_address(
    ffi.Pointer<LDKInit> this_ptr,
  ) {
    return _Init_get_remote_network_address(
      this_ptr,
    );
  }

  late final _Init_get_remote_network_addressPtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_NetAddressZ Function(
              ffi.Pointer<LDKInit>)>>('Init_get_remote_network_address');
  late final _Init_get_remote_network_address =
      _Init_get_remote_network_addressPtr.asFunction<
          LDKCOption_NetAddressZ Function(ffi.Pointer<LDKInit>)>();

  /// The receipient's network address. This adds the option to report a remote IP address
  /// back to a connecting peer using the init message. A node can decide to use that information
  /// to discover a potential update to its public IPv4 address (NAT) and use
  /// that for a node_announcement update message containing the new address.
  void Init_set_remote_network_address(
    ffi.Pointer<LDKInit> this_ptr,
    LDKCOption_NetAddressZ val,
  ) {
    return _Init_set_remote_network_address(
      this_ptr,
      val,
    );
  }

  late final _Init_set_remote_network_addressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInit>,
              LDKCOption_NetAddressZ)>>('Init_set_remote_network_address');
  late final _Init_set_remote_network_address =
      _Init_set_remote_network_addressPtr.asFunction<
          void Function(ffi.Pointer<LDKInit>, LDKCOption_NetAddressZ)>();

  /// Constructs a new Init given each field
  LDKInit Init_new(
    LDKInitFeatures features_arg,
    LDKCOption_NetAddressZ remote_network_address_arg,
  ) {
    return _Init_new(
      features_arg,
      remote_network_address_arg,
    );
  }

  late final _Init_newPtr = _lookup<
      ffi.NativeFunction<
          LDKInit Function(
              LDKInitFeatures, LDKCOption_NetAddressZ)>>('Init_new');
  late final _Init_new = _Init_newPtr.asFunction<
      LDKInit Function(LDKInitFeatures, LDKCOption_NetAddressZ)>();

  /// Creates a copy of the Init
  LDKInit Init_clone(
    ffi.Pointer<LDKInit> orig,
  ) {
    return _Init_clone(
      orig,
    );
  }

  late final _Init_clonePtr =
      _lookup<ffi.NativeFunction<LDKInit Function(ffi.Pointer<LDKInit>)>>(
          'Init_clone');
  late final _Init_clone =
      _Init_clonePtr.asFunction<LDKInit Function(ffi.Pointer<LDKInit>)>();

  /// Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
  void ErrorMessage_free(
    LDKErrorMessage this_obj,
  ) {
    return _ErrorMessage_free(
      this_obj,
    );
  }

  late final _ErrorMessage_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKErrorMessage)>>(
          'ErrorMessage_free');
  late final _ErrorMessage_free =
      _ErrorMessage_freePtr.asFunction<void Function(LDKErrorMessage)>();

  /// The channel ID involved in the error.
  ///
  /// All-0s indicates a general error unrelated to a specific channel, after which all channels
  /// with the sending peer should be closed.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ErrorMessage_get_channel_id(
    ffi.Pointer<LDKErrorMessage> this_ptr,
  ) {
    return _ErrorMessage_get_channel_id(
      this_ptr,
    );
  }

  late final _ErrorMessage_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKErrorMessage>)>>('ErrorMessage_get_channel_id');
  late final _ErrorMessage_get_channel_id =
      _ErrorMessage_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKErrorMessage>)>();

  /// The channel ID involved in the error.
  ///
  /// All-0s indicates a general error unrelated to a specific channel, after which all channels
  /// with the sending peer should be closed.
  void ErrorMessage_set_channel_id(
    ffi.Pointer<LDKErrorMessage> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ErrorMessage_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ErrorMessage_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKErrorMessage>,
              LDKThirtyTwoBytes)>>('ErrorMessage_set_channel_id');
  late final _ErrorMessage_set_channel_id =
      _ErrorMessage_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKErrorMessage>, LDKThirtyTwoBytes)>();

  /// A possibly human-readable error description.
  /// The string should be sanitized before it is used (e.g. emitted to logs or printed to
  /// stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
  /// the terminal emulator or the logging subsystem.
  LDKStr ErrorMessage_get_data(
    ffi.Pointer<LDKErrorMessage> this_ptr,
  ) {
    return _ErrorMessage_get_data(
      this_ptr,
    );
  }

  late final _ErrorMessage_get_dataPtr = _lookup<
          ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKErrorMessage>)>>(
      'ErrorMessage_get_data');
  late final _ErrorMessage_get_data = _ErrorMessage_get_dataPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKErrorMessage>)>();

  /// A possibly human-readable error description.
  /// The string should be sanitized before it is used (e.g. emitted to logs or printed to
  /// stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
  /// the terminal emulator or the logging subsystem.
  void ErrorMessage_set_data(
    ffi.Pointer<LDKErrorMessage> this_ptr,
    LDKStr val,
  ) {
    return _ErrorMessage_set_data(
      this_ptr,
      val,
    );
  }

  late final _ErrorMessage_set_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKErrorMessage>, LDKStr)>>('ErrorMessage_set_data');
  late final _ErrorMessage_set_data = _ErrorMessage_set_dataPtr.asFunction<
      void Function(ffi.Pointer<LDKErrorMessage>, LDKStr)>();

  /// Constructs a new ErrorMessage given each field
  LDKErrorMessage ErrorMessage_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKStr data_arg,
  ) {
    return _ErrorMessage_new(
      channel_id_arg,
      data_arg,
    );
  }

  late final _ErrorMessage_newPtr = _lookup<
      ffi.NativeFunction<
          LDKErrorMessage Function(
              LDKThirtyTwoBytes, LDKStr)>>('ErrorMessage_new');
  late final _ErrorMessage_new = _ErrorMessage_newPtr.asFunction<
      LDKErrorMessage Function(LDKThirtyTwoBytes, LDKStr)>();

  /// Creates a copy of the ErrorMessage
  LDKErrorMessage ErrorMessage_clone(
    ffi.Pointer<LDKErrorMessage> orig,
  ) {
    return _ErrorMessage_clone(
      orig,
    );
  }

  late final _ErrorMessage_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKErrorMessage Function(
              ffi.Pointer<LDKErrorMessage>)>>('ErrorMessage_clone');
  late final _ErrorMessage_clone = _ErrorMessage_clonePtr.asFunction<
      LDKErrorMessage Function(ffi.Pointer<LDKErrorMessage>)>();

  /// Frees any resources used by the WarningMessage, if is_owned is set and inner is non-NULL.
  void WarningMessage_free(
    LDKWarningMessage this_obj,
  ) {
    return _WarningMessage_free(
      this_obj,
    );
  }

  late final _WarningMessage_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKWarningMessage)>>(
          'WarningMessage_free');
  late final _WarningMessage_free =
      _WarningMessage_freePtr.asFunction<void Function(LDKWarningMessage)>();

  /// The channel ID involved in the warning.
  ///
  /// All-0s indicates a warning unrelated to a specific channel.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> WarningMessage_get_channel_id(
    ffi.Pointer<LDKWarningMessage> this_ptr,
  ) {
    return _WarningMessage_get_channel_id(
      this_ptr,
    );
  }

  late final _WarningMessage_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKWarningMessage>)>>(
      'WarningMessage_get_channel_id');
  late final _WarningMessage_get_channel_id =
      _WarningMessage_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKWarningMessage>)>();

  /// The channel ID involved in the warning.
  ///
  /// All-0s indicates a warning unrelated to a specific channel.
  void WarningMessage_set_channel_id(
    ffi.Pointer<LDKWarningMessage> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _WarningMessage_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _WarningMessage_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKWarningMessage>,
              LDKThirtyTwoBytes)>>('WarningMessage_set_channel_id');
  late final _WarningMessage_set_channel_id =
      _WarningMessage_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKWarningMessage>, LDKThirtyTwoBytes)>();

  /// A possibly human-readable warning description.
  /// The string should be sanitized before it is used (e.g. emitted to logs or printed to
  /// stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
  /// the terminal emulator or the logging subsystem.
  LDKStr WarningMessage_get_data(
    ffi.Pointer<LDKWarningMessage> this_ptr,
  ) {
    return _WarningMessage_get_data(
      this_ptr,
    );
  }

  late final _WarningMessage_get_dataPtr = _lookup<
          ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKWarningMessage>)>>(
      'WarningMessage_get_data');
  late final _WarningMessage_get_data = _WarningMessage_get_dataPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKWarningMessage>)>();

  /// A possibly human-readable warning description.
  /// The string should be sanitized before it is used (e.g. emitted to logs or printed to
  /// stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
  /// the terminal emulator or the logging subsystem.
  void WarningMessage_set_data(
    ffi.Pointer<LDKWarningMessage> this_ptr,
    LDKStr val,
  ) {
    return _WarningMessage_set_data(
      this_ptr,
      val,
    );
  }

  late final _WarningMessage_set_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKWarningMessage>,
              LDKStr)>>('WarningMessage_set_data');
  late final _WarningMessage_set_data = _WarningMessage_set_dataPtr.asFunction<
      void Function(ffi.Pointer<LDKWarningMessage>, LDKStr)>();

  /// Constructs a new WarningMessage given each field
  LDKWarningMessage WarningMessage_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKStr data_arg,
  ) {
    return _WarningMessage_new(
      channel_id_arg,
      data_arg,
    );
  }

  late final _WarningMessage_newPtr = _lookup<
      ffi.NativeFunction<
          LDKWarningMessage Function(
              LDKThirtyTwoBytes, LDKStr)>>('WarningMessage_new');
  late final _WarningMessage_new = _WarningMessage_newPtr.asFunction<
      LDKWarningMessage Function(LDKThirtyTwoBytes, LDKStr)>();

  /// Creates a copy of the WarningMessage
  LDKWarningMessage WarningMessage_clone(
    ffi.Pointer<LDKWarningMessage> orig,
  ) {
    return _WarningMessage_clone(
      orig,
    );
  }

  late final _WarningMessage_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKWarningMessage Function(
              ffi.Pointer<LDKWarningMessage>)>>('WarningMessage_clone');
  late final _WarningMessage_clone = _WarningMessage_clonePtr.asFunction<
      LDKWarningMessage Function(ffi.Pointer<LDKWarningMessage>)>();

  /// Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
  void Ping_free(
    LDKPing this_obj,
  ) {
    return _Ping_free(
      this_obj,
    );
  }

  late final _Ping_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPing)>>('Ping_free');
  late final _Ping_free = _Ping_freePtr.asFunction<void Function(LDKPing)>();

  /// The desired response length
  int Ping_get_ponglen(
    ffi.Pointer<LDKPing> this_ptr,
  ) {
    return _Ping_get_ponglen(
      this_ptr,
    );
  }

  late final _Ping_get_ponglenPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKPing>)>>(
          'Ping_get_ponglen');
  late final _Ping_get_ponglen =
      _Ping_get_ponglenPtr.asFunction<int Function(ffi.Pointer<LDKPing>)>();

  /// The desired response length
  void Ping_set_ponglen(
    ffi.Pointer<LDKPing> this_ptr,
    int val,
  ) {
    return _Ping_set_ponglen(
      this_ptr,
      val,
    );
  }

  late final _Ping_set_ponglenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKPing>, ffi.Uint16)>>('Ping_set_ponglen');
  late final _Ping_set_ponglen = _Ping_set_ponglenPtr.asFunction<
      void Function(ffi.Pointer<LDKPing>, int)>();

  /// The ping packet size.
  /// This field is not sent on the wire. byteslen zeros are sent.
  int Ping_get_byteslen(
    ffi.Pointer<LDKPing> this_ptr,
  ) {
    return _Ping_get_byteslen(
      this_ptr,
    );
  }

  late final _Ping_get_byteslenPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKPing>)>>(
          'Ping_get_byteslen');
  late final _Ping_get_byteslen =
      _Ping_get_byteslenPtr.asFunction<int Function(ffi.Pointer<LDKPing>)>();

  /// The ping packet size.
  /// This field is not sent on the wire. byteslen zeros are sent.
  void Ping_set_byteslen(
    ffi.Pointer<LDKPing> this_ptr,
    int val,
  ) {
    return _Ping_set_byteslen(
      this_ptr,
      val,
    );
  }

  late final _Ping_set_byteslenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKPing>, ffi.Uint16)>>('Ping_set_byteslen');
  late final _Ping_set_byteslen = _Ping_set_byteslenPtr.asFunction<
      void Function(ffi.Pointer<LDKPing>, int)>();

  /// Constructs a new Ping given each field
  LDKPing Ping_new(
    int ponglen_arg,
    int byteslen_arg,
  ) {
    return _Ping_new(
      ponglen_arg,
      byteslen_arg,
    );
  }

  late final _Ping_newPtr =
      _lookup<ffi.NativeFunction<LDKPing Function(ffi.Uint16, ffi.Uint16)>>(
          'Ping_new');
  late final _Ping_new = _Ping_newPtr.asFunction<LDKPing Function(int, int)>();

  /// Creates a copy of the Ping
  LDKPing Ping_clone(
    ffi.Pointer<LDKPing> orig,
  ) {
    return _Ping_clone(
      orig,
    );
  }

  late final _Ping_clonePtr =
      _lookup<ffi.NativeFunction<LDKPing Function(ffi.Pointer<LDKPing>)>>(
          'Ping_clone');
  late final _Ping_clone =
      _Ping_clonePtr.asFunction<LDKPing Function(ffi.Pointer<LDKPing>)>();

  /// Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
  void Pong_free(
    LDKPong this_obj,
  ) {
    return _Pong_free(
      this_obj,
    );
  }

  late final _Pong_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPong)>>('Pong_free');
  late final _Pong_free = _Pong_freePtr.asFunction<void Function(LDKPong)>();

  /// The pong packet size.
  /// This field is not sent on the wire. byteslen zeros are sent.
  int Pong_get_byteslen(
    ffi.Pointer<LDKPong> this_ptr,
  ) {
    return _Pong_get_byteslen(
      this_ptr,
    );
  }

  late final _Pong_get_byteslenPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKPong>)>>(
          'Pong_get_byteslen');
  late final _Pong_get_byteslen =
      _Pong_get_byteslenPtr.asFunction<int Function(ffi.Pointer<LDKPong>)>();

  /// The pong packet size.
  /// This field is not sent on the wire. byteslen zeros are sent.
  void Pong_set_byteslen(
    ffi.Pointer<LDKPong> this_ptr,
    int val,
  ) {
    return _Pong_set_byteslen(
      this_ptr,
      val,
    );
  }

  late final _Pong_set_byteslenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKPong>, ffi.Uint16)>>('Pong_set_byteslen');
  late final _Pong_set_byteslen = _Pong_set_byteslenPtr.asFunction<
      void Function(ffi.Pointer<LDKPong>, int)>();

  /// Constructs a new Pong given each field
  LDKPong Pong_new(
    int byteslen_arg,
  ) {
    return _Pong_new(
      byteslen_arg,
    );
  }

  late final _Pong_newPtr =
      _lookup<ffi.NativeFunction<LDKPong Function(ffi.Uint16)>>('Pong_new');
  late final _Pong_new = _Pong_newPtr.asFunction<LDKPong Function(int)>();

  /// Creates a copy of the Pong
  LDKPong Pong_clone(
    ffi.Pointer<LDKPong> orig,
  ) {
    return _Pong_clone(
      orig,
    );
  }

  late final _Pong_clonePtr =
      _lookup<ffi.NativeFunction<LDKPong Function(ffi.Pointer<LDKPong>)>>(
          'Pong_clone');
  late final _Pong_clone =
      _Pong_clonePtr.asFunction<LDKPong Function(ffi.Pointer<LDKPong>)>();

  /// Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
  void OpenChannel_free(
    LDKOpenChannel this_obj,
  ) {
    return _OpenChannel_free(
      this_obj,
    );
  }

  late final _OpenChannel_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKOpenChannel)>>(
          'OpenChannel_free');
  late final _OpenChannel_free =
      _OpenChannel_freePtr.asFunction<void Function(LDKOpenChannel)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> OpenChannel_get_chain_hash(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_chain_hash(
      this_ptr,
    );
  }

  late final _OpenChannel_get_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_get_chain_hash');
  late final _OpenChannel_get_chain_hash =
      _OpenChannel_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKOpenChannel>)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  void OpenChannel_set_chain_hash(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _OpenChannel_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKThirtyTwoBytes)>>('OpenChannel_set_chain_hash');
  late final _OpenChannel_set_chain_hash =
      _OpenChannel_set_chain_hashPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKThirtyTwoBytes)>();

  /// A temporary channel ID, until the funding outpoint is announced
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> OpenChannel_get_temporary_channel_id(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_temporary_channel_id(
      this_ptr,
    );
  }

  late final _OpenChannel_get_temporary_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_temporary_channel_id');
  late final _OpenChannel_get_temporary_channel_id =
      _OpenChannel_get_temporary_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKOpenChannel>)>();

  /// A temporary channel ID, until the funding outpoint is announced
  void OpenChannel_set_temporary_channel_id(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _OpenChannel_set_temporary_channel_id(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_temporary_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKThirtyTwoBytes)>>('OpenChannel_set_temporary_channel_id');
  late final _OpenChannel_set_temporary_channel_id =
      _OpenChannel_set_temporary_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKThirtyTwoBytes)>();

  /// The channel value
  int OpenChannel_get_funding_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_funding_satoshis(
      this_ptr,
    );
  }

  late final _OpenChannel_get_funding_satoshisPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_funding_satoshis');
  late final _OpenChannel_get_funding_satoshis =
      _OpenChannel_get_funding_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The channel value
  void OpenChannel_set_funding_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_funding_satoshis(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_funding_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_funding_satoshis');
  late final _OpenChannel_set_funding_satoshis =
      _OpenChannel_set_funding_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The amount to push to the counterparty as part of the open, in milli-satoshi
  int OpenChannel_get_push_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_push_msat(
      this_ptr,
    );
  }

  late final _OpenChannel_get_push_msatPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_push_msat');
  late final _OpenChannel_get_push_msat = _OpenChannel_get_push_msatPtr
      .asFunction<int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The amount to push to the counterparty as part of the open, in milli-satoshi
  void OpenChannel_set_push_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_push_msat(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_push_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_push_msat');
  late final _OpenChannel_set_push_msat = _OpenChannel_set_push_msatPtr
      .asFunction<void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The threshold below which outputs on transactions broadcast by sender will be omitted
  int OpenChannel_get_dust_limit_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_dust_limit_satoshis(
      this_ptr,
    );
  }

  late final _OpenChannel_get_dust_limit_satoshisPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_dust_limit_satoshis');
  late final _OpenChannel_get_dust_limit_satoshis =
      _OpenChannel_get_dust_limit_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The threshold below which outputs on transactions broadcast by sender will be omitted
  void OpenChannel_set_dust_limit_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_dust_limit_satoshis(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_dust_limit_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_dust_limit_satoshis');
  late final _OpenChannel_set_dust_limit_satoshis =
      _OpenChannel_set_dust_limit_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The maximum inbound HTLC value in flight towards sender, in milli-satoshi
  int OpenChannel_get_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_max_htlc_value_in_flight_msat(
      this_ptr,
    );
  }

  late final _OpenChannel_get_max_htlc_value_in_flight_msatPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_max_htlc_value_in_flight_msat');
  late final _OpenChannel_get_max_htlc_value_in_flight_msat =
      _OpenChannel_get_max_htlc_value_in_flight_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The maximum inbound HTLC value in flight towards sender, in milli-satoshi
  void OpenChannel_set_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_max_htlc_value_in_flight_msat(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_max_htlc_value_in_flight_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_max_htlc_value_in_flight_msat');
  late final _OpenChannel_set_max_htlc_value_in_flight_msat =
      _OpenChannel_set_max_htlc_value_in_flight_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
  int OpenChannel_get_channel_reserve_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_channel_reserve_satoshis(
      this_ptr,
    );
  }

  late final _OpenChannel_get_channel_reserve_satoshisPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_channel_reserve_satoshis');
  late final _OpenChannel_get_channel_reserve_satoshis =
      _OpenChannel_get_channel_reserve_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
  void OpenChannel_set_channel_reserve_satoshis(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_channel_reserve_satoshis(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_channel_reserve_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_channel_reserve_satoshis');
  late final _OpenChannel_set_channel_reserve_satoshis =
      _OpenChannel_set_channel_reserve_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  int OpenChannel_get_htlc_minimum_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _OpenChannel_get_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_htlc_minimum_msat');
  late final _OpenChannel_get_htlc_minimum_msat =
      _OpenChannel_get_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  void OpenChannel_set_htlc_minimum_msat(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint64)>>('OpenChannel_set_htlc_minimum_msat');
  late final _OpenChannel_set_htlc_minimum_msat =
      _OpenChannel_set_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The feerate per 1000-weight of sender generated transactions, until updated by update_fee
  int OpenChannel_get_feerate_per_kw(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_feerate_per_kw(
      this_ptr,
    );
  }

  late final _OpenChannel_get_feerate_per_kwPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_feerate_per_kw');
  late final _OpenChannel_get_feerate_per_kw =
      _OpenChannel_get_feerate_per_kwPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The feerate per 1000-weight of sender generated transactions, until updated by update_fee
  void OpenChannel_set_feerate_per_kw(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_feerate_per_kw(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_feerate_per_kwPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint32)>>('OpenChannel_set_feerate_per_kw');
  late final _OpenChannel_set_feerate_per_kw =
      _OpenChannel_set_feerate_per_kwPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
  int OpenChannel_get_to_self_delay(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_to_self_delay(
      this_ptr,
    );
  }

  late final _OpenChannel_get_to_self_delayPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_to_self_delay');
  late final _OpenChannel_get_to_self_delay = _OpenChannel_get_to_self_delayPtr
      .asFunction<int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
  void OpenChannel_set_to_self_delay(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_to_self_delay(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_to_self_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint16)>>('OpenChannel_set_to_self_delay');
  late final _OpenChannel_set_to_self_delay = _OpenChannel_set_to_self_delayPtr
      .asFunction<void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The maximum number of inbound HTLCs towards sender
  int OpenChannel_get_max_accepted_htlcs(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_max_accepted_htlcs(
      this_ptr,
    );
  }

  late final _OpenChannel_get_max_accepted_htlcsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_max_accepted_htlcs');
  late final _OpenChannel_get_max_accepted_htlcs =
      _OpenChannel_get_max_accepted_htlcsPtr.asFunction<
          int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The maximum number of inbound HTLCs towards sender
  void OpenChannel_set_max_accepted_htlcs(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_max_accepted_htlcs(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_max_accepted_htlcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint16)>>('OpenChannel_set_max_accepted_htlcs');
  late final _OpenChannel_set_max_accepted_htlcs =
      _OpenChannel_set_max_accepted_htlcsPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The sender's key controlling the funding transaction
  LDKPublicKey OpenChannel_get_funding_pubkey(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_funding_pubkey(
      this_ptr,
    );
  }

  late final _OpenChannel_get_funding_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_get_funding_pubkey');
  late final _OpenChannel_get_funding_pubkey =
      _OpenChannel_get_funding_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The sender's key controlling the funding transaction
  void OpenChannel_set_funding_pubkey(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_funding_pubkey(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_funding_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_funding_pubkey');
  late final _OpenChannel_set_funding_pubkey =
      _OpenChannel_set_funding_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// Used to derive a revocation key for transactions broadcast by counterparty
  LDKPublicKey OpenChannel_get_revocation_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_revocation_basepoint(
      this_ptr,
    );
  }

  late final _OpenChannel_get_revocation_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_revocation_basepoint');
  late final _OpenChannel_get_revocation_basepoint =
      _OpenChannel_get_revocation_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Used to derive a revocation key for transactions broadcast by counterparty
  void OpenChannel_set_revocation_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_revocation_basepoint(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_revocation_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_revocation_basepoint');
  late final _OpenChannel_set_revocation_basepoint =
      _OpenChannel_set_revocation_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// A payment key to sender for transactions broadcast by counterparty
  LDKPublicKey OpenChannel_get_payment_point(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_payment_point(
      this_ptr,
    );
  }

  late final _OpenChannel_get_payment_pointPtr = _lookup<
      ffi.NativeFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_get_payment_point');
  late final _OpenChannel_get_payment_point = _OpenChannel_get_payment_pointPtr
      .asFunction<LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// A payment key to sender for transactions broadcast by counterparty
  void OpenChannel_set_payment_point(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_payment_point(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_payment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_payment_point');
  late final _OpenChannel_set_payment_point = _OpenChannel_set_payment_pointPtr
      .asFunction<void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// Used to derive a payment key to sender for transactions broadcast by sender
  LDKPublicKey OpenChannel_get_delayed_payment_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_delayed_payment_basepoint(
      this_ptr,
    );
  }

  late final _OpenChannel_get_delayed_payment_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_delayed_payment_basepoint');
  late final _OpenChannel_get_delayed_payment_basepoint =
      _OpenChannel_get_delayed_payment_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Used to derive a payment key to sender for transactions broadcast by sender
  void OpenChannel_set_delayed_payment_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_delayed_payment_basepoint(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_delayed_payment_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_delayed_payment_basepoint');
  late final _OpenChannel_set_delayed_payment_basepoint =
      _OpenChannel_set_delayed_payment_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// Used to derive an HTLC payment key to sender
  LDKPublicKey OpenChannel_get_htlc_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_htlc_basepoint(
      this_ptr,
    );
  }

  late final _OpenChannel_get_htlc_basepointPtr = _lookup<
      ffi.NativeFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_get_htlc_basepoint');
  late final _OpenChannel_get_htlc_basepoint =
      _OpenChannel_get_htlc_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Used to derive an HTLC payment key to sender
  void OpenChannel_set_htlc_basepoint(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_htlc_basepoint(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_htlc_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_htlc_basepoint');
  late final _OpenChannel_set_htlc_basepoint =
      _OpenChannel_set_htlc_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// The first to-be-broadcast-by-sender transaction's per commitment point
  LDKPublicKey OpenChannel_get_first_per_commitment_point(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_first_per_commitment_point(
      this_ptr,
    );
  }

  late final _OpenChannel_get_first_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_first_per_commitment_point');
  late final _OpenChannel_get_first_per_commitment_point =
      _OpenChannel_get_first_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The first to-be-broadcast-by-sender transaction's per commitment point
  void OpenChannel_set_first_per_commitment_point(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _OpenChannel_set_first_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_first_per_commitment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKPublicKey)>>('OpenChannel_set_first_per_commitment_point');
  late final _OpenChannel_set_first_per_commitment_point =
      _OpenChannel_set_first_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKPublicKey)>();

  /// Channel flags
  int OpenChannel_get_channel_flags(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_channel_flags(
      this_ptr,
    );
  }

  late final _OpenChannel_get_channel_flagsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<LDKOpenChannel>)>>(
      'OpenChannel_get_channel_flags');
  late final _OpenChannel_get_channel_flags = _OpenChannel_get_channel_flagsPtr
      .asFunction<int Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Channel flags
  void OpenChannel_set_channel_flags(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    int val,
  ) {
    return _OpenChannel_set_channel_flags(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_channel_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              ffi.Uint8)>>('OpenChannel_set_channel_flags');
  late final _OpenChannel_set_channel_flags = _OpenChannel_set_channel_flagsPtr
      .asFunction<void Function(ffi.Pointer<LDKOpenChannel>, int)>();

  /// The channel type that this channel will represent. If none is set, we derive the channel
  /// type from the intersection of our feature bits with our counterparty's feature bits from
  /// the Init message.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelTypeFeatures OpenChannel_get_channel_type(
    ffi.Pointer<LDKOpenChannel> this_ptr,
  ) {
    return _OpenChannel_get_channel_type(
      this_ptr,
    );
  }

  late final _OpenChannel_get_channel_typePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelTypeFeatures Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_get_channel_type');
  late final _OpenChannel_get_channel_type =
      _OpenChannel_get_channel_typePtr.asFunction<
          LDKChannelTypeFeatures Function(ffi.Pointer<LDKOpenChannel>)>();

  /// The channel type that this channel will represent. If none is set, we derive the channel
  /// type from the intersection of our feature bits with our counterparty's feature bits from
  /// the Init message.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void OpenChannel_set_channel_type(
    ffi.Pointer<LDKOpenChannel> this_ptr,
    LDKChannelTypeFeatures val,
  ) {
    return _OpenChannel_set_channel_type(
      this_ptr,
      val,
    );
  }

  late final _OpenChannel_set_channel_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKOpenChannel>,
              LDKChannelTypeFeatures)>>('OpenChannel_set_channel_type');
  late final _OpenChannel_set_channel_type =
      _OpenChannel_set_channel_typePtr.asFunction<
          void Function(ffi.Pointer<LDKOpenChannel>, LDKChannelTypeFeatures)>();

  /// Creates a copy of the OpenChannel
  LDKOpenChannel OpenChannel_clone(
    ffi.Pointer<LDKOpenChannel> orig,
  ) {
    return _OpenChannel_clone(
      orig,
    );
  }

  late final _OpenChannel_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKOpenChannel Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_clone');
  late final _OpenChannel_clone = _OpenChannel_clonePtr.asFunction<
      LDKOpenChannel Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
  void AcceptChannel_free(
    LDKAcceptChannel this_obj,
  ) {
    return _AcceptChannel_free(
      this_obj,
    );
  }

  late final _AcceptChannel_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKAcceptChannel)>>(
          'AcceptChannel_free');
  late final _AcceptChannel_free =
      _AcceptChannel_freePtr.asFunction<void Function(LDKAcceptChannel)>();

  /// A temporary channel ID, until the funding outpoint is announced
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> AcceptChannel_get_temporary_channel_id(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_temporary_channel_id(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_temporary_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_temporary_channel_id');
  late final _AcceptChannel_get_temporary_channel_id =
      _AcceptChannel_get_temporary_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKAcceptChannel>)>();

  /// A temporary channel ID, until the funding outpoint is announced
  void AcceptChannel_set_temporary_channel_id(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _AcceptChannel_set_temporary_channel_id(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_temporary_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKThirtyTwoBytes)>>('AcceptChannel_set_temporary_channel_id');
  late final _AcceptChannel_set_temporary_channel_id =
      _AcceptChannel_set_temporary_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKThirtyTwoBytes)>();

  /// The threshold below which outputs on transactions broadcast by sender will be omitted
  int AcceptChannel_get_dust_limit_satoshis(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_dust_limit_satoshis(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_dust_limit_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_dust_limit_satoshis');
  late final _AcceptChannel_get_dust_limit_satoshis =
      _AcceptChannel_get_dust_limit_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The threshold below which outputs on transactions broadcast by sender will be omitted
  void AcceptChannel_set_dust_limit_satoshis(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_dust_limit_satoshis(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_dust_limit_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint64)>>('AcceptChannel_set_dust_limit_satoshis');
  late final _AcceptChannel_set_dust_limit_satoshis =
      _AcceptChannel_set_dust_limit_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The maximum inbound HTLC value in flight towards sender, in milli-satoshi
  int AcceptChannel_get_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_max_htlc_value_in_flight_msat(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_max_htlc_value_in_flight_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_max_htlc_value_in_flight_msat');
  late final _AcceptChannel_get_max_htlc_value_in_flight_msat =
      _AcceptChannel_get_max_htlc_value_in_flight_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The maximum inbound HTLC value in flight towards sender, in milli-satoshi
  void AcceptChannel_set_max_htlc_value_in_flight_msat(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_max_htlc_value_in_flight_msat(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_max_htlc_value_in_flight_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint64)>>('AcceptChannel_set_max_htlc_value_in_flight_msat');
  late final _AcceptChannel_set_max_htlc_value_in_flight_msat =
      _AcceptChannel_set_max_htlc_value_in_flight_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
  int AcceptChannel_get_channel_reserve_satoshis(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_channel_reserve_satoshis(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_channel_reserve_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_channel_reserve_satoshis');
  late final _AcceptChannel_get_channel_reserve_satoshis =
      _AcceptChannel_get_channel_reserve_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
  void AcceptChannel_set_channel_reserve_satoshis(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_channel_reserve_satoshis(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_channel_reserve_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint64)>>('AcceptChannel_set_channel_reserve_satoshis');
  late final _AcceptChannel_set_channel_reserve_satoshis =
      _AcceptChannel_set_channel_reserve_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  int AcceptChannel_get_htlc_minimum_msat(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_htlc_minimum_msat');
  late final _AcceptChannel_get_htlc_minimum_msat =
      _AcceptChannel_get_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  void AcceptChannel_set_htlc_minimum_msat(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint64)>>('AcceptChannel_set_htlc_minimum_msat');
  late final _AcceptChannel_set_htlc_minimum_msat =
      _AcceptChannel_set_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// Minimum depth of the funding transaction before the channel is considered open
  int AcceptChannel_get_minimum_depth(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_minimum_depth(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_minimum_depthPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_minimum_depth');
  late final _AcceptChannel_get_minimum_depth =
      _AcceptChannel_get_minimum_depthPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Minimum depth of the funding transaction before the channel is considered open
  void AcceptChannel_set_minimum_depth(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_minimum_depth(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_minimum_depthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint32)>>('AcceptChannel_set_minimum_depth');
  late final _AcceptChannel_set_minimum_depth =
      _AcceptChannel_set_minimum_depthPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
  int AcceptChannel_get_to_self_delay(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_to_self_delay(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_to_self_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_to_self_delay');
  late final _AcceptChannel_get_to_self_delay =
      _AcceptChannel_get_to_self_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
  void AcceptChannel_set_to_self_delay(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_to_self_delay(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_to_self_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint16)>>('AcceptChannel_set_to_self_delay');
  late final _AcceptChannel_set_to_self_delay =
      _AcceptChannel_set_to_self_delayPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The maximum number of inbound HTLCs towards sender
  int AcceptChannel_get_max_accepted_htlcs(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_max_accepted_htlcs(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_max_accepted_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_max_accepted_htlcs');
  late final _AcceptChannel_get_max_accepted_htlcs =
      _AcceptChannel_get_max_accepted_htlcsPtr.asFunction<
          int Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The maximum number of inbound HTLCs towards sender
  void AcceptChannel_set_max_accepted_htlcs(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    int val,
  ) {
    return _AcceptChannel_set_max_accepted_htlcs(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_max_accepted_htlcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              ffi.Uint16)>>('AcceptChannel_set_max_accepted_htlcs');
  late final _AcceptChannel_set_max_accepted_htlcs =
      _AcceptChannel_set_max_accepted_htlcsPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, int)>();

  /// The sender's key controlling the funding transaction
  LDKPublicKey AcceptChannel_get_funding_pubkey(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_funding_pubkey(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_funding_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_funding_pubkey');
  late final _AcceptChannel_get_funding_pubkey =
      _AcceptChannel_get_funding_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The sender's key controlling the funding transaction
  void AcceptChannel_set_funding_pubkey(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_funding_pubkey(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_funding_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_funding_pubkey');
  late final _AcceptChannel_set_funding_pubkey =
      _AcceptChannel_set_funding_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// Used to derive a revocation key for transactions broadcast by counterparty
  LDKPublicKey AcceptChannel_get_revocation_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_revocation_basepoint(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_revocation_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_revocation_basepoint');
  late final _AcceptChannel_get_revocation_basepoint =
      _AcceptChannel_get_revocation_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Used to derive a revocation key for transactions broadcast by counterparty
  void AcceptChannel_set_revocation_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_revocation_basepoint(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_revocation_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_revocation_basepoint');
  late final _AcceptChannel_set_revocation_basepoint =
      _AcceptChannel_set_revocation_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// A payment key to sender for transactions broadcast by counterparty
  LDKPublicKey AcceptChannel_get_payment_point(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_payment_point(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_payment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_payment_point');
  late final _AcceptChannel_get_payment_point =
      _AcceptChannel_get_payment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// A payment key to sender for transactions broadcast by counterparty
  void AcceptChannel_set_payment_point(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_payment_point(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_payment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_payment_point');
  late final _AcceptChannel_set_payment_point =
      _AcceptChannel_set_payment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// Used to derive a payment key to sender for transactions broadcast by sender
  LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_delayed_payment_basepoint(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_delayed_payment_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_delayed_payment_basepoint');
  late final _AcceptChannel_get_delayed_payment_basepoint =
      _AcceptChannel_get_delayed_payment_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Used to derive a payment key to sender for transactions broadcast by sender
  void AcceptChannel_set_delayed_payment_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_delayed_payment_basepoint(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_delayed_payment_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_delayed_payment_basepoint');
  late final _AcceptChannel_set_delayed_payment_basepoint =
      _AcceptChannel_set_delayed_payment_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
  LDKPublicKey AcceptChannel_get_htlc_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_htlc_basepoint(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_htlc_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_htlc_basepoint');
  late final _AcceptChannel_get_htlc_basepoint =
      _AcceptChannel_get_htlc_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
  void AcceptChannel_set_htlc_basepoint(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_htlc_basepoint(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_htlc_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_htlc_basepoint');
  late final _AcceptChannel_set_htlc_basepoint =
      _AcceptChannel_set_htlc_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// The first to-be-broadcast-by-sender transaction's per commitment point
  LDKPublicKey AcceptChannel_get_first_per_commitment_point(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_first_per_commitment_point(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_first_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_first_per_commitment_point');
  late final _AcceptChannel_get_first_per_commitment_point =
      _AcceptChannel_get_first_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The first to-be-broadcast-by-sender transaction's per commitment point
  void AcceptChannel_set_first_per_commitment_point(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKPublicKey val,
  ) {
    return _AcceptChannel_set_first_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_first_per_commitment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKPublicKey)>>('AcceptChannel_set_first_per_commitment_point');
  late final _AcceptChannel_set_first_per_commitment_point =
      _AcceptChannel_set_first_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKAcceptChannel>, LDKPublicKey)>();

  /// The channel type that this channel will represent. If none is set, we derive the channel
  /// type from the intersection of our feature bits with our counterparty's feature bits from
  /// the Init message.
  ///
  /// This is required to match the equivalent field in [`OpenChannel::channel_type`].
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelTypeFeatures AcceptChannel_get_channel_type(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
  ) {
    return _AcceptChannel_get_channel_type(
      this_ptr,
    );
  }

  late final _AcceptChannel_get_channel_typePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelTypeFeatures Function(ffi.Pointer<LDKAcceptChannel>)>>(
      'AcceptChannel_get_channel_type');
  late final _AcceptChannel_get_channel_type =
      _AcceptChannel_get_channel_typePtr.asFunction<
          LDKChannelTypeFeatures Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// The channel type that this channel will represent. If none is set, we derive the channel
  /// type from the intersection of our feature bits with our counterparty's feature bits from
  /// the Init message.
  ///
  /// This is required to match the equivalent field in [`OpenChannel::channel_type`].
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void AcceptChannel_set_channel_type(
    ffi.Pointer<LDKAcceptChannel> this_ptr,
    LDKChannelTypeFeatures val,
  ) {
    return _AcceptChannel_set_channel_type(
      this_ptr,
      val,
    );
  }

  late final _AcceptChannel_set_channel_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAcceptChannel>,
              LDKChannelTypeFeatures)>>('AcceptChannel_set_channel_type');
  late final _AcceptChannel_set_channel_type =
      _AcceptChannel_set_channel_typePtr.asFunction<
          void Function(
              ffi.Pointer<LDKAcceptChannel>, LDKChannelTypeFeatures)>();

  /// Creates a copy of the AcceptChannel
  LDKAcceptChannel AcceptChannel_clone(
    ffi.Pointer<LDKAcceptChannel> orig,
  ) {
    return _AcceptChannel_clone(
      orig,
    );
  }

  late final _AcceptChannel_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKAcceptChannel Function(
              ffi.Pointer<LDKAcceptChannel>)>>('AcceptChannel_clone');
  late final _AcceptChannel_clone = _AcceptChannel_clonePtr.asFunction<
      LDKAcceptChannel Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
  void FundingCreated_free(
    LDKFundingCreated this_obj,
  ) {
    return _FundingCreated_free(
      this_obj,
    );
  }

  late final _FundingCreated_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFundingCreated)>>(
          'FundingCreated_free');
  late final _FundingCreated_free =
      _FundingCreated_freePtr.asFunction<void Function(LDKFundingCreated)>();

  /// A temporary channel ID, until the funding is established
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> FundingCreated_get_temporary_channel_id(
    ffi.Pointer<LDKFundingCreated> this_ptr,
  ) {
    return _FundingCreated_get_temporary_channel_id(
      this_ptr,
    );
  }

  late final _FundingCreated_get_temporary_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKFundingCreated>)>>(
      'FundingCreated_get_temporary_channel_id');
  late final _FundingCreated_get_temporary_channel_id =
      _FundingCreated_get_temporary_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKFundingCreated>)>();

  /// A temporary channel ID, until the funding is established
  void FundingCreated_set_temporary_channel_id(
    ffi.Pointer<LDKFundingCreated> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _FundingCreated_set_temporary_channel_id(
      this_ptr,
      val,
    );
  }

  late final _FundingCreated_set_temporary_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingCreated>,
              LDKThirtyTwoBytes)>>('FundingCreated_set_temporary_channel_id');
  late final _FundingCreated_set_temporary_channel_id =
      _FundingCreated_set_temporary_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKFundingCreated>, LDKThirtyTwoBytes)>();

  /// The funding transaction ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> FundingCreated_get_funding_txid(
    ffi.Pointer<LDKFundingCreated> this_ptr,
  ) {
    return _FundingCreated_get_funding_txid(
      this_ptr,
    );
  }

  late final _FundingCreated_get_funding_txidPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKFundingCreated>)>>(
      'FundingCreated_get_funding_txid');
  late final _FundingCreated_get_funding_txid =
      _FundingCreated_get_funding_txidPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKFundingCreated>)>();

  /// The funding transaction ID
  void FundingCreated_set_funding_txid(
    ffi.Pointer<LDKFundingCreated> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _FundingCreated_set_funding_txid(
      this_ptr,
      val,
    );
  }

  late final _FundingCreated_set_funding_txidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingCreated>,
              LDKThirtyTwoBytes)>>('FundingCreated_set_funding_txid');
  late final _FundingCreated_set_funding_txid =
      _FundingCreated_set_funding_txidPtr.asFunction<
          void Function(ffi.Pointer<LDKFundingCreated>, LDKThirtyTwoBytes)>();

  /// The specific output index funding this channel
  int FundingCreated_get_funding_output_index(
    ffi.Pointer<LDKFundingCreated> this_ptr,
  ) {
    return _FundingCreated_get_funding_output_index(
      this_ptr,
    );
  }

  late final _FundingCreated_get_funding_output_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKFundingCreated>)>>(
      'FundingCreated_get_funding_output_index');
  late final _FundingCreated_get_funding_output_index =
      _FundingCreated_get_funding_output_indexPtr.asFunction<
          int Function(ffi.Pointer<LDKFundingCreated>)>();

  /// The specific output index funding this channel
  void FundingCreated_set_funding_output_index(
    ffi.Pointer<LDKFundingCreated> this_ptr,
    int val,
  ) {
    return _FundingCreated_set_funding_output_index(
      this_ptr,
      val,
    );
  }

  late final _FundingCreated_set_funding_output_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingCreated>,
              ffi.Uint16)>>('FundingCreated_set_funding_output_index');
  late final _FundingCreated_set_funding_output_index =
      _FundingCreated_set_funding_output_indexPtr.asFunction<
          void Function(ffi.Pointer<LDKFundingCreated>, int)>();

  /// The signature of the channel initiator (funder) on the initial commitment transaction
  LDKSignature FundingCreated_get_signature(
    ffi.Pointer<LDKFundingCreated> this_ptr,
  ) {
    return _FundingCreated_get_signature(
      this_ptr,
    );
  }

  late final _FundingCreated_get_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKFundingCreated>)>>('FundingCreated_get_signature');
  late final _FundingCreated_get_signature = _FundingCreated_get_signaturePtr
      .asFunction<LDKSignature Function(ffi.Pointer<LDKFundingCreated>)>();

  /// The signature of the channel initiator (funder) on the initial commitment transaction
  void FundingCreated_set_signature(
    ffi.Pointer<LDKFundingCreated> this_ptr,
    LDKSignature val,
  ) {
    return _FundingCreated_set_signature(
      this_ptr,
      val,
    );
  }

  late final _FundingCreated_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingCreated>,
              LDKSignature)>>('FundingCreated_set_signature');
  late final _FundingCreated_set_signature =
      _FundingCreated_set_signaturePtr.asFunction<
          void Function(ffi.Pointer<LDKFundingCreated>, LDKSignature)>();

  /// Constructs a new FundingCreated given each field
  LDKFundingCreated FundingCreated_new(
    LDKThirtyTwoBytes temporary_channel_id_arg,
    LDKThirtyTwoBytes funding_txid_arg,
    int funding_output_index_arg,
    LDKSignature signature_arg,
  ) {
    return _FundingCreated_new(
      temporary_channel_id_arg,
      funding_txid_arg,
      funding_output_index_arg,
      signature_arg,
    );
  }

  late final _FundingCreated_newPtr = _lookup<
      ffi.NativeFunction<
          LDKFundingCreated Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              ffi.Uint16, LDKSignature)>>('FundingCreated_new');
  late final _FundingCreated_new = _FundingCreated_newPtr.asFunction<
      LDKFundingCreated Function(
          LDKThirtyTwoBytes, LDKThirtyTwoBytes, int, LDKSignature)>();

  /// Creates a copy of the FundingCreated
  LDKFundingCreated FundingCreated_clone(
    ffi.Pointer<LDKFundingCreated> orig,
  ) {
    return _FundingCreated_clone(
      orig,
    );
  }

  late final _FundingCreated_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKFundingCreated Function(
              ffi.Pointer<LDKFundingCreated>)>>('FundingCreated_clone');
  late final _FundingCreated_clone = _FundingCreated_clonePtr.asFunction<
      LDKFundingCreated Function(ffi.Pointer<LDKFundingCreated>)>();

  /// Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
  void FundingSigned_free(
    LDKFundingSigned this_obj,
  ) {
    return _FundingSigned_free(
      this_obj,
    );
  }

  late final _FundingSigned_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFundingSigned)>>(
          'FundingSigned_free');
  late final _FundingSigned_free =
      _FundingSigned_freePtr.asFunction<void Function(LDKFundingSigned)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> FundingSigned_get_channel_id(
    ffi.Pointer<LDKFundingSigned> this_ptr,
  ) {
    return _FundingSigned_get_channel_id(
      this_ptr,
    );
  }

  late final _FundingSigned_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKFundingSigned>)>>('FundingSigned_get_channel_id');
  late final _FundingSigned_get_channel_id =
      _FundingSigned_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKFundingSigned>)>();

  /// The channel ID
  void FundingSigned_set_channel_id(
    ffi.Pointer<LDKFundingSigned> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _FundingSigned_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _FundingSigned_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingSigned>,
              LDKThirtyTwoBytes)>>('FundingSigned_set_channel_id');
  late final _FundingSigned_set_channel_id =
      _FundingSigned_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKFundingSigned>, LDKThirtyTwoBytes)>();

  /// The signature of the channel acceptor (fundee) on the initial commitment transaction
  LDKSignature FundingSigned_get_signature(
    ffi.Pointer<LDKFundingSigned> this_ptr,
  ) {
    return _FundingSigned_get_signature(
      this_ptr,
    );
  }

  late final _FundingSigned_get_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKFundingSigned>)>>('FundingSigned_get_signature');
  late final _FundingSigned_get_signature = _FundingSigned_get_signaturePtr
      .asFunction<LDKSignature Function(ffi.Pointer<LDKFundingSigned>)>();

  /// The signature of the channel acceptor (fundee) on the initial commitment transaction
  void FundingSigned_set_signature(
    ffi.Pointer<LDKFundingSigned> this_ptr,
    LDKSignature val,
  ) {
    return _FundingSigned_set_signature(
      this_ptr,
      val,
    );
  }

  late final _FundingSigned_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKFundingSigned>,
              LDKSignature)>>('FundingSigned_set_signature');
  late final _FundingSigned_set_signature = _FundingSigned_set_signaturePtr
      .asFunction<void Function(ffi.Pointer<LDKFundingSigned>, LDKSignature)>();

  /// Constructs a new FundingSigned given each field
  LDKFundingSigned FundingSigned_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKSignature signature_arg,
  ) {
    return _FundingSigned_new(
      channel_id_arg,
      signature_arg,
    );
  }

  late final _FundingSigned_newPtr = _lookup<
      ffi.NativeFunction<
          LDKFundingSigned Function(
              LDKThirtyTwoBytes, LDKSignature)>>('FundingSigned_new');
  late final _FundingSigned_new = _FundingSigned_newPtr.asFunction<
      LDKFundingSigned Function(LDKThirtyTwoBytes, LDKSignature)>();

  /// Creates a copy of the FundingSigned
  LDKFundingSigned FundingSigned_clone(
    ffi.Pointer<LDKFundingSigned> orig,
  ) {
    return _FundingSigned_clone(
      orig,
    );
  }

  late final _FundingSigned_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKFundingSigned Function(
              ffi.Pointer<LDKFundingSigned>)>>('FundingSigned_clone');
  late final _FundingSigned_clone = _FundingSigned_clonePtr.asFunction<
      LDKFundingSigned Function(ffi.Pointer<LDKFundingSigned>)>();

  /// Frees any resources used by the ChannelReady, if is_owned is set and inner is non-NULL.
  void ChannelReady_free(
    LDKChannelReady this_obj,
  ) {
    return _ChannelReady_free(
      this_obj,
    );
  }

  late final _ChannelReady_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelReady)>>(
          'ChannelReady_free');
  late final _ChannelReady_free =
      _ChannelReady_freePtr.asFunction<void Function(LDKChannelReady)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ChannelReady_get_channel_id(
    ffi.Pointer<LDKChannelReady> this_ptr,
  ) {
    return _ChannelReady_get_channel_id(
      this_ptr,
    );
  }

  late final _ChannelReady_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKChannelReady>)>>('ChannelReady_get_channel_id');
  late final _ChannelReady_get_channel_id =
      _ChannelReady_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKChannelReady>)>();

  /// The channel ID
  void ChannelReady_set_channel_id(
    ffi.Pointer<LDKChannelReady> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ChannelReady_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelReady_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelReady>,
              LDKThirtyTwoBytes)>>('ChannelReady_set_channel_id');
  late final _ChannelReady_set_channel_id =
      _ChannelReady_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelReady>, LDKThirtyTwoBytes)>();

  /// The per-commitment point of the second commitment transaction
  LDKPublicKey ChannelReady_get_next_per_commitment_point(
    ffi.Pointer<LDKChannelReady> this_ptr,
  ) {
    return _ChannelReady_get_next_per_commitment_point(
      this_ptr,
    );
  }

  late final _ChannelReady_get_next_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelReady>)>>(
      'ChannelReady_get_next_per_commitment_point');
  late final _ChannelReady_get_next_per_commitment_point =
      _ChannelReady_get_next_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelReady>)>();

  /// The per-commitment point of the second commitment transaction
  void ChannelReady_set_next_per_commitment_point(
    ffi.Pointer<LDKChannelReady> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelReady_set_next_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _ChannelReady_set_next_per_commitment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelReady>,
              LDKPublicKey)>>('ChannelReady_set_next_per_commitment_point');
  late final _ChannelReady_set_next_per_commitment_point =
      _ChannelReady_set_next_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelReady>, LDKPublicKey)>();

  /// If set, provides a short_channel_id alias for this channel. The sender will accept payments
  /// to be forwarded over this SCID and forward them to this messages' recipient.
  LDKCOption_u64Z ChannelReady_get_short_channel_id_alias(
    ffi.Pointer<LDKChannelReady> this_ptr,
  ) {
    return _ChannelReady_get_short_channel_id_alias(
      this_ptr,
    );
  }

  late final _ChannelReady_get_short_channel_id_aliasPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKChannelReady>)>>(
      'ChannelReady_get_short_channel_id_alias');
  late final _ChannelReady_get_short_channel_id_alias =
      _ChannelReady_get_short_channel_id_aliasPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKChannelReady>)>();

  /// If set, provides a short_channel_id alias for this channel. The sender will accept payments
  /// to be forwarded over this SCID and forward them to this messages' recipient.
  void ChannelReady_set_short_channel_id_alias(
    ffi.Pointer<LDKChannelReady> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelReady_set_short_channel_id_alias(
      this_ptr,
      val,
    );
  }

  late final _ChannelReady_set_short_channel_id_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelReady>,
              LDKCOption_u64Z)>>('ChannelReady_set_short_channel_id_alias');
  late final _ChannelReady_set_short_channel_id_alias =
      _ChannelReady_set_short_channel_id_aliasPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelReady>, LDKCOption_u64Z)>();

  /// Constructs a new ChannelReady given each field
  LDKChannelReady ChannelReady_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKPublicKey next_per_commitment_point_arg,
    LDKCOption_u64Z short_channel_id_alias_arg,
  ) {
    return _ChannelReady_new(
      channel_id_arg,
      next_per_commitment_point_arg,
      short_channel_id_alias_arg,
    );
  }

  late final _ChannelReady_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelReady Function(LDKThirtyTwoBytes, LDKPublicKey,
              LDKCOption_u64Z)>>('ChannelReady_new');
  late final _ChannelReady_new = _ChannelReady_newPtr.asFunction<
      LDKChannelReady Function(
          LDKThirtyTwoBytes, LDKPublicKey, LDKCOption_u64Z)>();

  /// Creates a copy of the ChannelReady
  LDKChannelReady ChannelReady_clone(
    ffi.Pointer<LDKChannelReady> orig,
  ) {
    return _ChannelReady_clone(
      orig,
    );
  }

  late final _ChannelReady_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelReady Function(
              ffi.Pointer<LDKChannelReady>)>>('ChannelReady_clone');
  late final _ChannelReady_clone = _ChannelReady_clonePtr.asFunction<
      LDKChannelReady Function(ffi.Pointer<LDKChannelReady>)>();

  /// Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
  void Shutdown_free(
    LDKShutdown this_obj,
  ) {
    return _Shutdown_free(
      this_obj,
    );
  }

  late final _Shutdown_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKShutdown)>>(
          'Shutdown_free');
  late final _Shutdown_free =
      _Shutdown_freePtr.asFunction<void Function(LDKShutdown)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> Shutdown_get_channel_id(
    ffi.Pointer<LDKShutdown> this_ptr,
  ) {
    return _Shutdown_get_channel_id(
      this_ptr,
    );
  }

  late final _Shutdown_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKShutdown>)>>('Shutdown_get_channel_id');
  late final _Shutdown_get_channel_id = _Shutdown_get_channel_idPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(ffi.Pointer<LDKShutdown>)>();

  /// The channel ID
  void Shutdown_set_channel_id(
    ffi.Pointer<LDKShutdown> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _Shutdown_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _Shutdown_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKShutdown>,
              LDKThirtyTwoBytes)>>('Shutdown_set_channel_id');
  late final _Shutdown_set_channel_id = _Shutdown_set_channel_idPtr.asFunction<
      void Function(ffi.Pointer<LDKShutdown>, LDKThirtyTwoBytes)>();

  /// The destination of this peer's funds on closing.
  /// Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
  LDKu8slice Shutdown_get_scriptpubkey(
    ffi.Pointer<LDKShutdown> this_ptr,
  ) {
    return _Shutdown_get_scriptpubkey(
      this_ptr,
    );
  }

  late final _Shutdown_get_scriptpubkeyPtr = _lookup<
          ffi.NativeFunction<LDKu8slice Function(ffi.Pointer<LDKShutdown>)>>(
      'Shutdown_get_scriptpubkey');
  late final _Shutdown_get_scriptpubkey = _Shutdown_get_scriptpubkeyPtr
      .asFunction<LDKu8slice Function(ffi.Pointer<LDKShutdown>)>();

  /// The destination of this peer's funds on closing.
  /// Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
  void Shutdown_set_scriptpubkey(
    ffi.Pointer<LDKShutdown> this_ptr,
    LDKCVec_u8Z val,
  ) {
    return _Shutdown_set_scriptpubkey(
      this_ptr,
      val,
    );
  }

  late final _Shutdown_set_scriptpubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKShutdown>,
              LDKCVec_u8Z)>>('Shutdown_set_scriptpubkey');
  late final _Shutdown_set_scriptpubkey = _Shutdown_set_scriptpubkeyPtr
      .asFunction<void Function(ffi.Pointer<LDKShutdown>, LDKCVec_u8Z)>();

  /// Constructs a new Shutdown given each field
  LDKShutdown Shutdown_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKCVec_u8Z scriptpubkey_arg,
  ) {
    return _Shutdown_new(
      channel_id_arg,
      scriptpubkey_arg,
    );
  }

  late final _Shutdown_newPtr = _lookup<
      ffi.NativeFunction<
          LDKShutdown Function(
              LDKThirtyTwoBytes, LDKCVec_u8Z)>>('Shutdown_new');
  late final _Shutdown_new = _Shutdown_newPtr.asFunction<
      LDKShutdown Function(LDKThirtyTwoBytes, LDKCVec_u8Z)>();

  /// Creates a copy of the Shutdown
  LDKShutdown Shutdown_clone(
    ffi.Pointer<LDKShutdown> orig,
  ) {
    return _Shutdown_clone(
      orig,
    );
  }

  late final _Shutdown_clonePtr = _lookup<
          ffi.NativeFunction<LDKShutdown Function(ffi.Pointer<LDKShutdown>)>>(
      'Shutdown_clone');
  late final _Shutdown_clone = _Shutdown_clonePtr.asFunction<
      LDKShutdown Function(ffi.Pointer<LDKShutdown>)>();

  /// Frees any resources used by the ClosingSignedFeeRange, if is_owned is set and inner is non-NULL.
  void ClosingSignedFeeRange_free(
    LDKClosingSignedFeeRange this_obj,
  ) {
    return _ClosingSignedFeeRange_free(
      this_obj,
    );
  }

  late final _ClosingSignedFeeRange_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKClosingSignedFeeRange)>>(
          'ClosingSignedFeeRange_free');
  late final _ClosingSignedFeeRange_free = _ClosingSignedFeeRange_freePtr
      .asFunction<void Function(LDKClosingSignedFeeRange)>();

  /// The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
  /// transaction.
  int ClosingSignedFeeRange_get_min_fee_satoshis(
    ffi.Pointer<LDKClosingSignedFeeRange> this_ptr,
  ) {
    return _ClosingSignedFeeRange_get_min_fee_satoshis(
      this_ptr,
    );
  }

  late final _ClosingSignedFeeRange_get_min_fee_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKClosingSignedFeeRange>)>>(
      'ClosingSignedFeeRange_get_min_fee_satoshis');
  late final _ClosingSignedFeeRange_get_min_fee_satoshis =
      _ClosingSignedFeeRange_get_min_fee_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKClosingSignedFeeRange>)>();

  /// The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
  /// transaction.
  void ClosingSignedFeeRange_set_min_fee_satoshis(
    ffi.Pointer<LDKClosingSignedFeeRange> this_ptr,
    int val,
  ) {
    return _ClosingSignedFeeRange_set_min_fee_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ClosingSignedFeeRange_set_min_fee_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSignedFeeRange>,
              ffi.Uint64)>>('ClosingSignedFeeRange_set_min_fee_satoshis');
  late final _ClosingSignedFeeRange_set_min_fee_satoshis =
      _ClosingSignedFeeRange_set_min_fee_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKClosingSignedFeeRange>, int)>();

  /// The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
  /// transaction.
  int ClosingSignedFeeRange_get_max_fee_satoshis(
    ffi.Pointer<LDKClosingSignedFeeRange> this_ptr,
  ) {
    return _ClosingSignedFeeRange_get_max_fee_satoshis(
      this_ptr,
    );
  }

  late final _ClosingSignedFeeRange_get_max_fee_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKClosingSignedFeeRange>)>>(
      'ClosingSignedFeeRange_get_max_fee_satoshis');
  late final _ClosingSignedFeeRange_get_max_fee_satoshis =
      _ClosingSignedFeeRange_get_max_fee_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKClosingSignedFeeRange>)>();

  /// The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
  /// transaction.
  void ClosingSignedFeeRange_set_max_fee_satoshis(
    ffi.Pointer<LDKClosingSignedFeeRange> this_ptr,
    int val,
  ) {
    return _ClosingSignedFeeRange_set_max_fee_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ClosingSignedFeeRange_set_max_fee_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSignedFeeRange>,
              ffi.Uint64)>>('ClosingSignedFeeRange_set_max_fee_satoshis');
  late final _ClosingSignedFeeRange_set_max_fee_satoshis =
      _ClosingSignedFeeRange_set_max_fee_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKClosingSignedFeeRange>, int)>();

  /// Constructs a new ClosingSignedFeeRange given each field
  LDKClosingSignedFeeRange ClosingSignedFeeRange_new(
    int min_fee_satoshis_arg,
    int max_fee_satoshis_arg,
  ) {
    return _ClosingSignedFeeRange_new(
      min_fee_satoshis_arg,
      max_fee_satoshis_arg,
    );
  }

  late final _ClosingSignedFeeRange_newPtr = _lookup<
      ffi.NativeFunction<
          LDKClosingSignedFeeRange Function(
              ffi.Uint64, ffi.Uint64)>>('ClosingSignedFeeRange_new');
  late final _ClosingSignedFeeRange_new = _ClosingSignedFeeRange_newPtr
      .asFunction<LDKClosingSignedFeeRange Function(int, int)>();

  /// Creates a copy of the ClosingSignedFeeRange
  LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(
    ffi.Pointer<LDKClosingSignedFeeRange> orig,
  ) {
    return _ClosingSignedFeeRange_clone(
      orig,
    );
  }

  late final _ClosingSignedFeeRange_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKClosingSignedFeeRange Function(
                  ffi.Pointer<LDKClosingSignedFeeRange>)>>(
      'ClosingSignedFeeRange_clone');
  late final _ClosingSignedFeeRange_clone =
      _ClosingSignedFeeRange_clonePtr.asFunction<
          LDKClosingSignedFeeRange Function(
              ffi.Pointer<LDKClosingSignedFeeRange>)>();

  /// Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
  void ClosingSigned_free(
    LDKClosingSigned this_obj,
  ) {
    return _ClosingSigned_free(
      this_obj,
    );
  }

  late final _ClosingSigned_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKClosingSigned)>>(
          'ClosingSigned_free');
  late final _ClosingSigned_free =
      _ClosingSigned_freePtr.asFunction<void Function(LDKClosingSigned)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ClosingSigned_get_channel_id(
    ffi.Pointer<LDKClosingSigned> this_ptr,
  ) {
    return _ClosingSigned_get_channel_id(
      this_ptr,
    );
  }

  late final _ClosingSigned_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKClosingSigned>)>>('ClosingSigned_get_channel_id');
  late final _ClosingSigned_get_channel_id =
      _ClosingSigned_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKClosingSigned>)>();

  /// The channel ID
  void ClosingSigned_set_channel_id(
    ffi.Pointer<LDKClosingSigned> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ClosingSigned_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ClosingSigned_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSigned>,
              LDKThirtyTwoBytes)>>('ClosingSigned_set_channel_id');
  late final _ClosingSigned_set_channel_id =
      _ClosingSigned_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKClosingSigned>, LDKThirtyTwoBytes)>();

  /// The proposed total fee for the closing transaction
  int ClosingSigned_get_fee_satoshis(
    ffi.Pointer<LDKClosingSigned> this_ptr,
  ) {
    return _ClosingSigned_get_fee_satoshis(
      this_ptr,
    );
  }

  late final _ClosingSigned_get_fee_satoshisPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKClosingSigned>)>>(
      'ClosingSigned_get_fee_satoshis');
  late final _ClosingSigned_get_fee_satoshis =
      _ClosingSigned_get_fee_satoshisPtr.asFunction<
          int Function(ffi.Pointer<LDKClosingSigned>)>();

  /// The proposed total fee for the closing transaction
  void ClosingSigned_set_fee_satoshis(
    ffi.Pointer<LDKClosingSigned> this_ptr,
    int val,
  ) {
    return _ClosingSigned_set_fee_satoshis(
      this_ptr,
      val,
    );
  }

  late final _ClosingSigned_set_fee_satoshisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSigned>,
              ffi.Uint64)>>('ClosingSigned_set_fee_satoshis');
  late final _ClosingSigned_set_fee_satoshis =
      _ClosingSigned_set_fee_satoshisPtr.asFunction<
          void Function(ffi.Pointer<LDKClosingSigned>, int)>();

  /// A signature on the closing transaction
  LDKSignature ClosingSigned_get_signature(
    ffi.Pointer<LDKClosingSigned> this_ptr,
  ) {
    return _ClosingSigned_get_signature(
      this_ptr,
    );
  }

  late final _ClosingSigned_get_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKClosingSigned>)>>('ClosingSigned_get_signature');
  late final _ClosingSigned_get_signature = _ClosingSigned_get_signaturePtr
      .asFunction<LDKSignature Function(ffi.Pointer<LDKClosingSigned>)>();

  /// A signature on the closing transaction
  void ClosingSigned_set_signature(
    ffi.Pointer<LDKClosingSigned> this_ptr,
    LDKSignature val,
  ) {
    return _ClosingSigned_set_signature(
      this_ptr,
      val,
    );
  }

  late final _ClosingSigned_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSigned>,
              LDKSignature)>>('ClosingSigned_set_signature');
  late final _ClosingSigned_set_signature = _ClosingSigned_set_signaturePtr
      .asFunction<void Function(ffi.Pointer<LDKClosingSigned>, LDKSignature)>();

  /// The minimum and maximum fees which the sender is willing to accept, provided only by new
  /// nodes.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKClosingSignedFeeRange ClosingSigned_get_fee_range(
    ffi.Pointer<LDKClosingSigned> this_ptr,
  ) {
    return _ClosingSigned_get_fee_range(
      this_ptr,
    );
  }

  late final _ClosingSigned_get_fee_rangePtr = _lookup<
      ffi.NativeFunction<
          LDKClosingSignedFeeRange Function(
              ffi.Pointer<LDKClosingSigned>)>>('ClosingSigned_get_fee_range');
  late final _ClosingSigned_get_fee_range =
      _ClosingSigned_get_fee_rangePtr.asFunction<
          LDKClosingSignedFeeRange Function(ffi.Pointer<LDKClosingSigned>)>();

  /// The minimum and maximum fees which the sender is willing to accept, provided only by new
  /// nodes.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ClosingSigned_set_fee_range(
    ffi.Pointer<LDKClosingSigned> this_ptr,
    LDKClosingSignedFeeRange val,
  ) {
    return _ClosingSigned_set_fee_range(
      this_ptr,
      val,
    );
  }

  late final _ClosingSigned_set_fee_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKClosingSigned>,
              LDKClosingSignedFeeRange)>>('ClosingSigned_set_fee_range');
  late final _ClosingSigned_set_fee_range =
      _ClosingSigned_set_fee_rangePtr.asFunction<
          void Function(
              ffi.Pointer<LDKClosingSigned>, LDKClosingSignedFeeRange)>();

  /// Constructs a new ClosingSigned given each field
  LDKClosingSigned ClosingSigned_new(
    LDKThirtyTwoBytes channel_id_arg,
    int fee_satoshis_arg,
    LDKSignature signature_arg,
    LDKClosingSignedFeeRange fee_range_arg,
  ) {
    return _ClosingSigned_new(
      channel_id_arg,
      fee_satoshis_arg,
      signature_arg,
      fee_range_arg,
    );
  }

  late final _ClosingSigned_newPtr = _lookup<
      ffi.NativeFunction<
          LDKClosingSigned Function(LDKThirtyTwoBytes, ffi.Uint64, LDKSignature,
              LDKClosingSignedFeeRange)>>('ClosingSigned_new');
  late final _ClosingSigned_new = _ClosingSigned_newPtr.asFunction<
      LDKClosingSigned Function(
          LDKThirtyTwoBytes, int, LDKSignature, LDKClosingSignedFeeRange)>();

  /// Creates a copy of the ClosingSigned
  LDKClosingSigned ClosingSigned_clone(
    ffi.Pointer<LDKClosingSigned> orig,
  ) {
    return _ClosingSigned_clone(
      orig,
    );
  }

  late final _ClosingSigned_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKClosingSigned Function(
              ffi.Pointer<LDKClosingSigned>)>>('ClosingSigned_clone');
  late final _ClosingSigned_clone = _ClosingSigned_clonePtr.asFunction<
      LDKClosingSigned Function(ffi.Pointer<LDKClosingSigned>)>();

  /// Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
  void UpdateAddHTLC_free(
    LDKUpdateAddHTLC this_obj,
  ) {
    return _UpdateAddHTLC_free(
      this_obj,
    );
  }

  late final _UpdateAddHTLC_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUpdateAddHTLC)>>(
          'UpdateAddHTLC_free');
  late final _UpdateAddHTLC_free =
      _UpdateAddHTLC_freePtr.asFunction<void Function(LDKUpdateAddHTLC)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateAddHTLC_get_channel_id(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
  ) {
    return _UpdateAddHTLC_get_channel_id(
      this_ptr,
    );
  }

  late final _UpdateAddHTLC_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_get_channel_id');
  late final _UpdateAddHTLC_get_channel_id =
      _UpdateAddHTLC_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// The channel ID
  void UpdateAddHTLC_set_channel_id(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateAddHTLC_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateAddHTLC_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateAddHTLC>,
              LDKThirtyTwoBytes)>>('UpdateAddHTLC_set_channel_id');
  late final _UpdateAddHTLC_set_channel_id =
      _UpdateAddHTLC_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateAddHTLC>, LDKThirtyTwoBytes)>();

  /// The HTLC ID
  int UpdateAddHTLC_get_htlc_id(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
  ) {
    return _UpdateAddHTLC_get_htlc_id(
      this_ptr,
    );
  }

  late final _UpdateAddHTLC_get_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_get_htlc_id');
  late final _UpdateAddHTLC_get_htlc_id = _UpdateAddHTLC_get_htlc_idPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// The HTLC ID
  void UpdateAddHTLC_set_htlc_id(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
    int val,
  ) {
    return _UpdateAddHTLC_set_htlc_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateAddHTLC_set_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateAddHTLC>,
              ffi.Uint64)>>('UpdateAddHTLC_set_htlc_id');
  late final _UpdateAddHTLC_set_htlc_id = _UpdateAddHTLC_set_htlc_idPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateAddHTLC>, int)>();

  /// The HTLC value in milli-satoshi
  int UpdateAddHTLC_get_amount_msat(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
  ) {
    return _UpdateAddHTLC_get_amount_msat(
      this_ptr,
    );
  }

  late final _UpdateAddHTLC_get_amount_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_get_amount_msat');
  late final _UpdateAddHTLC_get_amount_msat = _UpdateAddHTLC_get_amount_msatPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// The HTLC value in milli-satoshi
  void UpdateAddHTLC_set_amount_msat(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
    int val,
  ) {
    return _UpdateAddHTLC_set_amount_msat(
      this_ptr,
      val,
    );
  }

  late final _UpdateAddHTLC_set_amount_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateAddHTLC>,
              ffi.Uint64)>>('UpdateAddHTLC_set_amount_msat');
  late final _UpdateAddHTLC_set_amount_msat = _UpdateAddHTLC_set_amount_msatPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateAddHTLC>, int)>();

  /// The payment hash, the pre-image of which controls HTLC redemption
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateAddHTLC_get_payment_hash(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
  ) {
    return _UpdateAddHTLC_get_payment_hash(
      this_ptr,
    );
  }

  late final _UpdateAddHTLC_get_payment_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUpdateAddHTLC>)>>(
      'UpdateAddHTLC_get_payment_hash');
  late final _UpdateAddHTLC_get_payment_hash =
      _UpdateAddHTLC_get_payment_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// The payment hash, the pre-image of which controls HTLC redemption
  void UpdateAddHTLC_set_payment_hash(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateAddHTLC_set_payment_hash(
      this_ptr,
      val,
    );
  }

  late final _UpdateAddHTLC_set_payment_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateAddHTLC>,
              LDKThirtyTwoBytes)>>('UpdateAddHTLC_set_payment_hash');
  late final _UpdateAddHTLC_set_payment_hash =
      _UpdateAddHTLC_set_payment_hashPtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateAddHTLC>, LDKThirtyTwoBytes)>();

  /// The expiry height of the HTLC
  int UpdateAddHTLC_get_cltv_expiry(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
  ) {
    return _UpdateAddHTLC_get_cltv_expiry(
      this_ptr,
    );
  }

  late final _UpdateAddHTLC_get_cltv_expiryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_get_cltv_expiry');
  late final _UpdateAddHTLC_get_cltv_expiry = _UpdateAddHTLC_get_cltv_expiryPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// The expiry height of the HTLC
  void UpdateAddHTLC_set_cltv_expiry(
    ffi.Pointer<LDKUpdateAddHTLC> this_ptr,
    int val,
  ) {
    return _UpdateAddHTLC_set_cltv_expiry(
      this_ptr,
      val,
    );
  }

  late final _UpdateAddHTLC_set_cltv_expiryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateAddHTLC>,
              ffi.Uint32)>>('UpdateAddHTLC_set_cltv_expiry');
  late final _UpdateAddHTLC_set_cltv_expiry = _UpdateAddHTLC_set_cltv_expiryPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateAddHTLC>, int)>();

  /// Creates a copy of the UpdateAddHTLC
  LDKUpdateAddHTLC UpdateAddHTLC_clone(
    ffi.Pointer<LDKUpdateAddHTLC> orig,
  ) {
    return _UpdateAddHTLC_clone(
      orig,
    );
  }

  late final _UpdateAddHTLC_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKUpdateAddHTLC Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_clone');
  late final _UpdateAddHTLC_clone = _UpdateAddHTLC_clonePtr.asFunction<
      LDKUpdateAddHTLC Function(ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
  void UpdateFulfillHTLC_free(
    LDKUpdateFulfillHTLC this_obj,
  ) {
    return _UpdateFulfillHTLC_free(
      this_obj,
    );
  }

  late final _UpdateFulfillHTLC_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUpdateFulfillHTLC)>>(
          'UpdateFulfillHTLC_free');
  late final _UpdateFulfillHTLC_free = _UpdateFulfillHTLC_freePtr.asFunction<
      void Function(LDKUpdateFulfillHTLC)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateFulfillHTLC_get_channel_id(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
  ) {
    return _UpdateFulfillHTLC_get_channel_id(
      this_ptr,
    );
  }

  late final _UpdateFulfillHTLC_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUpdateFulfillHTLC>)>>(
      'UpdateFulfillHTLC_get_channel_id');
  late final _UpdateFulfillHTLC_get_channel_id =
      _UpdateFulfillHTLC_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>)>();

  /// The channel ID
  void UpdateFulfillHTLC_set_channel_id(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateFulfillHTLC_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFulfillHTLC_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFulfillHTLC>,
              LDKThirtyTwoBytes)>>('UpdateFulfillHTLC_set_channel_id');
  late final _UpdateFulfillHTLC_set_channel_id =
      _UpdateFulfillHTLC_set_channel_idPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>, LDKThirtyTwoBytes)>();

  /// The HTLC ID
  int UpdateFulfillHTLC_get_htlc_id(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
  ) {
    return _UpdateFulfillHTLC_get_htlc_id(
      this_ptr,
    );
  }

  late final _UpdateFulfillHTLC_get_htlc_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKUpdateFulfillHTLC>)>>(
      'UpdateFulfillHTLC_get_htlc_id');
  late final _UpdateFulfillHTLC_get_htlc_id = _UpdateFulfillHTLC_get_htlc_idPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateFulfillHTLC>)>();

  /// The HTLC ID
  void UpdateFulfillHTLC_set_htlc_id(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
    int val,
  ) {
    return _UpdateFulfillHTLC_set_htlc_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFulfillHTLC_set_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFulfillHTLC>,
              ffi.Uint64)>>('UpdateFulfillHTLC_set_htlc_id');
  late final _UpdateFulfillHTLC_set_htlc_id = _UpdateFulfillHTLC_set_htlc_idPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateFulfillHTLC>, int)>();

  /// The pre-image of the payment hash, allowing HTLC redemption
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateFulfillHTLC_get_payment_preimage(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
  ) {
    return _UpdateFulfillHTLC_get_payment_preimage(
      this_ptr,
    );
  }

  late final _UpdateFulfillHTLC_get_payment_preimagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUpdateFulfillHTLC>)>>(
      'UpdateFulfillHTLC_get_payment_preimage');
  late final _UpdateFulfillHTLC_get_payment_preimage =
      _UpdateFulfillHTLC_get_payment_preimagePtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>)>();

  /// The pre-image of the payment hash, allowing HTLC redemption
  void UpdateFulfillHTLC_set_payment_preimage(
    ffi.Pointer<LDKUpdateFulfillHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateFulfillHTLC_set_payment_preimage(
      this_ptr,
      val,
    );
  }

  late final _UpdateFulfillHTLC_set_payment_preimagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFulfillHTLC>,
              LDKThirtyTwoBytes)>>('UpdateFulfillHTLC_set_payment_preimage');
  late final _UpdateFulfillHTLC_set_payment_preimage =
      _UpdateFulfillHTLC_set_payment_preimagePtr.asFunction<
          void Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>, LDKThirtyTwoBytes)>();

  /// Constructs a new UpdateFulfillHTLC given each field
  LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(
    LDKThirtyTwoBytes channel_id_arg,
    int htlc_id_arg,
    LDKThirtyTwoBytes payment_preimage_arg,
  ) {
    return _UpdateFulfillHTLC_new(
      channel_id_arg,
      htlc_id_arg,
      payment_preimage_arg,
    );
  }

  late final _UpdateFulfillHTLC_newPtr = _lookup<
      ffi.NativeFunction<
          LDKUpdateFulfillHTLC Function(LDKThirtyTwoBytes, ffi.Uint64,
              LDKThirtyTwoBytes)>>('UpdateFulfillHTLC_new');
  late final _UpdateFulfillHTLC_new = _UpdateFulfillHTLC_newPtr.asFunction<
      LDKUpdateFulfillHTLC Function(
          LDKThirtyTwoBytes, int, LDKThirtyTwoBytes)>();

  /// Creates a copy of the UpdateFulfillHTLC
  LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(
    ffi.Pointer<LDKUpdateFulfillHTLC> orig,
  ) {
    return _UpdateFulfillHTLC_clone(
      orig,
    );
  }

  late final _UpdateFulfillHTLC_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKUpdateFulfillHTLC Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>)>>('UpdateFulfillHTLC_clone');
  late final _UpdateFulfillHTLC_clone = _UpdateFulfillHTLC_clonePtr.asFunction<
      LDKUpdateFulfillHTLC Function(ffi.Pointer<LDKUpdateFulfillHTLC>)>();

  /// Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
  void UpdateFailHTLC_free(
    LDKUpdateFailHTLC this_obj,
  ) {
    return _UpdateFailHTLC_free(
      this_obj,
    );
  }

  late final _UpdateFailHTLC_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUpdateFailHTLC)>>(
          'UpdateFailHTLC_free');
  late final _UpdateFailHTLC_free =
      _UpdateFailHTLC_freePtr.asFunction<void Function(LDKUpdateFailHTLC)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateFailHTLC_get_channel_id(
    ffi.Pointer<LDKUpdateFailHTLC> this_ptr,
  ) {
    return _UpdateFailHTLC_get_channel_id(
      this_ptr,
    );
  }

  late final _UpdateFailHTLC_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUpdateFailHTLC>)>>(
      'UpdateFailHTLC_get_channel_id');
  late final _UpdateFailHTLC_get_channel_id =
      _UpdateFailHTLC_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFailHTLC>)>();

  /// The channel ID
  void UpdateFailHTLC_set_channel_id(
    ffi.Pointer<LDKUpdateFailHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateFailHTLC_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFailHTLC_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFailHTLC>,
              LDKThirtyTwoBytes)>>('UpdateFailHTLC_set_channel_id');
  late final _UpdateFailHTLC_set_channel_id =
      _UpdateFailHTLC_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateFailHTLC>, LDKThirtyTwoBytes)>();

  /// The HTLC ID
  int UpdateFailHTLC_get_htlc_id(
    ffi.Pointer<LDKUpdateFailHTLC> this_ptr,
  ) {
    return _UpdateFailHTLC_get_htlc_id(
      this_ptr,
    );
  }

  late final _UpdateFailHTLC_get_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKUpdateFailHTLC>)>>('UpdateFailHTLC_get_htlc_id');
  late final _UpdateFailHTLC_get_htlc_id = _UpdateFailHTLC_get_htlc_idPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateFailHTLC>)>();

  /// The HTLC ID
  void UpdateFailHTLC_set_htlc_id(
    ffi.Pointer<LDKUpdateFailHTLC> this_ptr,
    int val,
  ) {
    return _UpdateFailHTLC_set_htlc_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFailHTLC_set_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFailHTLC>,
              ffi.Uint64)>>('UpdateFailHTLC_set_htlc_id');
  late final _UpdateFailHTLC_set_htlc_id = _UpdateFailHTLC_set_htlc_idPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateFailHTLC>, int)>();

  /// Creates a copy of the UpdateFailHTLC
  LDKUpdateFailHTLC UpdateFailHTLC_clone(
    ffi.Pointer<LDKUpdateFailHTLC> orig,
  ) {
    return _UpdateFailHTLC_clone(
      orig,
    );
  }

  late final _UpdateFailHTLC_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKUpdateFailHTLC Function(
              ffi.Pointer<LDKUpdateFailHTLC>)>>('UpdateFailHTLC_clone');
  late final _UpdateFailHTLC_clone = _UpdateFailHTLC_clonePtr.asFunction<
      LDKUpdateFailHTLC Function(ffi.Pointer<LDKUpdateFailHTLC>)>();

  /// Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
  void UpdateFailMalformedHTLC_free(
    LDKUpdateFailMalformedHTLC this_obj,
  ) {
    return _UpdateFailMalformedHTLC_free(
      this_obj,
    );
  }

  late final _UpdateFailMalformedHTLC_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKUpdateFailMalformedHTLC)>>(
      'UpdateFailMalformedHTLC_free');
  late final _UpdateFailMalformedHTLC_free = _UpdateFailMalformedHTLC_freePtr
      .asFunction<void Function(LDKUpdateFailMalformedHTLC)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateFailMalformedHTLC_get_channel_id(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
  ) {
    return _UpdateFailMalformedHTLC_get_channel_id(
      this_ptr,
    );
  }

  late final _UpdateFailMalformedHTLC_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>(
      'UpdateFailMalformedHTLC_get_channel_id');
  late final _UpdateFailMalformedHTLC_get_channel_id =
      _UpdateFailMalformedHTLC_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFailMalformedHTLC>)>();

  /// The channel ID
  void UpdateFailMalformedHTLC_set_channel_id(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateFailMalformedHTLC_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFailMalformedHTLC_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>,
              LDKThirtyTwoBytes)>>('UpdateFailMalformedHTLC_set_channel_id');
  late final _UpdateFailMalformedHTLC_set_channel_id =
      _UpdateFailMalformedHTLC_set_channel_idPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUpdateFailMalformedHTLC>, LDKThirtyTwoBytes)>();

  /// The HTLC ID
  int UpdateFailMalformedHTLC_get_htlc_id(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
  ) {
    return _UpdateFailMalformedHTLC_get_htlc_id(
      this_ptr,
    );
  }

  late final _UpdateFailMalformedHTLC_get_htlc_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>(
      'UpdateFailMalformedHTLC_get_htlc_id');
  late final _UpdateFailMalformedHTLC_get_htlc_id =
      _UpdateFailMalformedHTLC_get_htlc_idPtr.asFunction<
          int Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>();

  /// The HTLC ID
  void UpdateFailMalformedHTLC_set_htlc_id(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
    int val,
  ) {
    return _UpdateFailMalformedHTLC_set_htlc_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFailMalformedHTLC_set_htlc_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>,
              ffi.Uint64)>>('UpdateFailMalformedHTLC_set_htlc_id');
  late final _UpdateFailMalformedHTLC_set_htlc_id =
      _UpdateFailMalformedHTLC_set_htlc_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>, int)>();

  /// The failure code
  int UpdateFailMalformedHTLC_get_failure_code(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
  ) {
    return _UpdateFailMalformedHTLC_get_failure_code(
      this_ptr,
    );
  }

  late final _UpdateFailMalformedHTLC_get_failure_codePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>(
      'UpdateFailMalformedHTLC_get_failure_code');
  late final _UpdateFailMalformedHTLC_get_failure_code =
      _UpdateFailMalformedHTLC_get_failure_codePtr.asFunction<
          int Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>();

  /// The failure code
  void UpdateFailMalformedHTLC_set_failure_code(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> this_ptr,
    int val,
  ) {
    return _UpdateFailMalformedHTLC_set_failure_code(
      this_ptr,
      val,
    );
  }

  late final _UpdateFailMalformedHTLC_set_failure_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>,
              ffi.Uint16)>>('UpdateFailMalformedHTLC_set_failure_code');
  late final _UpdateFailMalformedHTLC_set_failure_code =
      _UpdateFailMalformedHTLC_set_failure_codePtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>, int)>();

  /// Creates a copy of the UpdateFailMalformedHTLC
  LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> orig,
  ) {
    return _UpdateFailMalformedHTLC_clone(
      orig,
    );
  }

  late final _UpdateFailMalformedHTLC_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKUpdateFailMalformedHTLC Function(
                  ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>(
      'UpdateFailMalformedHTLC_clone');
  late final _UpdateFailMalformedHTLC_clone =
      _UpdateFailMalformedHTLC_clonePtr.asFunction<
          LDKUpdateFailMalformedHTLC Function(
              ffi.Pointer<LDKUpdateFailMalformedHTLC>)>();

  /// Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
  void CommitmentSigned_free(
    LDKCommitmentSigned this_obj,
  ) {
    return _CommitmentSigned_free(
      this_obj,
    );
  }

  late final _CommitmentSigned_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCommitmentSigned)>>(
          'CommitmentSigned_free');
  late final _CommitmentSigned_free = _CommitmentSigned_freePtr.asFunction<
      void Function(LDKCommitmentSigned)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> CommitmentSigned_get_channel_id(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
  ) {
    return _CommitmentSigned_get_channel_id(
      this_ptr,
    );
  }

  late final _CommitmentSigned_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKCommitmentSigned>)>>(
      'CommitmentSigned_get_channel_id');
  late final _CommitmentSigned_get_channel_id =
      _CommitmentSigned_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKCommitmentSigned>)>();

  /// The channel ID
  void CommitmentSigned_set_channel_id(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _CommitmentSigned_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _CommitmentSigned_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCommitmentSigned>,
              LDKThirtyTwoBytes)>>('CommitmentSigned_set_channel_id');
  late final _CommitmentSigned_set_channel_id =
      _CommitmentSigned_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKCommitmentSigned>, LDKThirtyTwoBytes)>();

  /// A signature on the commitment transaction
  LDKSignature CommitmentSigned_get_signature(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
  ) {
    return _CommitmentSigned_get_signature(
      this_ptr,
    );
  }

  late final _CommitmentSigned_get_signaturePtr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKCommitmentSigned>)>>(
      'CommitmentSigned_get_signature');
  late final _CommitmentSigned_get_signature =
      _CommitmentSigned_get_signaturePtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKCommitmentSigned>)>();

  /// A signature on the commitment transaction
  void CommitmentSigned_set_signature(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
    LDKSignature val,
  ) {
    return _CommitmentSigned_set_signature(
      this_ptr,
      val,
    );
  }

  late final _CommitmentSigned_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCommitmentSigned>,
              LDKSignature)>>('CommitmentSigned_set_signature');
  late final _CommitmentSigned_set_signature =
      _CommitmentSigned_set_signaturePtr.asFunction<
          void Function(ffi.Pointer<LDKCommitmentSigned>, LDKSignature)>();

  /// Signatures on the HTLC transactions
  ///
  /// Returns a copy of the field.
  LDKCVec_SignatureZ CommitmentSigned_get_htlc_signatures(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
  ) {
    return _CommitmentSigned_get_htlc_signatures(
      this_ptr,
    );
  }

  late final _CommitmentSigned_get_htlc_signaturesPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_SignatureZ Function(ffi.Pointer<LDKCommitmentSigned>)>>(
      'CommitmentSigned_get_htlc_signatures');
  late final _CommitmentSigned_get_htlc_signatures =
      _CommitmentSigned_get_htlc_signaturesPtr.asFunction<
          LDKCVec_SignatureZ Function(ffi.Pointer<LDKCommitmentSigned>)>();

  /// Signatures on the HTLC transactions
  void CommitmentSigned_set_htlc_signatures(
    ffi.Pointer<LDKCommitmentSigned> this_ptr,
    LDKCVec_SignatureZ val,
  ) {
    return _CommitmentSigned_set_htlc_signatures(
      this_ptr,
      val,
    );
  }

  late final _CommitmentSigned_set_htlc_signaturesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCommitmentSigned>,
              LDKCVec_SignatureZ)>>('CommitmentSigned_set_htlc_signatures');
  late final _CommitmentSigned_set_htlc_signatures =
      _CommitmentSigned_set_htlc_signaturesPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCommitmentSigned>, LDKCVec_SignatureZ)>();

  /// Constructs a new CommitmentSigned given each field
  LDKCommitmentSigned CommitmentSigned_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKSignature signature_arg,
    LDKCVec_SignatureZ htlc_signatures_arg,
  ) {
    return _CommitmentSigned_new(
      channel_id_arg,
      signature_arg,
      htlc_signatures_arg,
    );
  }

  late final _CommitmentSigned_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCommitmentSigned Function(LDKThirtyTwoBytes, LDKSignature,
              LDKCVec_SignatureZ)>>('CommitmentSigned_new');
  late final _CommitmentSigned_new = _CommitmentSigned_newPtr.asFunction<
      LDKCommitmentSigned Function(
          LDKThirtyTwoBytes, LDKSignature, LDKCVec_SignatureZ)>();

  /// Creates a copy of the CommitmentSigned
  LDKCommitmentSigned CommitmentSigned_clone(
    ffi.Pointer<LDKCommitmentSigned> orig,
  ) {
    return _CommitmentSigned_clone(
      orig,
    );
  }

  late final _CommitmentSigned_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCommitmentSigned Function(
              ffi.Pointer<LDKCommitmentSigned>)>>('CommitmentSigned_clone');
  late final _CommitmentSigned_clone = _CommitmentSigned_clonePtr.asFunction<
      LDKCommitmentSigned Function(ffi.Pointer<LDKCommitmentSigned>)>();

  /// Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
  void RevokeAndACK_free(
    LDKRevokeAndACK this_obj,
  ) {
    return _RevokeAndACK_free(
      this_obj,
    );
  }

  late final _RevokeAndACK_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRevokeAndACK)>>(
          'RevokeAndACK_free');
  late final _RevokeAndACK_free =
      _RevokeAndACK_freePtr.asFunction<void Function(LDKRevokeAndACK)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> RevokeAndACK_get_channel_id(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
  ) {
    return _RevokeAndACK_get_channel_id(
      this_ptr,
    );
  }

  late final _RevokeAndACK_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKRevokeAndACK>)>>('RevokeAndACK_get_channel_id');
  late final _RevokeAndACK_get_channel_id =
      _RevokeAndACK_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKRevokeAndACK>)>();

  /// The channel ID
  void RevokeAndACK_set_channel_id(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _RevokeAndACK_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _RevokeAndACK_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRevokeAndACK>,
              LDKThirtyTwoBytes)>>('RevokeAndACK_set_channel_id');
  late final _RevokeAndACK_set_channel_id =
      _RevokeAndACK_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKRevokeAndACK>, LDKThirtyTwoBytes)>();

  /// The secret corresponding to the per-commitment point
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> RevokeAndACK_get_per_commitment_secret(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
  ) {
    return _RevokeAndACK_get_per_commitment_secret(
      this_ptr,
    );
  }

  late final _RevokeAndACK_get_per_commitment_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKRevokeAndACK>)>>(
      'RevokeAndACK_get_per_commitment_secret');
  late final _RevokeAndACK_get_per_commitment_secret =
      _RevokeAndACK_get_per_commitment_secretPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKRevokeAndACK>)>();

  /// The secret corresponding to the per-commitment point
  void RevokeAndACK_set_per_commitment_secret(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _RevokeAndACK_set_per_commitment_secret(
      this_ptr,
      val,
    );
  }

  late final _RevokeAndACK_set_per_commitment_secretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRevokeAndACK>,
              LDKThirtyTwoBytes)>>('RevokeAndACK_set_per_commitment_secret');
  late final _RevokeAndACK_set_per_commitment_secret =
      _RevokeAndACK_set_per_commitment_secretPtr.asFunction<
          void Function(ffi.Pointer<LDKRevokeAndACK>, LDKThirtyTwoBytes)>();

  /// The next sender-broadcast commitment transaction's per-commitment point
  LDKPublicKey RevokeAndACK_get_next_per_commitment_point(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
  ) {
    return _RevokeAndACK_get_next_per_commitment_point(
      this_ptr,
    );
  }

  late final _RevokeAndACK_get_next_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKRevokeAndACK>)>>(
      'RevokeAndACK_get_next_per_commitment_point');
  late final _RevokeAndACK_get_next_per_commitment_point =
      _RevokeAndACK_get_next_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKRevokeAndACK>)>();

  /// The next sender-broadcast commitment transaction's per-commitment point
  void RevokeAndACK_set_next_per_commitment_point(
    ffi.Pointer<LDKRevokeAndACK> this_ptr,
    LDKPublicKey val,
  ) {
    return _RevokeAndACK_set_next_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _RevokeAndACK_set_next_per_commitment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRevokeAndACK>,
              LDKPublicKey)>>('RevokeAndACK_set_next_per_commitment_point');
  late final _RevokeAndACK_set_next_per_commitment_point =
      _RevokeAndACK_set_next_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKRevokeAndACK>, LDKPublicKey)>();

  /// Constructs a new RevokeAndACK given each field
  LDKRevokeAndACK RevokeAndACK_new(
    LDKThirtyTwoBytes channel_id_arg,
    LDKThirtyTwoBytes per_commitment_secret_arg,
    LDKPublicKey next_per_commitment_point_arg,
  ) {
    return _RevokeAndACK_new(
      channel_id_arg,
      per_commitment_secret_arg,
      next_per_commitment_point_arg,
    );
  }

  late final _RevokeAndACK_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRevokeAndACK Function(LDKThirtyTwoBytes, LDKThirtyTwoBytes,
              LDKPublicKey)>>('RevokeAndACK_new');
  late final _RevokeAndACK_new = _RevokeAndACK_newPtr.asFunction<
      LDKRevokeAndACK Function(
          LDKThirtyTwoBytes, LDKThirtyTwoBytes, LDKPublicKey)>();

  /// Creates a copy of the RevokeAndACK
  LDKRevokeAndACK RevokeAndACK_clone(
    ffi.Pointer<LDKRevokeAndACK> orig,
  ) {
    return _RevokeAndACK_clone(
      orig,
    );
  }

  late final _RevokeAndACK_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRevokeAndACK Function(
              ffi.Pointer<LDKRevokeAndACK>)>>('RevokeAndACK_clone');
  late final _RevokeAndACK_clone = _RevokeAndACK_clonePtr.asFunction<
      LDKRevokeAndACK Function(ffi.Pointer<LDKRevokeAndACK>)>();

  /// Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
  void UpdateFee_free(
    LDKUpdateFee this_obj,
  ) {
    return _UpdateFee_free(
      this_obj,
    );
  }

  late final _UpdateFee_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUpdateFee)>>(
          'UpdateFee_free');
  late final _UpdateFee_free =
      _UpdateFee_freePtr.asFunction<void Function(LDKUpdateFee)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UpdateFee_get_channel_id(
    ffi.Pointer<LDKUpdateFee> this_ptr,
  ) {
    return _UpdateFee_get_channel_id(
      this_ptr,
    );
  }

  late final _UpdateFee_get_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFee>)>>('UpdateFee_get_channel_id');
  late final _UpdateFee_get_channel_id =
      _UpdateFee_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUpdateFee>)>();

  /// The channel ID
  void UpdateFee_set_channel_id(
    ffi.Pointer<LDKUpdateFee> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UpdateFee_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UpdateFee_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFee>,
              LDKThirtyTwoBytes)>>('UpdateFee_set_channel_id');
  late final _UpdateFee_set_channel_id =
      _UpdateFee_set_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUpdateFee>, LDKThirtyTwoBytes)>();

  /// Fee rate per 1000-weight of the transaction
  int UpdateFee_get_feerate_per_kw(
    ffi.Pointer<LDKUpdateFee> this_ptr,
  ) {
    return _UpdateFee_get_feerate_per_kw(
      this_ptr,
    );
  }

  late final _UpdateFee_get_feerate_per_kwPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKUpdateFee>)>>(
      'UpdateFee_get_feerate_per_kw');
  late final _UpdateFee_get_feerate_per_kw = _UpdateFee_get_feerate_per_kwPtr
      .asFunction<int Function(ffi.Pointer<LDKUpdateFee>)>();

  /// Fee rate per 1000-weight of the transaction
  void UpdateFee_set_feerate_per_kw(
    ffi.Pointer<LDKUpdateFee> this_ptr,
    int val,
  ) {
    return _UpdateFee_set_feerate_per_kw(
      this_ptr,
      val,
    );
  }

  late final _UpdateFee_set_feerate_per_kwPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUpdateFee>,
              ffi.Uint32)>>('UpdateFee_set_feerate_per_kw');
  late final _UpdateFee_set_feerate_per_kw = _UpdateFee_set_feerate_per_kwPtr
      .asFunction<void Function(ffi.Pointer<LDKUpdateFee>, int)>();

  /// Constructs a new UpdateFee given each field
  LDKUpdateFee UpdateFee_new(
    LDKThirtyTwoBytes channel_id_arg,
    int feerate_per_kw_arg,
  ) {
    return _UpdateFee_new(
      channel_id_arg,
      feerate_per_kw_arg,
    );
  }

  late final _UpdateFee_newPtr = _lookup<
      ffi.NativeFunction<
          LDKUpdateFee Function(
              LDKThirtyTwoBytes, ffi.Uint32)>>('UpdateFee_new');
  late final _UpdateFee_new = _UpdateFee_newPtr.asFunction<
      LDKUpdateFee Function(LDKThirtyTwoBytes, int)>();

  /// Creates a copy of the UpdateFee
  LDKUpdateFee UpdateFee_clone(
    ffi.Pointer<LDKUpdateFee> orig,
  ) {
    return _UpdateFee_clone(
      orig,
    );
  }

  late final _UpdateFee_clonePtr = _lookup<
          ffi.NativeFunction<LDKUpdateFee Function(ffi.Pointer<LDKUpdateFee>)>>(
      'UpdateFee_clone');
  late final _UpdateFee_clone = _UpdateFee_clonePtr.asFunction<
      LDKUpdateFee Function(ffi.Pointer<LDKUpdateFee>)>();

  /// Frees any resources used by the DataLossProtect, if is_owned is set and inner is non-NULL.
  void DataLossProtect_free(
    LDKDataLossProtect this_obj,
  ) {
    return _DataLossProtect_free(
      this_obj,
    );
  }

  late final _DataLossProtect_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKDataLossProtect)>>(
          'DataLossProtect_free');
  late final _DataLossProtect_free =
      _DataLossProtect_freePtr.asFunction<void Function(LDKDataLossProtect)>();

  /// Proof that the sender knows the per-commitment secret of a specific commitment transaction
  /// belonging to the recipient
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>
      DataLossProtect_get_your_last_per_commitment_secret(
    ffi.Pointer<LDKDataLossProtect> this_ptr,
  ) {
    return _DataLossProtect_get_your_last_per_commitment_secret(
      this_ptr,
    );
  }

  late final _DataLossProtect_get_your_last_per_commitment_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKDataLossProtect>)>>(
      'DataLossProtect_get_your_last_per_commitment_secret');
  late final _DataLossProtect_get_your_last_per_commitment_secret =
      _DataLossProtect_get_your_last_per_commitment_secretPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKDataLossProtect>)>();

  /// Proof that the sender knows the per-commitment secret of a specific commitment transaction
  /// belonging to the recipient
  void DataLossProtect_set_your_last_per_commitment_secret(
    ffi.Pointer<LDKDataLossProtect> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _DataLossProtect_set_your_last_per_commitment_secret(
      this_ptr,
      val,
    );
  }

  late final _DataLossProtect_set_your_last_per_commitment_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKDataLossProtect>, LDKThirtyTwoBytes)>>(
      'DataLossProtect_set_your_last_per_commitment_secret');
  late final _DataLossProtect_set_your_last_per_commitment_secret =
      _DataLossProtect_set_your_last_per_commitment_secretPtr.asFunction<
          void Function(ffi.Pointer<LDKDataLossProtect>, LDKThirtyTwoBytes)>();

  /// The sender's per-commitment point for their current commitment transaction
  LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(
    ffi.Pointer<LDKDataLossProtect> this_ptr,
  ) {
    return _DataLossProtect_get_my_current_per_commitment_point(
      this_ptr,
    );
  }

  late final _DataLossProtect_get_my_current_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKDataLossProtect>)>>(
      'DataLossProtect_get_my_current_per_commitment_point');
  late final _DataLossProtect_get_my_current_per_commitment_point =
      _DataLossProtect_get_my_current_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKDataLossProtect>)>();

  /// The sender's per-commitment point for their current commitment transaction
  void DataLossProtect_set_my_current_per_commitment_point(
    ffi.Pointer<LDKDataLossProtect> this_ptr,
    LDKPublicKey val,
  ) {
    return _DataLossProtect_set_my_current_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _DataLossProtect_set_my_current_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKDataLossProtect>, LDKPublicKey)>>(
      'DataLossProtect_set_my_current_per_commitment_point');
  late final _DataLossProtect_set_my_current_per_commitment_point =
      _DataLossProtect_set_my_current_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKDataLossProtect>, LDKPublicKey)>();

  /// Constructs a new DataLossProtect given each field
  LDKDataLossProtect DataLossProtect_new(
    LDKThirtyTwoBytes your_last_per_commitment_secret_arg,
    LDKPublicKey my_current_per_commitment_point_arg,
  ) {
    return _DataLossProtect_new(
      your_last_per_commitment_secret_arg,
      my_current_per_commitment_point_arg,
    );
  }

  late final _DataLossProtect_newPtr = _lookup<
      ffi.NativeFunction<
          LDKDataLossProtect Function(
              LDKThirtyTwoBytes, LDKPublicKey)>>('DataLossProtect_new');
  late final _DataLossProtect_new = _DataLossProtect_newPtr.asFunction<
      LDKDataLossProtect Function(LDKThirtyTwoBytes, LDKPublicKey)>();

  /// Creates a copy of the DataLossProtect
  LDKDataLossProtect DataLossProtect_clone(
    ffi.Pointer<LDKDataLossProtect> orig,
  ) {
    return _DataLossProtect_clone(
      orig,
    );
  }

  late final _DataLossProtect_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKDataLossProtect Function(
              ffi.Pointer<LDKDataLossProtect>)>>('DataLossProtect_clone');
  late final _DataLossProtect_clone = _DataLossProtect_clonePtr.asFunction<
      LDKDataLossProtect Function(ffi.Pointer<LDKDataLossProtect>)>();

  /// Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
  void ChannelReestablish_free(
    LDKChannelReestablish this_obj,
  ) {
    return _ChannelReestablish_free(
      this_obj,
    );
  }

  late final _ChannelReestablish_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelReestablish)>>(
          'ChannelReestablish_free');
  late final _ChannelReestablish_free = _ChannelReestablish_freePtr.asFunction<
      void Function(LDKChannelReestablish)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ChannelReestablish_get_channel_id(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
  ) {
    return _ChannelReestablish_get_channel_id(
      this_ptr,
    );
  }

  late final _ChannelReestablish_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKChannelReestablish>)>>(
      'ChannelReestablish_get_channel_id');
  late final _ChannelReestablish_get_channel_id =
      _ChannelReestablish_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKChannelReestablish>)>();

  /// The channel ID
  void ChannelReestablish_set_channel_id(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ChannelReestablish_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _ChannelReestablish_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelReestablish>,
              LDKThirtyTwoBytes)>>('ChannelReestablish_set_channel_id');
  late final _ChannelReestablish_set_channel_id =
      _ChannelReestablish_set_channel_idPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelReestablish>, LDKThirtyTwoBytes)>();

  /// The next commitment number for the sender
  int ChannelReestablish_get_next_local_commitment_number(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
  ) {
    return _ChannelReestablish_get_next_local_commitment_number(
      this_ptr,
    );
  }

  late final _ChannelReestablish_get_next_local_commitment_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelReestablish>)>>(
      'ChannelReestablish_get_next_local_commitment_number');
  late final _ChannelReestablish_get_next_local_commitment_number =
      _ChannelReestablish_get_next_local_commitment_numberPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelReestablish>)>();

  /// The next commitment number for the sender
  void ChannelReestablish_set_next_local_commitment_number(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
    int val,
  ) {
    return _ChannelReestablish_set_next_local_commitment_number(
      this_ptr,
      val,
    );
  }

  late final _ChannelReestablish_set_next_local_commitment_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelReestablish>, ffi.Uint64)>>(
      'ChannelReestablish_set_next_local_commitment_number');
  late final _ChannelReestablish_set_next_local_commitment_number =
      _ChannelReestablish_set_next_local_commitment_numberPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelReestablish>, int)>();

  /// The next commitment number for the recipient
  int ChannelReestablish_get_next_remote_commitment_number(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
  ) {
    return _ChannelReestablish_get_next_remote_commitment_number(
      this_ptr,
    );
  }

  late final _ChannelReestablish_get_next_remote_commitment_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelReestablish>)>>(
      'ChannelReestablish_get_next_remote_commitment_number');
  late final _ChannelReestablish_get_next_remote_commitment_number =
      _ChannelReestablish_get_next_remote_commitment_numberPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelReestablish>)>();

  /// The next commitment number for the recipient
  void ChannelReestablish_set_next_remote_commitment_number(
    ffi.Pointer<LDKChannelReestablish> this_ptr,
    int val,
  ) {
    return _ChannelReestablish_set_next_remote_commitment_number(
      this_ptr,
      val,
    );
  }

  late final _ChannelReestablish_set_next_remote_commitment_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelReestablish>, ffi.Uint64)>>(
      'ChannelReestablish_set_next_remote_commitment_number');
  late final _ChannelReestablish_set_next_remote_commitment_number =
      _ChannelReestablish_set_next_remote_commitment_numberPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelReestablish>, int)>();

  /// Creates a copy of the ChannelReestablish
  LDKChannelReestablish ChannelReestablish_clone(
    ffi.Pointer<LDKChannelReestablish> orig,
  ) {
    return _ChannelReestablish_clone(
      orig,
    );
  }

  late final _ChannelReestablish_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelReestablish Function(
              ffi.Pointer<LDKChannelReestablish>)>>('ChannelReestablish_clone');
  late final _ChannelReestablish_clone =
      _ChannelReestablish_clonePtr.asFunction<
          LDKChannelReestablish Function(ffi.Pointer<LDKChannelReestablish>)>();

  /// Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
  void AnnouncementSignatures_free(
    LDKAnnouncementSignatures this_obj,
  ) {
    return _AnnouncementSignatures_free(
      this_obj,
    );
  }

  late final _AnnouncementSignatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKAnnouncementSignatures)>>(
          'AnnouncementSignatures_free');
  late final _AnnouncementSignatures_free = _AnnouncementSignatures_freePtr
      .asFunction<void Function(LDKAnnouncementSignatures)>();

  /// The channel ID
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> AnnouncementSignatures_get_channel_id(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
  ) {
    return _AnnouncementSignatures_get_channel_id(
      this_ptr,
    );
  }

  late final _AnnouncementSignatures_get_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_get_channel_id');
  late final _AnnouncementSignatures_get_channel_id =
      _AnnouncementSignatures_get_channel_idPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// The channel ID
  void AnnouncementSignatures_set_channel_id(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _AnnouncementSignatures_set_channel_id(
      this_ptr,
      val,
    );
  }

  late final _AnnouncementSignatures_set_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAnnouncementSignatures>,
              LDKThirtyTwoBytes)>>('AnnouncementSignatures_set_channel_id');
  late final _AnnouncementSignatures_set_channel_id =
      _AnnouncementSignatures_set_channel_idPtr.asFunction<
          void Function(
              ffi.Pointer<LDKAnnouncementSignatures>, LDKThirtyTwoBytes)>();

  /// The short channel ID
  int AnnouncementSignatures_get_short_channel_id(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
  ) {
    return _AnnouncementSignatures_get_short_channel_id(
      this_ptr,
    );
  }

  late final _AnnouncementSignatures_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_get_short_channel_id');
  late final _AnnouncementSignatures_get_short_channel_id =
      _AnnouncementSignatures_get_short_channel_idPtr.asFunction<
          int Function(ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// The short channel ID
  void AnnouncementSignatures_set_short_channel_id(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
    int val,
  ) {
    return _AnnouncementSignatures_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _AnnouncementSignatures_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAnnouncementSignatures>,
              ffi.Uint64)>>('AnnouncementSignatures_set_short_channel_id');
  late final _AnnouncementSignatures_set_short_channel_id =
      _AnnouncementSignatures_set_short_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKAnnouncementSignatures>, int)>();

  /// A signature by the node key
  LDKSignature AnnouncementSignatures_get_node_signature(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
  ) {
    return _AnnouncementSignatures_get_node_signature(
      this_ptr,
    );
  }

  late final _AnnouncementSignatures_get_node_signaturePtr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_get_node_signature');
  late final _AnnouncementSignatures_get_node_signature =
      _AnnouncementSignatures_get_node_signaturePtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// A signature by the node key
  void AnnouncementSignatures_set_node_signature(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
    LDKSignature val,
  ) {
    return _AnnouncementSignatures_set_node_signature(
      this_ptr,
      val,
    );
  }

  late final _AnnouncementSignatures_set_node_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAnnouncementSignatures>,
              LDKSignature)>>('AnnouncementSignatures_set_node_signature');
  late final _AnnouncementSignatures_set_node_signature =
      _AnnouncementSignatures_set_node_signaturePtr.asFunction<
          void Function(
              ffi.Pointer<LDKAnnouncementSignatures>, LDKSignature)>();

  /// A signature by the funding key
  LDKSignature AnnouncementSignatures_get_bitcoin_signature(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
  ) {
    return _AnnouncementSignatures_get_bitcoin_signature(
      this_ptr,
    );
  }

  late final _AnnouncementSignatures_get_bitcoin_signaturePtr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_get_bitcoin_signature');
  late final _AnnouncementSignatures_get_bitcoin_signature =
      _AnnouncementSignatures_get_bitcoin_signaturePtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// A signature by the funding key
  void AnnouncementSignatures_set_bitcoin_signature(
    ffi.Pointer<LDKAnnouncementSignatures> this_ptr,
    LDKSignature val,
  ) {
    return _AnnouncementSignatures_set_bitcoin_signature(
      this_ptr,
      val,
    );
  }

  late final _AnnouncementSignatures_set_bitcoin_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKAnnouncementSignatures>,
              LDKSignature)>>('AnnouncementSignatures_set_bitcoin_signature');
  late final _AnnouncementSignatures_set_bitcoin_signature =
      _AnnouncementSignatures_set_bitcoin_signaturePtr.asFunction<
          void Function(
              ffi.Pointer<LDKAnnouncementSignatures>, LDKSignature)>();

  /// Constructs a new AnnouncementSignatures given each field
  LDKAnnouncementSignatures AnnouncementSignatures_new(
    LDKThirtyTwoBytes channel_id_arg,
    int short_channel_id_arg,
    LDKSignature node_signature_arg,
    LDKSignature bitcoin_signature_arg,
  ) {
    return _AnnouncementSignatures_new(
      channel_id_arg,
      short_channel_id_arg,
      node_signature_arg,
      bitcoin_signature_arg,
    );
  }

  late final _AnnouncementSignatures_newPtr = _lookup<
      ffi.NativeFunction<
          LDKAnnouncementSignatures Function(LDKThirtyTwoBytes, ffi.Uint64,
              LDKSignature, LDKSignature)>>('AnnouncementSignatures_new');
  late final _AnnouncementSignatures_new =
      _AnnouncementSignatures_newPtr.asFunction<
          LDKAnnouncementSignatures Function(
              LDKThirtyTwoBytes, int, LDKSignature, LDKSignature)>();

  /// Creates a copy of the AnnouncementSignatures
  LDKAnnouncementSignatures AnnouncementSignatures_clone(
    ffi.Pointer<LDKAnnouncementSignatures> orig,
  ) {
    return _AnnouncementSignatures_clone(
      orig,
    );
  }

  late final _AnnouncementSignatures_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKAnnouncementSignatures Function(
                  ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_clone');
  late final _AnnouncementSignatures_clone =
      _AnnouncementSignatures_clonePtr.asFunction<
          LDKAnnouncementSignatures Function(
              ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// Frees any resources used by the NetAddress
  void NetAddress_free(
    LDKNetAddress this_ptr,
  ) {
    return _NetAddress_free(
      this_ptr,
    );
  }

  late final _NetAddress_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNetAddress)>>(
          'NetAddress_free');
  late final _NetAddress_free =
      _NetAddress_freePtr.asFunction<void Function(LDKNetAddress)>();

  /// Creates a copy of the NetAddress
  LDKNetAddress NetAddress_clone(
    ffi.Pointer<LDKNetAddress> orig,
  ) {
    return _NetAddress_clone(
      orig,
    );
  }

  late final _NetAddress_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKNetAddress Function(
              ffi.Pointer<LDKNetAddress>)>>('NetAddress_clone');
  late final _NetAddress_clone = _NetAddress_clonePtr.asFunction<
      LDKNetAddress Function(ffi.Pointer<LDKNetAddress>)>();

  /// Utility method to constructs a new IPv4-variant NetAddress
  LDKNetAddress NetAddress_ipv4(
    LDKFourBytes addr,
    int port,
  ) {
    return _NetAddress_ipv4(
      addr,
      port,
    );
  }

  late final _NetAddress_ipv4Ptr = _lookup<
          ffi.NativeFunction<LDKNetAddress Function(LDKFourBytes, ffi.Uint16)>>(
      'NetAddress_ipv4');
  late final _NetAddress_ipv4 = _NetAddress_ipv4Ptr.asFunction<
      LDKNetAddress Function(LDKFourBytes, int)>();

  /// Utility method to constructs a new IPv6-variant NetAddress
  LDKNetAddress NetAddress_ipv6(
    LDKSixteenBytes addr,
    int port,
  ) {
    return _NetAddress_ipv6(
      addr,
      port,
    );
  }

  late final _NetAddress_ipv6Ptr = _lookup<
      ffi.NativeFunction<
          LDKNetAddress Function(
              LDKSixteenBytes, ffi.Uint16)>>('NetAddress_ipv6');
  late final _NetAddress_ipv6 = _NetAddress_ipv6Ptr.asFunction<
      LDKNetAddress Function(LDKSixteenBytes, int)>();

  /// Utility method to constructs a new OnionV2-variant NetAddress
  LDKNetAddress NetAddress_onion_v2(
    LDKTwelveBytes a,
  ) {
    return _NetAddress_onion_v2(
      a,
    );
  }

  late final _NetAddress_onion_v2Ptr =
      _lookup<ffi.NativeFunction<LDKNetAddress Function(LDKTwelveBytes)>>(
          'NetAddress_onion_v2');
  late final _NetAddress_onion_v2 = _NetAddress_onion_v2Ptr.asFunction<
      LDKNetAddress Function(LDKTwelveBytes)>();

  /// Utility method to constructs a new OnionV3-variant NetAddress
  LDKNetAddress NetAddress_onion_v3(
    LDKThirtyTwoBytes ed25519_pubkey,
    int checksum,
    int version,
    int port,
  ) {
    return _NetAddress_onion_v3(
      ed25519_pubkey,
      checksum,
      version,
      port,
    );
  }

  late final _NetAddress_onion_v3Ptr = _lookup<
      ffi.NativeFunction<
          LDKNetAddress Function(LDKThirtyTwoBytes, ffi.Uint16, ffi.Uint8,
              ffi.Uint16)>>('NetAddress_onion_v3');
  late final _NetAddress_onion_v3 = _NetAddress_onion_v3Ptr.asFunction<
      LDKNetAddress Function(LDKThirtyTwoBytes, int, int, int)>();

  /// Utility method to constructs a new Hostname-variant NetAddress
  LDKNetAddress NetAddress_hostname(
    LDKHostname hostname,
    int port,
  ) {
    return _NetAddress_hostname(
      hostname,
      port,
    );
  }

  late final _NetAddress_hostnamePtr = _lookup<
          ffi.NativeFunction<LDKNetAddress Function(LDKHostname, ffi.Uint16)>>(
      'NetAddress_hostname');
  late final _NetAddress_hostname = _NetAddress_hostnamePtr.asFunction<
      LDKNetAddress Function(LDKHostname, int)>();

  /// Serialize the NetAddress object into a byte array which can be read by NetAddress_read
  LDKCVec_u8Z NetAddress_write(
    ffi.Pointer<LDKNetAddress> obj,
  ) {
    return _NetAddress_write(
      obj,
    );
  }

  late final _NetAddress_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKNetAddress>)>>(
      'NetAddress_write');
  late final _NetAddress_write = _NetAddress_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNetAddress>)>();

  /// Read a NetAddress from a byte array, created by NetAddress_write
  LDKCResult_NetAddressDecodeErrorZ NetAddress_read(
    LDKu8slice ser,
  ) {
    return _NetAddress_read(
      ser,
    );
  }

  late final _NetAddress_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetAddressDecodeErrorZ Function(
              LDKu8slice)>>('NetAddress_read');
  late final _NetAddress_read = _NetAddress_readPtr.asFunction<
      LDKCResult_NetAddressDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
  void UnsignedNodeAnnouncement_free(
    LDKUnsignedNodeAnnouncement this_obj,
  ) {
    return _UnsignedNodeAnnouncement_free(
      this_obj,
    );
  }

  late final _UnsignedNodeAnnouncement_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKUnsignedNodeAnnouncement)>>(
      'UnsignedNodeAnnouncement_free');
  late final _UnsignedNodeAnnouncement_free = _UnsignedNodeAnnouncement_freePtr
      .asFunction<void Function(LDKUnsignedNodeAnnouncement)>();

  /// The advertised features
  LDKNodeFeatures UnsignedNodeAnnouncement_get_features(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_features(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_featuresPtr = _lookup<
          ffi.NativeFunction<
              LDKNodeFeatures Function(
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_features');
  late final _UnsignedNodeAnnouncement_get_features =
      _UnsignedNodeAnnouncement_get_featuresPtr.asFunction<
          LDKNodeFeatures Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// The advertised features
  void UnsignedNodeAnnouncement_set_features(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    LDKNodeFeatures val,
  ) {
    return _UnsignedNodeAnnouncement_set_features(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              LDKNodeFeatures)>>('UnsignedNodeAnnouncement_set_features');
  late final _UnsignedNodeAnnouncement_set_features =
      _UnsignedNodeAnnouncement_set_featuresPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>, LDKNodeFeatures)>();

  /// A strictly monotonic announcement counter, with gaps allowed
  int UnsignedNodeAnnouncement_get_timestamp(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_timestamp(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_timestamp');
  late final _UnsignedNodeAnnouncement_get_timestamp =
      _UnsignedNodeAnnouncement_get_timestampPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// A strictly monotonic announcement counter, with gaps allowed
  void UnsignedNodeAnnouncement_set_timestamp(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    int val,
  ) {
    return _UnsignedNodeAnnouncement_set_timestamp(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              ffi.Uint32)>>('UnsignedNodeAnnouncement_set_timestamp');
  late final _UnsignedNodeAnnouncement_set_timestamp =
      _UnsignedNodeAnnouncement_set_timestampPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>, int)>();

  /// The node_id this announcement originated from (don't rebroadcast the node_announcement back
  /// to this node).
  LDKPublicKey UnsignedNodeAnnouncement_get_node_id(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_node_id(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_node_idPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_node_id');
  late final _UnsignedNodeAnnouncement_get_node_id =
      _UnsignedNodeAnnouncement_get_node_idPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// The node_id this announcement originated from (don't rebroadcast the node_announcement back
  /// to this node).
  void UnsignedNodeAnnouncement_set_node_id(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    LDKPublicKey val,
  ) {
    return _UnsignedNodeAnnouncement_set_node_id(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_node_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              LDKPublicKey)>>('UnsignedNodeAnnouncement_set_node_id');
  late final _UnsignedNodeAnnouncement_set_node_id =
      _UnsignedNodeAnnouncement_set_node_idPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>, LDKPublicKey)>();

  /// An RGB color for UI purposes
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UnsignedNodeAnnouncement_get_rgb(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_rgb(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_rgbPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_rgb');
  late final _UnsignedNodeAnnouncement_get_rgb =
      _UnsignedNodeAnnouncement_get_rgbPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// An RGB color for UI purposes
  void UnsignedNodeAnnouncement_set_rgb(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    LDKThreeBytes val,
  ) {
    return _UnsignedNodeAnnouncement_set_rgb(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_rgbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              LDKThreeBytes)>>('UnsignedNodeAnnouncement_set_rgb');
  late final _UnsignedNodeAnnouncement_set_rgb =
      _UnsignedNodeAnnouncement_set_rgbPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>, LDKThreeBytes)>();

  /// An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
  /// of uniqueness.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UnsignedNodeAnnouncement_get_alias(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_alias(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_aliasPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_alias');
  late final _UnsignedNodeAnnouncement_get_alias =
      _UnsignedNodeAnnouncement_get_aliasPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
  /// of uniqueness.
  void UnsignedNodeAnnouncement_set_alias(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UnsignedNodeAnnouncement_set_alias(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              LDKThirtyTwoBytes)>>('UnsignedNodeAnnouncement_set_alias');
  late final _UnsignedNodeAnnouncement_set_alias =
      _UnsignedNodeAnnouncement_set_aliasPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>, LDKThirtyTwoBytes)>();

  /// List of addresses on which this node is reachable
  ///
  /// Returns a copy of the field.
  LDKCVec_NetAddressZ UnsignedNodeAnnouncement_get_addresses(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
  ) {
    return _UnsignedNodeAnnouncement_get_addresses(
      this_ptr,
    );
  }

  late final _UnsignedNodeAnnouncement_get_addressesPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_NetAddressZ Function(
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_get_addresses');
  late final _UnsignedNodeAnnouncement_get_addresses =
      _UnsignedNodeAnnouncement_get_addressesPtr.asFunction<
          LDKCVec_NetAddressZ Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// List of addresses on which this node is reachable
  void UnsignedNodeAnnouncement_set_addresses(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> this_ptr,
    LDKCVec_NetAddressZ val,
  ) {
    return _UnsignedNodeAnnouncement_set_addresses(
      this_ptr,
      val,
    );
  }

  late final _UnsignedNodeAnnouncement_set_addressesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>,
              LDKCVec_NetAddressZ)>>('UnsignedNodeAnnouncement_set_addresses');
  late final _UnsignedNodeAnnouncement_set_addresses =
      _UnsignedNodeAnnouncement_set_addressesPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>, LDKCVec_NetAddressZ)>();

  /// Creates a copy of the UnsignedNodeAnnouncement
  LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> orig,
  ) {
    return _UnsignedNodeAnnouncement_clone(
      orig,
    );
  }

  late final _UnsignedNodeAnnouncement_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKUnsignedNodeAnnouncement Function(
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_clone');
  late final _UnsignedNodeAnnouncement_clone =
      _UnsignedNodeAnnouncement_clonePtr.asFunction<
          LDKUnsignedNodeAnnouncement Function(
              ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
  void NodeAnnouncement_free(
    LDKNodeAnnouncement this_obj,
  ) {
    return _NodeAnnouncement_free(
      this_obj,
    );
  }

  late final _NodeAnnouncement_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeAnnouncement)>>(
          'NodeAnnouncement_free');
  late final _NodeAnnouncement_free = _NodeAnnouncement_freePtr.asFunction<
      void Function(LDKNodeAnnouncement)>();

  /// The signature by the node key
  LDKSignature NodeAnnouncement_get_signature(
    ffi.Pointer<LDKNodeAnnouncement> this_ptr,
  ) {
    return _NodeAnnouncement_get_signature(
      this_ptr,
    );
  }

  late final _NodeAnnouncement_get_signaturePtr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKNodeAnnouncement>)>>(
      'NodeAnnouncement_get_signature');
  late final _NodeAnnouncement_get_signature =
      _NodeAnnouncement_get_signaturePtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKNodeAnnouncement>)>();

  /// The signature by the node key
  void NodeAnnouncement_set_signature(
    ffi.Pointer<LDKNodeAnnouncement> this_ptr,
    LDKSignature val,
  ) {
    return _NodeAnnouncement_set_signature(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncement_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncement>,
              LDKSignature)>>('NodeAnnouncement_set_signature');
  late final _NodeAnnouncement_set_signature =
      _NodeAnnouncement_set_signaturePtr.asFunction<
          void Function(ffi.Pointer<LDKNodeAnnouncement>, LDKSignature)>();

  /// The actual content of the announcement
  LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(
    ffi.Pointer<LDKNodeAnnouncement> this_ptr,
  ) {
    return _NodeAnnouncement_get_contents(
      this_ptr,
    );
  }

  late final _NodeAnnouncement_get_contentsPtr = _lookup<
          ffi.NativeFunction<
              LDKUnsignedNodeAnnouncement Function(
                  ffi.Pointer<LDKNodeAnnouncement>)>>(
      'NodeAnnouncement_get_contents');
  late final _NodeAnnouncement_get_contents =
      _NodeAnnouncement_get_contentsPtr.asFunction<
          LDKUnsignedNodeAnnouncement Function(
              ffi.Pointer<LDKNodeAnnouncement>)>();

  /// The actual content of the announcement
  void NodeAnnouncement_set_contents(
    ffi.Pointer<LDKNodeAnnouncement> this_ptr,
    LDKUnsignedNodeAnnouncement val,
  ) {
    return _NodeAnnouncement_set_contents(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncement_set_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncement>,
              LDKUnsignedNodeAnnouncement)>>('NodeAnnouncement_set_contents');
  late final _NodeAnnouncement_set_contents =
      _NodeAnnouncement_set_contentsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKNodeAnnouncement>, LDKUnsignedNodeAnnouncement)>();

  /// Constructs a new NodeAnnouncement given each field
  LDKNodeAnnouncement NodeAnnouncement_new(
    LDKSignature signature_arg,
    LDKUnsignedNodeAnnouncement contents_arg,
  ) {
    return _NodeAnnouncement_new(
      signature_arg,
      contents_arg,
    );
  }

  late final _NodeAnnouncement_newPtr = _lookup<
      ffi.NativeFunction<
          LDKNodeAnnouncement Function(LDKSignature,
              LDKUnsignedNodeAnnouncement)>>('NodeAnnouncement_new');
  late final _NodeAnnouncement_new = _NodeAnnouncement_newPtr.asFunction<
      LDKNodeAnnouncement Function(
          LDKSignature, LDKUnsignedNodeAnnouncement)>();

  /// Creates a copy of the NodeAnnouncement
  LDKNodeAnnouncement NodeAnnouncement_clone(
    ffi.Pointer<LDKNodeAnnouncement> orig,
  ) {
    return _NodeAnnouncement_clone(
      orig,
    );
  }

  late final _NodeAnnouncement_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKNodeAnnouncement Function(
              ffi.Pointer<LDKNodeAnnouncement>)>>('NodeAnnouncement_clone');
  late final _NodeAnnouncement_clone = _NodeAnnouncement_clonePtr.asFunction<
      LDKNodeAnnouncement Function(ffi.Pointer<LDKNodeAnnouncement>)>();

  /// Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
  void UnsignedChannelAnnouncement_free(
    LDKUnsignedChannelAnnouncement this_obj,
  ) {
    return _UnsignedChannelAnnouncement_free(
      this_obj,
    );
  }

  late final _UnsignedChannelAnnouncement_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKUnsignedChannelAnnouncement)>>(
      'UnsignedChannelAnnouncement_free');
  late final _UnsignedChannelAnnouncement_free =
      _UnsignedChannelAnnouncement_freePtr.asFunction<
          void Function(LDKUnsignedChannelAnnouncement)>();

  /// The advertised channel features
  LDKChannelFeatures UnsignedChannelAnnouncement_get_features(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_features(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_featuresPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelFeatures Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_features');
  late final _UnsignedChannelAnnouncement_get_features =
      _UnsignedChannelAnnouncement_get_featuresPtr.asFunction<
          LDKChannelFeatures Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The advertised channel features
  void UnsignedChannelAnnouncement_set_features(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKChannelFeatures val,
  ) {
    return _UnsignedChannelAnnouncement_set_features(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKChannelFeatures)>>('UnsignedChannelAnnouncement_set_features');
  late final _UnsignedChannelAnnouncement_set_features =
      _UnsignedChannelAnnouncement_set_featuresPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKChannelFeatures)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>
      UnsignedChannelAnnouncement_get_chain_hash(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_chain_hash(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_chain_hash');
  late final _UnsignedChannelAnnouncement_get_chain_hash =
      _UnsignedChannelAnnouncement_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  void UnsignedChannelAnnouncement_set_chain_hash(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UnsignedChannelAnnouncement_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
                  LDKThirtyTwoBytes)>>(
      'UnsignedChannelAnnouncement_set_chain_hash');
  late final _UnsignedChannelAnnouncement_set_chain_hash =
      _UnsignedChannelAnnouncement_set_chain_hashPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKThirtyTwoBytes)>();

  /// The short channel ID
  int UnsignedChannelAnnouncement_get_short_channel_id(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_short_channel_id(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_short_channel_id');
  late final _UnsignedChannelAnnouncement_get_short_channel_id =
      _UnsignedChannelAnnouncement_get_short_channel_idPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The short channel ID
  void UnsignedChannelAnnouncement_set_short_channel_id(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    int val,
  ) {
    return _UnsignedChannelAnnouncement_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              ffi.Uint64)>>('UnsignedChannelAnnouncement_set_short_channel_id');
  late final _UnsignedChannelAnnouncement_set_short_channel_id =
      _UnsignedChannelAnnouncement_set_short_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>, int)>();

  /// One of the two node_ids which are endpoints of this channel
  LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_node_id_1(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_node_id_1Ptr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_node_id_1');
  late final _UnsignedChannelAnnouncement_get_node_id_1 =
      _UnsignedChannelAnnouncement_get_node_id_1Ptr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// One of the two node_ids which are endpoints of this channel
  void UnsignedChannelAnnouncement_set_node_id_1(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKPublicKey val,
  ) {
    return _UnsignedChannelAnnouncement_set_node_id_1(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_node_id_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKPublicKey)>>('UnsignedChannelAnnouncement_set_node_id_1');
  late final _UnsignedChannelAnnouncement_set_node_id_1 =
      _UnsignedChannelAnnouncement_set_node_id_1Ptr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>, LDKPublicKey)>();

  /// The other of the two node_ids which are endpoints of this channel
  LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_node_id_2(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_node_id_2Ptr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_node_id_2');
  late final _UnsignedChannelAnnouncement_get_node_id_2 =
      _UnsignedChannelAnnouncement_get_node_id_2Ptr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The other of the two node_ids which are endpoints of this channel
  void UnsignedChannelAnnouncement_set_node_id_2(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKPublicKey val,
  ) {
    return _UnsignedChannelAnnouncement_set_node_id_2(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_node_id_2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKPublicKey)>>('UnsignedChannelAnnouncement_set_node_id_2');
  late final _UnsignedChannelAnnouncement_set_node_id_2 =
      _UnsignedChannelAnnouncement_set_node_id_2Ptr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>, LDKPublicKey)>();

  /// The funding key for the first node
  LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_bitcoin_key_1(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_bitcoin_key_1Ptr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_bitcoin_key_1');
  late final _UnsignedChannelAnnouncement_get_bitcoin_key_1 =
      _UnsignedChannelAnnouncement_get_bitcoin_key_1Ptr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The funding key for the first node
  void UnsignedChannelAnnouncement_set_bitcoin_key_1(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKPublicKey val,
  ) {
    return _UnsignedChannelAnnouncement_set_bitcoin_key_1(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_bitcoin_key_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKPublicKey)>>('UnsignedChannelAnnouncement_set_bitcoin_key_1');
  late final _UnsignedChannelAnnouncement_set_bitcoin_key_1 =
      _UnsignedChannelAnnouncement_set_bitcoin_key_1Ptr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>, LDKPublicKey)>();

  /// The funding key for the second node
  LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
  ) {
    return _UnsignedChannelAnnouncement_get_bitcoin_key_2(
      this_ptr,
    );
  }

  late final _UnsignedChannelAnnouncement_get_bitcoin_key_2Ptr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_get_bitcoin_key_2');
  late final _UnsignedChannelAnnouncement_get_bitcoin_key_2 =
      _UnsignedChannelAnnouncement_get_bitcoin_key_2Ptr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// The funding key for the second node
  void UnsignedChannelAnnouncement_set_bitcoin_key_2(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> this_ptr,
    LDKPublicKey val,
  ) {
    return _UnsignedChannelAnnouncement_set_bitcoin_key_2(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelAnnouncement_set_bitcoin_key_2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKPublicKey)>>('UnsignedChannelAnnouncement_set_bitcoin_key_2');
  late final _UnsignedChannelAnnouncement_set_bitcoin_key_2 =
      _UnsignedChannelAnnouncement_set_bitcoin_key_2Ptr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>, LDKPublicKey)>();

  /// Creates a copy of the UnsignedChannelAnnouncement
  LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> orig,
  ) {
    return _UnsignedChannelAnnouncement_clone(
      orig,
    );
  }

  late final _UnsignedChannelAnnouncement_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKUnsignedChannelAnnouncement Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_clone');
  late final _UnsignedChannelAnnouncement_clone =
      _UnsignedChannelAnnouncement_clonePtr.asFunction<
          LDKUnsignedChannelAnnouncement Function(
              ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
  void ChannelAnnouncement_free(
    LDKChannelAnnouncement this_obj,
  ) {
    return _ChannelAnnouncement_free(
      this_obj,
    );
  }

  late final _ChannelAnnouncement_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelAnnouncement)>>(
          'ChannelAnnouncement_free');
  late final _ChannelAnnouncement_free = _ChannelAnnouncement_freePtr
      .asFunction<void Function(LDKChannelAnnouncement)>();

  /// Authentication of the announcement by the first public node
  LDKSignature ChannelAnnouncement_get_node_signature_1(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
  ) {
    return _ChannelAnnouncement_get_node_signature_1(
      this_ptr,
    );
  }

  late final _ChannelAnnouncement_get_node_signature_1Ptr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_get_node_signature_1');
  late final _ChannelAnnouncement_get_node_signature_1 =
      _ChannelAnnouncement_get_node_signature_1Ptr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Authentication of the announcement by the first public node
  void ChannelAnnouncement_set_node_signature_1(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
    LDKSignature val,
  ) {
    return _ChannelAnnouncement_set_node_signature_1(
      this_ptr,
      val,
    );
  }

  late final _ChannelAnnouncement_set_node_signature_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelAnnouncement>,
              LDKSignature)>>('ChannelAnnouncement_set_node_signature_1');
  late final _ChannelAnnouncement_set_node_signature_1 =
      _ChannelAnnouncement_set_node_signature_1Ptr.asFunction<
          void Function(ffi.Pointer<LDKChannelAnnouncement>, LDKSignature)>();

  /// Authentication of the announcement by the second public node
  LDKSignature ChannelAnnouncement_get_node_signature_2(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
  ) {
    return _ChannelAnnouncement_get_node_signature_2(
      this_ptr,
    );
  }

  late final _ChannelAnnouncement_get_node_signature_2Ptr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_get_node_signature_2');
  late final _ChannelAnnouncement_get_node_signature_2 =
      _ChannelAnnouncement_get_node_signature_2Ptr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Authentication of the announcement by the second public node
  void ChannelAnnouncement_set_node_signature_2(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
    LDKSignature val,
  ) {
    return _ChannelAnnouncement_set_node_signature_2(
      this_ptr,
      val,
    );
  }

  late final _ChannelAnnouncement_set_node_signature_2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelAnnouncement>,
              LDKSignature)>>('ChannelAnnouncement_set_node_signature_2');
  late final _ChannelAnnouncement_set_node_signature_2 =
      _ChannelAnnouncement_set_node_signature_2Ptr.asFunction<
          void Function(ffi.Pointer<LDKChannelAnnouncement>, LDKSignature)>();

  /// Proof of funding UTXO ownership by the first public node
  LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
  ) {
    return _ChannelAnnouncement_get_bitcoin_signature_1(
      this_ptr,
    );
  }

  late final _ChannelAnnouncement_get_bitcoin_signature_1Ptr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_get_bitcoin_signature_1');
  late final _ChannelAnnouncement_get_bitcoin_signature_1 =
      _ChannelAnnouncement_get_bitcoin_signature_1Ptr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Proof of funding UTXO ownership by the first public node
  void ChannelAnnouncement_set_bitcoin_signature_1(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
    LDKSignature val,
  ) {
    return _ChannelAnnouncement_set_bitcoin_signature_1(
      this_ptr,
      val,
    );
  }

  late final _ChannelAnnouncement_set_bitcoin_signature_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelAnnouncement>,
              LDKSignature)>>('ChannelAnnouncement_set_bitcoin_signature_1');
  late final _ChannelAnnouncement_set_bitcoin_signature_1 =
      _ChannelAnnouncement_set_bitcoin_signature_1Ptr.asFunction<
          void Function(ffi.Pointer<LDKChannelAnnouncement>, LDKSignature)>();

  /// Proof of funding UTXO ownership by the second public node
  LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
  ) {
    return _ChannelAnnouncement_get_bitcoin_signature_2(
      this_ptr,
    );
  }

  late final _ChannelAnnouncement_get_bitcoin_signature_2Ptr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_get_bitcoin_signature_2');
  late final _ChannelAnnouncement_get_bitcoin_signature_2 =
      _ChannelAnnouncement_get_bitcoin_signature_2Ptr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Proof of funding UTXO ownership by the second public node
  void ChannelAnnouncement_set_bitcoin_signature_2(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
    LDKSignature val,
  ) {
    return _ChannelAnnouncement_set_bitcoin_signature_2(
      this_ptr,
      val,
    );
  }

  late final _ChannelAnnouncement_set_bitcoin_signature_2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelAnnouncement>,
              LDKSignature)>>('ChannelAnnouncement_set_bitcoin_signature_2');
  late final _ChannelAnnouncement_set_bitcoin_signature_2 =
      _ChannelAnnouncement_set_bitcoin_signature_2Ptr.asFunction<
          void Function(ffi.Pointer<LDKChannelAnnouncement>, LDKSignature)>();

  /// The actual announcement
  LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
  ) {
    return _ChannelAnnouncement_get_contents(
      this_ptr,
    );
  }

  late final _ChannelAnnouncement_get_contentsPtr = _lookup<
          ffi.NativeFunction<
              LDKUnsignedChannelAnnouncement Function(
                  ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_get_contents');
  late final _ChannelAnnouncement_get_contents =
      _ChannelAnnouncement_get_contentsPtr.asFunction<
          LDKUnsignedChannelAnnouncement Function(
              ffi.Pointer<LDKChannelAnnouncement>)>();

  /// The actual announcement
  void ChannelAnnouncement_set_contents(
    ffi.Pointer<LDKChannelAnnouncement> this_ptr,
    LDKUnsignedChannelAnnouncement val,
  ) {
    return _ChannelAnnouncement_set_contents(
      this_ptr,
      val,
    );
  }

  late final _ChannelAnnouncement_set_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelAnnouncement>,
                  LDKUnsignedChannelAnnouncement)>>(
      'ChannelAnnouncement_set_contents');
  late final _ChannelAnnouncement_set_contents =
      _ChannelAnnouncement_set_contentsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelAnnouncement>,
              LDKUnsignedChannelAnnouncement)>();

  /// Constructs a new ChannelAnnouncement given each field
  LDKChannelAnnouncement ChannelAnnouncement_new(
    LDKSignature node_signature_1_arg,
    LDKSignature node_signature_2_arg,
    LDKSignature bitcoin_signature_1_arg,
    LDKSignature bitcoin_signature_2_arg,
    LDKUnsignedChannelAnnouncement contents_arg,
  ) {
    return _ChannelAnnouncement_new(
      node_signature_1_arg,
      node_signature_2_arg,
      bitcoin_signature_1_arg,
      bitcoin_signature_2_arg,
      contents_arg,
    );
  }

  late final _ChannelAnnouncement_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelAnnouncement Function(
              LDKSignature,
              LDKSignature,
              LDKSignature,
              LDKSignature,
              LDKUnsignedChannelAnnouncement)>>('ChannelAnnouncement_new');
  late final _ChannelAnnouncement_new = _ChannelAnnouncement_newPtr.asFunction<
      LDKChannelAnnouncement Function(LDKSignature, LDKSignature, LDKSignature,
          LDKSignature, LDKUnsignedChannelAnnouncement)>();

  /// Creates a copy of the ChannelAnnouncement
  LDKChannelAnnouncement ChannelAnnouncement_clone(
    ffi.Pointer<LDKChannelAnnouncement> orig,
  ) {
    return _ChannelAnnouncement_clone(
      orig,
    );
  }

  late final _ChannelAnnouncement_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelAnnouncement Function(
                  ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_clone');
  late final _ChannelAnnouncement_clone =
      _ChannelAnnouncement_clonePtr.asFunction<
          LDKChannelAnnouncement Function(
              ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
  void UnsignedChannelUpdate_free(
    LDKUnsignedChannelUpdate this_obj,
  ) {
    return _UnsignedChannelUpdate_free(
      this_obj,
    );
  }

  late final _UnsignedChannelUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKUnsignedChannelUpdate)>>(
          'UnsignedChannelUpdate_free');
  late final _UnsignedChannelUpdate_free = _UnsignedChannelUpdate_freePtr
      .asFunction<void Function(LDKUnsignedChannelUpdate)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> UnsignedChannelUpdate_get_chain_hash(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_chain_hash(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_chain_hash');
  late final _UnsignedChannelUpdate_get_chain_hash =
      _UnsignedChannelUpdate_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The genesis hash of the blockchain where the channel is to be opened
  void UnsignedChannelUpdate_set_chain_hash(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _UnsignedChannelUpdate_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              LDKThirtyTwoBytes)>>('UnsignedChannelUpdate_set_chain_hash');
  late final _UnsignedChannelUpdate_set_chain_hash =
      _UnsignedChannelUpdate_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKUnsignedChannelUpdate>, LDKThirtyTwoBytes)>();

  /// The short channel ID
  int UnsignedChannelUpdate_get_short_channel_id(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_short_channel_id(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_short_channel_id');
  late final _UnsignedChannelUpdate_get_short_channel_id =
      _UnsignedChannelUpdate_get_short_channel_idPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The short channel ID
  void UnsignedChannelUpdate_set_short_channel_id(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint64)>>('UnsignedChannelUpdate_set_short_channel_id');
  late final _UnsignedChannelUpdate_set_short_channel_id =
      _UnsignedChannelUpdate_set_short_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// A strictly monotonic announcement counter, with gaps allowed, specific to this channel
  int UnsignedChannelUpdate_get_timestamp(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_timestamp(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_timestamp');
  late final _UnsignedChannelUpdate_get_timestamp =
      _UnsignedChannelUpdate_get_timestampPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// A strictly monotonic announcement counter, with gaps allowed, specific to this channel
  void UnsignedChannelUpdate_set_timestamp(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_timestamp(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint32)>>('UnsignedChannelUpdate_set_timestamp');
  late final _UnsignedChannelUpdate_set_timestamp =
      _UnsignedChannelUpdate_set_timestampPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// Channel flags
  int UnsignedChannelUpdate_get_flags(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_flags(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_flagsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_flags');
  late final _UnsignedChannelUpdate_get_flags =
      _UnsignedChannelUpdate_get_flagsPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// Channel flags
  void UnsignedChannelUpdate_set_flags(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_flags(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint8)>>('UnsignedChannelUpdate_set_flags');
  late final _UnsignedChannelUpdate_set_flags =
      _UnsignedChannelUpdate_set_flagsPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// The number of blocks such that if:
  /// `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
  /// then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
  /// the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
  /// cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
  /// then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
  /// forwarding. Note that the HTLC sender is the one who originally sets this value when
  /// constructing the route.
  int UnsignedChannelUpdate_get_cltv_expiry_delta(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_cltv_expiry_delta');
  late final _UnsignedChannelUpdate_get_cltv_expiry_delta =
      _UnsignedChannelUpdate_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The number of blocks such that if:
  /// `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
  /// then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
  /// the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
  /// cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
  /// then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
  /// forwarding. Note that the HTLC sender is the one who originally sets this value when
  /// constructing the route.
  void UnsignedChannelUpdate_set_cltv_expiry_delta(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint16)>>('UnsignedChannelUpdate_set_cltv_expiry_delta');
  late final _UnsignedChannelUpdate_set_cltv_expiry_delta =
      _UnsignedChannelUpdate_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  int UnsignedChannelUpdate_get_htlc_minimum_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_htlc_minimum_msat');
  late final _UnsignedChannelUpdate_get_htlc_minimum_msat =
      _UnsignedChannelUpdate_get_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The minimum HTLC size incoming to sender, in milli-satoshi
  void UnsignedChannelUpdate_set_htlc_minimum_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint64)>>('UnsignedChannelUpdate_set_htlc_minimum_msat');
  late final _UnsignedChannelUpdate_set_htlc_minimum_msat =
      _UnsignedChannelUpdate_set_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// The maximum HTLC value incoming to sender, in milli-satoshi. Used to be optional.
  int UnsignedChannelUpdate_get_htlc_maximum_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_htlc_maximum_msat(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_htlc_maximum_msat');
  late final _UnsignedChannelUpdate_get_htlc_maximum_msat =
      _UnsignedChannelUpdate_get_htlc_maximum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The maximum HTLC value incoming to sender, in milli-satoshi. Used to be optional.
  void UnsignedChannelUpdate_set_htlc_maximum_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_htlc_maximum_msat(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_htlc_maximum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint64)>>('UnsignedChannelUpdate_set_htlc_maximum_msat');
  late final _UnsignedChannelUpdate_set_htlc_maximum_msat =
      _UnsignedChannelUpdate_set_htlc_maximum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// The base HTLC fee charged by sender, in milli-satoshi
  int UnsignedChannelUpdate_get_fee_base_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_fee_base_msat(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_fee_base_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_fee_base_msat');
  late final _UnsignedChannelUpdate_get_fee_base_msat =
      _UnsignedChannelUpdate_get_fee_base_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The base HTLC fee charged by sender, in milli-satoshi
  void UnsignedChannelUpdate_set_fee_base_msat(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_fee_base_msat(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_fee_base_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              ffi.Uint32)>>('UnsignedChannelUpdate_set_fee_base_msat');
  late final _UnsignedChannelUpdate_set_fee_base_msat =
      _UnsignedChannelUpdate_set_fee_base_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// The amount to fee multiplier, in micro-satoshi
  int UnsignedChannelUpdate_get_fee_proportional_millionths(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_fee_proportional_millionths(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint32 Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
          'UnsignedChannelUpdate_get_fee_proportional_millionths');
  late final _UnsignedChannelUpdate_get_fee_proportional_millionths =
      _UnsignedChannelUpdate_get_fee_proportional_millionthsPtr.asFunction<
          int Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// The amount to fee multiplier, in micro-satoshi
  void UnsignedChannelUpdate_set_fee_proportional_millionths(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    int val,
  ) {
    return _UnsignedChannelUpdate_set_fee_proportional_millionths(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_fee_proportional_millionthsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKUnsignedChannelUpdate>, ffi.Uint32)>>(
          'UnsignedChannelUpdate_set_fee_proportional_millionths');
  late final _UnsignedChannelUpdate_set_fee_proportional_millionths =
      _UnsignedChannelUpdate_set_fee_proportional_millionthsPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, int)>();

  /// Excess data which was signed as a part of the message which we do not (yet) understand how
  /// to decode. This is stored to ensure forward-compatibility as new fields are added to the
  /// lightning gossip
  ///
  /// Returns a copy of the field.
  LDKCVec_u8Z UnsignedChannelUpdate_get_excess_data(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
  ) {
    return _UnsignedChannelUpdate_get_excess_data(
      this_ptr,
    );
  }

  late final _UnsignedChannelUpdate_get_excess_dataPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_get_excess_data');
  late final _UnsignedChannelUpdate_get_excess_data =
      _UnsignedChannelUpdate_get_excess_dataPtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// Excess data which was signed as a part of the message which we do not (yet) understand how
  /// to decode. This is stored to ensure forward-compatibility as new fields are added to the
  /// lightning gossip
  void UnsignedChannelUpdate_set_excess_data(
    ffi.Pointer<LDKUnsignedChannelUpdate> this_ptr,
    LDKCVec_u8Z val,
  ) {
    return _UnsignedChannelUpdate_set_excess_data(
      this_ptr,
      val,
    );
  }

  late final _UnsignedChannelUpdate_set_excess_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKUnsignedChannelUpdate>,
              LDKCVec_u8Z)>>('UnsignedChannelUpdate_set_excess_data');
  late final _UnsignedChannelUpdate_set_excess_data =
      _UnsignedChannelUpdate_set_excess_dataPtr.asFunction<
          void Function(ffi.Pointer<LDKUnsignedChannelUpdate>, LDKCVec_u8Z)>();

  /// Constructs a new UnsignedChannelUpdate given each field
  LDKUnsignedChannelUpdate UnsignedChannelUpdate_new(
    LDKThirtyTwoBytes chain_hash_arg,
    int short_channel_id_arg,
    int timestamp_arg,
    int flags_arg,
    int cltv_expiry_delta_arg,
    int htlc_minimum_msat_arg,
    int htlc_maximum_msat_arg,
    int fee_base_msat_arg,
    int fee_proportional_millionths_arg,
    LDKCVec_u8Z excess_data_arg,
  ) {
    return _UnsignedChannelUpdate_new(
      chain_hash_arg,
      short_channel_id_arg,
      timestamp_arg,
      flags_arg,
      cltv_expiry_delta_arg,
      htlc_minimum_msat_arg,
      htlc_maximum_msat_arg,
      fee_base_msat_arg,
      fee_proportional_millionths_arg,
      excess_data_arg,
    );
  }

  late final _UnsignedChannelUpdate_newPtr = _lookup<
      ffi.NativeFunction<
          LDKUnsignedChannelUpdate Function(
              LDKThirtyTwoBytes,
              ffi.Uint64,
              ffi.Uint32,
              ffi.Uint8,
              ffi.Uint16,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Uint32,
              ffi.Uint32,
              LDKCVec_u8Z)>>('UnsignedChannelUpdate_new');
  late final _UnsignedChannelUpdate_new =
      _UnsignedChannelUpdate_newPtr.asFunction<
          LDKUnsignedChannelUpdate Function(LDKThirtyTwoBytes, int, int, int,
              int, int, int, int, int, LDKCVec_u8Z)>();

  /// Creates a copy of the UnsignedChannelUpdate
  LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(
    ffi.Pointer<LDKUnsignedChannelUpdate> orig,
  ) {
    return _UnsignedChannelUpdate_clone(
      orig,
    );
  }

  late final _UnsignedChannelUpdate_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKUnsignedChannelUpdate Function(
                  ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_clone');
  late final _UnsignedChannelUpdate_clone =
      _UnsignedChannelUpdate_clonePtr.asFunction<
          LDKUnsignedChannelUpdate Function(
              ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
  void ChannelUpdate_free(
    LDKChannelUpdate this_obj,
  ) {
    return _ChannelUpdate_free(
      this_obj,
    );
  }

  late final _ChannelUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelUpdate)>>(
          'ChannelUpdate_free');
  late final _ChannelUpdate_free =
      _ChannelUpdate_freePtr.asFunction<void Function(LDKChannelUpdate)>();

  /// A signature of the channel update
  LDKSignature ChannelUpdate_get_signature(
    ffi.Pointer<LDKChannelUpdate> this_ptr,
  ) {
    return _ChannelUpdate_get_signature(
      this_ptr,
    );
  }

  late final _ChannelUpdate_get_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKChannelUpdate>)>>('ChannelUpdate_get_signature');
  late final _ChannelUpdate_get_signature = _ChannelUpdate_get_signaturePtr
      .asFunction<LDKSignature Function(ffi.Pointer<LDKChannelUpdate>)>();

  /// A signature of the channel update
  void ChannelUpdate_set_signature(
    ffi.Pointer<LDKChannelUpdate> this_ptr,
    LDKSignature val,
  ) {
    return _ChannelUpdate_set_signature(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdate_set_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdate>,
              LDKSignature)>>('ChannelUpdate_set_signature');
  late final _ChannelUpdate_set_signature = _ChannelUpdate_set_signaturePtr
      .asFunction<void Function(ffi.Pointer<LDKChannelUpdate>, LDKSignature)>();

  /// The actual channel update
  LDKUnsignedChannelUpdate ChannelUpdate_get_contents(
    ffi.Pointer<LDKChannelUpdate> this_ptr,
  ) {
    return _ChannelUpdate_get_contents(
      this_ptr,
    );
  }

  late final _ChannelUpdate_get_contentsPtr = _lookup<
      ffi.NativeFunction<
          LDKUnsignedChannelUpdate Function(
              ffi.Pointer<LDKChannelUpdate>)>>('ChannelUpdate_get_contents');
  late final _ChannelUpdate_get_contents =
      _ChannelUpdate_get_contentsPtr.asFunction<
          LDKUnsignedChannelUpdate Function(ffi.Pointer<LDKChannelUpdate>)>();

  /// The actual channel update
  void ChannelUpdate_set_contents(
    ffi.Pointer<LDKChannelUpdate> this_ptr,
    LDKUnsignedChannelUpdate val,
  ) {
    return _ChannelUpdate_set_contents(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdate_set_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdate>,
              LDKUnsignedChannelUpdate)>>('ChannelUpdate_set_contents');
  late final _ChannelUpdate_set_contents =
      _ChannelUpdate_set_contentsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelUpdate>, LDKUnsignedChannelUpdate)>();

  /// Constructs a new ChannelUpdate given each field
  LDKChannelUpdate ChannelUpdate_new(
    LDKSignature signature_arg,
    LDKUnsignedChannelUpdate contents_arg,
  ) {
    return _ChannelUpdate_new(
      signature_arg,
      contents_arg,
    );
  }

  late final _ChannelUpdate_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdate Function(
              LDKSignature, LDKUnsignedChannelUpdate)>>('ChannelUpdate_new');
  late final _ChannelUpdate_new = _ChannelUpdate_newPtr.asFunction<
      LDKChannelUpdate Function(LDKSignature, LDKUnsignedChannelUpdate)>();

  /// Creates a copy of the ChannelUpdate
  LDKChannelUpdate ChannelUpdate_clone(
    ffi.Pointer<LDKChannelUpdate> orig,
  ) {
    return _ChannelUpdate_clone(
      orig,
    );
  }

  late final _ChannelUpdate_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdate Function(
              ffi.Pointer<LDKChannelUpdate>)>>('ChannelUpdate_clone');
  late final _ChannelUpdate_clone = _ChannelUpdate_clonePtr.asFunction<
      LDKChannelUpdate Function(ffi.Pointer<LDKChannelUpdate>)>();

  /// Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
  void QueryChannelRange_free(
    LDKQueryChannelRange this_obj,
  ) {
    return _QueryChannelRange_free(
      this_obj,
    );
  }

  late final _QueryChannelRange_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKQueryChannelRange)>>(
          'QueryChannelRange_free');
  late final _QueryChannelRange_free = _QueryChannelRange_freePtr.asFunction<
      void Function(LDKQueryChannelRange)>();

  /// The genesis hash of the blockchain being queried
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> QueryChannelRange_get_chain_hash(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
  ) {
    return _QueryChannelRange_get_chain_hash(
      this_ptr,
    );
  }

  late final _QueryChannelRange_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKQueryChannelRange>)>>(
      'QueryChannelRange_get_chain_hash');
  late final _QueryChannelRange_get_chain_hash =
      _QueryChannelRange_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKQueryChannelRange>)>();

  /// The genesis hash of the blockchain being queried
  void QueryChannelRange_set_chain_hash(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _QueryChannelRange_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _QueryChannelRange_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKQueryChannelRange>,
              LDKThirtyTwoBytes)>>('QueryChannelRange_set_chain_hash');
  late final _QueryChannelRange_set_chain_hash =
      _QueryChannelRange_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKQueryChannelRange>, LDKThirtyTwoBytes)>();

  /// The height of the first block for the channel UTXOs being queried
  int QueryChannelRange_get_first_blocknum(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
  ) {
    return _QueryChannelRange_get_first_blocknum(
      this_ptr,
    );
  }

  late final _QueryChannelRange_get_first_blocknumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKQueryChannelRange>)>>(
      'QueryChannelRange_get_first_blocknum');
  late final _QueryChannelRange_get_first_blocknum =
      _QueryChannelRange_get_first_blocknumPtr.asFunction<
          int Function(ffi.Pointer<LDKQueryChannelRange>)>();

  /// The height of the first block for the channel UTXOs being queried
  void QueryChannelRange_set_first_blocknum(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
    int val,
  ) {
    return _QueryChannelRange_set_first_blocknum(
      this_ptr,
      val,
    );
  }

  late final _QueryChannelRange_set_first_blocknumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKQueryChannelRange>,
              ffi.Uint32)>>('QueryChannelRange_set_first_blocknum');
  late final _QueryChannelRange_set_first_blocknum =
      _QueryChannelRange_set_first_blocknumPtr.asFunction<
          void Function(ffi.Pointer<LDKQueryChannelRange>, int)>();

  /// The number of blocks to include in the query results
  int QueryChannelRange_get_number_of_blocks(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
  ) {
    return _QueryChannelRange_get_number_of_blocks(
      this_ptr,
    );
  }

  late final _QueryChannelRange_get_number_of_blocksPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKQueryChannelRange>)>>(
      'QueryChannelRange_get_number_of_blocks');
  late final _QueryChannelRange_get_number_of_blocks =
      _QueryChannelRange_get_number_of_blocksPtr.asFunction<
          int Function(ffi.Pointer<LDKQueryChannelRange>)>();

  /// The number of blocks to include in the query results
  void QueryChannelRange_set_number_of_blocks(
    ffi.Pointer<LDKQueryChannelRange> this_ptr,
    int val,
  ) {
    return _QueryChannelRange_set_number_of_blocks(
      this_ptr,
      val,
    );
  }

  late final _QueryChannelRange_set_number_of_blocksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKQueryChannelRange>,
              ffi.Uint32)>>('QueryChannelRange_set_number_of_blocks');
  late final _QueryChannelRange_set_number_of_blocks =
      _QueryChannelRange_set_number_of_blocksPtr.asFunction<
          void Function(ffi.Pointer<LDKQueryChannelRange>, int)>();

  /// Constructs a new QueryChannelRange given each field
  LDKQueryChannelRange QueryChannelRange_new(
    LDKThirtyTwoBytes chain_hash_arg,
    int first_blocknum_arg,
    int number_of_blocks_arg,
  ) {
    return _QueryChannelRange_new(
      chain_hash_arg,
      first_blocknum_arg,
      number_of_blocks_arg,
    );
  }

  late final _QueryChannelRange_newPtr = _lookup<
      ffi.NativeFunction<
          LDKQueryChannelRange Function(LDKThirtyTwoBytes, ffi.Uint32,
              ffi.Uint32)>>('QueryChannelRange_new');
  late final _QueryChannelRange_new = _QueryChannelRange_newPtr.asFunction<
      LDKQueryChannelRange Function(LDKThirtyTwoBytes, int, int)>();

  /// Creates a copy of the QueryChannelRange
  LDKQueryChannelRange QueryChannelRange_clone(
    ffi.Pointer<LDKQueryChannelRange> orig,
  ) {
    return _QueryChannelRange_clone(
      orig,
    );
  }

  late final _QueryChannelRange_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKQueryChannelRange Function(
              ffi.Pointer<LDKQueryChannelRange>)>>('QueryChannelRange_clone');
  late final _QueryChannelRange_clone = _QueryChannelRange_clonePtr.asFunction<
      LDKQueryChannelRange Function(ffi.Pointer<LDKQueryChannelRange>)>();

  /// Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
  void ReplyChannelRange_free(
    LDKReplyChannelRange this_obj,
  ) {
    return _ReplyChannelRange_free(
      this_obj,
    );
  }

  late final _ReplyChannelRange_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKReplyChannelRange)>>(
          'ReplyChannelRange_free');
  late final _ReplyChannelRange_free = _ReplyChannelRange_freePtr.asFunction<
      void Function(LDKReplyChannelRange)>();

  /// The genesis hash of the blockchain being queried
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ReplyChannelRange_get_chain_hash(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
  ) {
    return _ReplyChannelRange_get_chain_hash(
      this_ptr,
    );
  }

  late final _ReplyChannelRange_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKReplyChannelRange>)>>(
      'ReplyChannelRange_get_chain_hash');
  late final _ReplyChannelRange_get_chain_hash =
      _ReplyChannelRange_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKReplyChannelRange>)>();

  /// The genesis hash of the blockchain being queried
  void ReplyChannelRange_set_chain_hash(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ReplyChannelRange_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _ReplyChannelRange_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyChannelRange>,
              LDKThirtyTwoBytes)>>('ReplyChannelRange_set_chain_hash');
  late final _ReplyChannelRange_set_chain_hash =
      _ReplyChannelRange_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKReplyChannelRange>, LDKThirtyTwoBytes)>();

  /// The height of the first block in the range of the reply
  int ReplyChannelRange_get_first_blocknum(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
  ) {
    return _ReplyChannelRange_get_first_blocknum(
      this_ptr,
    );
  }

  late final _ReplyChannelRange_get_first_blocknumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKReplyChannelRange>)>>(
      'ReplyChannelRange_get_first_blocknum');
  late final _ReplyChannelRange_get_first_blocknum =
      _ReplyChannelRange_get_first_blocknumPtr.asFunction<
          int Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// The height of the first block in the range of the reply
  void ReplyChannelRange_set_first_blocknum(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
    int val,
  ) {
    return _ReplyChannelRange_set_first_blocknum(
      this_ptr,
      val,
    );
  }

  late final _ReplyChannelRange_set_first_blocknumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyChannelRange>,
              ffi.Uint32)>>('ReplyChannelRange_set_first_blocknum');
  late final _ReplyChannelRange_set_first_blocknum =
      _ReplyChannelRange_set_first_blocknumPtr.asFunction<
          void Function(ffi.Pointer<LDKReplyChannelRange>, int)>();

  /// The number of blocks included in the range of the reply
  int ReplyChannelRange_get_number_of_blocks(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
  ) {
    return _ReplyChannelRange_get_number_of_blocks(
      this_ptr,
    );
  }

  late final _ReplyChannelRange_get_number_of_blocksPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKReplyChannelRange>)>>(
      'ReplyChannelRange_get_number_of_blocks');
  late final _ReplyChannelRange_get_number_of_blocks =
      _ReplyChannelRange_get_number_of_blocksPtr.asFunction<
          int Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// The number of blocks included in the range of the reply
  void ReplyChannelRange_set_number_of_blocks(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
    int val,
  ) {
    return _ReplyChannelRange_set_number_of_blocks(
      this_ptr,
      val,
    );
  }

  late final _ReplyChannelRange_set_number_of_blocksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyChannelRange>,
              ffi.Uint32)>>('ReplyChannelRange_set_number_of_blocks');
  late final _ReplyChannelRange_set_number_of_blocks =
      _ReplyChannelRange_set_number_of_blocksPtr.asFunction<
          void Function(ffi.Pointer<LDKReplyChannelRange>, int)>();

  /// True when this is the final reply for a query
  bool ReplyChannelRange_get_sync_complete(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
  ) {
    return _ReplyChannelRange_get_sync_complete(
      this_ptr,
    );
  }

  late final _ReplyChannelRange_get_sync_completePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKReplyChannelRange>)>>(
      'ReplyChannelRange_get_sync_complete');
  late final _ReplyChannelRange_get_sync_complete =
      _ReplyChannelRange_get_sync_completePtr.asFunction<
          bool Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// True when this is the final reply for a query
  void ReplyChannelRange_set_sync_complete(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
    bool val,
  ) {
    return _ReplyChannelRange_set_sync_complete(
      this_ptr,
      val,
    );
  }

  late final _ReplyChannelRange_set_sync_completePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyChannelRange>,
              ffi.Bool)>>('ReplyChannelRange_set_sync_complete');
  late final _ReplyChannelRange_set_sync_complete =
      _ReplyChannelRange_set_sync_completePtr.asFunction<
          void Function(ffi.Pointer<LDKReplyChannelRange>, bool)>();

  /// The short_channel_ids in the channel range
  ///
  /// Returns a copy of the field.
  LDKCVec_u64Z ReplyChannelRange_get_short_channel_ids(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
  ) {
    return _ReplyChannelRange_get_short_channel_ids(
      this_ptr,
    );
  }

  late final _ReplyChannelRange_get_short_channel_idsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u64Z Function(ffi.Pointer<LDKReplyChannelRange>)>>(
      'ReplyChannelRange_get_short_channel_ids');
  late final _ReplyChannelRange_get_short_channel_ids =
      _ReplyChannelRange_get_short_channel_idsPtr.asFunction<
          LDKCVec_u64Z Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// The short_channel_ids in the channel range
  void ReplyChannelRange_set_short_channel_ids(
    ffi.Pointer<LDKReplyChannelRange> this_ptr,
    LDKCVec_u64Z val,
  ) {
    return _ReplyChannelRange_set_short_channel_ids(
      this_ptr,
      val,
    );
  }

  late final _ReplyChannelRange_set_short_channel_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyChannelRange>,
              LDKCVec_u64Z)>>('ReplyChannelRange_set_short_channel_ids');
  late final _ReplyChannelRange_set_short_channel_ids =
      _ReplyChannelRange_set_short_channel_idsPtr.asFunction<
          void Function(ffi.Pointer<LDKReplyChannelRange>, LDKCVec_u64Z)>();

  /// Constructs a new ReplyChannelRange given each field
  LDKReplyChannelRange ReplyChannelRange_new(
    LDKThirtyTwoBytes chain_hash_arg,
    int first_blocknum_arg,
    int number_of_blocks_arg,
    bool sync_complete_arg,
    LDKCVec_u64Z short_channel_ids_arg,
  ) {
    return _ReplyChannelRange_new(
      chain_hash_arg,
      first_blocknum_arg,
      number_of_blocks_arg,
      sync_complete_arg,
      short_channel_ids_arg,
    );
  }

  late final _ReplyChannelRange_newPtr = _lookup<
      ffi.NativeFunction<
          LDKReplyChannelRange Function(LDKThirtyTwoBytes, ffi.Uint32,
              ffi.Uint32, ffi.Bool, LDKCVec_u64Z)>>('ReplyChannelRange_new');
  late final _ReplyChannelRange_new = _ReplyChannelRange_newPtr.asFunction<
      LDKReplyChannelRange Function(
          LDKThirtyTwoBytes, int, int, bool, LDKCVec_u64Z)>();

  /// Creates a copy of the ReplyChannelRange
  LDKReplyChannelRange ReplyChannelRange_clone(
    ffi.Pointer<LDKReplyChannelRange> orig,
  ) {
    return _ReplyChannelRange_clone(
      orig,
    );
  }

  late final _ReplyChannelRange_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKReplyChannelRange Function(
              ffi.Pointer<LDKReplyChannelRange>)>>('ReplyChannelRange_clone');
  late final _ReplyChannelRange_clone = _ReplyChannelRange_clonePtr.asFunction<
      LDKReplyChannelRange Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
  void QueryShortChannelIds_free(
    LDKQueryShortChannelIds this_obj,
  ) {
    return _QueryShortChannelIds_free(
      this_obj,
    );
  }

  late final _QueryShortChannelIds_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKQueryShortChannelIds)>>(
          'QueryShortChannelIds_free');
  late final _QueryShortChannelIds_free = _QueryShortChannelIds_freePtr
      .asFunction<void Function(LDKQueryShortChannelIds)>();

  /// The genesis hash of the blockchain being queried
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> QueryShortChannelIds_get_chain_hash(
    ffi.Pointer<LDKQueryShortChannelIds> this_ptr,
  ) {
    return _QueryShortChannelIds_get_chain_hash(
      this_ptr,
    );
  }

  late final _QueryShortChannelIds_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKQueryShortChannelIds>)>>(
      'QueryShortChannelIds_get_chain_hash');
  late final _QueryShortChannelIds_get_chain_hash =
      _QueryShortChannelIds_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKQueryShortChannelIds>)>();

  /// The genesis hash of the blockchain being queried
  void QueryShortChannelIds_set_chain_hash(
    ffi.Pointer<LDKQueryShortChannelIds> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _QueryShortChannelIds_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _QueryShortChannelIds_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKQueryShortChannelIds>,
              LDKThirtyTwoBytes)>>('QueryShortChannelIds_set_chain_hash');
  late final _QueryShortChannelIds_set_chain_hash =
      _QueryShortChannelIds_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKQueryShortChannelIds>, LDKThirtyTwoBytes)>();

  /// The short_channel_ids that are being queried
  ///
  /// Returns a copy of the field.
  LDKCVec_u64Z QueryShortChannelIds_get_short_channel_ids(
    ffi.Pointer<LDKQueryShortChannelIds> this_ptr,
  ) {
    return _QueryShortChannelIds_get_short_channel_ids(
      this_ptr,
    );
  }

  late final _QueryShortChannelIds_get_short_channel_idsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u64Z Function(ffi.Pointer<LDKQueryShortChannelIds>)>>(
      'QueryShortChannelIds_get_short_channel_ids');
  late final _QueryShortChannelIds_get_short_channel_ids =
      _QueryShortChannelIds_get_short_channel_idsPtr.asFunction<
          LDKCVec_u64Z Function(ffi.Pointer<LDKQueryShortChannelIds>)>();

  /// The short_channel_ids that are being queried
  void QueryShortChannelIds_set_short_channel_ids(
    ffi.Pointer<LDKQueryShortChannelIds> this_ptr,
    LDKCVec_u64Z val,
  ) {
    return _QueryShortChannelIds_set_short_channel_ids(
      this_ptr,
      val,
    );
  }

  late final _QueryShortChannelIds_set_short_channel_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKQueryShortChannelIds>,
              LDKCVec_u64Z)>>('QueryShortChannelIds_set_short_channel_ids');
  late final _QueryShortChannelIds_set_short_channel_ids =
      _QueryShortChannelIds_set_short_channel_idsPtr.asFunction<
          void Function(ffi.Pointer<LDKQueryShortChannelIds>, LDKCVec_u64Z)>();

  /// Constructs a new QueryShortChannelIds given each field
  LDKQueryShortChannelIds QueryShortChannelIds_new(
    LDKThirtyTwoBytes chain_hash_arg,
    LDKCVec_u64Z short_channel_ids_arg,
  ) {
    return _QueryShortChannelIds_new(
      chain_hash_arg,
      short_channel_ids_arg,
    );
  }

  late final _QueryShortChannelIds_newPtr = _lookup<
      ffi.NativeFunction<
          LDKQueryShortChannelIds Function(
              LDKThirtyTwoBytes, LDKCVec_u64Z)>>('QueryShortChannelIds_new');
  late final _QueryShortChannelIds_new =
      _QueryShortChannelIds_newPtr.asFunction<
          LDKQueryShortChannelIds Function(LDKThirtyTwoBytes, LDKCVec_u64Z)>();

  /// Creates a copy of the QueryShortChannelIds
  LDKQueryShortChannelIds QueryShortChannelIds_clone(
    ffi.Pointer<LDKQueryShortChannelIds> orig,
  ) {
    return _QueryShortChannelIds_clone(
      orig,
    );
  }

  late final _QueryShortChannelIds_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKQueryShortChannelIds Function(
                  ffi.Pointer<LDKQueryShortChannelIds>)>>(
      'QueryShortChannelIds_clone');
  late final _QueryShortChannelIds_clone =
      _QueryShortChannelIds_clonePtr.asFunction<
          LDKQueryShortChannelIds Function(
              ffi.Pointer<LDKQueryShortChannelIds>)>();

  /// Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
  void ReplyShortChannelIdsEnd_free(
    LDKReplyShortChannelIdsEnd this_obj,
  ) {
    return _ReplyShortChannelIdsEnd_free(
      this_obj,
    );
  }

  late final _ReplyShortChannelIdsEnd_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKReplyShortChannelIdsEnd)>>(
      'ReplyShortChannelIdsEnd_free');
  late final _ReplyShortChannelIdsEnd_free = _ReplyShortChannelIdsEnd_freePtr
      .asFunction<void Function(LDKReplyShortChannelIdsEnd)>();

  /// The genesis hash of the blockchain that was queried
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> ReplyShortChannelIdsEnd_get_chain_hash(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> this_ptr,
  ) {
    return _ReplyShortChannelIdsEnd_get_chain_hash(
      this_ptr,
    );
  }

  late final _ReplyShortChannelIdsEnd_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKReplyShortChannelIdsEnd>)>>(
      'ReplyShortChannelIdsEnd_get_chain_hash');
  late final _ReplyShortChannelIdsEnd_get_chain_hash =
      _ReplyShortChannelIdsEnd_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKReplyShortChannelIdsEnd>)>();

  /// The genesis hash of the blockchain that was queried
  void ReplyShortChannelIdsEnd_set_chain_hash(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _ReplyShortChannelIdsEnd_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _ReplyShortChannelIdsEnd_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>,
              LDKThirtyTwoBytes)>>('ReplyShortChannelIdsEnd_set_chain_hash');
  late final _ReplyShortChannelIdsEnd_set_chain_hash =
      _ReplyShortChannelIdsEnd_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKReplyShortChannelIdsEnd>, LDKThirtyTwoBytes)>();

  /// Indicates if the query recipient maintains up-to-date channel
  /// information for the chain_hash
  bool ReplyShortChannelIdsEnd_get_full_information(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> this_ptr,
  ) {
    return _ReplyShortChannelIdsEnd_get_full_information(
      this_ptr,
    );
  }

  late final _ReplyShortChannelIdsEnd_get_full_informationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>)>>(
      'ReplyShortChannelIdsEnd_get_full_information');
  late final _ReplyShortChannelIdsEnd_get_full_information =
      _ReplyShortChannelIdsEnd_get_full_informationPtr.asFunction<
          bool Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>)>();

  /// Indicates if the query recipient maintains up-to-date channel
  /// information for the chain_hash
  void ReplyShortChannelIdsEnd_set_full_information(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> this_ptr,
    bool val,
  ) {
    return _ReplyShortChannelIdsEnd_set_full_information(
      this_ptr,
      val,
    );
  }

  late final _ReplyShortChannelIdsEnd_set_full_informationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>,
              ffi.Bool)>>('ReplyShortChannelIdsEnd_set_full_information');
  late final _ReplyShortChannelIdsEnd_set_full_information =
      _ReplyShortChannelIdsEnd_set_full_informationPtr.asFunction<
          void Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>, bool)>();

  /// Constructs a new ReplyShortChannelIdsEnd given each field
  LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(
    LDKThirtyTwoBytes chain_hash_arg,
    bool full_information_arg,
  ) {
    return _ReplyShortChannelIdsEnd_new(
      chain_hash_arg,
      full_information_arg,
    );
  }

  late final _ReplyShortChannelIdsEnd_newPtr = _lookup<
      ffi.NativeFunction<
          LDKReplyShortChannelIdsEnd Function(
              LDKThirtyTwoBytes, ffi.Bool)>>('ReplyShortChannelIdsEnd_new');
  late final _ReplyShortChannelIdsEnd_new =
      _ReplyShortChannelIdsEnd_newPtr.asFunction<
          LDKReplyShortChannelIdsEnd Function(LDKThirtyTwoBytes, bool)>();

  /// Creates a copy of the ReplyShortChannelIdsEnd
  LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> orig,
  ) {
    return _ReplyShortChannelIdsEnd_clone(
      orig,
    );
  }

  late final _ReplyShortChannelIdsEnd_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKReplyShortChannelIdsEnd Function(
                  ffi.Pointer<LDKReplyShortChannelIdsEnd>)>>(
      'ReplyShortChannelIdsEnd_clone');
  late final _ReplyShortChannelIdsEnd_clone =
      _ReplyShortChannelIdsEnd_clonePtr.asFunction<
          LDKReplyShortChannelIdsEnd Function(
              ffi.Pointer<LDKReplyShortChannelIdsEnd>)>();

  /// Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
  void GossipTimestampFilter_free(
    LDKGossipTimestampFilter this_obj,
  ) {
    return _GossipTimestampFilter_free(
      this_obj,
    );
  }

  late final _GossipTimestampFilter_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKGossipTimestampFilter)>>(
          'GossipTimestampFilter_free');
  late final _GossipTimestampFilter_free = _GossipTimestampFilter_freePtr
      .asFunction<void Function(LDKGossipTimestampFilter)>();

  /// The genesis hash of the blockchain for channel and node information
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> GossipTimestampFilter_get_chain_hash(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
  ) {
    return _GossipTimestampFilter_get_chain_hash(
      this_ptr,
    );
  }

  late final _GossipTimestampFilter_get_chain_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKGossipTimestampFilter>)>>(
      'GossipTimestampFilter_get_chain_hash');
  late final _GossipTimestampFilter_get_chain_hash =
      _GossipTimestampFilter_get_chain_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKGossipTimestampFilter>)>();

  /// The genesis hash of the blockchain for channel and node information
  void GossipTimestampFilter_set_chain_hash(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _GossipTimestampFilter_set_chain_hash(
      this_ptr,
      val,
    );
  }

  late final _GossipTimestampFilter_set_chain_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKGossipTimestampFilter>,
              LDKThirtyTwoBytes)>>('GossipTimestampFilter_set_chain_hash');
  late final _GossipTimestampFilter_set_chain_hash =
      _GossipTimestampFilter_set_chain_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKGossipTimestampFilter>, LDKThirtyTwoBytes)>();

  /// The starting unix timestamp
  int GossipTimestampFilter_get_first_timestamp(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
  ) {
    return _GossipTimestampFilter_get_first_timestamp(
      this_ptr,
    );
  }

  late final _GossipTimestampFilter_get_first_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKGossipTimestampFilter>)>>(
      'GossipTimestampFilter_get_first_timestamp');
  late final _GossipTimestampFilter_get_first_timestamp =
      _GossipTimestampFilter_get_first_timestampPtr.asFunction<
          int Function(ffi.Pointer<LDKGossipTimestampFilter>)>();

  /// The starting unix timestamp
  void GossipTimestampFilter_set_first_timestamp(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
    int val,
  ) {
    return _GossipTimestampFilter_set_first_timestamp(
      this_ptr,
      val,
    );
  }

  late final _GossipTimestampFilter_set_first_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKGossipTimestampFilter>,
              ffi.Uint32)>>('GossipTimestampFilter_set_first_timestamp');
  late final _GossipTimestampFilter_set_first_timestamp =
      _GossipTimestampFilter_set_first_timestampPtr.asFunction<
          void Function(ffi.Pointer<LDKGossipTimestampFilter>, int)>();

  /// The range of information in seconds
  int GossipTimestampFilter_get_timestamp_range(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
  ) {
    return _GossipTimestampFilter_get_timestamp_range(
      this_ptr,
    );
  }

  late final _GossipTimestampFilter_get_timestamp_rangePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKGossipTimestampFilter>)>>(
      'GossipTimestampFilter_get_timestamp_range');
  late final _GossipTimestampFilter_get_timestamp_range =
      _GossipTimestampFilter_get_timestamp_rangePtr.asFunction<
          int Function(ffi.Pointer<LDKGossipTimestampFilter>)>();

  /// The range of information in seconds
  void GossipTimestampFilter_set_timestamp_range(
    ffi.Pointer<LDKGossipTimestampFilter> this_ptr,
    int val,
  ) {
    return _GossipTimestampFilter_set_timestamp_range(
      this_ptr,
      val,
    );
  }

  late final _GossipTimestampFilter_set_timestamp_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKGossipTimestampFilter>,
              ffi.Uint32)>>('GossipTimestampFilter_set_timestamp_range');
  late final _GossipTimestampFilter_set_timestamp_range =
      _GossipTimestampFilter_set_timestamp_rangePtr.asFunction<
          void Function(ffi.Pointer<LDKGossipTimestampFilter>, int)>();

  /// Constructs a new GossipTimestampFilter given each field
  LDKGossipTimestampFilter GossipTimestampFilter_new(
    LDKThirtyTwoBytes chain_hash_arg,
    int first_timestamp_arg,
    int timestamp_range_arg,
  ) {
    return _GossipTimestampFilter_new(
      chain_hash_arg,
      first_timestamp_arg,
      timestamp_range_arg,
    );
  }

  late final _GossipTimestampFilter_newPtr = _lookup<
      ffi.NativeFunction<
          LDKGossipTimestampFilter Function(LDKThirtyTwoBytes, ffi.Uint32,
              ffi.Uint32)>>('GossipTimestampFilter_new');
  late final _GossipTimestampFilter_new =
      _GossipTimestampFilter_newPtr.asFunction<
          LDKGossipTimestampFilter Function(LDKThirtyTwoBytes, int, int)>();

  /// Creates a copy of the GossipTimestampFilter
  LDKGossipTimestampFilter GossipTimestampFilter_clone(
    ffi.Pointer<LDKGossipTimestampFilter> orig,
  ) {
    return _GossipTimestampFilter_clone(
      orig,
    );
  }

  late final _GossipTimestampFilter_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKGossipTimestampFilter Function(
                  ffi.Pointer<LDKGossipTimestampFilter>)>>(
      'GossipTimestampFilter_clone');
  late final _GossipTimestampFilter_clone =
      _GossipTimestampFilter_clonePtr.asFunction<
          LDKGossipTimestampFilter Function(
              ffi.Pointer<LDKGossipTimestampFilter>)>();

  /// Frees any resources used by the ErrorAction
  void ErrorAction_free(
    LDKErrorAction this_ptr,
  ) {
    return _ErrorAction_free(
      this_ptr,
    );
  }

  late final _ErrorAction_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKErrorAction)>>(
          'ErrorAction_free');
  late final _ErrorAction_free =
      _ErrorAction_freePtr.asFunction<void Function(LDKErrorAction)>();

  /// Creates a copy of the ErrorAction
  LDKErrorAction ErrorAction_clone(
    ffi.Pointer<LDKErrorAction> orig,
  ) {
    return _ErrorAction_clone(
      orig,
    );
  }

  late final _ErrorAction_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKErrorAction Function(
              ffi.Pointer<LDKErrorAction>)>>('ErrorAction_clone');
  late final _ErrorAction_clone = _ErrorAction_clonePtr.asFunction<
      LDKErrorAction Function(ffi.Pointer<LDKErrorAction>)>();

  /// Utility method to constructs a new DisconnectPeer-variant ErrorAction
  LDKErrorAction ErrorAction_disconnect_peer(
    LDKErrorMessage msg,
  ) {
    return _ErrorAction_disconnect_peer(
      msg,
    );
  }

  late final _ErrorAction_disconnect_peerPtr =
      _lookup<ffi.NativeFunction<LDKErrorAction Function(LDKErrorMessage)>>(
          'ErrorAction_disconnect_peer');
  late final _ErrorAction_disconnect_peer = _ErrorAction_disconnect_peerPtr
      .asFunction<LDKErrorAction Function(LDKErrorMessage)>();

  /// Utility method to constructs a new IgnoreError-variant ErrorAction
  LDKErrorAction ErrorAction_ignore_error() {
    return _ErrorAction_ignore_error();
  }

  late final _ErrorAction_ignore_errorPtr =
      _lookup<ffi.NativeFunction<LDKErrorAction Function()>>(
          'ErrorAction_ignore_error');
  late final _ErrorAction_ignore_error =
      _ErrorAction_ignore_errorPtr.asFunction<LDKErrorAction Function()>();

  /// Utility method to constructs a new IgnoreAndLog-variant ErrorAction
  LDKErrorAction ErrorAction_ignore_and_log(
    int a,
  ) {
    return _ErrorAction_ignore_and_log(
      a,
    );
  }

  late final _ErrorAction_ignore_and_logPtr =
      _lookup<ffi.NativeFunction<LDKErrorAction Function(ffi.Int32)>>(
          'ErrorAction_ignore_and_log');
  late final _ErrorAction_ignore_and_log =
      _ErrorAction_ignore_and_logPtr.asFunction<LDKErrorAction Function(int)>();

  /// Utility method to constructs a new IgnoreDuplicateGossip-variant ErrorAction
  LDKErrorAction ErrorAction_ignore_duplicate_gossip() {
    return _ErrorAction_ignore_duplicate_gossip();
  }

  late final _ErrorAction_ignore_duplicate_gossipPtr =
      _lookup<ffi.NativeFunction<LDKErrorAction Function()>>(
          'ErrorAction_ignore_duplicate_gossip');
  late final _ErrorAction_ignore_duplicate_gossip =
      _ErrorAction_ignore_duplicate_gossipPtr.asFunction<
          LDKErrorAction Function()>();

  /// Utility method to constructs a new SendErrorMessage-variant ErrorAction
  LDKErrorAction ErrorAction_send_error_message(
    LDKErrorMessage msg,
  ) {
    return _ErrorAction_send_error_message(
      msg,
    );
  }

  late final _ErrorAction_send_error_messagePtr =
      _lookup<ffi.NativeFunction<LDKErrorAction Function(LDKErrorMessage)>>(
          'ErrorAction_send_error_message');
  late final _ErrorAction_send_error_message =
      _ErrorAction_send_error_messagePtr.asFunction<
          LDKErrorAction Function(LDKErrorMessage)>();

  /// Utility method to constructs a new SendWarningMessage-variant ErrorAction
  LDKErrorAction ErrorAction_send_warning_message(
    LDKWarningMessage msg,
    int log_level,
  ) {
    return _ErrorAction_send_warning_message(
      msg,
      log_level,
    );
  }

  late final _ErrorAction_send_warning_messagePtr = _lookup<
      ffi.NativeFunction<
          LDKErrorAction Function(LDKWarningMessage,
              ffi.Int32)>>('ErrorAction_send_warning_message');
  late final _ErrorAction_send_warning_message =
      _ErrorAction_send_warning_messagePtr.asFunction<
          LDKErrorAction Function(LDKWarningMessage, int)>();

  /// Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
  void LightningError_free(
    LDKLightningError this_obj,
  ) {
    return _LightningError_free(
      this_obj,
    );
  }

  late final _LightningError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKLightningError)>>(
          'LightningError_free');
  late final _LightningError_free =
      _LightningError_freePtr.asFunction<void Function(LDKLightningError)>();

  /// A human-readable message describing the error
  LDKStr LightningError_get_err(
    ffi.Pointer<LDKLightningError> this_ptr,
  ) {
    return _LightningError_get_err(
      this_ptr,
    );
  }

  late final _LightningError_get_errPtr = _lookup<
          ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKLightningError>)>>(
      'LightningError_get_err');
  late final _LightningError_get_err = _LightningError_get_errPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKLightningError>)>();

  /// A human-readable message describing the error
  void LightningError_set_err(
    ffi.Pointer<LDKLightningError> this_ptr,
    LDKStr val,
  ) {
    return _LightningError_set_err(
      this_ptr,
      val,
    );
  }

  late final _LightningError_set_errPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKLightningError>,
              LDKStr)>>('LightningError_set_err');
  late final _LightningError_set_err = _LightningError_set_errPtr.asFunction<
      void Function(ffi.Pointer<LDKLightningError>, LDKStr)>();

  /// The action which should be taken against the offending peer.
  LDKErrorAction LightningError_get_action(
    ffi.Pointer<LDKLightningError> this_ptr,
  ) {
    return _LightningError_get_action(
      this_ptr,
    );
  }

  late final _LightningError_get_actionPtr = _lookup<
      ffi.NativeFunction<
          LDKErrorAction Function(
              ffi.Pointer<LDKLightningError>)>>('LightningError_get_action');
  late final _LightningError_get_action = _LightningError_get_actionPtr
      .asFunction<LDKErrorAction Function(ffi.Pointer<LDKLightningError>)>();

  /// The action which should be taken against the offending peer.
  void LightningError_set_action(
    ffi.Pointer<LDKLightningError> this_ptr,
    LDKErrorAction val,
  ) {
    return _LightningError_set_action(
      this_ptr,
      val,
    );
  }

  late final _LightningError_set_actionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKLightningError>,
              LDKErrorAction)>>('LightningError_set_action');
  late final _LightningError_set_action =
      _LightningError_set_actionPtr.asFunction<
          void Function(ffi.Pointer<LDKLightningError>, LDKErrorAction)>();

  /// Constructs a new LightningError given each field
  LDKLightningError LightningError_new(
    LDKStr err_arg,
    LDKErrorAction action_arg,
  ) {
    return _LightningError_new(
      err_arg,
      action_arg,
    );
  }

  late final _LightningError_newPtr = _lookup<
      ffi.NativeFunction<
          LDKLightningError Function(
              LDKStr, LDKErrorAction)>>('LightningError_new');
  late final _LightningError_new = _LightningError_newPtr.asFunction<
      LDKLightningError Function(LDKStr, LDKErrorAction)>();

  /// Creates a copy of the LightningError
  LDKLightningError LightningError_clone(
    ffi.Pointer<LDKLightningError> orig,
  ) {
    return _LightningError_clone(
      orig,
    );
  }

  late final _LightningError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKLightningError Function(
              ffi.Pointer<LDKLightningError>)>>('LightningError_clone');
  late final _LightningError_clone = _LightningError_clonePtr.asFunction<
      LDKLightningError Function(ffi.Pointer<LDKLightningError>)>();

  /// Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
  void CommitmentUpdate_free(
    LDKCommitmentUpdate this_obj,
  ) {
    return _CommitmentUpdate_free(
      this_obj,
    );
  }

  late final _CommitmentUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCommitmentUpdate)>>(
          'CommitmentUpdate_free');
  late final _CommitmentUpdate_free = _CommitmentUpdate_freePtr.asFunction<
      void Function(LDKCommitmentUpdate)>();

  /// update_add_htlc messages which should be sent
  LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_update_add_htlcs(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_update_add_htlcsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_UpdateAddHTLCZ Function(
                  ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_update_add_htlcs');
  late final _CommitmentUpdate_get_update_add_htlcs =
      _CommitmentUpdate_get_update_add_htlcsPtr.asFunction<
          LDKCVec_UpdateAddHTLCZ Function(ffi.Pointer<LDKCommitmentUpdate>)>();

  /// update_add_htlc messages which should be sent
  void CommitmentUpdate_set_update_add_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKCVec_UpdateAddHTLCZ val,
  ) {
    return _CommitmentUpdate_set_update_add_htlcs(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_update_add_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKCommitmentUpdate>, LDKCVec_UpdateAddHTLCZ)>>(
      'CommitmentUpdate_set_update_add_htlcs');
  late final _CommitmentUpdate_set_update_add_htlcs =
      _CommitmentUpdate_set_update_add_htlcsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCommitmentUpdate>, LDKCVec_UpdateAddHTLCZ)>();

  /// update_fulfill_htlc messages which should be sent
  LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_update_fulfill_htlcs(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_update_fulfill_htlcsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_UpdateFulfillHTLCZ Function(
                  ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_update_fulfill_htlcs');
  late final _CommitmentUpdate_get_update_fulfill_htlcs =
      _CommitmentUpdate_get_update_fulfill_htlcsPtr.asFunction<
          LDKCVec_UpdateFulfillHTLCZ Function(
              ffi.Pointer<LDKCommitmentUpdate>)>();

  /// update_fulfill_htlc messages which should be sent
  void CommitmentUpdate_set_update_fulfill_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKCVec_UpdateFulfillHTLCZ val,
  ) {
    return _CommitmentUpdate_set_update_fulfill_htlcs(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_update_fulfill_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKCommitmentUpdate>,
                  LDKCVec_UpdateFulfillHTLCZ)>>(
      'CommitmentUpdate_set_update_fulfill_htlcs');
  late final _CommitmentUpdate_set_update_fulfill_htlcs =
      _CommitmentUpdate_set_update_fulfill_htlcsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCommitmentUpdate>, LDKCVec_UpdateFulfillHTLCZ)>();

  /// update_fail_htlc messages which should be sent
  LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_update_fail_htlcs(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_update_fail_htlcsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_UpdateFailHTLCZ Function(
                  ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_update_fail_htlcs');
  late final _CommitmentUpdate_get_update_fail_htlcs =
      _CommitmentUpdate_get_update_fail_htlcsPtr.asFunction<
          LDKCVec_UpdateFailHTLCZ Function(ffi.Pointer<LDKCommitmentUpdate>)>();

  /// update_fail_htlc messages which should be sent
  void CommitmentUpdate_set_update_fail_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKCVec_UpdateFailHTLCZ val,
  ) {
    return _CommitmentUpdate_set_update_fail_htlcs(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_update_fail_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKCommitmentUpdate>, LDKCVec_UpdateFailHTLCZ)>>(
      'CommitmentUpdate_set_update_fail_htlcs');
  late final _CommitmentUpdate_set_update_fail_htlcs =
      _CommitmentUpdate_set_update_fail_htlcsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCommitmentUpdate>, LDKCVec_UpdateFailHTLCZ)>();

  /// update_fail_malformed_htlc messages which should be sent
  LDKCVec_UpdateFailMalformedHTLCZ
      CommitmentUpdate_get_update_fail_malformed_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_update_fail_malformed_htlcs(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_update_fail_malformed_htlcsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_UpdateFailMalformedHTLCZ Function(
                  ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_update_fail_malformed_htlcs');
  late final _CommitmentUpdate_get_update_fail_malformed_htlcs =
      _CommitmentUpdate_get_update_fail_malformed_htlcsPtr.asFunction<
          LDKCVec_UpdateFailMalformedHTLCZ Function(
              ffi.Pointer<LDKCommitmentUpdate>)>();

  /// update_fail_malformed_htlc messages which should be sent
  void CommitmentUpdate_set_update_fail_malformed_htlcs(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKCVec_UpdateFailMalformedHTLCZ val,
  ) {
    return _CommitmentUpdate_set_update_fail_malformed_htlcs(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_update_fail_malformed_htlcsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKCommitmentUpdate>,
                  LDKCVec_UpdateFailMalformedHTLCZ)>>(
      'CommitmentUpdate_set_update_fail_malformed_htlcs');
  late final _CommitmentUpdate_set_update_fail_malformed_htlcs =
      _CommitmentUpdate_set_update_fail_malformed_htlcsPtr.asFunction<
          void Function(ffi.Pointer<LDKCommitmentUpdate>,
              LDKCVec_UpdateFailMalformedHTLCZ)>();

  /// An update_fee message which should be sent
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKUpdateFee CommitmentUpdate_get_update_fee(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_update_fee(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_update_feePtr = _lookup<
          ffi.NativeFunction<
              LDKUpdateFee Function(ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_update_fee');
  late final _CommitmentUpdate_get_update_fee =
      _CommitmentUpdate_get_update_feePtr.asFunction<
          LDKUpdateFee Function(ffi.Pointer<LDKCommitmentUpdate>)>();

  /// An update_fee message which should be sent
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void CommitmentUpdate_set_update_fee(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKUpdateFee val,
  ) {
    return _CommitmentUpdate_set_update_fee(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_update_feePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCommitmentUpdate>,
              LDKUpdateFee)>>('CommitmentUpdate_set_update_fee');
  late final _CommitmentUpdate_set_update_fee =
      _CommitmentUpdate_set_update_feePtr.asFunction<
          void Function(ffi.Pointer<LDKCommitmentUpdate>, LDKUpdateFee)>();

  /// Finally, the commitment_signed message which should be sent
  LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
  ) {
    return _CommitmentUpdate_get_commitment_signed(
      this_ptr,
    );
  }

  late final _CommitmentUpdate_get_commitment_signedPtr = _lookup<
          ffi.NativeFunction<
              LDKCommitmentSigned Function(ffi.Pointer<LDKCommitmentUpdate>)>>(
      'CommitmentUpdate_get_commitment_signed');
  late final _CommitmentUpdate_get_commitment_signed =
      _CommitmentUpdate_get_commitment_signedPtr.asFunction<
          LDKCommitmentSigned Function(ffi.Pointer<LDKCommitmentUpdate>)>();

  /// Finally, the commitment_signed message which should be sent
  void CommitmentUpdate_set_commitment_signed(
    ffi.Pointer<LDKCommitmentUpdate> this_ptr,
    LDKCommitmentSigned val,
  ) {
    return _CommitmentUpdate_set_commitment_signed(
      this_ptr,
      val,
    );
  }

  late final _CommitmentUpdate_set_commitment_signedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKCommitmentUpdate>,
              LDKCommitmentSigned)>>('CommitmentUpdate_set_commitment_signed');
  late final _CommitmentUpdate_set_commitment_signed =
      _CommitmentUpdate_set_commitment_signedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCommitmentUpdate>, LDKCommitmentSigned)>();

  /// Constructs a new CommitmentUpdate given each field
  LDKCommitmentUpdate CommitmentUpdate_new(
    LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg,
    LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg,
    LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg,
    LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg,
    LDKUpdateFee update_fee_arg,
    LDKCommitmentSigned commitment_signed_arg,
  ) {
    return _CommitmentUpdate_new(
      update_add_htlcs_arg,
      update_fulfill_htlcs_arg,
      update_fail_htlcs_arg,
      update_fail_malformed_htlcs_arg,
      update_fee_arg,
      commitment_signed_arg,
    );
  }

  late final _CommitmentUpdate_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCommitmentUpdate Function(
              LDKCVec_UpdateAddHTLCZ,
              LDKCVec_UpdateFulfillHTLCZ,
              LDKCVec_UpdateFailHTLCZ,
              LDKCVec_UpdateFailMalformedHTLCZ,
              LDKUpdateFee,
              LDKCommitmentSigned)>>('CommitmentUpdate_new');
  late final _CommitmentUpdate_new = _CommitmentUpdate_newPtr.asFunction<
      LDKCommitmentUpdate Function(
          LDKCVec_UpdateAddHTLCZ,
          LDKCVec_UpdateFulfillHTLCZ,
          LDKCVec_UpdateFailHTLCZ,
          LDKCVec_UpdateFailMalformedHTLCZ,
          LDKUpdateFee,
          LDKCommitmentSigned)>();

  /// Creates a copy of the CommitmentUpdate
  LDKCommitmentUpdate CommitmentUpdate_clone(
    ffi.Pointer<LDKCommitmentUpdate> orig,
  ) {
    return _CommitmentUpdate_clone(
      orig,
    );
  }

  late final _CommitmentUpdate_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKCommitmentUpdate Function(
              ffi.Pointer<LDKCommitmentUpdate>)>>('CommitmentUpdate_clone');
  late final _CommitmentUpdate_clone = _CommitmentUpdate_clonePtr.asFunction<
      LDKCommitmentUpdate Function(ffi.Pointer<LDKCommitmentUpdate>)>();

  /// Calls the free function if one is set
  void ChannelMessageHandler_free(
    LDKChannelMessageHandler this_ptr,
  ) {
    return _ChannelMessageHandler_free(
      this_ptr,
    );
  }

  late final _ChannelMessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelMessageHandler)>>(
          'ChannelMessageHandler_free');
  late final _ChannelMessageHandler_free = _ChannelMessageHandler_freePtr
      .asFunction<void Function(LDKChannelMessageHandler)>();

  /// Calls the free function if one is set
  void RoutingMessageHandler_free(
    LDKRoutingMessageHandler this_ptr,
  ) {
    return _RoutingMessageHandler_free(
      this_ptr,
    );
  }

  late final _RoutingMessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRoutingMessageHandler)>>(
          'RoutingMessageHandler_free');
  late final _RoutingMessageHandler_free = _RoutingMessageHandler_freePtr
      .asFunction<void Function(LDKRoutingMessageHandler)>();

  /// Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
  LDKCVec_u8Z AcceptChannel_write(
    ffi.Pointer<LDKAcceptChannel> obj,
  ) {
    return _AcceptChannel_write(
      obj,
    );
  }

  late final _AcceptChannel_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKAcceptChannel>)>>('AcceptChannel_write');
  late final _AcceptChannel_write = _AcceptChannel_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKAcceptChannel>)>();

  /// Read a AcceptChannel from a byte array, created by AcceptChannel_write
  LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(
    LDKu8slice ser,
  ) {
    return _AcceptChannel_read(
      ser,
    );
  }

  late final _AcceptChannel_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_AcceptChannelDecodeErrorZ Function(
              LDKu8slice)>>('AcceptChannel_read');
  late final _AcceptChannel_read = _AcceptChannel_readPtr.asFunction<
      LDKCResult_AcceptChannelDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
  LDKCVec_u8Z AnnouncementSignatures_write(
    ffi.Pointer<LDKAnnouncementSignatures> obj,
  ) {
    return _AnnouncementSignatures_write(
      obj,
    );
  }

  late final _AnnouncementSignatures_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKAnnouncementSignatures>)>>(
      'AnnouncementSignatures_write');
  late final _AnnouncementSignatures_write =
      _AnnouncementSignatures_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKAnnouncementSignatures>)>();

  /// Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
  LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(
    LDKu8slice ser,
  ) {
    return _AnnouncementSignatures_read(
      ser,
    );
  }

  late final _AnnouncementSignatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(
              LDKu8slice)>>('AnnouncementSignatures_read');
  late final _AnnouncementSignatures_read =
      _AnnouncementSignatures_readPtr.asFunction<
          LDKCResult_AnnouncementSignaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
  LDKCVec_u8Z ChannelReestablish_write(
    ffi.Pointer<LDKChannelReestablish> obj,
  ) {
    return _ChannelReestablish_write(
      obj,
    );
  }

  late final _ChannelReestablish_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelReestablish>)>>('ChannelReestablish_write');
  late final _ChannelReestablish_write = _ChannelReestablish_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKChannelReestablish>)>();

  /// Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
  LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(
    LDKu8slice ser,
  ) {
    return _ChannelReestablish_read(
      ser,
    );
  }

  late final _ChannelReestablish_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelReestablishDecodeErrorZ Function(
              LDKu8slice)>>('ChannelReestablish_read');
  late final _ChannelReestablish_read = _ChannelReestablish_readPtr.asFunction<
      LDKCResult_ChannelReestablishDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
  LDKCVec_u8Z ClosingSigned_write(
    ffi.Pointer<LDKClosingSigned> obj,
  ) {
    return _ClosingSigned_write(
      obj,
    );
  }

  late final _ClosingSigned_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKClosingSigned>)>>('ClosingSigned_write');
  late final _ClosingSigned_write = _ClosingSigned_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKClosingSigned>)>();

  /// Read a ClosingSigned from a byte array, created by ClosingSigned_write
  LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(
    LDKu8slice ser,
  ) {
    return _ClosingSigned_read(
      ser,
    );
  }

  late final _ClosingSigned_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ClosingSignedDecodeErrorZ Function(
              LDKu8slice)>>('ClosingSigned_read');
  late final _ClosingSigned_read = _ClosingSigned_readPtr.asFunction<
      LDKCResult_ClosingSignedDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ClosingSignedFeeRange object into a byte array which can be read by ClosingSignedFeeRange_read
  LDKCVec_u8Z ClosingSignedFeeRange_write(
    ffi.Pointer<LDKClosingSignedFeeRange> obj,
  ) {
    return _ClosingSignedFeeRange_write(
      obj,
    );
  }

  late final _ClosingSignedFeeRange_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKClosingSignedFeeRange>)>>(
      'ClosingSignedFeeRange_write');
  late final _ClosingSignedFeeRange_write =
      _ClosingSignedFeeRange_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKClosingSignedFeeRange>)>();

  /// Read a ClosingSignedFeeRange from a byte array, created by ClosingSignedFeeRange_write
  LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(
    LDKu8slice ser,
  ) {
    return _ClosingSignedFeeRange_read(
      ser,
    );
  }

  late final _ClosingSignedFeeRange_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(
              LDKu8slice)>>('ClosingSignedFeeRange_read');
  late final _ClosingSignedFeeRange_read =
      _ClosingSignedFeeRange_readPtr.asFunction<
          LDKCResult_ClosingSignedFeeRangeDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
  LDKCVec_u8Z CommitmentSigned_write(
    ffi.Pointer<LDKCommitmentSigned> obj,
  ) {
    return _CommitmentSigned_write(
      obj,
    );
  }

  late final _CommitmentSigned_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKCommitmentSigned>)>>('CommitmentSigned_write');
  late final _CommitmentSigned_write = _CommitmentSigned_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKCommitmentSigned>)>();

  /// Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
  LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(
    LDKu8slice ser,
  ) {
    return _CommitmentSigned_read(
      ser,
    );
  }

  late final _CommitmentSigned_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CommitmentSignedDecodeErrorZ Function(
              LDKu8slice)>>('CommitmentSigned_read');
  late final _CommitmentSigned_read = _CommitmentSigned_readPtr.asFunction<
      LDKCResult_CommitmentSignedDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
  LDKCVec_u8Z FundingCreated_write(
    ffi.Pointer<LDKFundingCreated> obj,
  ) {
    return _FundingCreated_write(
      obj,
    );
  }

  late final _FundingCreated_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKFundingCreated>)>>('FundingCreated_write');
  late final _FundingCreated_write = _FundingCreated_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKFundingCreated>)>();

  /// Read a FundingCreated from a byte array, created by FundingCreated_write
  LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(
    LDKu8slice ser,
  ) {
    return _FundingCreated_read(
      ser,
    );
  }

  late final _FundingCreated_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingCreatedDecodeErrorZ Function(
              LDKu8slice)>>('FundingCreated_read');
  late final _FundingCreated_read = _FundingCreated_readPtr.asFunction<
      LDKCResult_FundingCreatedDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
  LDKCVec_u8Z FundingSigned_write(
    ffi.Pointer<LDKFundingSigned> obj,
  ) {
    return _FundingSigned_write(
      obj,
    );
  }

  late final _FundingSigned_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKFundingSigned>)>>('FundingSigned_write');
  late final _FundingSigned_write = _FundingSigned_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKFundingSigned>)>();

  /// Read a FundingSigned from a byte array, created by FundingSigned_write
  LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(
    LDKu8slice ser,
  ) {
    return _FundingSigned_read(
      ser,
    );
  }

  late final _FundingSigned_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FundingSignedDecodeErrorZ Function(
              LDKu8slice)>>('FundingSigned_read');
  late final _FundingSigned_read = _FundingSigned_readPtr.asFunction<
      LDKCResult_FundingSignedDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelReady object into a byte array which can be read by ChannelReady_read
  LDKCVec_u8Z ChannelReady_write(
    ffi.Pointer<LDKChannelReady> obj,
  ) {
    return _ChannelReady_write(
      obj,
    );
  }

  late final _ChannelReady_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelReady>)>>('ChannelReady_write');
  late final _ChannelReady_write = _ChannelReady_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelReady>)>();

  /// Read a ChannelReady from a byte array, created by ChannelReady_write
  LDKCResult_ChannelReadyDecodeErrorZ ChannelReady_read(
    LDKu8slice ser,
  ) {
    return _ChannelReady_read(
      ser,
    );
  }

  late final _ChannelReady_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelReadyDecodeErrorZ Function(
              LDKu8slice)>>('ChannelReady_read');
  late final _ChannelReady_read = _ChannelReady_readPtr.asFunction<
      LDKCResult_ChannelReadyDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the Init object into a byte array which can be read by Init_read
  LDKCVec_u8Z Init_write(
    ffi.Pointer<LDKInit> obj,
  ) {
    return _Init_write(
      obj,
    );
  }

  late final _Init_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKInit>)>>(
          'Init_write');
  late final _Init_write =
      _Init_writePtr.asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKInit>)>();

  /// Read a Init from a byte array, created by Init_write
  LDKCResult_InitDecodeErrorZ Init_read(
    LDKu8slice ser,
  ) {
    return _Init_read(
      ser,
    );
  }

  late final _Init_readPtr = _lookup<
          ffi.NativeFunction<LDKCResult_InitDecodeErrorZ Function(LDKu8slice)>>(
      'Init_read');
  late final _Init_read = _Init_readPtr.asFunction<
      LDKCResult_InitDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
  LDKCVec_u8Z OpenChannel_write(
    ffi.Pointer<LDKOpenChannel> obj,
  ) {
    return _OpenChannel_write(
      obj,
    );
  }

  late final _OpenChannel_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKOpenChannel>)>>('OpenChannel_write');
  late final _OpenChannel_write = _OpenChannel_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKOpenChannel>)>();

  /// Read a OpenChannel from a byte array, created by OpenChannel_write
  LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(
    LDKu8slice ser,
  ) {
    return _OpenChannel_read(
      ser,
    );
  }

  late final _OpenChannel_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_OpenChannelDecodeErrorZ Function(
              LDKu8slice)>>('OpenChannel_read');
  late final _OpenChannel_read = _OpenChannel_readPtr.asFunction<
      LDKCResult_OpenChannelDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
  LDKCVec_u8Z RevokeAndACK_write(
    ffi.Pointer<LDKRevokeAndACK> obj,
  ) {
    return _RevokeAndACK_write(
      obj,
    );
  }

  late final _RevokeAndACK_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKRevokeAndACK>)>>('RevokeAndACK_write');
  late final _RevokeAndACK_write = _RevokeAndACK_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRevokeAndACK>)>();

  /// Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
  LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(
    LDKu8slice ser,
  ) {
    return _RevokeAndACK_read(
      ser,
    );
  }

  late final _RevokeAndACK_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RevokeAndACKDecodeErrorZ Function(
              LDKu8slice)>>('RevokeAndACK_read');
  late final _RevokeAndACK_read = _RevokeAndACK_readPtr.asFunction<
      LDKCResult_RevokeAndACKDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the Shutdown object into a byte array which can be read by Shutdown_read
  LDKCVec_u8Z Shutdown_write(
    ffi.Pointer<LDKShutdown> obj,
  ) {
    return _Shutdown_write(
      obj,
    );
  }

  late final _Shutdown_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKShutdown>)>>(
      'Shutdown_write');
  late final _Shutdown_write = _Shutdown_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKShutdown>)>();

  /// Read a Shutdown from a byte array, created by Shutdown_write
  LDKCResult_ShutdownDecodeErrorZ Shutdown_read(
    LDKu8slice ser,
  ) {
    return _Shutdown_read(
      ser,
    );
  }

  late final _Shutdown_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownDecodeErrorZ Function(
              LDKu8slice)>>('Shutdown_read');
  late final _Shutdown_read = _Shutdown_readPtr.asFunction<
      LDKCResult_ShutdownDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
  LDKCVec_u8Z UpdateFailHTLC_write(
    ffi.Pointer<LDKUpdateFailHTLC> obj,
  ) {
    return _UpdateFailHTLC_write(
      obj,
    );
  }

  late final _UpdateFailHTLC_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKUpdateFailHTLC>)>>('UpdateFailHTLC_write');
  late final _UpdateFailHTLC_write = _UpdateFailHTLC_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFailHTLC>)>();

  /// Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
  LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(
    LDKu8slice ser,
  ) {
    return _UpdateFailHTLC_read(
      ser,
    );
  }

  late final _UpdateFailHTLC_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFailHTLCDecodeErrorZ Function(
              LDKu8slice)>>('UpdateFailHTLC_read');
  late final _UpdateFailHTLC_read = _UpdateFailHTLC_readPtr.asFunction<
      LDKCResult_UpdateFailHTLCDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
  LDKCVec_u8Z UpdateFailMalformedHTLC_write(
    ffi.Pointer<LDKUpdateFailMalformedHTLC> obj,
  ) {
    return _UpdateFailMalformedHTLC_write(
      obj,
    );
  }

  late final _UpdateFailMalformedHTLC_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>(
      'UpdateFailMalformedHTLC_write');
  late final _UpdateFailMalformedHTLC_write =
      _UpdateFailMalformedHTLC_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFailMalformedHTLC>)>();

  /// Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
  LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(
    LDKu8slice ser,
  ) {
    return _UpdateFailMalformedHTLC_read(
      ser,
    );
  }

  late final _UpdateFailMalformedHTLC_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
              LDKu8slice)>>('UpdateFailMalformedHTLC_read');
  late final _UpdateFailMalformedHTLC_read =
      _UpdateFailMalformedHTLC_readPtr.asFunction<
          LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ Function(
              LDKu8slice)>();

  /// Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
  LDKCVec_u8Z UpdateFee_write(
    ffi.Pointer<LDKUpdateFee> obj,
  ) {
    return _UpdateFee_write(
      obj,
    );
  }

  late final _UpdateFee_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFee>)>>(
      'UpdateFee_write');
  late final _UpdateFee_write = _UpdateFee_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFee>)>();

  /// Read a UpdateFee from a byte array, created by UpdateFee_write
  LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(
    LDKu8slice ser,
  ) {
    return _UpdateFee_read(
      ser,
    );
  }

  late final _UpdateFee_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFeeDecodeErrorZ Function(
              LDKu8slice)>>('UpdateFee_read');
  late final _UpdateFee_read = _UpdateFee_readPtr.asFunction<
      LDKCResult_UpdateFeeDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
  LDKCVec_u8Z UpdateFulfillHTLC_write(
    ffi.Pointer<LDKUpdateFulfillHTLC> obj,
  ) {
    return _UpdateFulfillHTLC_write(
      obj,
    );
  }

  late final _UpdateFulfillHTLC_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKUpdateFulfillHTLC>)>>('UpdateFulfillHTLC_write');
  late final _UpdateFulfillHTLC_write = _UpdateFulfillHTLC_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateFulfillHTLC>)>();

  /// Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
  LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(
    LDKu8slice ser,
  ) {
    return _UpdateFulfillHTLC_read(
      ser,
    );
  }

  late final _UpdateFulfillHTLC_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(
              LDKu8slice)>>('UpdateFulfillHTLC_read');
  late final _UpdateFulfillHTLC_read = _UpdateFulfillHTLC_readPtr.asFunction<
      LDKCResult_UpdateFulfillHTLCDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
  LDKCVec_u8Z UpdateAddHTLC_write(
    ffi.Pointer<LDKUpdateAddHTLC> obj,
  ) {
    return _UpdateAddHTLC_write(
      obj,
    );
  }

  late final _UpdateAddHTLC_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKUpdateAddHTLC>)>>('UpdateAddHTLC_write');
  late final _UpdateAddHTLC_write = _UpdateAddHTLC_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKUpdateAddHTLC>)>();

  /// Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
  LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(
    LDKu8slice ser,
  ) {
    return _UpdateAddHTLC_read(
      ser,
    );
  }

  late final _UpdateAddHTLC_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UpdateAddHTLCDecodeErrorZ Function(
              LDKu8slice)>>('UpdateAddHTLC_read');
  late final _UpdateAddHTLC_read = _UpdateAddHTLC_readPtr.asFunction<
      LDKCResult_UpdateAddHTLCDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the Ping object into a byte array which can be read by Ping_read
  LDKCVec_u8Z Ping_write(
    ffi.Pointer<LDKPing> obj,
  ) {
    return _Ping_write(
      obj,
    );
  }

  late final _Ping_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKPing>)>>(
          'Ping_write');
  late final _Ping_write =
      _Ping_writePtr.asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKPing>)>();

  /// Read a Ping from a byte array, created by Ping_write
  LDKCResult_PingDecodeErrorZ Ping_read(
    LDKu8slice ser,
  ) {
    return _Ping_read(
      ser,
    );
  }

  late final _Ping_readPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PingDecodeErrorZ Function(LDKu8slice)>>(
      'Ping_read');
  late final _Ping_read = _Ping_readPtr.asFunction<
      LDKCResult_PingDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the Pong object into a byte array which can be read by Pong_read
  LDKCVec_u8Z Pong_write(
    ffi.Pointer<LDKPong> obj,
  ) {
    return _Pong_write(
      obj,
    );
  }

  late final _Pong_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKPong>)>>(
          'Pong_write');
  late final _Pong_write =
      _Pong_writePtr.asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKPong>)>();

  /// Read a Pong from a byte array, created by Pong_write
  LDKCResult_PongDecodeErrorZ Pong_read(
    LDKu8slice ser,
  ) {
    return _Pong_read(
      ser,
    );
  }

  late final _Pong_readPtr = _lookup<
          ffi.NativeFunction<LDKCResult_PongDecodeErrorZ Function(LDKu8slice)>>(
      'Pong_read');
  late final _Pong_read = _Pong_readPtr.asFunction<
      LDKCResult_PongDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
  LDKCVec_u8Z UnsignedChannelAnnouncement_write(
    ffi.Pointer<LDKUnsignedChannelAnnouncement> obj,
  ) {
    return _UnsignedChannelAnnouncement_write(
      obj,
    );
  }

  late final _UnsignedChannelAnnouncement_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>(
      'UnsignedChannelAnnouncement_write');
  late final _UnsignedChannelAnnouncement_write =
      _UnsignedChannelAnnouncement_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedChannelAnnouncement>)>();

  /// Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
  LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ
      UnsignedChannelAnnouncement_read(
    LDKu8slice ser,
  ) {
    return _UnsignedChannelAnnouncement_read(
      ser,
    );
  }

  late final _UnsignedChannelAnnouncement_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
              LDKu8slice)>>('UnsignedChannelAnnouncement_read');
  late final _UnsignedChannelAnnouncement_read =
      _UnsignedChannelAnnouncement_readPtr.asFunction<
          LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ Function(
              LDKu8slice)>();

  /// Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
  LDKCVec_u8Z ChannelAnnouncement_write(
    ffi.Pointer<LDKChannelAnnouncement> obj,
  ) {
    return _ChannelAnnouncement_write(
      obj,
    );
  }

  late final _ChannelAnnouncement_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKChannelAnnouncement>)>>(
      'ChannelAnnouncement_write');
  late final _ChannelAnnouncement_write = _ChannelAnnouncement_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKChannelAnnouncement>)>();

  /// Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
  LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(
    LDKu8slice ser,
  ) {
    return _ChannelAnnouncement_read(
      ser,
    );
  }

  late final _ChannelAnnouncement_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(
              LDKu8slice)>>('ChannelAnnouncement_read');
  late final _ChannelAnnouncement_read =
      _ChannelAnnouncement_readPtr.asFunction<
          LDKCResult_ChannelAnnouncementDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
  LDKCVec_u8Z UnsignedChannelUpdate_write(
    ffi.Pointer<LDKUnsignedChannelUpdate> obj,
  ) {
    return _UnsignedChannelUpdate_write(
      obj,
    );
  }

  late final _UnsignedChannelUpdate_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'UnsignedChannelUpdate_write');
  late final _UnsignedChannelUpdate_write =
      _UnsignedChannelUpdate_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
  LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(
    LDKu8slice ser,
  ) {
    return _UnsignedChannelUpdate_read(
      ser,
    );
  }

  late final _UnsignedChannelUpdate_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(
              LDKu8slice)>>('UnsignedChannelUpdate_read');
  late final _UnsignedChannelUpdate_read =
      _UnsignedChannelUpdate_readPtr.asFunction<
          LDKCResult_UnsignedChannelUpdateDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
  LDKCVec_u8Z ChannelUpdate_write(
    ffi.Pointer<LDKChannelUpdate> obj,
  ) {
    return _ChannelUpdate_write(
      obj,
    );
  }

  late final _ChannelUpdate_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelUpdate>)>>('ChannelUpdate_write');
  late final _ChannelUpdate_write = _ChannelUpdate_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelUpdate>)>();

  /// Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
  LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(
    LDKu8slice ser,
  ) {
    return _ChannelUpdate_read(
      ser,
    );
  }

  late final _ChannelUpdate_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelUpdateDecodeErrorZ Function(
              LDKu8slice)>>('ChannelUpdate_read');
  late final _ChannelUpdate_read = _ChannelUpdate_readPtr.asFunction<
      LDKCResult_ChannelUpdateDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
  LDKCVec_u8Z ErrorMessage_write(
    ffi.Pointer<LDKErrorMessage> obj,
  ) {
    return _ErrorMessage_write(
      obj,
    );
  }

  late final _ErrorMessage_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKErrorMessage>)>>('ErrorMessage_write');
  late final _ErrorMessage_write = _ErrorMessage_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKErrorMessage>)>();

  /// Read a ErrorMessage from a byte array, created by ErrorMessage_write
  LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(
    LDKu8slice ser,
  ) {
    return _ErrorMessage_read(
      ser,
    );
  }

  late final _ErrorMessage_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ErrorMessageDecodeErrorZ Function(
              LDKu8slice)>>('ErrorMessage_read');
  late final _ErrorMessage_read = _ErrorMessage_readPtr.asFunction<
      LDKCResult_ErrorMessageDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the WarningMessage object into a byte array which can be read by WarningMessage_read
  LDKCVec_u8Z WarningMessage_write(
    ffi.Pointer<LDKWarningMessage> obj,
  ) {
    return _WarningMessage_write(
      obj,
    );
  }

  late final _WarningMessage_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKWarningMessage>)>>('WarningMessage_write');
  late final _WarningMessage_write = _WarningMessage_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKWarningMessage>)>();

  /// Read a WarningMessage from a byte array, created by WarningMessage_write
  LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(
    LDKu8slice ser,
  ) {
    return _WarningMessage_read(
      ser,
    );
  }

  late final _WarningMessage_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_WarningMessageDecodeErrorZ Function(
              LDKu8slice)>>('WarningMessage_read');
  late final _WarningMessage_read = _WarningMessage_readPtr.asFunction<
      LDKCResult_WarningMessageDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
  LDKCVec_u8Z UnsignedNodeAnnouncement_write(
    ffi.Pointer<LDKUnsignedNodeAnnouncement> obj,
  ) {
    return _UnsignedNodeAnnouncement_write(
      obj,
    );
  }

  late final _UnsignedNodeAnnouncement_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'UnsignedNodeAnnouncement_write');
  late final _UnsignedNodeAnnouncement_write =
      _UnsignedNodeAnnouncement_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
  LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(
    LDKu8slice ser,
  ) {
    return _UnsignedNodeAnnouncement_read(
      ser,
    );
  }

  late final _UnsignedNodeAnnouncement_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
              LDKu8slice)>>('UnsignedNodeAnnouncement_read');
  late final _UnsignedNodeAnnouncement_read =
      _UnsignedNodeAnnouncement_readPtr.asFunction<
          LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ Function(
              LDKu8slice)>();

  /// Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
  LDKCVec_u8Z NodeAnnouncement_write(
    ffi.Pointer<LDKNodeAnnouncement> obj,
  ) {
    return _NodeAnnouncement_write(
      obj,
    );
  }

  late final _NodeAnnouncement_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKNodeAnnouncement>)>>('NodeAnnouncement_write');
  late final _NodeAnnouncement_write = _NodeAnnouncement_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNodeAnnouncement>)>();

  /// Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
  LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(
    LDKu8slice ser,
  ) {
    return _NodeAnnouncement_read(
      ser,
    );
  }

  late final _NodeAnnouncement_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAnnouncementDecodeErrorZ Function(
              LDKu8slice)>>('NodeAnnouncement_read');
  late final _NodeAnnouncement_read = _NodeAnnouncement_readPtr.asFunction<
      LDKCResult_NodeAnnouncementDecodeErrorZ Function(LDKu8slice)>();

  /// Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
  LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(
    LDKu8slice ser,
  ) {
    return _QueryShortChannelIds_read(
      ser,
    );
  }

  late final _QueryShortChannelIds_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(
              LDKu8slice)>>('QueryShortChannelIds_read');
  late final _QueryShortChannelIds_read =
      _QueryShortChannelIds_readPtr.asFunction<
          LDKCResult_QueryShortChannelIdsDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
  LDKCVec_u8Z QueryShortChannelIds_write(
    ffi.Pointer<LDKQueryShortChannelIds> obj,
  ) {
    return _QueryShortChannelIds_write(
      obj,
    );
  }

  late final _QueryShortChannelIds_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKQueryShortChannelIds>)>>(
      'QueryShortChannelIds_write');
  late final _QueryShortChannelIds_write = _QueryShortChannelIds_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKQueryShortChannelIds>)>();

  /// Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
  LDKCVec_u8Z ReplyShortChannelIdsEnd_write(
    ffi.Pointer<LDKReplyShortChannelIdsEnd> obj,
  ) {
    return _ReplyShortChannelIdsEnd_write(
      obj,
    );
  }

  late final _ReplyShortChannelIdsEnd_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>)>>(
      'ReplyShortChannelIdsEnd_write');
  late final _ReplyShortChannelIdsEnd_write =
      _ReplyShortChannelIdsEnd_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKReplyShortChannelIdsEnd>)>();

  /// Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
  LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(
    LDKu8slice ser,
  ) {
    return _ReplyShortChannelIdsEnd_read(
      ser,
    );
  }

  late final _ReplyShortChannelIdsEnd_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
              LDKu8slice)>>('ReplyShortChannelIdsEnd_read');
  late final _ReplyShortChannelIdsEnd_read =
      _ReplyShortChannelIdsEnd_readPtr.asFunction<
          LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ Function(
              LDKu8slice)>();

  /// \n\t * Calculates the overflow safe ending block height for the query.\n\t * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`\n\t
  int QueryChannelRange_end_blocknum(
    ffi.Pointer<LDKQueryChannelRange> this_arg,
  ) {
    return _QueryChannelRange_end_blocknum(
      this_arg,
    );
  }

  late final _QueryChannelRange_end_blocknumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKQueryChannelRange>)>>(
      'QueryChannelRange_end_blocknum');
  late final _QueryChannelRange_end_blocknum =
      _QueryChannelRange_end_blocknumPtr.asFunction<
          int Function(ffi.Pointer<LDKQueryChannelRange>)>();

  /// Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
  LDKCVec_u8Z QueryChannelRange_write(
    ffi.Pointer<LDKQueryChannelRange> obj,
  ) {
    return _QueryChannelRange_write(
      obj,
    );
  }

  late final _QueryChannelRange_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKQueryChannelRange>)>>('QueryChannelRange_write');
  late final _QueryChannelRange_write = _QueryChannelRange_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKQueryChannelRange>)>();

  /// Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
  LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(
    LDKu8slice ser,
  ) {
    return _QueryChannelRange_read(
      ser,
    );
  }

  late final _QueryChannelRange_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_QueryChannelRangeDecodeErrorZ Function(
              LDKu8slice)>>('QueryChannelRange_read');
  late final _QueryChannelRange_read = _QueryChannelRange_readPtr.asFunction<
      LDKCResult_QueryChannelRangeDecodeErrorZ Function(LDKu8slice)>();

  /// Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
  LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(
    LDKu8slice ser,
  ) {
    return _ReplyChannelRange_read(
      ser,
    );
  }

  late final _ReplyChannelRange_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ReplyChannelRangeDecodeErrorZ Function(
              LDKu8slice)>>('ReplyChannelRange_read');
  late final _ReplyChannelRange_read = _ReplyChannelRange_readPtr.asFunction<
      LDKCResult_ReplyChannelRangeDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
  LDKCVec_u8Z ReplyChannelRange_write(
    ffi.Pointer<LDKReplyChannelRange> obj,
  ) {
    return _ReplyChannelRange_write(
      obj,
    );
  }

  late final _ReplyChannelRange_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKReplyChannelRange>)>>('ReplyChannelRange_write');
  late final _ReplyChannelRange_write = _ReplyChannelRange_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKReplyChannelRange>)>();

  /// Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
  LDKCVec_u8Z GossipTimestampFilter_write(
    ffi.Pointer<LDKGossipTimestampFilter> obj,
  ) {
    return _GossipTimestampFilter_write(
      obj,
    );
  }

  late final _GossipTimestampFilter_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKGossipTimestampFilter>)>>(
      'GossipTimestampFilter_write');
  late final _GossipTimestampFilter_write =
      _GossipTimestampFilter_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKGossipTimestampFilter>)>();

  /// Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
  LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(
    LDKu8slice ser,
  ) {
    return _GossipTimestampFilter_read(
      ser,
    );
  }

  late final _GossipTimestampFilter_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_GossipTimestampFilterDecodeErrorZ Function(
              LDKu8slice)>>('GossipTimestampFilter_read');
  late final _GossipTimestampFilter_read =
      _GossipTimestampFilter_readPtr.asFunction<
          LDKCResult_GossipTimestampFilterDecodeErrorZ Function(LDKu8slice)>();

  /// Calls the free function if one is set
  void CustomMessageHandler_free(
    LDKCustomMessageHandler this_ptr,
  ) {
    return _CustomMessageHandler_free(
      this_ptr,
    );
  }

  late final _CustomMessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCustomMessageHandler)>>(
          'CustomMessageHandler_free');
  late final _CustomMessageHandler_free = _CustomMessageHandler_freePtr
      .asFunction<void Function(LDKCustomMessageHandler)>();

  /// Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
  void IgnoringMessageHandler_free(
    LDKIgnoringMessageHandler this_obj,
  ) {
    return _IgnoringMessageHandler_free(
      this_obj,
    );
  }

  late final _IgnoringMessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKIgnoringMessageHandler)>>(
          'IgnoringMessageHandler_free');
  late final _IgnoringMessageHandler_free = _IgnoringMessageHandler_freePtr
      .asFunction<void Function(LDKIgnoringMessageHandler)>();

  /// Constructs a new IgnoringMessageHandler given each field
  LDKIgnoringMessageHandler IgnoringMessageHandler_new() {
    return _IgnoringMessageHandler_new();
  }

  late final _IgnoringMessageHandler_newPtr =
      _lookup<ffi.NativeFunction<LDKIgnoringMessageHandler Function()>>(
          'IgnoringMessageHandler_new');
  late final _IgnoringMessageHandler_new = _IgnoringMessageHandler_newPtr
      .asFunction<LDKIgnoringMessageHandler Function()>();

  /// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
  LDKMessageSendEventsProvider
      IgnoringMessageHandler_as_MessageSendEventsProvider(
    ffi.Pointer<LDKIgnoringMessageHandler> this_arg,
  ) {
    return _IgnoringMessageHandler_as_MessageSendEventsProvider(
      this_arg,
    );
  }

  late final _IgnoringMessageHandler_as_MessageSendEventsProviderPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEventsProvider Function(
                  ffi.Pointer<LDKIgnoringMessageHandler>)>>(
      'IgnoringMessageHandler_as_MessageSendEventsProvider');
  late final _IgnoringMessageHandler_as_MessageSendEventsProvider =
      _IgnoringMessageHandler_as_MessageSendEventsProviderPtr.asFunction<
          LDKMessageSendEventsProvider Function(
              ffi.Pointer<LDKIgnoringMessageHandler>)>();

  /// Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
  LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(
    ffi.Pointer<LDKIgnoringMessageHandler> this_arg,
  ) {
    return _IgnoringMessageHandler_as_RoutingMessageHandler(
      this_arg,
    );
  }

  late final _IgnoringMessageHandler_as_RoutingMessageHandlerPtr = _lookup<
          ffi.NativeFunction<
              LDKRoutingMessageHandler Function(
                  ffi.Pointer<LDKIgnoringMessageHandler>)>>(
      'IgnoringMessageHandler_as_RoutingMessageHandler');
  late final _IgnoringMessageHandler_as_RoutingMessageHandler =
      _IgnoringMessageHandler_as_RoutingMessageHandlerPtr.asFunction<
          LDKRoutingMessageHandler Function(
              ffi.Pointer<LDKIgnoringMessageHandler>)>();

  /// Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
  LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(
    ffi.Pointer<LDKIgnoringMessageHandler> this_arg,
  ) {
    return _IgnoringMessageHandler_as_CustomMessageReader(
      this_arg,
    );
  }

  late final _IgnoringMessageHandler_as_CustomMessageReaderPtr = _lookup<
          ffi.NativeFunction<
              LDKCustomMessageReader Function(
                  ffi.Pointer<LDKIgnoringMessageHandler>)>>(
      'IgnoringMessageHandler_as_CustomMessageReader');
  late final _IgnoringMessageHandler_as_CustomMessageReader =
      _IgnoringMessageHandler_as_CustomMessageReaderPtr.asFunction<
          LDKCustomMessageReader Function(
              ffi.Pointer<LDKIgnoringMessageHandler>)>();

  /// Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
  LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(
    ffi.Pointer<LDKIgnoringMessageHandler> this_arg,
  ) {
    return _IgnoringMessageHandler_as_CustomMessageHandler(
      this_arg,
    );
  }

  late final _IgnoringMessageHandler_as_CustomMessageHandlerPtr = _lookup<
          ffi.NativeFunction<
              LDKCustomMessageHandler Function(
                  ffi.Pointer<LDKIgnoringMessageHandler>)>>(
      'IgnoringMessageHandler_as_CustomMessageHandler');
  late final _IgnoringMessageHandler_as_CustomMessageHandler =
      _IgnoringMessageHandler_as_CustomMessageHandlerPtr.asFunction<
          LDKCustomMessageHandler Function(
              ffi.Pointer<LDKIgnoringMessageHandler>)>();

  /// Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
  void ErroringMessageHandler_free(
    LDKErroringMessageHandler this_obj,
  ) {
    return _ErroringMessageHandler_free(
      this_obj,
    );
  }

  late final _ErroringMessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKErroringMessageHandler)>>(
          'ErroringMessageHandler_free');
  late final _ErroringMessageHandler_free = _ErroringMessageHandler_freePtr
      .asFunction<void Function(LDKErroringMessageHandler)>();

  /// Constructs a new ErroringMessageHandler
  LDKErroringMessageHandler ErroringMessageHandler_new() {
    return _ErroringMessageHandler_new();
  }

  late final _ErroringMessageHandler_newPtr =
      _lookup<ffi.NativeFunction<LDKErroringMessageHandler Function()>>(
          'ErroringMessageHandler_new');
  late final _ErroringMessageHandler_new = _ErroringMessageHandler_newPtr
      .asFunction<LDKErroringMessageHandler Function()>();

  /// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
  LDKMessageSendEventsProvider
      ErroringMessageHandler_as_MessageSendEventsProvider(
    ffi.Pointer<LDKErroringMessageHandler> this_arg,
  ) {
    return _ErroringMessageHandler_as_MessageSendEventsProvider(
      this_arg,
    );
  }

  late final _ErroringMessageHandler_as_MessageSendEventsProviderPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEventsProvider Function(
                  ffi.Pointer<LDKErroringMessageHandler>)>>(
      'ErroringMessageHandler_as_MessageSendEventsProvider');
  late final _ErroringMessageHandler_as_MessageSendEventsProvider =
      _ErroringMessageHandler_as_MessageSendEventsProviderPtr.asFunction<
          LDKMessageSendEventsProvider Function(
              ffi.Pointer<LDKErroringMessageHandler>)>();

  /// Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
  LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(
    ffi.Pointer<LDKErroringMessageHandler> this_arg,
  ) {
    return _ErroringMessageHandler_as_ChannelMessageHandler(
      this_arg,
    );
  }

  late final _ErroringMessageHandler_as_ChannelMessageHandlerPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelMessageHandler Function(
                  ffi.Pointer<LDKErroringMessageHandler>)>>(
      'ErroringMessageHandler_as_ChannelMessageHandler');
  late final _ErroringMessageHandler_as_ChannelMessageHandler =
      _ErroringMessageHandler_as_ChannelMessageHandlerPtr.asFunction<
          LDKChannelMessageHandler Function(
              ffi.Pointer<LDKErroringMessageHandler>)>();

  /// Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
  void MessageHandler_free(
    LDKMessageHandler this_obj,
  ) {
    return _MessageHandler_free(
      this_obj,
    );
  }

  late final _MessageHandler_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKMessageHandler)>>(
          'MessageHandler_free');
  late final _MessageHandler_free =
      _MessageHandler_freePtr.asFunction<void Function(LDKMessageHandler)>();

  /// A message handler which handles messages specific to channels. Usually this is just a
  /// [`ChannelManager`] object or an [`ErroringMessageHandler`].
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  ffi.Pointer<LDKChannelMessageHandler> MessageHandler_get_chan_handler(
    ffi.Pointer<LDKMessageHandler> this_ptr,
  ) {
    return _MessageHandler_get_chan_handler(
      this_ptr,
    );
  }

  late final _MessageHandler_get_chan_handlerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKChannelMessageHandler> Function(
                  ffi.Pointer<LDKMessageHandler>)>>(
      'MessageHandler_get_chan_handler');
  late final _MessageHandler_get_chan_handler =
      _MessageHandler_get_chan_handlerPtr.asFunction<
          ffi.Pointer<LDKChannelMessageHandler> Function(
              ffi.Pointer<LDKMessageHandler>)>();

  /// A message handler which handles messages specific to channels. Usually this is just a
  /// [`ChannelManager`] object or an [`ErroringMessageHandler`].
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  void MessageHandler_set_chan_handler(
    ffi.Pointer<LDKMessageHandler> this_ptr,
    LDKChannelMessageHandler val,
  ) {
    return _MessageHandler_set_chan_handler(
      this_ptr,
      val,
    );
  }

  late final _MessageHandler_set_chan_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKMessageHandler>,
              LDKChannelMessageHandler)>>('MessageHandler_set_chan_handler');
  late final _MessageHandler_set_chan_handler =
      _MessageHandler_set_chan_handlerPtr.asFunction<
          void Function(
              ffi.Pointer<LDKMessageHandler>, LDKChannelMessageHandler)>();

  /// A message handler which handles messages updating our knowledge of the network channel
  /// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
  ///
  /// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
  ffi.Pointer<LDKRoutingMessageHandler> MessageHandler_get_route_handler(
    ffi.Pointer<LDKMessageHandler> this_ptr,
  ) {
    return _MessageHandler_get_route_handler(
      this_ptr,
    );
  }

  late final _MessageHandler_get_route_handlerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<LDKRoutingMessageHandler> Function(
                  ffi.Pointer<LDKMessageHandler>)>>(
      'MessageHandler_get_route_handler');
  late final _MessageHandler_get_route_handler =
      _MessageHandler_get_route_handlerPtr.asFunction<
          ffi.Pointer<LDKRoutingMessageHandler> Function(
              ffi.Pointer<LDKMessageHandler>)>();

  /// A message handler which handles messages updating our knowledge of the network channel
  /// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
  ///
  /// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
  void MessageHandler_set_route_handler(
    ffi.Pointer<LDKMessageHandler> this_ptr,
    LDKRoutingMessageHandler val,
  ) {
    return _MessageHandler_set_route_handler(
      this_ptr,
      val,
    );
  }

  late final _MessageHandler_set_route_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKMessageHandler>,
              LDKRoutingMessageHandler)>>('MessageHandler_set_route_handler');
  late final _MessageHandler_set_route_handler =
      _MessageHandler_set_route_handlerPtr.asFunction<
          void Function(
              ffi.Pointer<LDKMessageHandler>, LDKRoutingMessageHandler)>();

  /// Constructs a new MessageHandler given each field
  LDKMessageHandler MessageHandler_new(
    LDKChannelMessageHandler chan_handler_arg,
    LDKRoutingMessageHandler route_handler_arg,
  ) {
    return _MessageHandler_new(
      chan_handler_arg,
      route_handler_arg,
    );
  }

  late final _MessageHandler_newPtr = _lookup<
      ffi.NativeFunction<
          LDKMessageHandler Function(LDKChannelMessageHandler,
              LDKRoutingMessageHandler)>>('MessageHandler_new');
  late final _MessageHandler_new = _MessageHandler_newPtr.asFunction<
      LDKMessageHandler Function(
          LDKChannelMessageHandler, LDKRoutingMessageHandler)>();

  /// Creates a copy of a SocketDescriptor
  LDKSocketDescriptor SocketDescriptor_clone(
    ffi.Pointer<LDKSocketDescriptor> orig,
  ) {
    return _SocketDescriptor_clone(
      orig,
    );
  }

  late final _SocketDescriptor_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKSocketDescriptor Function(
              ffi.Pointer<LDKSocketDescriptor>)>>('SocketDescriptor_clone');
  late final _SocketDescriptor_clone = _SocketDescriptor_clonePtr.asFunction<
      LDKSocketDescriptor Function(ffi.Pointer<LDKSocketDescriptor>)>();

  /// Calls the free function if one is set
  void SocketDescriptor_free(
    LDKSocketDescriptor this_ptr,
  ) {
    return _SocketDescriptor_free(
      this_ptr,
    );
  }

  late final _SocketDescriptor_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKSocketDescriptor)>>(
          'SocketDescriptor_free');
  late final _SocketDescriptor_free = _SocketDescriptor_freePtr.asFunction<
      void Function(LDKSocketDescriptor)>();

  /// Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
  void PeerHandleError_free(
    LDKPeerHandleError this_obj,
  ) {
    return _PeerHandleError_free(
      this_obj,
    );
  }

  late final _PeerHandleError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPeerHandleError)>>(
          'PeerHandleError_free');
  late final _PeerHandleError_free =
      _PeerHandleError_freePtr.asFunction<void Function(LDKPeerHandleError)>();

  /// Used to indicate that we probably can't make any future connections to this peer (e.g.
  /// because we required features that our peer was missing, or vice versa).
  ///
  /// While LDK's [`ChannelManager`] will not do it automatically, you likely wish to force-close
  /// any channels with this peer or check for new versions of LDK.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  bool PeerHandleError_get_no_connection_possible(
    ffi.Pointer<LDKPeerHandleError> this_ptr,
  ) {
    return _PeerHandleError_get_no_connection_possible(
      this_ptr,
    );
  }

  late final _PeerHandleError_get_no_connection_possiblePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKPeerHandleError>)>>(
      'PeerHandleError_get_no_connection_possible');
  late final _PeerHandleError_get_no_connection_possible =
      _PeerHandleError_get_no_connection_possiblePtr.asFunction<
          bool Function(ffi.Pointer<LDKPeerHandleError>)>();

  /// Used to indicate that we probably can't make any future connections to this peer (e.g.
  /// because we required features that our peer was missing, or vice versa).
  ///
  /// While LDK's [`ChannelManager`] will not do it automatically, you likely wish to force-close
  /// any channels with this peer or check for new versions of LDK.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  void PeerHandleError_set_no_connection_possible(
    ffi.Pointer<LDKPeerHandleError> this_ptr,
    bool val,
  ) {
    return _PeerHandleError_set_no_connection_possible(
      this_ptr,
      val,
    );
  }

  late final _PeerHandleError_set_no_connection_possiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPeerHandleError>,
              ffi.Bool)>>('PeerHandleError_set_no_connection_possible');
  late final _PeerHandleError_set_no_connection_possible =
      _PeerHandleError_set_no_connection_possiblePtr.asFunction<
          void Function(ffi.Pointer<LDKPeerHandleError>, bool)>();

  /// Constructs a new PeerHandleError given each field
  LDKPeerHandleError PeerHandleError_new(
    bool no_connection_possible_arg,
  ) {
    return _PeerHandleError_new(
      no_connection_possible_arg,
    );
  }

  late final _PeerHandleError_newPtr =
      _lookup<ffi.NativeFunction<LDKPeerHandleError Function(ffi.Bool)>>(
          'PeerHandleError_new');
  late final _PeerHandleError_new =
      _PeerHandleError_newPtr.asFunction<LDKPeerHandleError Function(bool)>();

  /// Creates a copy of the PeerHandleError
  LDKPeerHandleError PeerHandleError_clone(
    ffi.Pointer<LDKPeerHandleError> orig,
  ) {
    return _PeerHandleError_clone(
      orig,
    );
  }

  late final _PeerHandleError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPeerHandleError Function(
              ffi.Pointer<LDKPeerHandleError>)>>('PeerHandleError_clone');
  late final _PeerHandleError_clone = _PeerHandleError_clonePtr.asFunction<
      LDKPeerHandleError Function(ffi.Pointer<LDKPeerHandleError>)>();

  /// Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
  void PeerManager_free(
    LDKPeerManager this_obj,
  ) {
    return _PeerManager_free(
      this_obj,
    );
  }

  late final _PeerManager_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPeerManager)>>(
          'PeerManager_free');
  late final _PeerManager_free =
      _PeerManager_freePtr.asFunction<void Function(LDKPeerManager)>();

  /// Constructs a new PeerManager with the given message handlers and node_id secret key
  /// ephemeral_random_data is used to derive per-connection ephemeral keys and must be
  /// cryptographically secure random bytes.
  LDKPeerManager PeerManager_new(
    LDKMessageHandler message_handler,
    LDKSecretKey our_node_secret,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> ephemeral_random_data,
    LDKLogger logger,
    LDKCustomMessageHandler custom_message_handler,
  ) {
    return _PeerManager_new(
      message_handler,
      our_node_secret,
      ephemeral_random_data,
      logger,
      custom_message_handler,
    );
  }

  late final _PeerManager_newPtr = _lookup<
      ffi.NativeFunction<
          LDKPeerManager Function(
              LDKMessageHandler,
              LDKSecretKey,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKLogger,
              LDKCustomMessageHandler)>>('PeerManager_new');
  late final _PeerManager_new = _PeerManager_newPtr.asFunction<
      LDKPeerManager Function(
          LDKMessageHandler,
          LDKSecretKey,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          LDKLogger,
          LDKCustomMessageHandler)>();

  /// Get the list of node ids for peers which have completed the initial handshake.
  ///
  /// For outbound connections, this will be the same as the their_node_id parameter passed in to
  /// new_outbound_connection, however entries will only appear once the initial handshake has
  /// completed and we are sure the remote peer has the private key for the given node_id.
  LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(
    ffi.Pointer<LDKPeerManager> this_arg,
  ) {
    return _PeerManager_get_peer_node_ids(
      this_arg,
    );
  }

  late final _PeerManager_get_peer_node_idsPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_PublicKeyZ Function(
              ffi.Pointer<LDKPeerManager>)>>('PeerManager_get_peer_node_ids');
  late final _PeerManager_get_peer_node_ids = _PeerManager_get_peer_node_idsPtr
      .asFunction<LDKCVec_PublicKeyZ Function(ffi.Pointer<LDKPeerManager>)>();

  /// Indicates a new outbound connection has been established to a node with the given node_id
  /// and an optional remote network address.
  ///
  /// The remote network address adds the option to report a remote IP address back to a connecting
  /// peer using the init message.
  /// The user should pass the remote network address of the host they are connected to.
  ///
  /// If an `Err` is returned here you must disconnect the connection immediately.
  ///
  /// Returns a small number of bytes to send to the remote node (currently always 50).
  ///
  /// Panics if descriptor is duplicative with some other descriptor which has not yet been
  /// [`socket_disconnected()`].
  ///
  /// [`socket_disconnected()`]: PeerManager::socket_disconnected
  LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(
    ffi.Pointer<LDKPeerManager> this_arg,
    LDKPublicKey their_node_id,
    LDKSocketDescriptor descriptor,
    LDKCOption_NetAddressZ remote_network_address,
  ) {
    return _PeerManager_new_outbound_connection(
      this_arg,
      their_node_id,
      descriptor,
      remote_network_address,
    );
  }

  late final _PeerManager_new_outbound_connectionPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
              ffi.Pointer<LDKPeerManager>,
              LDKPublicKey,
              LDKSocketDescriptor,
              LDKCOption_NetAddressZ)>>('PeerManager_new_outbound_connection');
  late final _PeerManager_new_outbound_connection =
      _PeerManager_new_outbound_connectionPtr.asFunction<
          LDKCResult_CVec_u8ZPeerHandleErrorZ Function(
              ffi.Pointer<LDKPeerManager>,
              LDKPublicKey,
              LDKSocketDescriptor,
              LDKCOption_NetAddressZ)>();

  /// Indicates a new inbound connection has been established to a node with an optional remote
  /// network address.
  ///
  /// The remote network address adds the option to report a remote IP address back to a connecting
  /// peer using the init message.
  /// The user should pass the remote network address of the host they are connected to.
  ///
  /// May refuse the connection by returning an Err, but will never write bytes to the remote end
  /// (outbound connector always speaks first). If an `Err` is returned here you must disconnect
  /// the connection immediately.
  ///
  /// Panics if descriptor is duplicative with some other descriptor which has not yet been
  /// [`socket_disconnected()`].
  ///
  /// [`socket_disconnected()`]: PeerManager::socket_disconnected
  LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(
    ffi.Pointer<LDKPeerManager> this_arg,
    LDKSocketDescriptor descriptor,
    LDKCOption_NetAddressZ remote_network_address,
  ) {
    return _PeerManager_new_inbound_connection(
      this_arg,
      descriptor,
      remote_network_address,
    );
  }

  late final _PeerManager_new_inbound_connectionPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NonePeerHandleErrorZ Function(
              ffi.Pointer<LDKPeerManager>,
              LDKSocketDescriptor,
              LDKCOption_NetAddressZ)>>('PeerManager_new_inbound_connection');
  late final _PeerManager_new_inbound_connection =
      _PeerManager_new_inbound_connectionPtr.asFunction<
          LDKCResult_NonePeerHandleErrorZ Function(ffi.Pointer<LDKPeerManager>,
              LDKSocketDescriptor, LDKCOption_NetAddressZ)>();

  /// Indicates that there is room to write data to the given socket descriptor.
  ///
  /// May return an Err to indicate that the connection should be closed.
  ///
  /// May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
  /// returning. Thus, be very careful with reentrancy issues! The invariants around calling
  /// [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
  /// ready to call `[write_buffer_space_avail`] again if a write call generated here isn't
  /// sufficient!
  ///
  /// [`send_data`]: SocketDescriptor::send_data
  /// [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
  LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(
    ffi.Pointer<LDKPeerManager> this_arg,
    ffi.Pointer<LDKSocketDescriptor> descriptor,
  ) {
    return _PeerManager_write_buffer_space_avail(
      this_arg,
      descriptor,
    );
  }

  late final _PeerManager_write_buffer_space_availPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NonePeerHandleErrorZ Function(
                  ffi.Pointer<LDKPeerManager>,
                  ffi.Pointer<LDKSocketDescriptor>)>>(
      'PeerManager_write_buffer_space_avail');
  late final _PeerManager_write_buffer_space_avail =
      _PeerManager_write_buffer_space_availPtr.asFunction<
          LDKCResult_NonePeerHandleErrorZ Function(
              ffi.Pointer<LDKPeerManager>, ffi.Pointer<LDKSocketDescriptor>)>();

  /// Indicates that data was read from the given socket descriptor.
  ///
  /// May return an Err to indicate that the connection should be closed.
  ///
  /// Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
  /// Thus, however, you should call [`process_events`] after any `read_event` to generate
  /// [`send_data`] calls to handle responses.
  ///
  /// If `Ok(true)` is returned, further read_events should not be triggered until a
  /// [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
  /// send buffer).
  ///
  /// [`send_data`]: SocketDescriptor::send_data
  /// [`process_events`]: PeerManager::process_events
  LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(
    ffi.Pointer<LDKPeerManager> this_arg,
    ffi.Pointer<LDKSocketDescriptor> peer_descriptor,
    LDKu8slice data,
  ) {
    return _PeerManager_read_event(
      this_arg,
      peer_descriptor,
      data,
    );
  }

  late final _PeerManager_read_eventPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_boolPeerHandleErrorZ Function(
              ffi.Pointer<LDKPeerManager>,
              ffi.Pointer<LDKSocketDescriptor>,
              LDKu8slice)>>('PeerManager_read_event');
  late final _PeerManager_read_event = _PeerManager_read_eventPtr.asFunction<
      LDKCResult_boolPeerHandleErrorZ Function(ffi.Pointer<LDKPeerManager>,
          ffi.Pointer<LDKSocketDescriptor>, LDKu8slice)>();

  /// Checks for any events generated by our handlers and processes them. Includes sending most
  /// response messages as well as messages generated by calls to handler functions directly (eg
  /// functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
  ///
  /// May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
  /// issues!
  ///
  /// You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
  /// or one of the other clients provided in our language bindings.
  ///
  /// Note that if there are any other calls to this function waiting on lock(s) this may return
  /// without doing any work. All available events that need handling will be handled before the
  /// other calls return.
  ///
  /// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  /// [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
  /// [`send_data`]: SocketDescriptor::send_data
  void PeerManager_process_events(
    ffi.Pointer<LDKPeerManager> this_arg,
  ) {
    return _PeerManager_process_events(
      this_arg,
    );
  }

  late final _PeerManager_process_eventsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKPeerManager>)>>(
      'PeerManager_process_events');
  late final _PeerManager_process_events = _PeerManager_process_eventsPtr
      .asFunction<void Function(ffi.Pointer<LDKPeerManager>)>();

  /// Indicates that the given socket descriptor's connection is now closed.
  void PeerManager_socket_disconnected(
    ffi.Pointer<LDKPeerManager> this_arg,
    ffi.Pointer<LDKSocketDescriptor> descriptor,
  ) {
    return _PeerManager_socket_disconnected(
      this_arg,
      descriptor,
    );
  }

  late final _PeerManager_socket_disconnectedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKPeerManager>,
                  ffi.Pointer<LDKSocketDescriptor>)>>(
      'PeerManager_socket_disconnected');
  late final _PeerManager_socket_disconnected =
      _PeerManager_socket_disconnectedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKPeerManager>, ffi.Pointer<LDKSocketDescriptor>)>();

  /// Disconnect a peer given its node id.
  ///
  /// Set `no_connection_possible` to true to prevent any further connection with this peer,
  /// force-closing any channels we have with it.
  ///
  /// If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
  /// peer. Thus, be very careful about reentrancy issues.
  ///
  /// [`disconnect_socket`]: SocketDescriptor::disconnect_socket
  void PeerManager_disconnect_by_node_id(
    ffi.Pointer<LDKPeerManager> this_arg,
    LDKPublicKey node_id,
    bool no_connection_possible,
  ) {
    return _PeerManager_disconnect_by_node_id(
      this_arg,
      node_id,
      no_connection_possible,
    );
  }

  late final _PeerManager_disconnect_by_node_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPeerManager>, LDKPublicKey,
              ffi.Bool)>>('PeerManager_disconnect_by_node_id');
  late final _PeerManager_disconnect_by_node_id =
      _PeerManager_disconnect_by_node_idPtr.asFunction<
          void Function(ffi.Pointer<LDKPeerManager>, LDKPublicKey, bool)>();

  /// Disconnects all currently-connected peers. This is useful on platforms where there may be
  /// an indication that TCP sockets have stalled even if we weren't around to time them out
  /// using regular ping/pongs.
  void PeerManager_disconnect_all_peers(
    ffi.Pointer<LDKPeerManager> this_arg,
  ) {
    return _PeerManager_disconnect_all_peers(
      this_arg,
    );
  }

  late final _PeerManager_disconnect_all_peersPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKPeerManager>)>>(
      'PeerManager_disconnect_all_peers');
  late final _PeerManager_disconnect_all_peers =
      _PeerManager_disconnect_all_peersPtr.asFunction<
          void Function(ffi.Pointer<LDKPeerManager>)>();

  /// Send pings to each peer and disconnect those which did not respond to the last round of
  /// pings.
  ///
  /// This may be called on any timescale you want, however, roughly once every ten seconds is
  /// preferred. The call rate determines both how often we send a ping to our peers and how much
  /// time they have to respond before we disconnect them.
  ///
  /// May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
  /// issues!
  ///
  /// [`send_data`]: SocketDescriptor::send_data
  void PeerManager_timer_tick_occurred(
    ffi.Pointer<LDKPeerManager> this_arg,
  ) {
    return _PeerManager_timer_tick_occurred(
      this_arg,
    );
  }

  late final _PeerManager_timer_tick_occurredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKPeerManager>)>>(
      'PeerManager_timer_tick_occurred');
  late final _PeerManager_timer_tick_occurred =
      _PeerManager_timer_tick_occurredPtr.asFunction<
          void Function(ffi.Pointer<LDKPeerManager>)>();

  /// Gets the weight for an HTLC-Success transaction.
  int htlc_success_tx_weight(
    bool opt_anchors,
  ) {
    return _htlc_success_tx_weight(
      opt_anchors,
    );
  }

  late final _htlc_success_tx_weightPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Bool)>>(
          'htlc_success_tx_weight');
  late final _htlc_success_tx_weight =
      _htlc_success_tx_weightPtr.asFunction<int Function(bool)>();

  /// Gets the weight for an HTLC-Timeout transaction.
  int htlc_timeout_tx_weight(
    bool opt_anchors,
  ) {
    return _htlc_timeout_tx_weight(
      opt_anchors,
    );
  }

  late final _htlc_timeout_tx_weightPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Bool)>>(
          'htlc_timeout_tx_weight');
  late final _htlc_timeout_tx_weight =
      _htlc_timeout_tx_weightPtr.asFunction<int Function(bool)>();

  /// Build the commitment secret from the seed and the commitment number
  LDKThirtyTwoBytes build_commitment_secret(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> commitment_seed,
    int idx,
  ) {
    return _build_commitment_secret(
      commitment_seed,
      idx,
    );
  }

  late final _build_commitment_secretPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint64)>>('build_commitment_secret');
  late final _build_commitment_secret = _build_commitment_secretPtr.asFunction<
      LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int)>();

  /// Build a closing transaction
  LDKTransaction build_closing_transaction(
    int to_holder_value_sat,
    int to_counterparty_value_sat,
    LDKCVec_u8Z to_holder_script,
    LDKCVec_u8Z to_counterparty_script,
    LDKOutPoint funding_outpoint,
  ) {
    return _build_closing_transaction(
      to_holder_value_sat,
      to_counterparty_value_sat,
      to_holder_script,
      to_counterparty_script,
      funding_outpoint,
    );
  }

  late final _build_closing_transactionPtr = _lookup<
      ffi.NativeFunction<
          LDKTransaction Function(ffi.Uint64, ffi.Uint64, LDKCVec_u8Z,
              LDKCVec_u8Z, LDKOutPoint)>>('build_closing_transaction');
  late final _build_closing_transaction =
      _build_closing_transactionPtr.asFunction<
          LDKTransaction Function(
              int, int, LDKCVec_u8Z, LDKCVec_u8Z, LDKOutPoint)>();

  /// Frees any resources used by the CounterpartyCommitmentSecrets, if is_owned is set and inner is non-NULL.
  void CounterpartyCommitmentSecrets_free(
    LDKCounterpartyCommitmentSecrets this_obj,
  ) {
    return _CounterpartyCommitmentSecrets_free(
      this_obj,
    );
  }

  late final _CounterpartyCommitmentSecrets_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCounterpartyCommitmentSecrets)>>(
      'CounterpartyCommitmentSecrets_free');
  late final _CounterpartyCommitmentSecrets_free =
      _CounterpartyCommitmentSecrets_freePtr.asFunction<
          void Function(LDKCounterpartyCommitmentSecrets)>();

  /// Creates a copy of the CounterpartyCommitmentSecrets
  LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(
    ffi.Pointer<LDKCounterpartyCommitmentSecrets> orig,
  ) {
    return _CounterpartyCommitmentSecrets_clone(
      orig,
    );
  }

  late final _CounterpartyCommitmentSecrets_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCounterpartyCommitmentSecrets Function(
                  ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>>(
      'CounterpartyCommitmentSecrets_clone');
  late final _CounterpartyCommitmentSecrets_clone =
      _CounterpartyCommitmentSecrets_clonePtr.asFunction<
          LDKCounterpartyCommitmentSecrets Function(
              ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>();

  /// Creates a new empty `CounterpartyCommitmentSecrets` structure.
  LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new() {
    return _CounterpartyCommitmentSecrets_new();
  }

  late final _CounterpartyCommitmentSecrets_newPtr =
      _lookup<ffi.NativeFunction<LDKCounterpartyCommitmentSecrets Function()>>(
          'CounterpartyCommitmentSecrets_new');
  late final _CounterpartyCommitmentSecrets_new =
      _CounterpartyCommitmentSecrets_newPtr.asFunction<
          LDKCounterpartyCommitmentSecrets Function()>();

  /// Returns the minimum index of all stored secrets. Note that indexes start
  /// at 1 << 48 and get decremented by one for each new secret.
  int CounterpartyCommitmentSecrets_get_min_seen_secret(
    ffi.Pointer<LDKCounterpartyCommitmentSecrets> this_arg,
  ) {
    return _CounterpartyCommitmentSecrets_get_min_seen_secret(
      this_arg,
    );
  }

  late final _CounterpartyCommitmentSecrets_get_min_seen_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>>(
      'CounterpartyCommitmentSecrets_get_min_seen_secret');
  late final _CounterpartyCommitmentSecrets_get_min_seen_secret =
      _CounterpartyCommitmentSecrets_get_min_seen_secretPtr.asFunction<
          int Function(ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>();

  /// Inserts the `secret` at `idx`. Returns `Ok(())` if the secret
  /// was generated in accordance with BOLT 3 and is consistent with previous secrets.
  LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(
    ffi.Pointer<LDKCounterpartyCommitmentSecrets> this_arg,
    int idx,
    LDKThirtyTwoBytes secret,
  ) {
    return _CounterpartyCommitmentSecrets_provide_secret(
      this_arg,
      idx,
      secret,
    );
  }

  late final _CounterpartyCommitmentSecrets_provide_secretPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneNoneZ Function(
                  ffi.Pointer<LDKCounterpartyCommitmentSecrets>,
                  ffi.Uint64,
                  LDKThirtyTwoBytes)>>(
      'CounterpartyCommitmentSecrets_provide_secret');
  late final _CounterpartyCommitmentSecrets_provide_secret =
      _CounterpartyCommitmentSecrets_provide_secretPtr.asFunction<
          LDKCResult_NoneNoneZ Function(
              ffi.Pointer<LDKCounterpartyCommitmentSecrets>,
              int,
              LDKThirtyTwoBytes)>();

  /// Returns the secret at `idx`.
  /// Returns `None` if `idx` is < [`CounterpartyCommitmentSecrets::get_min_seen_secret`].
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(
    ffi.Pointer<LDKCounterpartyCommitmentSecrets> this_arg,
    int idx,
  ) {
    return _CounterpartyCommitmentSecrets_get_secret(
      this_arg,
      idx,
    );
  }

  late final _CounterpartyCommitmentSecrets_get_secretPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKCounterpartyCommitmentSecrets>,
              ffi.Uint64)>>('CounterpartyCommitmentSecrets_get_secret');
  late final _CounterpartyCommitmentSecrets_get_secret =
      _CounterpartyCommitmentSecrets_get_secretPtr.asFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKCounterpartyCommitmentSecrets>, int)>();

  /// Serialize the CounterpartyCommitmentSecrets object into a byte array which can be read by CounterpartyCommitmentSecrets_read
  LDKCVec_u8Z CounterpartyCommitmentSecrets_write(
    ffi.Pointer<LDKCounterpartyCommitmentSecrets> obj,
  ) {
    return _CounterpartyCommitmentSecrets_write(
      obj,
    );
  }

  late final _CounterpartyCommitmentSecrets_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>>(
      'CounterpartyCommitmentSecrets_write');
  late final _CounterpartyCommitmentSecrets_write =
      _CounterpartyCommitmentSecrets_writePtr.asFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKCounterpartyCommitmentSecrets>)>();

  /// Read a CounterpartyCommitmentSecrets from a byte array, created by CounterpartyCommitmentSecrets_write
  LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ
      CounterpartyCommitmentSecrets_read(
    LDKu8slice ser,
  ) {
    return _CounterpartyCommitmentSecrets_read(
      ser,
    );
  }

  late final _CounterpartyCommitmentSecrets_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
              LDKu8slice)>>('CounterpartyCommitmentSecrets_read');
  late final _CounterpartyCommitmentSecrets_read =
      _CounterpartyCommitmentSecrets_readPtr.asFunction<
          LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ Function(
              LDKu8slice)>();

  /// Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
  /// from the base secret and the per_commitment_point.
  ///
  /// Note that this is infallible iff we trust that at least one of the two input keys are randomly
  /// generated (ie our own).
  LDKCResult_SecretKeyErrorZ derive_private_key(
    LDKPublicKey per_commitment_point,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> base_secret,
  ) {
    return _derive_private_key(
      per_commitment_point,
      base_secret,
    );
  }

  late final _derive_private_keyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SecretKeyErrorZ Function(LDKPublicKey,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('derive_private_key');
  late final _derive_private_key = _derive_private_keyPtr.asFunction<
      LDKCResult_SecretKeyErrorZ Function(
          LDKPublicKey, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
  /// from the base point and the per_commitment_key. This is the public equivalent of
  /// derive_private_key - using only public keys to derive a public key instead of private keys.
  ///
  /// Note that this is infallible iff we trust that at least one of the two input keys are randomly
  /// generated (ie our own).
  LDKCResult_PublicKeyErrorZ derive_public_key(
    LDKPublicKey per_commitment_point,
    LDKPublicKey base_point,
  ) {
    return _derive_public_key(
      per_commitment_point,
      base_point,
    );
  }

  late final _derive_public_keyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PublicKeyErrorZ Function(
              LDKPublicKey, LDKPublicKey)>>('derive_public_key');
  late final _derive_public_key = _derive_public_keyPtr.asFunction<
      LDKCResult_PublicKeyErrorZ Function(LDKPublicKey, LDKPublicKey)>();

  /// Derives a per-commitment-transaction revocation key from its constituent parts.
  ///
  /// Only the cheating participant owns a valid witness to propagate a revoked
  /// commitment transaction, thus per_commitment_secret always come from cheater
  /// and revocation_base_secret always come from punisher, which is the broadcaster
  /// of the transaction spending with this key knowledge.
  ///
  /// Note that this is infallible iff we trust that at least one of the two input keys are randomly
  /// generated (ie our own).
  LDKCResult_SecretKeyErrorZ derive_private_revocation_key(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> per_commitment_secret,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> countersignatory_revocation_base_secret,
  ) {
    return _derive_private_revocation_key(
      per_commitment_secret,
      countersignatory_revocation_base_secret,
    );
  }

  late final _derive_private_revocation_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_SecretKeyErrorZ Function(
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'derive_private_revocation_key');
  late final _derive_private_revocation_key =
      _derive_private_revocation_keyPtr.asFunction<
          LDKCResult_SecretKeyErrorZ Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Derives a per-commitment-transaction revocation public key from its constituent parts. This is
  /// the public equivalend of derive_private_revocation_key - using only public keys to derive a
  /// public key instead of private keys.
  ///
  /// Only the cheating participant owns a valid witness to propagate a revoked
  /// commitment transaction, thus per_commitment_point always come from cheater
  /// and revocation_base_point always come from punisher, which is the broadcaster
  /// of the transaction spending with this key knowledge.
  ///
  /// Note that this is infallible iff we trust that at least one of the two input keys are randomly
  /// generated (ie our own).
  LDKCResult_PublicKeyErrorZ derive_public_revocation_key(
    LDKPublicKey per_commitment_point,
    LDKPublicKey countersignatory_revocation_base_point,
  ) {
    return _derive_public_revocation_key(
      per_commitment_point,
      countersignatory_revocation_base_point,
    );
  }

  late final _derive_public_revocation_keyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PublicKeyErrorZ Function(
              LDKPublicKey, LDKPublicKey)>>('derive_public_revocation_key');
  late final _derive_public_revocation_key =
      _derive_public_revocation_keyPtr.asFunction<
          LDKCResult_PublicKeyErrorZ Function(LDKPublicKey, LDKPublicKey)>();

  /// Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
  void TxCreationKeys_free(
    LDKTxCreationKeys this_obj,
  ) {
    return _TxCreationKeys_free(
      this_obj,
    );
  }

  late final _TxCreationKeys_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKTxCreationKeys)>>(
          'TxCreationKeys_free');
  late final _TxCreationKeys_free =
      _TxCreationKeys_freePtr.asFunction<void Function(LDKTxCreationKeys)>();

  /// The broadcaster's per-commitment public key which was used to derive the other keys.
  LDKPublicKey TxCreationKeys_get_per_commitment_point(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
  ) {
    return _TxCreationKeys_get_per_commitment_point(
      this_ptr,
    );
  }

  late final _TxCreationKeys_get_per_commitment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>>(
      'TxCreationKeys_get_per_commitment_point');
  late final _TxCreationKeys_get_per_commitment_point =
      _TxCreationKeys_get_per_commitment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// The broadcaster's per-commitment public key which was used to derive the other keys.
  void TxCreationKeys_set_per_commitment_point(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _TxCreationKeys_set_per_commitment_point(
      this_ptr,
      val,
    );
  }

  late final _TxCreationKeys_set_per_commitment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKTxCreationKeys>,
              LDKPublicKey)>>('TxCreationKeys_set_per_commitment_point');
  late final _TxCreationKeys_set_per_commitment_point =
      _TxCreationKeys_set_per_commitment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>();

  /// The revocation key which is used to allow the broadcaster of the commitment
  /// transaction to provide their counterparty the ability to punish them if they broadcast
  /// an old state.
  LDKPublicKey TxCreationKeys_get_revocation_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
  ) {
    return _TxCreationKeys_get_revocation_key(
      this_ptr,
    );
  }

  late final _TxCreationKeys_get_revocation_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>>(
      'TxCreationKeys_get_revocation_key');
  late final _TxCreationKeys_get_revocation_key =
      _TxCreationKeys_get_revocation_keyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// The revocation key which is used to allow the broadcaster of the commitment
  /// transaction to provide their counterparty the ability to punish them if they broadcast
  /// an old state.
  void TxCreationKeys_set_revocation_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _TxCreationKeys_set_revocation_key(
      this_ptr,
      val,
    );
  }

  late final _TxCreationKeys_set_revocation_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKTxCreationKeys>,
              LDKPublicKey)>>('TxCreationKeys_set_revocation_key');
  late final _TxCreationKeys_set_revocation_key =
      _TxCreationKeys_set_revocation_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>();

  /// Broadcaster's HTLC Key
  LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
  ) {
    return _TxCreationKeys_get_broadcaster_htlc_key(
      this_ptr,
    );
  }

  late final _TxCreationKeys_get_broadcaster_htlc_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>>(
      'TxCreationKeys_get_broadcaster_htlc_key');
  late final _TxCreationKeys_get_broadcaster_htlc_key =
      _TxCreationKeys_get_broadcaster_htlc_keyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// Broadcaster's HTLC Key
  void TxCreationKeys_set_broadcaster_htlc_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _TxCreationKeys_set_broadcaster_htlc_key(
      this_ptr,
      val,
    );
  }

  late final _TxCreationKeys_set_broadcaster_htlc_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKTxCreationKeys>,
              LDKPublicKey)>>('TxCreationKeys_set_broadcaster_htlc_key');
  late final _TxCreationKeys_set_broadcaster_htlc_key =
      _TxCreationKeys_set_broadcaster_htlc_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>();

  /// Countersignatory's HTLC Key
  LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
  ) {
    return _TxCreationKeys_get_countersignatory_htlc_key(
      this_ptr,
    );
  }

  late final _TxCreationKeys_get_countersignatory_htlc_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>>(
      'TxCreationKeys_get_countersignatory_htlc_key');
  late final _TxCreationKeys_get_countersignatory_htlc_key =
      _TxCreationKeys_get_countersignatory_htlc_keyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// Countersignatory's HTLC Key
  void TxCreationKeys_set_countersignatory_htlc_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _TxCreationKeys_set_countersignatory_htlc_key(
      this_ptr,
      val,
    );
  }

  late final _TxCreationKeys_set_countersignatory_htlc_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKTxCreationKeys>,
              LDKPublicKey)>>('TxCreationKeys_set_countersignatory_htlc_key');
  late final _TxCreationKeys_set_countersignatory_htlc_key =
      _TxCreationKeys_set_countersignatory_htlc_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>();

  /// Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
  LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
  ) {
    return _TxCreationKeys_get_broadcaster_delayed_payment_key(
      this_ptr,
    );
  }

  late final _TxCreationKeys_get_broadcaster_delayed_payment_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>>(
      'TxCreationKeys_get_broadcaster_delayed_payment_key');
  late final _TxCreationKeys_get_broadcaster_delayed_payment_key =
      _TxCreationKeys_get_broadcaster_delayed_payment_keyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
  void TxCreationKeys_set_broadcaster_delayed_payment_key(
    ffi.Pointer<LDKTxCreationKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _TxCreationKeys_set_broadcaster_delayed_payment_key(
      this_ptr,
      val,
    );
  }

  late final _TxCreationKeys_set_broadcaster_delayed_payment_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>>(
      'TxCreationKeys_set_broadcaster_delayed_payment_key');
  late final _TxCreationKeys_set_broadcaster_delayed_payment_key =
      _TxCreationKeys_set_broadcaster_delayed_payment_keyPtr.asFunction<
          void Function(ffi.Pointer<LDKTxCreationKeys>, LDKPublicKey)>();

  /// Constructs a new TxCreationKeys given each field
  LDKTxCreationKeys TxCreationKeys_new(
    LDKPublicKey per_commitment_point_arg,
    LDKPublicKey revocation_key_arg,
    LDKPublicKey broadcaster_htlc_key_arg,
    LDKPublicKey countersignatory_htlc_key_arg,
    LDKPublicKey broadcaster_delayed_payment_key_arg,
  ) {
    return _TxCreationKeys_new(
      per_commitment_point_arg,
      revocation_key_arg,
      broadcaster_htlc_key_arg,
      countersignatory_htlc_key_arg,
      broadcaster_delayed_payment_key_arg,
    );
  }

  late final _TxCreationKeys_newPtr = _lookup<
      ffi.NativeFunction<
          LDKTxCreationKeys Function(LDKPublicKey, LDKPublicKey, LDKPublicKey,
              LDKPublicKey, LDKPublicKey)>>('TxCreationKeys_new');
  late final _TxCreationKeys_new = _TxCreationKeys_newPtr.asFunction<
      LDKTxCreationKeys Function(LDKPublicKey, LDKPublicKey, LDKPublicKey,
          LDKPublicKey, LDKPublicKey)>();

  /// Creates a copy of the TxCreationKeys
  LDKTxCreationKeys TxCreationKeys_clone(
    ffi.Pointer<LDKTxCreationKeys> orig,
  ) {
    return _TxCreationKeys_clone(
      orig,
    );
  }

  late final _TxCreationKeys_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKTxCreationKeys Function(
              ffi.Pointer<LDKTxCreationKeys>)>>('TxCreationKeys_clone');
  late final _TxCreationKeys_clone = _TxCreationKeys_clonePtr.asFunction<
      LDKTxCreationKeys Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
  LDKCVec_u8Z TxCreationKeys_write(
    ffi.Pointer<LDKTxCreationKeys> obj,
  ) {
    return _TxCreationKeys_write(
      obj,
    );
  }

  late final _TxCreationKeys_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKTxCreationKeys>)>>('TxCreationKeys_write');
  late final _TxCreationKeys_write = _TxCreationKeys_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKTxCreationKeys>)>();

  /// Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
  LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(
    LDKu8slice ser,
  ) {
    return _TxCreationKeys_read(
      ser,
    );
  }

  late final _TxCreationKeys_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysDecodeErrorZ Function(
              LDKu8slice)>>('TxCreationKeys_read');
  late final _TxCreationKeys_read = _TxCreationKeys_readPtr.asFunction<
      LDKCResult_TxCreationKeysDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
  void ChannelPublicKeys_free(
    LDKChannelPublicKeys this_obj,
  ) {
    return _ChannelPublicKeys_free(
      this_obj,
    );
  }

  late final _ChannelPublicKeys_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelPublicKeys)>>(
          'ChannelPublicKeys_free');
  late final _ChannelPublicKeys_free = _ChannelPublicKeys_freePtr.asFunction<
      void Function(LDKChannelPublicKeys)>();

  /// The public key which is used to sign all commitment transactions, as it appears in the
  /// on-chain channel lock-in 2-of-2 multisig output.
  LDKPublicKey ChannelPublicKeys_get_funding_pubkey(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
  ) {
    return _ChannelPublicKeys_get_funding_pubkey(
      this_ptr,
    );
  }

  late final _ChannelPublicKeys_get_funding_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>>(
      'ChannelPublicKeys_get_funding_pubkey');
  late final _ChannelPublicKeys_get_funding_pubkey =
      _ChannelPublicKeys_get_funding_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// The public key which is used to sign all commitment transactions, as it appears in the
  /// on-chain channel lock-in 2-of-2 multisig output.
  void ChannelPublicKeys_set_funding_pubkey(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelPublicKeys_set_funding_pubkey(
      this_ptr,
      val,
    );
  }

  late final _ChannelPublicKeys_set_funding_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelPublicKeys>,
              LDKPublicKey)>>('ChannelPublicKeys_set_funding_pubkey');
  late final _ChannelPublicKeys_set_funding_pubkey =
      _ChannelPublicKeys_set_funding_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>();

  /// The base point which is used (with derive_public_revocation_key) to derive per-commitment
  /// revocation keys. This is combined with the per-commitment-secret generated by the
  /// counterparty to create a secret which the counterparty can reveal to revoke previous
  /// states.
  LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
  ) {
    return _ChannelPublicKeys_get_revocation_basepoint(
      this_ptr,
    );
  }

  late final _ChannelPublicKeys_get_revocation_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>>(
      'ChannelPublicKeys_get_revocation_basepoint');
  late final _ChannelPublicKeys_get_revocation_basepoint =
      _ChannelPublicKeys_get_revocation_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// The base point which is used (with derive_public_revocation_key) to derive per-commitment
  /// revocation keys. This is combined with the per-commitment-secret generated by the
  /// counterparty to create a secret which the counterparty can reveal to revoke previous
  /// states.
  void ChannelPublicKeys_set_revocation_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelPublicKeys_set_revocation_basepoint(
      this_ptr,
      val,
    );
  }

  late final _ChannelPublicKeys_set_revocation_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelPublicKeys>,
              LDKPublicKey)>>('ChannelPublicKeys_set_revocation_basepoint');
  late final _ChannelPublicKeys_set_revocation_basepoint =
      _ChannelPublicKeys_set_revocation_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>();

  /// The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
  /// spendable primary channel balance on the broadcaster's commitment transaction. This key is
  /// static across every commitment transaction.
  LDKPublicKey ChannelPublicKeys_get_payment_point(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
  ) {
    return _ChannelPublicKeys_get_payment_point(
      this_ptr,
    );
  }

  late final _ChannelPublicKeys_get_payment_pointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>>(
      'ChannelPublicKeys_get_payment_point');
  late final _ChannelPublicKeys_get_payment_point =
      _ChannelPublicKeys_get_payment_pointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
  /// spendable primary channel balance on the broadcaster's commitment transaction. This key is
  /// static across every commitment transaction.
  void ChannelPublicKeys_set_payment_point(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelPublicKeys_set_payment_point(
      this_ptr,
      val,
    );
  }

  late final _ChannelPublicKeys_set_payment_pointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelPublicKeys>,
              LDKPublicKey)>>('ChannelPublicKeys_set_payment_point');
  late final _ChannelPublicKeys_set_payment_point =
      _ChannelPublicKeys_set_payment_pointPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>();

  /// The base point which is used (with derive_public_key) to derive a per-commitment payment
  /// public key which receives non-HTLC-encumbered funds which are only available for spending
  /// after some delay (or can be claimed via the revocation path).
  LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
  ) {
    return _ChannelPublicKeys_get_delayed_payment_basepoint(
      this_ptr,
    );
  }

  late final _ChannelPublicKeys_get_delayed_payment_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>>(
      'ChannelPublicKeys_get_delayed_payment_basepoint');
  late final _ChannelPublicKeys_get_delayed_payment_basepoint =
      _ChannelPublicKeys_get_delayed_payment_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// The base point which is used (with derive_public_key) to derive a per-commitment payment
  /// public key which receives non-HTLC-encumbered funds which are only available for spending
  /// after some delay (or can be claimed via the revocation path).
  void ChannelPublicKeys_set_delayed_payment_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelPublicKeys_set_delayed_payment_basepoint(
      this_ptr,
      val,
    );
  }

  late final _ChannelPublicKeys_set_delayed_payment_basepointPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>>(
      'ChannelPublicKeys_set_delayed_payment_basepoint');
  late final _ChannelPublicKeys_set_delayed_payment_basepoint =
      _ChannelPublicKeys_set_delayed_payment_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>();

  /// The base point which is used (with derive_public_key) to derive a per-commitment public key
  /// which is used to encumber HTLC-in-flight outputs.
  LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
  ) {
    return _ChannelPublicKeys_get_htlc_basepoint(
      this_ptr,
    );
  }

  late final _ChannelPublicKeys_get_htlc_basepointPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>>(
      'ChannelPublicKeys_get_htlc_basepoint');
  late final _ChannelPublicKeys_get_htlc_basepoint =
      _ChannelPublicKeys_get_htlc_basepointPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// The base point which is used (with derive_public_key) to derive a per-commitment public key
  /// which is used to encumber HTLC-in-flight outputs.
  void ChannelPublicKeys_set_htlc_basepoint(
    ffi.Pointer<LDKChannelPublicKeys> this_ptr,
    LDKPublicKey val,
  ) {
    return _ChannelPublicKeys_set_htlc_basepoint(
      this_ptr,
      val,
    );
  }

  late final _ChannelPublicKeys_set_htlc_basepointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelPublicKeys>,
              LDKPublicKey)>>('ChannelPublicKeys_set_htlc_basepoint');
  late final _ChannelPublicKeys_set_htlc_basepoint =
      _ChannelPublicKeys_set_htlc_basepointPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelPublicKeys>, LDKPublicKey)>();

  /// Constructs a new ChannelPublicKeys given each field
  LDKChannelPublicKeys ChannelPublicKeys_new(
    LDKPublicKey funding_pubkey_arg,
    LDKPublicKey revocation_basepoint_arg,
    LDKPublicKey payment_point_arg,
    LDKPublicKey delayed_payment_basepoint_arg,
    LDKPublicKey htlc_basepoint_arg,
  ) {
    return _ChannelPublicKeys_new(
      funding_pubkey_arg,
      revocation_basepoint_arg,
      payment_point_arg,
      delayed_payment_basepoint_arg,
      htlc_basepoint_arg,
    );
  }

  late final _ChannelPublicKeys_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelPublicKeys Function(
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey)>>('ChannelPublicKeys_new');
  late final _ChannelPublicKeys_new = _ChannelPublicKeys_newPtr.asFunction<
      LDKChannelPublicKeys Function(LDKPublicKey, LDKPublicKey, LDKPublicKey,
          LDKPublicKey, LDKPublicKey)>();

  /// Creates a copy of the ChannelPublicKeys
  LDKChannelPublicKeys ChannelPublicKeys_clone(
    ffi.Pointer<LDKChannelPublicKeys> orig,
  ) {
    return _ChannelPublicKeys_clone(
      orig,
    );
  }

  late final _ChannelPublicKeys_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelPublicKeys Function(
              ffi.Pointer<LDKChannelPublicKeys>)>>('ChannelPublicKeys_clone');
  late final _ChannelPublicKeys_clone = _ChannelPublicKeys_clonePtr.asFunction<
      LDKChannelPublicKeys Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
  LDKCVec_u8Z ChannelPublicKeys_write(
    ffi.Pointer<LDKChannelPublicKeys> obj,
  ) {
    return _ChannelPublicKeys_write(
      obj,
    );
  }

  late final _ChannelPublicKeys_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelPublicKeys>)>>('ChannelPublicKeys_write');
  late final _ChannelPublicKeys_write = _ChannelPublicKeys_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelPublicKeys>)>();

  /// Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
  LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(
    LDKu8slice ser,
  ) {
    return _ChannelPublicKeys_read(
      ser,
    );
  }

  late final _ChannelPublicKeys_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelPublicKeysDecodeErrorZ Function(
              LDKu8slice)>>('ChannelPublicKeys_read');
  late final _ChannelPublicKeys_read = _ChannelPublicKeys_readPtr.asFunction<
      LDKCResult_ChannelPublicKeysDecodeErrorZ Function(LDKu8slice)>();

  /// Create per-state keys from channel base points and the per-commitment point.
  /// Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
  LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(
    LDKPublicKey per_commitment_point,
    LDKPublicKey broadcaster_delayed_payment_base,
    LDKPublicKey broadcaster_htlc_base,
    LDKPublicKey countersignatory_revocation_base,
    LDKPublicKey countersignatory_htlc_base,
  ) {
    return _TxCreationKeys_derive_new(
      per_commitment_point,
      broadcaster_delayed_payment_base,
      broadcaster_htlc_base,
      countersignatory_revocation_base,
      countersignatory_htlc_base,
    );
  }

  late final _TxCreationKeys_derive_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TxCreationKeysErrorZ Function(
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey,
              LDKPublicKey)>>('TxCreationKeys_derive_new');
  late final _TxCreationKeys_derive_new =
      _TxCreationKeys_derive_newPtr.asFunction<
          LDKCResult_TxCreationKeysErrorZ Function(LDKPublicKey, LDKPublicKey,
              LDKPublicKey, LDKPublicKey, LDKPublicKey)>();

  /// Generate per-state keys from channel static keys.
  /// Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
  LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(
    LDKPublicKey per_commitment_point,
    ffi.Pointer<LDKChannelPublicKeys> broadcaster_keys,
    ffi.Pointer<LDKChannelPublicKeys> countersignatory_keys,
  ) {
    return _TxCreationKeys_from_channel_static_keys(
      per_commitment_point,
      broadcaster_keys,
      countersignatory_keys,
    );
  }

  late final _TxCreationKeys_from_channel_static_keysPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TxCreationKeysErrorZ Function(
                  LDKPublicKey,
                  ffi.Pointer<LDKChannelPublicKeys>,
                  ffi.Pointer<LDKChannelPublicKeys>)>>(
      'TxCreationKeys_from_channel_static_keys');
  late final _TxCreationKeys_from_channel_static_keys =
      _TxCreationKeys_from_channel_static_keysPtr.asFunction<
          LDKCResult_TxCreationKeysErrorZ Function(
              LDKPublicKey,
              ffi.Pointer<LDKChannelPublicKeys>,
              ffi.Pointer<LDKChannelPublicKeys>)>();

  /// A script either spendable by the revocation
  /// key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
  /// Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
  LDKCVec_u8Z get_revokeable_redeemscript(
    LDKPublicKey revocation_key,
    int contest_delay,
    LDKPublicKey broadcaster_delayed_payment_key,
  ) {
    return _get_revokeable_redeemscript(
      revocation_key,
      contest_delay,
      broadcaster_delayed_payment_key,
    );
  }

  late final _get_revokeable_redeemscriptPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(LDKPublicKey, ffi.Uint16,
              LDKPublicKey)>>('get_revokeable_redeemscript');
  late final _get_revokeable_redeemscript = _get_revokeable_redeemscriptPtr
      .asFunction<LDKCVec_u8Z Function(LDKPublicKey, int, LDKPublicKey)>();

  /// Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
  void HTLCOutputInCommitment_free(
    LDKHTLCOutputInCommitment this_obj,
  ) {
    return _HTLCOutputInCommitment_free(
      this_obj,
    );
  }

  late final _HTLCOutputInCommitment_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKHTLCOutputInCommitment)>>(
          'HTLCOutputInCommitment_free');
  late final _HTLCOutputInCommitment_free = _HTLCOutputInCommitment_freePtr
      .asFunction<void Function(LDKHTLCOutputInCommitment)>();

  /// Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
  /// Note that this is not the same as whether it is ountbound *from us*. To determine that you
  /// need to compare this value to whether the commitment transaction in question is that of
  /// the counterparty or our own.
  bool HTLCOutputInCommitment_get_offered(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
  ) {
    return _HTLCOutputInCommitment_get_offered(
      this_ptr,
    );
  }

  late final _HTLCOutputInCommitment_get_offeredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_get_offered');
  late final _HTLCOutputInCommitment_get_offered =
      _HTLCOutputInCommitment_get_offeredPtr.asFunction<
          bool Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
  /// Note that this is not the same as whether it is ountbound *from us*. To determine that you
  /// need to compare this value to whether the commitment transaction in question is that of
  /// the counterparty or our own.
  void HTLCOutputInCommitment_set_offered(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
    bool val,
  ) {
    return _HTLCOutputInCommitment_set_offered(
      this_ptr,
      val,
    );
  }

  late final _HTLCOutputInCommitment_set_offeredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKHTLCOutputInCommitment>,
              ffi.Bool)>>('HTLCOutputInCommitment_set_offered');
  late final _HTLCOutputInCommitment_set_offered =
      _HTLCOutputInCommitment_set_offeredPtr.asFunction<
          void Function(ffi.Pointer<LDKHTLCOutputInCommitment>, bool)>();

  /// The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
  /// this divided by 1000.
  int HTLCOutputInCommitment_get_amount_msat(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
  ) {
    return _HTLCOutputInCommitment_get_amount_msat(
      this_ptr,
    );
  }

  late final _HTLCOutputInCommitment_get_amount_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_get_amount_msat');
  late final _HTLCOutputInCommitment_get_amount_msat =
      _HTLCOutputInCommitment_get_amount_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
  /// this divided by 1000.
  void HTLCOutputInCommitment_set_amount_msat(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
    int val,
  ) {
    return _HTLCOutputInCommitment_set_amount_msat(
      this_ptr,
      val,
    );
  }

  late final _HTLCOutputInCommitment_set_amount_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKHTLCOutputInCommitment>,
              ffi.Uint64)>>('HTLCOutputInCommitment_set_amount_msat');
  late final _HTLCOutputInCommitment_set_amount_msat =
      _HTLCOutputInCommitment_set_amount_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKHTLCOutputInCommitment>, int)>();

  /// The CLTV lock-time at which this HTLC expires.
  int HTLCOutputInCommitment_get_cltv_expiry(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
  ) {
    return _HTLCOutputInCommitment_get_cltv_expiry(
      this_ptr,
    );
  }

  late final _HTLCOutputInCommitment_get_cltv_expiryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_get_cltv_expiry');
  late final _HTLCOutputInCommitment_get_cltv_expiry =
      _HTLCOutputInCommitment_get_cltv_expiryPtr.asFunction<
          int Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// The CLTV lock-time at which this HTLC expires.
  void HTLCOutputInCommitment_set_cltv_expiry(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
    int val,
  ) {
    return _HTLCOutputInCommitment_set_cltv_expiry(
      this_ptr,
      val,
    );
  }

  late final _HTLCOutputInCommitment_set_cltv_expiryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKHTLCOutputInCommitment>,
              ffi.Uint32)>>('HTLCOutputInCommitment_set_cltv_expiry');
  late final _HTLCOutputInCommitment_set_cltv_expiry =
      _HTLCOutputInCommitment_set_cltv_expiryPtr.asFunction<
          void Function(ffi.Pointer<LDKHTLCOutputInCommitment>, int)>();

  /// The hash of the preimage which unlocks this HTLC.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> HTLCOutputInCommitment_get_payment_hash(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
  ) {
    return _HTLCOutputInCommitment_get_payment_hash(
      this_ptr,
    );
  }

  late final _HTLCOutputInCommitment_get_payment_hashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_get_payment_hash');
  late final _HTLCOutputInCommitment_get_payment_hash =
      _HTLCOutputInCommitment_get_payment_hashPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// The hash of the preimage which unlocks this HTLC.
  void HTLCOutputInCommitment_set_payment_hash(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _HTLCOutputInCommitment_set_payment_hash(
      this_ptr,
      val,
    );
  }

  late final _HTLCOutputInCommitment_set_payment_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKHTLCOutputInCommitment>,
              LDKThirtyTwoBytes)>>('HTLCOutputInCommitment_set_payment_hash');
  late final _HTLCOutputInCommitment_set_payment_hash =
      _HTLCOutputInCommitment_set_payment_hashPtr.asFunction<
          void Function(
              ffi.Pointer<LDKHTLCOutputInCommitment>, LDKThirtyTwoBytes)>();

  /// The position within the commitment transactions' outputs. This may be None if the value is
  /// below the dust limit (in which case no output appears in the commitment transaction and the
  /// value is spent to additional transaction fees).
  LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
  ) {
    return _HTLCOutputInCommitment_get_transaction_output_index(
      this_ptr,
    );
  }

  late final _HTLCOutputInCommitment_get_transaction_output_indexPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u32Z Function(
                  ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_get_transaction_output_index');
  late final _HTLCOutputInCommitment_get_transaction_output_index =
      _HTLCOutputInCommitment_get_transaction_output_indexPtr.asFunction<
          LDKCOption_u32Z Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// The position within the commitment transactions' outputs. This may be None if the value is
  /// below the dust limit (in which case no output appears in the commitment transaction and the
  /// value is spent to additional transaction fees).
  void HTLCOutputInCommitment_set_transaction_output_index(
    ffi.Pointer<LDKHTLCOutputInCommitment> this_ptr,
    LDKCOption_u32Z val,
  ) {
    return _HTLCOutputInCommitment_set_transaction_output_index(
      this_ptr,
      val,
    );
  }

  late final _HTLCOutputInCommitment_set_transaction_output_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKHTLCOutputInCommitment>, LDKCOption_u32Z)>>(
      'HTLCOutputInCommitment_set_transaction_output_index');
  late final _HTLCOutputInCommitment_set_transaction_output_index =
      _HTLCOutputInCommitment_set_transaction_output_indexPtr.asFunction<
          void Function(
              ffi.Pointer<LDKHTLCOutputInCommitment>, LDKCOption_u32Z)>();

  /// Constructs a new HTLCOutputInCommitment given each field
  LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(
    bool offered_arg,
    int amount_msat_arg,
    int cltv_expiry_arg,
    LDKThirtyTwoBytes payment_hash_arg,
    LDKCOption_u32Z transaction_output_index_arg,
  ) {
    return _HTLCOutputInCommitment_new(
      offered_arg,
      amount_msat_arg,
      cltv_expiry_arg,
      payment_hash_arg,
      transaction_output_index_arg,
    );
  }

  late final _HTLCOutputInCommitment_newPtr = _lookup<
      ffi.NativeFunction<
          LDKHTLCOutputInCommitment Function(
              ffi.Bool,
              ffi.Uint64,
              ffi.Uint32,
              LDKThirtyTwoBytes,
              LDKCOption_u32Z)>>('HTLCOutputInCommitment_new');
  late final _HTLCOutputInCommitment_new =
      _HTLCOutputInCommitment_newPtr.asFunction<
          LDKHTLCOutputInCommitment Function(
              bool, int, int, LDKThirtyTwoBytes, LDKCOption_u32Z)>();

  /// Creates a copy of the HTLCOutputInCommitment
  LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(
    ffi.Pointer<LDKHTLCOutputInCommitment> orig,
  ) {
    return _HTLCOutputInCommitment_clone(
      orig,
    );
  }

  late final _HTLCOutputInCommitment_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKHTLCOutputInCommitment Function(
                  ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_clone');
  late final _HTLCOutputInCommitment_clone =
      _HTLCOutputInCommitment_clonePtr.asFunction<
          LDKHTLCOutputInCommitment Function(
              ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
  LDKCVec_u8Z HTLCOutputInCommitment_write(
    ffi.Pointer<LDKHTLCOutputInCommitment> obj,
  ) {
    return _HTLCOutputInCommitment_write(
      obj,
    );
  }

  late final _HTLCOutputInCommitment_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>>(
      'HTLCOutputInCommitment_write');
  late final _HTLCOutputInCommitment_write =
      _HTLCOutputInCommitment_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCOutputInCommitment>)>();

  /// Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
  LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(
    LDKu8slice ser,
  ) {
    return _HTLCOutputInCommitment_read(
      ser,
    );
  }

  late final _HTLCOutputInCommitment_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(
              LDKu8slice)>>('HTLCOutputInCommitment_read');
  late final _HTLCOutputInCommitment_read =
      _HTLCOutputInCommitment_readPtr.asFunction<
          LDKCResult_HTLCOutputInCommitmentDecodeErrorZ Function(LDKu8slice)>();

  /// Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
  /// does not need to have its previous_output_index filled.
  LDKCVec_u8Z get_htlc_redeemscript(
    ffi.Pointer<LDKHTLCOutputInCommitment> htlc,
    bool opt_anchors,
    ffi.Pointer<LDKTxCreationKeys> keys,
  ) {
    return _get_htlc_redeemscript(
      htlc,
      opt_anchors,
      keys,
    );
  }

  late final _get_htlc_redeemscriptPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCOutputInCommitment>, ffi.Bool,
              ffi.Pointer<LDKTxCreationKeys>)>>('get_htlc_redeemscript');
  late final _get_htlc_redeemscript = _get_htlc_redeemscriptPtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKHTLCOutputInCommitment>, bool,
          ffi.Pointer<LDKTxCreationKeys>)>();

  /// Gets the redeemscript for a funding output from the two funding public keys.
  /// Note that the order of funding public keys does not matter.
  LDKCVec_u8Z make_funding_redeemscript(
    LDKPublicKey broadcaster,
    LDKPublicKey countersignatory,
  ) {
    return _make_funding_redeemscript(
      broadcaster,
      countersignatory,
    );
  }

  late final _make_funding_redeemscriptPtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(LDKPublicKey, LDKPublicKey)>>(
      'make_funding_redeemscript');
  late final _make_funding_redeemscript = _make_funding_redeemscriptPtr
      .asFunction<LDKCVec_u8Z Function(LDKPublicKey, LDKPublicKey)>();

  /// Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
  /// parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
  /// transaction which needs signing, and can be used to construct an HTLC transaction which is
  /// broadcastable given a counterparty HTLC signature.
  ///
  /// Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
  /// commitment transaction).
  LDKTransaction build_htlc_transaction(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> commitment_txid,
    int feerate_per_kw,
    int contest_delay,
    ffi.Pointer<LDKHTLCOutputInCommitment> htlc,
    bool opt_anchors,
    LDKPublicKey broadcaster_delayed_payment_key,
    LDKPublicKey revocation_key,
  ) {
    return _build_htlc_transaction(
      commitment_txid,
      feerate_per_kw,
      contest_delay,
      htlc,
      opt_anchors,
      broadcaster_delayed_payment_key,
      revocation_key,
    );
  }

  late final _build_htlc_transactionPtr = _lookup<
      ffi.NativeFunction<
          LDKTransaction Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint32,
              ffi.Uint16,
              ffi.Pointer<LDKHTLCOutputInCommitment>,
              ffi.Bool,
              LDKPublicKey,
              LDKPublicKey)>>('build_htlc_transaction');
  late final _build_htlc_transaction = _build_htlc_transactionPtr.asFunction<
      LDKTransaction Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          int,
          int,
          ffi.Pointer<LDKHTLCOutputInCommitment>,
          bool,
          LDKPublicKey,
          LDKPublicKey)>();

  /// Gets the witnessScript for an anchor output from the funding public key.
  /// The witness in the spending input must be:
  /// <BIP 143 funding_signature>
  /// After 16 blocks of confirmation, an alternative satisfying witness could be:
  /// <>
  /// (empty vector required to satisfy compliance with MINIMALIF-standard rule)
  LDKCVec_u8Z get_anchor_redeemscript(
    LDKPublicKey funding_pubkey,
  ) {
    return _get_anchor_redeemscript(
      funding_pubkey,
    );
  }

  late final _get_anchor_redeemscriptPtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(LDKPublicKey)>>(
          'get_anchor_redeemscript');
  late final _get_anchor_redeemscript = _get_anchor_redeemscriptPtr
      .asFunction<LDKCVec_u8Z Function(LDKPublicKey)>();

  /// Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
  void ChannelTransactionParameters_free(
    LDKChannelTransactionParameters this_obj,
  ) {
    return _ChannelTransactionParameters_free(
      this_obj,
    );
  }

  late final _ChannelTransactionParameters_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKChannelTransactionParameters)>>(
      'ChannelTransactionParameters_free');
  late final _ChannelTransactionParameters_free =
      _ChannelTransactionParameters_freePtr.asFunction<
          void Function(LDKChannelTransactionParameters)>();

  /// Holder public keys
  LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_holder_pubkeys(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_holder_pubkeysPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelPublicKeys Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_get_holder_pubkeys');
  late final _ChannelTransactionParameters_get_holder_pubkeys =
      _ChannelTransactionParameters_get_holder_pubkeysPtr.asFunction<
          LDKChannelPublicKeys Function(
              ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Holder public keys
  void ChannelTransactionParameters_set_holder_pubkeys(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    LDKChannelPublicKeys val,
  ) {
    return _ChannelTransactionParameters_set_holder_pubkeys(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_holder_pubkeysPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTransactionParameters>,
                  LDKChannelPublicKeys)>>(
      'ChannelTransactionParameters_set_holder_pubkeys');
  late final _ChannelTransactionParameters_set_holder_pubkeys =
      _ChannelTransactionParameters_set_holder_pubkeysPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTransactionParameters>,
              LDKChannelPublicKeys)>();

  /// The contest delay selected by the holder, which applies to counterparty-broadcast transactions
  int ChannelTransactionParameters_get_holder_selected_contest_delay(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_holder_selected_contest_delay(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_holder_selected_contest_delayPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint16 Function(
                      ffi.Pointer<LDKChannelTransactionParameters>)>>(
          'ChannelTransactionParameters_get_holder_selected_contest_delay');
  late final _ChannelTransactionParameters_get_holder_selected_contest_delay =
      _ChannelTransactionParameters_get_holder_selected_contest_delayPtr
          .asFunction<
              int Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// The contest delay selected by the holder, which applies to counterparty-broadcast transactions
  void ChannelTransactionParameters_set_holder_selected_contest_delay(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    int val,
  ) {
    return _ChannelTransactionParameters_set_holder_selected_contest_delay(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_holder_selected_contest_delayPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelTransactionParameters>,
                      ffi.Uint16)>>(
          'ChannelTransactionParameters_set_holder_selected_contest_delay');
  late final _ChannelTransactionParameters_set_holder_selected_contest_delay =
      _ChannelTransactionParameters_set_holder_selected_contest_delayPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKChannelTransactionParameters>, int)>();

  /// Whether the holder is the initiator of this channel.
  /// This is an input to the commitment number obscure factor computation.
  bool ChannelTransactionParameters_get_is_outbound_from_holder(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_is_outbound_from_holder(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_is_outbound_from_holderPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<LDKChannelTransactionParameters>)>>(
          'ChannelTransactionParameters_get_is_outbound_from_holder');
  late final _ChannelTransactionParameters_get_is_outbound_from_holder =
      _ChannelTransactionParameters_get_is_outbound_from_holderPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Whether the holder is the initiator of this channel.
  /// This is an input to the commitment number obscure factor computation.
  void ChannelTransactionParameters_set_is_outbound_from_holder(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    bool val,
  ) {
    return _ChannelTransactionParameters_set_is_outbound_from_holder(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_is_outbound_from_holderPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelTransactionParameters>, ffi.Bool)>>(
          'ChannelTransactionParameters_set_is_outbound_from_holder');
  late final _ChannelTransactionParameters_set_is_outbound_from_holder =
      _ChannelTransactionParameters_set_is_outbound_from_holderPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTransactionParameters>, bool)>();

  /// The late-bound counterparty channel transaction parameters.
  /// These parameters are populated at the point in the protocol where the counterparty provides them.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCounterpartyChannelTransactionParameters
      ChannelTransactionParameters_get_counterparty_parameters(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_counterparty_parameters(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_counterparty_parametersPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCounterpartyChannelTransactionParameters Function(
                      ffi.Pointer<LDKChannelTransactionParameters>)>>(
          'ChannelTransactionParameters_get_counterparty_parameters');
  late final _ChannelTransactionParameters_get_counterparty_parameters =
      _ChannelTransactionParameters_get_counterparty_parametersPtr.asFunction<
          LDKCounterpartyChannelTransactionParameters Function(
              ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// The late-bound counterparty channel transaction parameters.
  /// These parameters are populated at the point in the protocol where the counterparty provides them.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelTransactionParameters_set_counterparty_parameters(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    LDKCounterpartyChannelTransactionParameters val,
  ) {
    return _ChannelTransactionParameters_set_counterparty_parameters(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_counterparty_parametersPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKChannelTransactionParameters>,
                      LDKCounterpartyChannelTransactionParameters)>>(
          'ChannelTransactionParameters_set_counterparty_parameters');
  late final _ChannelTransactionParameters_set_counterparty_parameters =
      _ChannelTransactionParameters_set_counterparty_parametersPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTransactionParameters>,
              LDKCounterpartyChannelTransactionParameters)>();

  /// The late-bound funding outpoint
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_funding_outpoint(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_funding_outpointPtr = _lookup<
          ffi.NativeFunction<
              LDKOutPoint Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_get_funding_outpoint');
  late final _ChannelTransactionParameters_get_funding_outpoint =
      _ChannelTransactionParameters_get_funding_outpointPtr.asFunction<
          LDKOutPoint Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// The late-bound funding outpoint
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelTransactionParameters_set_funding_outpoint(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    LDKOutPoint val,
  ) {
    return _ChannelTransactionParameters_set_funding_outpoint(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_funding_outpointPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKChannelTransactionParameters>, LDKOutPoint)>>(
      'ChannelTransactionParameters_set_funding_outpoint');
  late final _ChannelTransactionParameters_set_funding_outpoint =
      _ChannelTransactionParameters_set_funding_outpointPtr.asFunction<
          void Function(
              ffi.Pointer<LDKChannelTransactionParameters>, LDKOutPoint)>();

  /// Are anchors used for this channel.  Boolean is serialization backwards-compatible
  int ChannelTransactionParameters_get_opt_anchors(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
  ) {
    return _ChannelTransactionParameters_get_opt_anchors(
      this_ptr,
    );
  }

  late final _ChannelTransactionParameters_get_opt_anchorsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_get_opt_anchors');
  late final _ChannelTransactionParameters_get_opt_anchors =
      _ChannelTransactionParameters_get_opt_anchorsPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Are anchors used for this channel.  Boolean is serialization backwards-compatible
  void ChannelTransactionParameters_set_opt_anchors(
    ffi.Pointer<LDKChannelTransactionParameters> this_ptr,
    int val,
  ) {
    return _ChannelTransactionParameters_set_opt_anchors(
      this_ptr,
      val,
    );
  }

  late final _ChannelTransactionParameters_set_opt_anchorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelTransactionParameters>,
              ffi.Int32)>>('ChannelTransactionParameters_set_opt_anchors');
  late final _ChannelTransactionParameters_set_opt_anchors =
      _ChannelTransactionParameters_set_opt_anchorsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTransactionParameters>, int)>();

  /// Constructs a new ChannelTransactionParameters given each field
  LDKChannelTransactionParameters ChannelTransactionParameters_new(
    LDKChannelPublicKeys holder_pubkeys_arg,
    int holder_selected_contest_delay_arg,
    bool is_outbound_from_holder_arg,
    LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg,
    LDKOutPoint funding_outpoint_arg,
    int opt_anchors_arg,
  ) {
    return _ChannelTransactionParameters_new(
      holder_pubkeys_arg,
      holder_selected_contest_delay_arg,
      is_outbound_from_holder_arg,
      counterparty_parameters_arg,
      funding_outpoint_arg,
      opt_anchors_arg,
    );
  }

  late final _ChannelTransactionParameters_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelTransactionParameters Function(
              LDKChannelPublicKeys,
              ffi.Uint16,
              ffi.Bool,
              LDKCounterpartyChannelTransactionParameters,
              LDKOutPoint,
              ffi.Int32)>>('ChannelTransactionParameters_new');
  late final _ChannelTransactionParameters_new =
      _ChannelTransactionParameters_newPtr.asFunction<
          LDKChannelTransactionParameters Function(
              LDKChannelPublicKeys,
              int,
              bool,
              LDKCounterpartyChannelTransactionParameters,
              LDKOutPoint,
              int)>();

  /// Creates a copy of the ChannelTransactionParameters
  LDKChannelTransactionParameters ChannelTransactionParameters_clone(
    ffi.Pointer<LDKChannelTransactionParameters> orig,
  ) {
    return _ChannelTransactionParameters_clone(
      orig,
    );
  }

  late final _ChannelTransactionParameters_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelTransactionParameters Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_clone');
  late final _ChannelTransactionParameters_clone =
      _ChannelTransactionParameters_clonePtr.asFunction<
          LDKChannelTransactionParameters Function(
              ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
  void CounterpartyChannelTransactionParameters_free(
    LDKCounterpartyChannelTransactionParameters this_obj,
  ) {
    return _CounterpartyChannelTransactionParameters_free(
      this_obj,
    );
  }

  late final _CounterpartyChannelTransactionParameters_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKCounterpartyChannelTransactionParameters)>>(
      'CounterpartyChannelTransactionParameters_free');
  late final _CounterpartyChannelTransactionParameters_free =
      _CounterpartyChannelTransactionParameters_freePtr.asFunction<
          void Function(LDKCounterpartyChannelTransactionParameters)>();

  /// Counter-party public keys
  LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> this_ptr,
  ) {
    return _CounterpartyChannelTransactionParameters_get_pubkeys(
      this_ptr,
    );
  }

  late final _CounterpartyChannelTransactionParameters_get_pubkeysPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelPublicKeys Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>>(
      'CounterpartyChannelTransactionParameters_get_pubkeys');
  late final _CounterpartyChannelTransactionParameters_get_pubkeys =
      _CounterpartyChannelTransactionParameters_get_pubkeysPtr.asFunction<
          LDKChannelPublicKeys Function(
              ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>();

  /// Counter-party public keys
  void CounterpartyChannelTransactionParameters_set_pubkeys(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> this_ptr,
    LDKChannelPublicKeys val,
  ) {
    return _CounterpartyChannelTransactionParameters_set_pubkeys(
      this_ptr,
      val,
    );
  }

  late final _CounterpartyChannelTransactionParameters_set_pubkeysPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>,
                  LDKChannelPublicKeys)>>(
      'CounterpartyChannelTransactionParameters_set_pubkeys');
  late final _CounterpartyChannelTransactionParameters_set_pubkeys =
      _CounterpartyChannelTransactionParameters_set_pubkeysPtr.asFunction<
          void Function(
              ffi.Pointer<LDKCounterpartyChannelTransactionParameters>,
              LDKChannelPublicKeys)>();

  /// The contest delay selected by the counterparty, which applies to holder-broadcast transactions
  int CounterpartyChannelTransactionParameters_get_selected_contest_delay(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> this_ptr,
  ) {
    return _CounterpartyChannelTransactionParameters_get_selected_contest_delay(
      this_ptr,
    );
  }

  late final _CounterpartyChannelTransactionParameters_get_selected_contest_delayPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint16 Function(
                      ffi.Pointer<
                          LDKCounterpartyChannelTransactionParameters>)>>(
          'CounterpartyChannelTransactionParameters_get_selected_contest_delay');
  late final _CounterpartyChannelTransactionParameters_get_selected_contest_delay =
      _CounterpartyChannelTransactionParameters_get_selected_contest_delayPtr
          .asFunction<
              int Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>();

  /// The contest delay selected by the counterparty, which applies to holder-broadcast transactions
  void CounterpartyChannelTransactionParameters_set_selected_contest_delay(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> this_ptr,
    int val,
  ) {
    return _CounterpartyChannelTransactionParameters_set_selected_contest_delay(
      this_ptr,
      val,
    );
  }

  late final _CounterpartyChannelTransactionParameters_set_selected_contest_delayPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKCounterpartyChannelTransactionParameters>,
                      ffi.Uint16)>>(
          'CounterpartyChannelTransactionParameters_set_selected_contest_delay');
  late final _CounterpartyChannelTransactionParameters_set_selected_contest_delay =
      _CounterpartyChannelTransactionParameters_set_selected_contest_delayPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>,
                  int)>();

  /// Constructs a new CounterpartyChannelTransactionParameters given each field
  LDKCounterpartyChannelTransactionParameters
      CounterpartyChannelTransactionParameters_new(
    LDKChannelPublicKeys pubkeys_arg,
    int selected_contest_delay_arg,
  ) {
    return _CounterpartyChannelTransactionParameters_new(
      pubkeys_arg,
      selected_contest_delay_arg,
    );
  }

  late final _CounterpartyChannelTransactionParameters_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCounterpartyChannelTransactionParameters Function(
              LDKChannelPublicKeys,
              ffi.Uint16)>>('CounterpartyChannelTransactionParameters_new');
  late final _CounterpartyChannelTransactionParameters_new =
      _CounterpartyChannelTransactionParameters_newPtr.asFunction<
          LDKCounterpartyChannelTransactionParameters Function(
              LDKChannelPublicKeys, int)>();

  /// Creates a copy of the CounterpartyChannelTransactionParameters
  LDKCounterpartyChannelTransactionParameters
      CounterpartyChannelTransactionParameters_clone(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> orig,
  ) {
    return _CounterpartyChannelTransactionParameters_clone(
      orig,
    );
  }

  late final _CounterpartyChannelTransactionParameters_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCounterpartyChannelTransactionParameters Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>>(
      'CounterpartyChannelTransactionParameters_clone');
  late final _CounterpartyChannelTransactionParameters_clone =
      _CounterpartyChannelTransactionParameters_clonePtr.asFunction<
          LDKCounterpartyChannelTransactionParameters Function(
              ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>();

  /// Whether the late bound parameters are populated.
  bool ChannelTransactionParameters_is_populated(
    ffi.Pointer<LDKChannelTransactionParameters> this_arg,
  ) {
    return _ChannelTransactionParameters_is_populated(
      this_arg,
    );
  }

  late final _ChannelTransactionParameters_is_populatedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_is_populated');
  late final _ChannelTransactionParameters_is_populated =
      _ChannelTransactionParameters_is_populatedPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
  /// given that the holder is the broadcaster.
  ///
  /// self.is_populated() must be true before calling this function.
  LDKDirectedChannelTransactionParameters
      ChannelTransactionParameters_as_holder_broadcastable(
    ffi.Pointer<LDKChannelTransactionParameters> this_arg,
  ) {
    return _ChannelTransactionParameters_as_holder_broadcastable(
      this_arg,
    );
  }

  late final _ChannelTransactionParameters_as_holder_broadcastablePtr = _lookup<
          ffi.NativeFunction<
              LDKDirectedChannelTransactionParameters Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_as_holder_broadcastable');
  late final _ChannelTransactionParameters_as_holder_broadcastable =
      _ChannelTransactionParameters_as_holder_broadcastablePtr.asFunction<
          LDKDirectedChannelTransactionParameters Function(
              ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
  /// given that the counterparty is the broadcaster.
  ///
  /// self.is_populated() must be true before calling this function.
  LDKDirectedChannelTransactionParameters
      ChannelTransactionParameters_as_counterparty_broadcastable(
    ffi.Pointer<LDKChannelTransactionParameters> this_arg,
  ) {
    return _ChannelTransactionParameters_as_counterparty_broadcastable(
      this_arg,
    );
  }

  late final _ChannelTransactionParameters_as_counterparty_broadcastablePtr =
      _lookup<
              ffi.NativeFunction<
                  LDKDirectedChannelTransactionParameters Function(
                      ffi.Pointer<LDKChannelTransactionParameters>)>>(
          'ChannelTransactionParameters_as_counterparty_broadcastable');
  late final _ChannelTransactionParameters_as_counterparty_broadcastable =
      _ChannelTransactionParameters_as_counterparty_broadcastablePtr.asFunction<
          LDKDirectedChannelTransactionParameters Function(
              ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
  LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(
    ffi.Pointer<LDKCounterpartyChannelTransactionParameters> obj,
  ) {
    return _CounterpartyChannelTransactionParameters_write(
      obj,
    );
  }

  late final _CounterpartyChannelTransactionParameters_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>>(
      'CounterpartyChannelTransactionParameters_write');
  late final _CounterpartyChannelTransactionParameters_write =
      _CounterpartyChannelTransactionParameters_writePtr.asFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKCounterpartyChannelTransactionParameters>)>();

  /// Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
  LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
      CounterpartyChannelTransactionParameters_read(
    LDKu8slice ser,
  ) {
    return _CounterpartyChannelTransactionParameters_read(
      ser,
    );
  }

  late final _CounterpartyChannelTransactionParameters_readPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
                  Function(LDKu8slice)>>(
      'CounterpartyChannelTransactionParameters_read');
  late final _CounterpartyChannelTransactionParameters_read =
      _CounterpartyChannelTransactionParameters_readPtr.asFunction<
          LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
              Function(LDKu8slice)>();

  /// Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
  LDKCVec_u8Z ChannelTransactionParameters_write(
    ffi.Pointer<LDKChannelTransactionParameters> obj,
  ) {
    return _ChannelTransactionParameters_write(
      obj,
    );
  }

  late final _ChannelTransactionParameters_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKChannelTransactionParameters>)>>(
      'ChannelTransactionParameters_write');
  late final _ChannelTransactionParameters_write =
      _ChannelTransactionParameters_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKChannelTransactionParameters>)>();

  /// Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
  LDKCResult_ChannelTransactionParametersDecodeErrorZ
      ChannelTransactionParameters_read(
    LDKu8slice ser,
  ) {
    return _ChannelTransactionParameters_read(
      ser,
    );
  }

  late final _ChannelTransactionParameters_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
              LDKu8slice)>>('ChannelTransactionParameters_read');
  late final _ChannelTransactionParameters_read =
      _ChannelTransactionParameters_readPtr.asFunction<
          LDKCResult_ChannelTransactionParametersDecodeErrorZ Function(
              LDKu8slice)>();

  /// Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
  void DirectedChannelTransactionParameters_free(
    LDKDirectedChannelTransactionParameters this_obj,
  ) {
    return _DirectedChannelTransactionParameters_free(
      this_obj,
    );
  }

  late final _DirectedChannelTransactionParameters_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKDirectedChannelTransactionParameters)>>(
      'DirectedChannelTransactionParameters_free');
  late final _DirectedChannelTransactionParameters_free =
      _DirectedChannelTransactionParameters_freePtr.asFunction<
          void Function(LDKDirectedChannelTransactionParameters)>();

  /// Get the channel pubkeys for the broadcaster
  LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_broadcaster_pubkeys(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_broadcaster_pubkeysPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKChannelPublicKeys Function(
                      ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
          'DirectedChannelTransactionParameters_broadcaster_pubkeys');
  late final _DirectedChannelTransactionParameters_broadcaster_pubkeys =
      _DirectedChannelTransactionParameters_broadcaster_pubkeysPtr.asFunction<
          LDKChannelPublicKeys Function(
              ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Get the channel pubkeys for the countersignatory
  LDKChannelPublicKeys
      DirectedChannelTransactionParameters_countersignatory_pubkeys(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_countersignatory_pubkeys(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_countersignatory_pubkeysPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKChannelPublicKeys Function(
                      ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
          'DirectedChannelTransactionParameters_countersignatory_pubkeys');
  late final _DirectedChannelTransactionParameters_countersignatory_pubkeys =
      _DirectedChannelTransactionParameters_countersignatory_pubkeysPtr
          .asFunction<
              LDKChannelPublicKeys Function(
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Get the contest delay applicable to the transactions.
  /// Note that the contest delay was selected by the countersignatory.
  int DirectedChannelTransactionParameters_contest_delay(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_contest_delay(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_contest_delayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
      'DirectedChannelTransactionParameters_contest_delay');
  late final _DirectedChannelTransactionParameters_contest_delay =
      _DirectedChannelTransactionParameters_contest_delayPtr.asFunction<
          int Function(ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Whether the channel is outbound from the broadcaster.
  ///
  /// The boolean representing the side that initiated the channel is
  /// an input to the commitment number obscure factor computation.
  bool DirectedChannelTransactionParameters_is_outbound(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_is_outbound(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_is_outboundPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
      'DirectedChannelTransactionParameters_is_outbound');
  late final _DirectedChannelTransactionParameters_is_outbound =
      _DirectedChannelTransactionParameters_is_outboundPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// The funding outpoint
  LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_funding_outpoint(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_funding_outpointPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKOutPoint Function(
                      ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
          'DirectedChannelTransactionParameters_funding_outpoint');
  late final _DirectedChannelTransactionParameters_funding_outpoint =
      _DirectedChannelTransactionParameters_funding_outpointPtr.asFunction<
          LDKOutPoint Function(
              ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Whether to use anchors for this channel
  bool DirectedChannelTransactionParameters_opt_anchors(
    ffi.Pointer<LDKDirectedChannelTransactionParameters> this_arg,
  ) {
    return _DirectedChannelTransactionParameters_opt_anchors(
      this_arg,
    );
  }

  late final _DirectedChannelTransactionParameters_opt_anchorsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
      'DirectedChannelTransactionParameters_opt_anchors');
  late final _DirectedChannelTransactionParameters_opt_anchors =
      _DirectedChannelTransactionParameters_opt_anchorsPtr.asFunction<
          bool Function(
              ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
  void HolderCommitmentTransaction_free(
    LDKHolderCommitmentTransaction this_obj,
  ) {
    return _HolderCommitmentTransaction_free(
      this_obj,
    );
  }

  late final _HolderCommitmentTransaction_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKHolderCommitmentTransaction)>>(
      'HolderCommitmentTransaction_free');
  late final _HolderCommitmentTransaction_free =
      _HolderCommitmentTransaction_freePtr.asFunction<
          void Function(LDKHolderCommitmentTransaction)>();

  /// Our counterparty's signature for the transaction
  LDKSignature HolderCommitmentTransaction_get_counterparty_sig(
    ffi.Pointer<LDKHolderCommitmentTransaction> this_ptr,
  ) {
    return _HolderCommitmentTransaction_get_counterparty_sig(
      this_ptr,
    );
  }

  late final _HolderCommitmentTransaction_get_counterparty_sigPtr = _lookup<
          ffi.NativeFunction<
              LDKSignature Function(
                  ffi.Pointer<LDKHolderCommitmentTransaction>)>>(
      'HolderCommitmentTransaction_get_counterparty_sig');
  late final _HolderCommitmentTransaction_get_counterparty_sig =
      _HolderCommitmentTransaction_get_counterparty_sigPtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKHolderCommitmentTransaction>)>();

  /// Our counterparty's signature for the transaction
  void HolderCommitmentTransaction_set_counterparty_sig(
    ffi.Pointer<LDKHolderCommitmentTransaction> this_ptr,
    LDKSignature val,
  ) {
    return _HolderCommitmentTransaction_set_counterparty_sig(
      this_ptr,
      val,
    );
  }

  late final _HolderCommitmentTransaction_set_counterparty_sigPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKHolderCommitmentTransaction>, LDKSignature)>>(
      'HolderCommitmentTransaction_set_counterparty_sig');
  late final _HolderCommitmentTransaction_set_counterparty_sig =
      _HolderCommitmentTransaction_set_counterparty_sigPtr.asFunction<
          void Function(
              ffi.Pointer<LDKHolderCommitmentTransaction>, LDKSignature)>();

  /// All non-dust counterparty HTLC signatures, in the order they appear in the transaction
  ///
  /// Returns a copy of the field.
  LDKCVec_SignatureZ HolderCommitmentTransaction_get_counterparty_htlc_sigs(
    ffi.Pointer<LDKHolderCommitmentTransaction> this_ptr,
  ) {
    return _HolderCommitmentTransaction_get_counterparty_htlc_sigs(
      this_ptr,
    );
  }

  late final _HolderCommitmentTransaction_get_counterparty_htlc_sigsPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCVec_SignatureZ Function(
                      ffi.Pointer<LDKHolderCommitmentTransaction>)>>(
          'HolderCommitmentTransaction_get_counterparty_htlc_sigs');
  late final _HolderCommitmentTransaction_get_counterparty_htlc_sigs =
      _HolderCommitmentTransaction_get_counterparty_htlc_sigsPtr.asFunction<
          LDKCVec_SignatureZ Function(
              ffi.Pointer<LDKHolderCommitmentTransaction>)>();

  /// All non-dust counterparty HTLC signatures, in the order they appear in the transaction
  void HolderCommitmentTransaction_set_counterparty_htlc_sigs(
    ffi.Pointer<LDKHolderCommitmentTransaction> this_ptr,
    LDKCVec_SignatureZ val,
  ) {
    return _HolderCommitmentTransaction_set_counterparty_htlc_sigs(
      this_ptr,
      val,
    );
  }

  late final _HolderCommitmentTransaction_set_counterparty_htlc_sigsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<LDKHolderCommitmentTransaction>,
                      LDKCVec_SignatureZ)>>(
          'HolderCommitmentTransaction_set_counterparty_htlc_sigs');
  late final _HolderCommitmentTransaction_set_counterparty_htlc_sigs =
      _HolderCommitmentTransaction_set_counterparty_htlc_sigsPtr.asFunction<
          void Function(ffi.Pointer<LDKHolderCommitmentTransaction>,
              LDKCVec_SignatureZ)>();

  /// Creates a copy of the HolderCommitmentTransaction
  LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(
    ffi.Pointer<LDKHolderCommitmentTransaction> orig,
  ) {
    return _HolderCommitmentTransaction_clone(
      orig,
    );
  }

  late final _HolderCommitmentTransaction_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKHolderCommitmentTransaction Function(
                  ffi.Pointer<LDKHolderCommitmentTransaction>)>>(
      'HolderCommitmentTransaction_clone');
  late final _HolderCommitmentTransaction_clone =
      _HolderCommitmentTransaction_clonePtr.asFunction<
          LDKHolderCommitmentTransaction Function(
              ffi.Pointer<LDKHolderCommitmentTransaction>)>();

  /// Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
  LDKCVec_u8Z HolderCommitmentTransaction_write(
    ffi.Pointer<LDKHolderCommitmentTransaction> obj,
  ) {
    return _HolderCommitmentTransaction_write(
      obj,
    );
  }

  late final _HolderCommitmentTransaction_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKHolderCommitmentTransaction>)>>(
      'HolderCommitmentTransaction_write');
  late final _HolderCommitmentTransaction_write =
      _HolderCommitmentTransaction_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKHolderCommitmentTransaction>)>();

  /// Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
  LDKCResult_HolderCommitmentTransactionDecodeErrorZ
      HolderCommitmentTransaction_read(
    LDKu8slice ser,
  ) {
    return _HolderCommitmentTransaction_read(
      ser,
    );
  }

  late final _HolderCommitmentTransaction_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
              LDKu8slice)>>('HolderCommitmentTransaction_read');
  late final _HolderCommitmentTransaction_read =
      _HolderCommitmentTransaction_readPtr.asFunction<
          LDKCResult_HolderCommitmentTransactionDecodeErrorZ Function(
              LDKu8slice)>();

  /// Create a new holder transaction with the given counterparty signatures.
  /// The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
  LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(
    LDKCommitmentTransaction commitment_tx,
    LDKSignature counterparty_sig,
    LDKCVec_SignatureZ counterparty_htlc_sigs,
    LDKPublicKey holder_funding_key,
    LDKPublicKey counterparty_funding_key,
  ) {
    return _HolderCommitmentTransaction_new(
      commitment_tx,
      counterparty_sig,
      counterparty_htlc_sigs,
      holder_funding_key,
      counterparty_funding_key,
    );
  }

  late final _HolderCommitmentTransaction_newPtr = _lookup<
      ffi.NativeFunction<
          LDKHolderCommitmentTransaction Function(
              LDKCommitmentTransaction,
              LDKSignature,
              LDKCVec_SignatureZ,
              LDKPublicKey,
              LDKPublicKey)>>('HolderCommitmentTransaction_new');
  late final _HolderCommitmentTransaction_new =
      _HolderCommitmentTransaction_newPtr.asFunction<
          LDKHolderCommitmentTransaction Function(LDKCommitmentTransaction,
              LDKSignature, LDKCVec_SignatureZ, LDKPublicKey, LDKPublicKey)>();

  /// Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
  void BuiltCommitmentTransaction_free(
    LDKBuiltCommitmentTransaction this_obj,
  ) {
    return _BuiltCommitmentTransaction_free(
      this_obj,
    );
  }

  late final _BuiltCommitmentTransaction_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKBuiltCommitmentTransaction)>>(
      'BuiltCommitmentTransaction_free');
  late final _BuiltCommitmentTransaction_free =
      _BuiltCommitmentTransaction_freePtr.asFunction<
          void Function(LDKBuiltCommitmentTransaction)>();

  /// The commitment transaction
  LDKTransaction BuiltCommitmentTransaction_get_transaction(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_ptr,
  ) {
    return _BuiltCommitmentTransaction_get_transaction(
      this_ptr,
    );
  }

  late final _BuiltCommitmentTransaction_get_transactionPtr = _lookup<
          ffi.NativeFunction<
              LDKTransaction Function(
                  ffi.Pointer<LDKBuiltCommitmentTransaction>)>>(
      'BuiltCommitmentTransaction_get_transaction');
  late final _BuiltCommitmentTransaction_get_transaction =
      _BuiltCommitmentTransaction_get_transactionPtr.asFunction<
          LDKTransaction Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>)>();

  /// The commitment transaction
  void BuiltCommitmentTransaction_set_transaction(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_ptr,
    LDKTransaction val,
  ) {
    return _BuiltCommitmentTransaction_set_transaction(
      this_ptr,
      val,
    );
  }

  late final _BuiltCommitmentTransaction_set_transactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKBuiltCommitmentTransaction>,
              LDKTransaction)>>('BuiltCommitmentTransaction_set_transaction');
  late final _BuiltCommitmentTransaction_set_transaction =
      _BuiltCommitmentTransaction_set_transactionPtr.asFunction<
          void Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>, LDKTransaction)>();

  /// The txid for the commitment transaction.
  ///
  /// This is provided as a performance optimization, instead of calling transaction.txid()
  /// multiple times.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> BuiltCommitmentTransaction_get_txid(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_ptr,
  ) {
    return _BuiltCommitmentTransaction_get_txid(
      this_ptr,
    );
  }

  late final _BuiltCommitmentTransaction_get_txidPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKBuiltCommitmentTransaction>)>>(
      'BuiltCommitmentTransaction_get_txid');
  late final _BuiltCommitmentTransaction_get_txid =
      _BuiltCommitmentTransaction_get_txidPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>)>();

  /// The txid for the commitment transaction.
  ///
  /// This is provided as a performance optimization, instead of calling transaction.txid()
  /// multiple times.
  void BuiltCommitmentTransaction_set_txid(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _BuiltCommitmentTransaction_set_txid(
      this_ptr,
      val,
    );
  }

  late final _BuiltCommitmentTransaction_set_txidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKBuiltCommitmentTransaction>,
              LDKThirtyTwoBytes)>>('BuiltCommitmentTransaction_set_txid');
  late final _BuiltCommitmentTransaction_set_txid =
      _BuiltCommitmentTransaction_set_txidPtr.asFunction<
          void Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>, LDKThirtyTwoBytes)>();

  /// Constructs a new BuiltCommitmentTransaction given each field
  LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(
    LDKTransaction transaction_arg,
    LDKThirtyTwoBytes txid_arg,
  ) {
    return _BuiltCommitmentTransaction_new(
      transaction_arg,
      txid_arg,
    );
  }

  late final _BuiltCommitmentTransaction_newPtr = _lookup<
      ffi.NativeFunction<
          LDKBuiltCommitmentTransaction Function(LDKTransaction,
              LDKThirtyTwoBytes)>>('BuiltCommitmentTransaction_new');
  late final _BuiltCommitmentTransaction_new =
      _BuiltCommitmentTransaction_newPtr.asFunction<
          LDKBuiltCommitmentTransaction Function(
              LDKTransaction, LDKThirtyTwoBytes)>();

  /// Creates a copy of the BuiltCommitmentTransaction
  LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(
    ffi.Pointer<LDKBuiltCommitmentTransaction> orig,
  ) {
    return _BuiltCommitmentTransaction_clone(
      orig,
    );
  }

  late final _BuiltCommitmentTransaction_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKBuiltCommitmentTransaction Function(
                  ffi.Pointer<LDKBuiltCommitmentTransaction>)>>(
      'BuiltCommitmentTransaction_clone');
  late final _BuiltCommitmentTransaction_clone =
      _BuiltCommitmentTransaction_clonePtr.asFunction<
          LDKBuiltCommitmentTransaction Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>)>();

  /// Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
  LDKCVec_u8Z BuiltCommitmentTransaction_write(
    ffi.Pointer<LDKBuiltCommitmentTransaction> obj,
  ) {
    return _BuiltCommitmentTransaction_write(
      obj,
    );
  }

  late final _BuiltCommitmentTransaction_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKBuiltCommitmentTransaction>)>>(
      'BuiltCommitmentTransaction_write');
  late final _BuiltCommitmentTransaction_write =
      _BuiltCommitmentTransaction_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKBuiltCommitmentTransaction>)>();

  /// Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
  LDKCResult_BuiltCommitmentTransactionDecodeErrorZ
      BuiltCommitmentTransaction_read(
    LDKu8slice ser,
  ) {
    return _BuiltCommitmentTransaction_read(
      ser,
    );
  }

  late final _BuiltCommitmentTransaction_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
              LDKu8slice)>>('BuiltCommitmentTransaction_read');
  late final _BuiltCommitmentTransaction_read =
      _BuiltCommitmentTransaction_readPtr.asFunction<
          LDKCResult_BuiltCommitmentTransactionDecodeErrorZ Function(
              LDKu8slice)>();

  /// Get the SIGHASH_ALL sighash value of the transaction.
  ///
  /// This can be used to verify a signature.
  LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_arg,
    LDKu8slice funding_redeemscript,
    int channel_value_satoshis,
  ) {
    return _BuiltCommitmentTransaction_get_sighash_all(
      this_arg,
      funding_redeemscript,
      channel_value_satoshis,
    );
  }

  late final _BuiltCommitmentTransaction_get_sighash_allPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>,
              LDKu8slice,
              ffi.Uint64)>>('BuiltCommitmentTransaction_get_sighash_all');
  late final _BuiltCommitmentTransaction_get_sighash_all =
      _BuiltCommitmentTransaction_get_sighash_allPtr.asFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>, LDKu8slice, int)>();

  /// Sign a transaction, either because we are counter-signing the counterparty's transaction or
  /// because we are about to broadcast a holder transaction.
  LDKSignature BuiltCommitmentTransaction_sign(
    ffi.Pointer<LDKBuiltCommitmentTransaction> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> funding_key,
    LDKu8slice funding_redeemscript,
    int channel_value_satoshis,
  ) {
    return _BuiltCommitmentTransaction_sign(
      this_arg,
      funding_key,
      funding_redeemscript,
      channel_value_satoshis,
    );
  }

  late final _BuiltCommitmentTransaction_signPtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKBuiltCommitmentTransaction>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKu8slice,
              ffi.Uint64)>>('BuiltCommitmentTransaction_sign');
  late final _BuiltCommitmentTransaction_sign =
      _BuiltCommitmentTransaction_signPtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKBuiltCommitmentTransaction>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKu8slice, int)>();

  /// Frees any resources used by the ClosingTransaction, if is_owned is set and inner is non-NULL.
  void ClosingTransaction_free(
    LDKClosingTransaction this_obj,
  ) {
    return _ClosingTransaction_free(
      this_obj,
    );
  }

  late final _ClosingTransaction_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKClosingTransaction)>>(
          'ClosingTransaction_free');
  late final _ClosingTransaction_free = _ClosingTransaction_freePtr.asFunction<
      void Function(LDKClosingTransaction)>();

  /// Creates a copy of the ClosingTransaction
  LDKClosingTransaction ClosingTransaction_clone(
    ffi.Pointer<LDKClosingTransaction> orig,
  ) {
    return _ClosingTransaction_clone(
      orig,
    );
  }

  late final _ClosingTransaction_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKClosingTransaction Function(
              ffi.Pointer<LDKClosingTransaction>)>>('ClosingTransaction_clone');
  late final _ClosingTransaction_clone =
      _ClosingTransaction_clonePtr.asFunction<
          LDKClosingTransaction Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// Checks if two ClosingTransactions contain equal inner contents.
  int ClosingTransaction_hash(
    ffi.Pointer<LDKClosingTransaction> o,
  ) {
    return _ClosingTransaction_hash(
      o,
    );
  }

  late final _ClosingTransaction_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKClosingTransaction>)>>('ClosingTransaction_hash');
  late final _ClosingTransaction_hash = _ClosingTransaction_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// Construct an object of the class
  LDKClosingTransaction ClosingTransaction_new(
    int to_holder_value_sat,
    int to_counterparty_value_sat,
    LDKCVec_u8Z to_holder_script,
    LDKCVec_u8Z to_counterparty_script,
    LDKOutPoint funding_outpoint,
  ) {
    return _ClosingTransaction_new(
      to_holder_value_sat,
      to_counterparty_value_sat,
      to_holder_script,
      to_counterparty_script,
      funding_outpoint,
    );
  }

  late final _ClosingTransaction_newPtr = _lookup<
      ffi.NativeFunction<
          LDKClosingTransaction Function(ffi.Uint64, ffi.Uint64, LDKCVec_u8Z,
              LDKCVec_u8Z, LDKOutPoint)>>('ClosingTransaction_new');
  late final _ClosingTransaction_new = _ClosingTransaction_newPtr.asFunction<
      LDKClosingTransaction Function(
          int, int, LDKCVec_u8Z, LDKCVec_u8Z, LDKOutPoint)>();

  /// Trust our pre-built transaction.
  ///
  /// Applies a wrapper which allows access to the transaction.
  ///
  /// This should only be used if you fully trust the builder of this object. It should not
  /// be used by an external signer - instead use the verify function.
  LDKTrustedClosingTransaction ClosingTransaction_trust(
    ffi.Pointer<LDKClosingTransaction> this_arg,
  ) {
    return _ClosingTransaction_trust(
      this_arg,
    );
  }

  late final _ClosingTransaction_trustPtr = _lookup<
      ffi.NativeFunction<
          LDKTrustedClosingTransaction Function(
              ffi.Pointer<LDKClosingTransaction>)>>('ClosingTransaction_trust');
  late final _ClosingTransaction_trust =
      _ClosingTransaction_trustPtr.asFunction<
          LDKTrustedClosingTransaction Function(
              ffi.Pointer<LDKClosingTransaction>)>();

  /// Verify our pre-built transaction.
  ///
  /// Applies a wrapper which allows access to the transaction.
  ///
  /// An external validating signer must call this method before signing
  /// or using the built transaction.
  LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(
    ffi.Pointer<LDKClosingTransaction> this_arg,
    LDKOutPoint funding_outpoint,
  ) {
    return _ClosingTransaction_verify(
      this_arg,
      funding_outpoint,
    );
  }

  late final _ClosingTransaction_verifyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_TrustedClosingTransactionNoneZ Function(
              ffi.Pointer<LDKClosingTransaction>,
              LDKOutPoint)>>('ClosingTransaction_verify');
  late final _ClosingTransaction_verify =
      _ClosingTransaction_verifyPtr.asFunction<
          LDKCResult_TrustedClosingTransactionNoneZ Function(
              ffi.Pointer<LDKClosingTransaction>, LDKOutPoint)>();

  /// The value to be sent to the holder, or zero if the output will be omitted
  int ClosingTransaction_to_holder_value_sat(
    ffi.Pointer<LDKClosingTransaction> this_arg,
  ) {
    return _ClosingTransaction_to_holder_value_sat(
      this_arg,
    );
  }

  late final _ClosingTransaction_to_holder_value_satPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKClosingTransaction>)>>(
      'ClosingTransaction_to_holder_value_sat');
  late final _ClosingTransaction_to_holder_value_sat =
      _ClosingTransaction_to_holder_value_satPtr.asFunction<
          int Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// The value to be sent to the counterparty, or zero if the output will be omitted
  int ClosingTransaction_to_counterparty_value_sat(
    ffi.Pointer<LDKClosingTransaction> this_arg,
  ) {
    return _ClosingTransaction_to_counterparty_value_sat(
      this_arg,
    );
  }

  late final _ClosingTransaction_to_counterparty_value_satPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKClosingTransaction>)>>(
      'ClosingTransaction_to_counterparty_value_sat');
  late final _ClosingTransaction_to_counterparty_value_sat =
      _ClosingTransaction_to_counterparty_value_satPtr.asFunction<
          int Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// The destination of the holder's output
  LDKu8slice ClosingTransaction_to_holder_script(
    ffi.Pointer<LDKClosingTransaction> this_arg,
  ) {
    return _ClosingTransaction_to_holder_script(
      this_arg,
    );
  }

  late final _ClosingTransaction_to_holder_scriptPtr = _lookup<
          ffi.NativeFunction<
              LDKu8slice Function(ffi.Pointer<LDKClosingTransaction>)>>(
      'ClosingTransaction_to_holder_script');
  late final _ClosingTransaction_to_holder_script =
      _ClosingTransaction_to_holder_scriptPtr.asFunction<
          LDKu8slice Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// The destination of the counterparty's output
  LDKu8slice ClosingTransaction_to_counterparty_script(
    ffi.Pointer<LDKClosingTransaction> this_arg,
  ) {
    return _ClosingTransaction_to_counterparty_script(
      this_arg,
    );
  }

  late final _ClosingTransaction_to_counterparty_scriptPtr = _lookup<
          ffi.NativeFunction<
              LDKu8slice Function(ffi.Pointer<LDKClosingTransaction>)>>(
      'ClosingTransaction_to_counterparty_script');
  late final _ClosingTransaction_to_counterparty_script =
      _ClosingTransaction_to_counterparty_scriptPtr.asFunction<
          LDKu8slice Function(ffi.Pointer<LDKClosingTransaction>)>();

  /// Frees any resources used by the TrustedClosingTransaction, if is_owned is set and inner is non-NULL.
  void TrustedClosingTransaction_free(
    LDKTrustedClosingTransaction this_obj,
  ) {
    return _TrustedClosingTransaction_free(
      this_obj,
    );
  }

  late final _TrustedClosingTransaction_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKTrustedClosingTransaction)>>(
      'TrustedClosingTransaction_free');
  late final _TrustedClosingTransaction_free =
      _TrustedClosingTransaction_freePtr.asFunction<
          void Function(LDKTrustedClosingTransaction)>();

  /// The pre-built Bitcoin commitment transaction
  LDKTransaction TrustedClosingTransaction_built_transaction(
    ffi.Pointer<LDKTrustedClosingTransaction> this_arg,
  ) {
    return _TrustedClosingTransaction_built_transaction(
      this_arg,
    );
  }

  late final _TrustedClosingTransaction_built_transactionPtr = _lookup<
          ffi.NativeFunction<
              LDKTransaction Function(
                  ffi.Pointer<LDKTrustedClosingTransaction>)>>(
      'TrustedClosingTransaction_built_transaction');
  late final _TrustedClosingTransaction_built_transaction =
      _TrustedClosingTransaction_built_transactionPtr.asFunction<
          LDKTransaction Function(ffi.Pointer<LDKTrustedClosingTransaction>)>();

  /// Get the SIGHASH_ALL sighash value of the transaction.
  ///
  /// This can be used to verify a signature.
  LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(
    ffi.Pointer<LDKTrustedClosingTransaction> this_arg,
    LDKu8slice funding_redeemscript,
    int channel_value_satoshis,
  ) {
    return _TrustedClosingTransaction_get_sighash_all(
      this_arg,
      funding_redeemscript,
      channel_value_satoshis,
    );
  }

  late final _TrustedClosingTransaction_get_sighash_allPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKTrustedClosingTransaction>,
              LDKu8slice,
              ffi.Uint64)>>('TrustedClosingTransaction_get_sighash_all');
  late final _TrustedClosingTransaction_get_sighash_all =
      _TrustedClosingTransaction_get_sighash_allPtr.asFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKTrustedClosingTransaction>, LDKu8slice, int)>();

  /// Sign a transaction, either because we are counter-signing the counterparty's transaction or
  /// because we are about to broadcast a holder transaction.
  LDKSignature TrustedClosingTransaction_sign(
    ffi.Pointer<LDKTrustedClosingTransaction> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> funding_key,
    LDKu8slice funding_redeemscript,
    int channel_value_satoshis,
  ) {
    return _TrustedClosingTransaction_sign(
      this_arg,
      funding_key,
      funding_redeemscript,
      channel_value_satoshis,
    );
  }

  late final _TrustedClosingTransaction_signPtr = _lookup<
      ffi.NativeFunction<
          LDKSignature Function(
              ffi.Pointer<LDKTrustedClosingTransaction>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKu8slice,
              ffi.Uint64)>>('TrustedClosingTransaction_sign');
  late final _TrustedClosingTransaction_sign =
      _TrustedClosingTransaction_signPtr.asFunction<
          LDKSignature Function(ffi.Pointer<LDKTrustedClosingTransaction>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKu8slice, int)>();

  /// Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
  void CommitmentTransaction_free(
    LDKCommitmentTransaction this_obj,
  ) {
    return _CommitmentTransaction_free(
      this_obj,
    );
  }

  late final _CommitmentTransaction_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCommitmentTransaction)>>(
          'CommitmentTransaction_free');
  late final _CommitmentTransaction_free = _CommitmentTransaction_freePtr
      .asFunction<void Function(LDKCommitmentTransaction)>();

  /// Creates a copy of the CommitmentTransaction
  LDKCommitmentTransaction CommitmentTransaction_clone(
    ffi.Pointer<LDKCommitmentTransaction> orig,
  ) {
    return _CommitmentTransaction_clone(
      orig,
    );
  }

  late final _CommitmentTransaction_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKCommitmentTransaction Function(
                  ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_clone');
  late final _CommitmentTransaction_clone =
      _CommitmentTransaction_clonePtr.asFunction<
          LDKCommitmentTransaction Function(
              ffi.Pointer<LDKCommitmentTransaction>)>();

  /// Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
  LDKCVec_u8Z CommitmentTransaction_write(
    ffi.Pointer<LDKCommitmentTransaction> obj,
  ) {
    return _CommitmentTransaction_write(
      obj,
    );
  }

  late final _CommitmentTransaction_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_write');
  late final _CommitmentTransaction_write =
      _CommitmentTransaction_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKCommitmentTransaction>)>();

  /// Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
  LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(
    LDKu8slice ser,
  ) {
    return _CommitmentTransaction_read(
      ser,
    );
  }

  late final _CommitmentTransaction_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CommitmentTransactionDecodeErrorZ Function(
              LDKu8slice)>>('CommitmentTransaction_read');
  late final _CommitmentTransaction_read =
      _CommitmentTransaction_readPtr.asFunction<
          LDKCResult_CommitmentTransactionDecodeErrorZ Function(LDKu8slice)>();

  /// The backwards-counting commitment number
  int CommitmentTransaction_commitment_number(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
  ) {
    return _CommitmentTransaction_commitment_number(
      this_arg,
    );
  }

  late final _CommitmentTransaction_commitment_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_commitment_number');
  late final _CommitmentTransaction_commitment_number =
      _CommitmentTransaction_commitment_numberPtr.asFunction<
          int Function(ffi.Pointer<LDKCommitmentTransaction>)>();

  /// The value to be sent to the broadcaster
  int CommitmentTransaction_to_broadcaster_value_sat(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
  ) {
    return _CommitmentTransaction_to_broadcaster_value_sat(
      this_arg,
    );
  }

  late final _CommitmentTransaction_to_broadcaster_value_satPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_to_broadcaster_value_sat');
  late final _CommitmentTransaction_to_broadcaster_value_sat =
      _CommitmentTransaction_to_broadcaster_value_satPtr.asFunction<
          int Function(ffi.Pointer<LDKCommitmentTransaction>)>();

  /// The value to be sent to the counterparty
  int CommitmentTransaction_to_countersignatory_value_sat(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
  ) {
    return _CommitmentTransaction_to_countersignatory_value_sat(
      this_arg,
    );
  }

  late final _CommitmentTransaction_to_countersignatory_value_satPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_to_countersignatory_value_sat');
  late final _CommitmentTransaction_to_countersignatory_value_sat =
      _CommitmentTransaction_to_countersignatory_value_satPtr.asFunction<
          int Function(ffi.Pointer<LDKCommitmentTransaction>)>();

  /// The feerate paid per 1000-weight-unit in this commitment transaction.
  int CommitmentTransaction_feerate_per_kw(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
  ) {
    return _CommitmentTransaction_feerate_per_kw(
      this_arg,
    );
  }

  late final _CommitmentTransaction_feerate_per_kwPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_feerate_per_kw');
  late final _CommitmentTransaction_feerate_per_kw =
      _CommitmentTransaction_feerate_per_kwPtr.asFunction<
          int Function(ffi.Pointer<LDKCommitmentTransaction>)>();

  /// Trust our pre-built transaction and derived transaction creation public keys.
  ///
  /// Applies a wrapper which allows access to these fields.
  ///
  /// This should only be used if you fully trust the builder of this object.  It should not
  /// be used by an external signer - instead use the verify function.
  LDKTrustedCommitmentTransaction CommitmentTransaction_trust(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
  ) {
    return _CommitmentTransaction_trust(
      this_arg,
    );
  }

  late final _CommitmentTransaction_trustPtr = _lookup<
          ffi.NativeFunction<
              LDKTrustedCommitmentTransaction Function(
                  ffi.Pointer<LDKCommitmentTransaction>)>>(
      'CommitmentTransaction_trust');
  late final _CommitmentTransaction_trust =
      _CommitmentTransaction_trustPtr.asFunction<
          LDKTrustedCommitmentTransaction Function(
              ffi.Pointer<LDKCommitmentTransaction>)>();

  /// Verify our pre-built transaction and derived transaction creation public keys.
  ///
  /// Applies a wrapper which allows access to these fields.
  ///
  /// An external validating signer must call this method before signing
  /// or using the built transaction.
  LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(
    ffi.Pointer<LDKCommitmentTransaction> this_arg,
    ffi.Pointer<LDKDirectedChannelTransactionParameters> channel_parameters,
    ffi.Pointer<LDKChannelPublicKeys> broadcaster_keys,
    ffi.Pointer<LDKChannelPublicKeys> countersignatory_keys,
  ) {
    return _CommitmentTransaction_verify(
      this_arg,
      channel_parameters,
      broadcaster_keys,
      countersignatory_keys,
    );
  }

  late final _CommitmentTransaction_verifyPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_TrustedCommitmentTransactionNoneZ Function(
                  ffi.Pointer<LDKCommitmentTransaction>,
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>,
                  ffi.Pointer<LDKChannelPublicKeys>,
                  ffi.Pointer<LDKChannelPublicKeys>)>>(
      'CommitmentTransaction_verify');
  late final _CommitmentTransaction_verify =
      _CommitmentTransaction_verifyPtr.asFunction<
          LDKCResult_TrustedCommitmentTransactionNoneZ Function(
              ffi.Pointer<LDKCommitmentTransaction>,
              ffi.Pointer<LDKDirectedChannelTransactionParameters>,
              ffi.Pointer<LDKChannelPublicKeys>,
              ffi.Pointer<LDKChannelPublicKeys>)>();

  /// Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
  void TrustedCommitmentTransaction_free(
    LDKTrustedCommitmentTransaction this_obj,
  ) {
    return _TrustedCommitmentTransaction_free(
      this_obj,
    );
  }

  late final _TrustedCommitmentTransaction_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKTrustedCommitmentTransaction)>>(
      'TrustedCommitmentTransaction_free');
  late final _TrustedCommitmentTransaction_free =
      _TrustedCommitmentTransaction_freePtr.asFunction<
          void Function(LDKTrustedCommitmentTransaction)>();

  /// The transaction ID of the built Bitcoin transaction
  LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(
    ffi.Pointer<LDKTrustedCommitmentTransaction> this_arg,
  ) {
    return _TrustedCommitmentTransaction_txid(
      this_arg,
    );
  }

  late final _TrustedCommitmentTransaction_txidPtr = _lookup<
          ffi.NativeFunction<
              LDKThirtyTwoBytes Function(
                  ffi.Pointer<LDKTrustedCommitmentTransaction>)>>(
      'TrustedCommitmentTransaction_txid');
  late final _TrustedCommitmentTransaction_txid =
      _TrustedCommitmentTransaction_txidPtr.asFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKTrustedCommitmentTransaction>)>();

  /// The pre-built Bitcoin commitment transaction
  LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(
    ffi.Pointer<LDKTrustedCommitmentTransaction> this_arg,
  ) {
    return _TrustedCommitmentTransaction_built_transaction(
      this_arg,
    );
  }

  late final _TrustedCommitmentTransaction_built_transactionPtr = _lookup<
          ffi.NativeFunction<
              LDKBuiltCommitmentTransaction Function(
                  ffi.Pointer<LDKTrustedCommitmentTransaction>)>>(
      'TrustedCommitmentTransaction_built_transaction');
  late final _TrustedCommitmentTransaction_built_transaction =
      _TrustedCommitmentTransaction_built_transactionPtr.asFunction<
          LDKBuiltCommitmentTransaction Function(
              ffi.Pointer<LDKTrustedCommitmentTransaction>)>();

  /// The pre-calculated transaction creation public keys.
  LDKTxCreationKeys TrustedCommitmentTransaction_keys(
    ffi.Pointer<LDKTrustedCommitmentTransaction> this_arg,
  ) {
    return _TrustedCommitmentTransaction_keys(
      this_arg,
    );
  }

  late final _TrustedCommitmentTransaction_keysPtr = _lookup<
          ffi.NativeFunction<
              LDKTxCreationKeys Function(
                  ffi.Pointer<LDKTrustedCommitmentTransaction>)>>(
      'TrustedCommitmentTransaction_keys');
  late final _TrustedCommitmentTransaction_keys =
      _TrustedCommitmentTransaction_keysPtr.asFunction<
          LDKTxCreationKeys Function(
              ffi.Pointer<LDKTrustedCommitmentTransaction>)>();

  /// Should anchors be used.
  bool TrustedCommitmentTransaction_opt_anchors(
    ffi.Pointer<LDKTrustedCommitmentTransaction> this_arg,
  ) {
    return _TrustedCommitmentTransaction_opt_anchors(
      this_arg,
    );
  }

  late final _TrustedCommitmentTransaction_opt_anchorsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKTrustedCommitmentTransaction>)>>(
      'TrustedCommitmentTransaction_opt_anchors');
  late final _TrustedCommitmentTransaction_opt_anchors =
      _TrustedCommitmentTransaction_opt_anchorsPtr.asFunction<
          bool Function(ffi.Pointer<LDKTrustedCommitmentTransaction>)>();

  /// Get a signature for each HTLC which was included in the commitment transaction (ie for
  /// which HTLCOutputInCommitment::transaction_output_index.is_some()).
  ///
  /// The returned Vec has one entry for each HTLC, and in the same order.
  ///
  /// This function is only valid in the holder commitment context, it always uses EcdsaSighashType::All.
  LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(
    ffi.Pointer<LDKTrustedCommitmentTransaction> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> htlc_base_key,
    ffi.Pointer<LDKDirectedChannelTransactionParameters> channel_parameters,
  ) {
    return _TrustedCommitmentTransaction_get_htlc_sigs(
      this_arg,
      htlc_base_key,
      channel_parameters,
    );
  }

  late final _TrustedCommitmentTransaction_get_htlc_sigsPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_CVec_SignatureZNoneZ Function(
                  ffi.Pointer<LDKTrustedCommitmentTransaction>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<LDKDirectedChannelTransactionParameters>)>>(
      'TrustedCommitmentTransaction_get_htlc_sigs');
  late final _TrustedCommitmentTransaction_get_htlc_sigs =
      _TrustedCommitmentTransaction_get_htlc_sigsPtr.asFunction<
          LDKCResult_CVec_SignatureZNoneZ Function(
              ffi.Pointer<LDKTrustedCommitmentTransaction>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<LDKDirectedChannelTransactionParameters>)>();

  /// Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
  /// shared secret first. This prevents on-chain observers from discovering how many commitment
  /// transactions occurred in a channel before it was closed.
  ///
  /// This function gets the shared secret from relevant channel public keys and can be used to
  /// \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
  int get_commitment_transaction_number_obscure_factor(
    LDKPublicKey broadcaster_payment_basepoint,
    LDKPublicKey countersignatory_payment_basepoint,
    bool outbound_from_broadcaster,
  ) {
    return _get_commitment_transaction_number_obscure_factor(
      broadcaster_payment_basepoint,
      countersignatory_payment_basepoint,
      outbound_from_broadcaster,
    );
  }

  late final _get_commitment_transaction_number_obscure_factorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(LDKPublicKey, LDKPublicKey,
              ffi.Bool)>>('get_commitment_transaction_number_obscure_factor');
  late final _get_commitment_transaction_number_obscure_factor =
      _get_commitment_transaction_number_obscure_factorPtr
          .asFunction<int Function(LDKPublicKey, LDKPublicKey, bool)>();

  /// Checks if two InitFeaturess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool InitFeatures_eq(
    ffi.Pointer<LDKInitFeatures> a,
    ffi.Pointer<LDKInitFeatures> b,
  ) {
    return _InitFeatures_eq(
      a,
      b,
    );
  }

  late final _InitFeatures_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKInitFeatures>,
              ffi.Pointer<LDKInitFeatures>)>>('InitFeatures_eq');
  late final _InitFeatures_eq = _InitFeatures_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKInitFeatures>, ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if two NodeFeaturess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool NodeFeatures_eq(
    ffi.Pointer<LDKNodeFeatures> a,
    ffi.Pointer<LDKNodeFeatures> b,
  ) {
    return _NodeFeatures_eq(
      a,
      b,
    );
  }

  late final _NodeFeatures_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>,
              ffi.Pointer<LDKNodeFeatures>)>>('NodeFeatures_eq');
  late final _NodeFeatures_eq = _NodeFeatures_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKNodeFeatures>, ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if two ChannelFeaturess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool ChannelFeatures_eq(
    ffi.Pointer<LDKChannelFeatures> a,
    ffi.Pointer<LDKChannelFeatures> b,
  ) {
    return _ChannelFeatures_eq(
      a,
      b,
    );
  }

  late final _ChannelFeatures_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKChannelFeatures>,
              ffi.Pointer<LDKChannelFeatures>)>>('ChannelFeatures_eq');
  late final _ChannelFeatures_eq = _ChannelFeatures_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKChannelFeatures>, ffi.Pointer<LDKChannelFeatures>)>();

  /// Checks if two InvoiceFeaturess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool InvoiceFeatures_eq(
    ffi.Pointer<LDKInvoiceFeatures> a,
    ffi.Pointer<LDKInvoiceFeatures> b,
  ) {
    return _InvoiceFeatures_eq(
      a,
      b,
    );
  }

  late final _InvoiceFeatures_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>,
              ffi.Pointer<LDKInvoiceFeatures>)>>('InvoiceFeatures_eq');
  late final _InvoiceFeatures_eq = _InvoiceFeatures_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKInvoiceFeatures>, ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if two ChannelTypeFeaturess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool ChannelTypeFeatures_eq(
    ffi.Pointer<LDKChannelTypeFeatures> a,
    ffi.Pointer<LDKChannelTypeFeatures> b,
  ) {
    return _ChannelTypeFeatures_eq(
      a,
      b,
    );
  }

  late final _ChannelTypeFeatures_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>,
              ffi.Pointer<LDKChannelTypeFeatures>)>>('ChannelTypeFeatures_eq');
  late final _ChannelTypeFeatures_eq = _ChannelTypeFeatures_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKChannelTypeFeatures>,
          ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Creates a copy of the InitFeatures
  LDKInitFeatures InitFeatures_clone(
    ffi.Pointer<LDKInitFeatures> orig,
  ) {
    return _InitFeatures_clone(
      orig,
    );
  }

  late final _InitFeatures_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKInitFeatures Function(
              ffi.Pointer<LDKInitFeatures>)>>('InitFeatures_clone');
  late final _InitFeatures_clone = _InitFeatures_clonePtr.asFunction<
      LDKInitFeatures Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Creates a copy of the NodeFeatures
  LDKNodeFeatures NodeFeatures_clone(
    ffi.Pointer<LDKNodeFeatures> orig,
  ) {
    return _NodeFeatures_clone(
      orig,
    );
  }

  late final _NodeFeatures_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKNodeFeatures Function(
              ffi.Pointer<LDKNodeFeatures>)>>('NodeFeatures_clone');
  late final _NodeFeatures_clone = _NodeFeatures_clonePtr.asFunction<
      LDKNodeFeatures Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Creates a copy of the ChannelFeatures
  LDKChannelFeatures ChannelFeatures_clone(
    ffi.Pointer<LDKChannelFeatures> orig,
  ) {
    return _ChannelFeatures_clone(
      orig,
    );
  }

  late final _ChannelFeatures_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelFeatures Function(
              ffi.Pointer<LDKChannelFeatures>)>>('ChannelFeatures_clone');
  late final _ChannelFeatures_clone = _ChannelFeatures_clonePtr.asFunction<
      LDKChannelFeatures Function(ffi.Pointer<LDKChannelFeatures>)>();

  /// Creates a copy of the InvoiceFeatures
  LDKInvoiceFeatures InvoiceFeatures_clone(
    ffi.Pointer<LDKInvoiceFeatures> orig,
  ) {
    return _InvoiceFeatures_clone(
      orig,
    );
  }

  late final _InvoiceFeatures_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKInvoiceFeatures Function(
              ffi.Pointer<LDKInvoiceFeatures>)>>('InvoiceFeatures_clone');
  late final _InvoiceFeatures_clone = _InvoiceFeatures_clonePtr.asFunction<
      LDKInvoiceFeatures Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Creates a copy of the ChannelTypeFeatures
  LDKChannelTypeFeatures ChannelTypeFeatures_clone(
    ffi.Pointer<LDKChannelTypeFeatures> orig,
  ) {
    return _ChannelTypeFeatures_clone(
      orig,
    );
  }

  late final _ChannelTypeFeatures_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelTypeFeatures Function(
                  ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_clone');
  late final _ChannelTypeFeatures_clone =
      _ChannelTypeFeatures_clonePtr.asFunction<
          LDKChannelTypeFeatures Function(
              ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
  void InitFeatures_free(
    LDKInitFeatures this_obj,
  ) {
    return _InitFeatures_free(
      this_obj,
    );
  }

  late final _InitFeatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInitFeatures)>>(
          'InitFeatures_free');
  late final _InitFeatures_free =
      _InitFeatures_freePtr.asFunction<void Function(LDKInitFeatures)>();

  /// Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
  void NodeFeatures_free(
    LDKNodeFeatures this_obj,
  ) {
    return _NodeFeatures_free(
      this_obj,
    );
  }

  late final _NodeFeatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeFeatures)>>(
          'NodeFeatures_free');
  late final _NodeFeatures_free =
      _NodeFeatures_freePtr.asFunction<void Function(LDKNodeFeatures)>();

  /// Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
  void ChannelFeatures_free(
    LDKChannelFeatures this_obj,
  ) {
    return _ChannelFeatures_free(
      this_obj,
    );
  }

  late final _ChannelFeatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelFeatures)>>(
          'ChannelFeatures_free');
  late final _ChannelFeatures_free =
      _ChannelFeatures_freePtr.asFunction<void Function(LDKChannelFeatures)>();

  /// Frees any resources used by the InvoiceFeatures, if is_owned is set and inner is non-NULL.
  void InvoiceFeatures_free(
    LDKInvoiceFeatures this_obj,
  ) {
    return _InvoiceFeatures_free(
      this_obj,
    );
  }

  late final _InvoiceFeatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInvoiceFeatures)>>(
          'InvoiceFeatures_free');
  late final _InvoiceFeatures_free =
      _InvoiceFeatures_freePtr.asFunction<void Function(LDKInvoiceFeatures)>();

  /// Frees any resources used by the ChannelTypeFeatures, if is_owned is set and inner is non-NULL.
  void ChannelTypeFeatures_free(
    LDKChannelTypeFeatures this_obj,
  ) {
    return _ChannelTypeFeatures_free(
      this_obj,
    );
  }

  late final _ChannelTypeFeatures_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelTypeFeatures)>>(
          'ChannelTypeFeatures_free');
  late final _ChannelTypeFeatures_free = _ChannelTypeFeatures_freePtr
      .asFunction<void Function(LDKChannelTypeFeatures)>();

  /// Create a blank Features with no features set
  LDKInitFeatures InitFeatures_empty() {
    return _InitFeatures_empty();
  }

  late final _InitFeatures_emptyPtr =
      _lookup<ffi.NativeFunction<LDKInitFeatures Function()>>(
          'InitFeatures_empty');
  late final _InitFeatures_empty =
      _InitFeatures_emptyPtr.asFunction<LDKInitFeatures Function()>();

  /// Creates a Features with the bits set which are known by the implementation
  LDKInitFeatures InitFeatures_known() {
    return _InitFeatures_known();
  }

  late final _InitFeatures_knownPtr =
      _lookup<ffi.NativeFunction<LDKInitFeatures Function()>>(
          'InitFeatures_known');
  late final _InitFeatures_known =
      _InitFeatures_knownPtr.asFunction<LDKInitFeatures Function()>();

  /// Returns true if this `Features` object contains unknown feature flags which are set as
  /// \"required\".
  bool InitFeatures_requires_unknown_bits(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_unknown_bits(
      this_arg,
    );
  }

  late final _InitFeatures_requires_unknown_bitsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_unknown_bits');
  late final _InitFeatures_requires_unknown_bits =
      _InitFeatures_requires_unknown_bitsPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Create a blank Features with no features set
  LDKNodeFeatures NodeFeatures_empty() {
    return _NodeFeatures_empty();
  }

  late final _NodeFeatures_emptyPtr =
      _lookup<ffi.NativeFunction<LDKNodeFeatures Function()>>(
          'NodeFeatures_empty');
  late final _NodeFeatures_empty =
      _NodeFeatures_emptyPtr.asFunction<LDKNodeFeatures Function()>();

  /// Creates a Features with the bits set which are known by the implementation
  LDKNodeFeatures NodeFeatures_known() {
    return _NodeFeatures_known();
  }

  late final _NodeFeatures_knownPtr =
      _lookup<ffi.NativeFunction<LDKNodeFeatures Function()>>(
          'NodeFeatures_known');
  late final _NodeFeatures_known =
      _NodeFeatures_knownPtr.asFunction<LDKNodeFeatures Function()>();

  /// Returns true if this `Features` object contains unknown feature flags which are set as
  /// \"required\".
  bool NodeFeatures_requires_unknown_bits(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_unknown_bits(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_unknown_bitsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_unknown_bits');
  late final _NodeFeatures_requires_unknown_bits =
      _NodeFeatures_requires_unknown_bitsPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Create a blank Features with no features set
  LDKChannelFeatures ChannelFeatures_empty() {
    return _ChannelFeatures_empty();
  }

  late final _ChannelFeatures_emptyPtr =
      _lookup<ffi.NativeFunction<LDKChannelFeatures Function()>>(
          'ChannelFeatures_empty');
  late final _ChannelFeatures_empty =
      _ChannelFeatures_emptyPtr.asFunction<LDKChannelFeatures Function()>();

  /// Creates a Features with the bits set which are known by the implementation
  LDKChannelFeatures ChannelFeatures_known() {
    return _ChannelFeatures_known();
  }

  late final _ChannelFeatures_knownPtr =
      _lookup<ffi.NativeFunction<LDKChannelFeatures Function()>>(
          'ChannelFeatures_known');
  late final _ChannelFeatures_known =
      _ChannelFeatures_knownPtr.asFunction<LDKChannelFeatures Function()>();

  /// Returns true if this `Features` object contains unknown feature flags which are set as
  /// \"required\".
  bool ChannelFeatures_requires_unknown_bits(
    ffi.Pointer<LDKChannelFeatures> this_arg,
  ) {
    return _ChannelFeatures_requires_unknown_bits(
      this_arg,
    );
  }

  late final _ChannelFeatures_requires_unknown_bitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelFeatures>)>>(
      'ChannelFeatures_requires_unknown_bits');
  late final _ChannelFeatures_requires_unknown_bits =
      _ChannelFeatures_requires_unknown_bitsPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelFeatures>)>();

  /// Create a blank Features with no features set
  LDKInvoiceFeatures InvoiceFeatures_empty() {
    return _InvoiceFeatures_empty();
  }

  late final _InvoiceFeatures_emptyPtr =
      _lookup<ffi.NativeFunction<LDKInvoiceFeatures Function()>>(
          'InvoiceFeatures_empty');
  late final _InvoiceFeatures_empty =
      _InvoiceFeatures_emptyPtr.asFunction<LDKInvoiceFeatures Function()>();

  /// Creates a Features with the bits set which are known by the implementation
  LDKInvoiceFeatures InvoiceFeatures_known() {
    return _InvoiceFeatures_known();
  }

  late final _InvoiceFeatures_knownPtr =
      _lookup<ffi.NativeFunction<LDKInvoiceFeatures Function()>>(
          'InvoiceFeatures_known');
  late final _InvoiceFeatures_known =
      _InvoiceFeatures_knownPtr.asFunction<LDKInvoiceFeatures Function()>();

  /// Returns true if this `Features` object contains unknown feature flags which are set as
  /// \"required\".
  bool InvoiceFeatures_requires_unknown_bits(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_requires_unknown_bits(
      this_arg,
    );
  }

  late final _InvoiceFeatures_requires_unknown_bitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_requires_unknown_bits');
  late final _InvoiceFeatures_requires_unknown_bits =
      _InvoiceFeatures_requires_unknown_bitsPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Create a blank Features with no features set
  LDKChannelTypeFeatures ChannelTypeFeatures_empty() {
    return _ChannelTypeFeatures_empty();
  }

  late final _ChannelTypeFeatures_emptyPtr =
      _lookup<ffi.NativeFunction<LDKChannelTypeFeatures Function()>>(
          'ChannelTypeFeatures_empty');
  late final _ChannelTypeFeatures_empty = _ChannelTypeFeatures_emptyPtr
      .asFunction<LDKChannelTypeFeatures Function()>();

  /// Creates a Features with the bits set which are known by the implementation
  LDKChannelTypeFeatures ChannelTypeFeatures_known() {
    return _ChannelTypeFeatures_known();
  }

  late final _ChannelTypeFeatures_knownPtr =
      _lookup<ffi.NativeFunction<LDKChannelTypeFeatures Function()>>(
          'ChannelTypeFeatures_known');
  late final _ChannelTypeFeatures_known = _ChannelTypeFeatures_knownPtr
      .asFunction<LDKChannelTypeFeatures Function()>();

  /// Returns true if this `Features` object contains unknown feature flags which are set as
  /// \"required\".
  bool ChannelTypeFeatures_requires_unknown_bits(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_requires_unknown_bits(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_requires_unknown_bitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_requires_unknown_bits');
  late final _ChannelTypeFeatures_requires_unknown_bits =
      _ChannelTypeFeatures_requires_unknown_bitsPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
  LDKCVec_u8Z InitFeatures_write(
    ffi.Pointer<LDKInitFeatures> obj,
  ) {
    return _InitFeatures_write(
      obj,
    );
  }

  late final _InitFeatures_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKInitFeatures>)>>('InitFeatures_write');
  late final _InitFeatures_write = _InitFeatures_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Read a InitFeatures from a byte array, created by InitFeatures_write
  LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(
    LDKu8slice ser,
  ) {
    return _InitFeatures_read(
      ser,
    );
  }

  late final _InitFeatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InitFeaturesDecodeErrorZ Function(
              LDKu8slice)>>('InitFeatures_read');
  late final _InitFeatures_read = _InitFeatures_readPtr.asFunction<
      LDKCResult_InitFeaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
  LDKCVec_u8Z ChannelFeatures_write(
    ffi.Pointer<LDKChannelFeatures> obj,
  ) {
    return _ChannelFeatures_write(
      obj,
    );
  }

  late final _ChannelFeatures_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelFeatures>)>>('ChannelFeatures_write');
  late final _ChannelFeatures_write = _ChannelFeatures_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelFeatures>)>();

  /// Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
  LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(
    LDKu8slice ser,
  ) {
    return _ChannelFeatures_read(
      ser,
    );
  }

  late final _ChannelFeatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelFeaturesDecodeErrorZ Function(
              LDKu8slice)>>('ChannelFeatures_read');
  late final _ChannelFeatures_read = _ChannelFeatures_readPtr.asFunction<
      LDKCResult_ChannelFeaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
  LDKCVec_u8Z NodeFeatures_write(
    ffi.Pointer<LDKNodeFeatures> obj,
  ) {
    return _NodeFeatures_write(
      obj,
    );
  }

  late final _NodeFeatures_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKNodeFeatures>)>>('NodeFeatures_write');
  late final _NodeFeatures_write = _NodeFeatures_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Read a NodeFeatures from a byte array, created by NodeFeatures_write
  LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(
    LDKu8slice ser,
  ) {
    return _NodeFeatures_read(
      ser,
    );
  }

  late final _NodeFeatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeFeaturesDecodeErrorZ Function(
              LDKu8slice)>>('NodeFeatures_read');
  late final _NodeFeatures_read = _NodeFeatures_readPtr.asFunction<
      LDKCResult_NodeFeaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
  LDKCVec_u8Z InvoiceFeatures_write(
    ffi.Pointer<LDKInvoiceFeatures> obj,
  ) {
    return _InvoiceFeatures_write(
      obj,
    );
  }

  late final _InvoiceFeatures_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKInvoiceFeatures>)>>('InvoiceFeatures_write');
  late final _InvoiceFeatures_write = _InvoiceFeatures_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
  LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(
    LDKu8slice ser,
  ) {
    return _InvoiceFeatures_read(
      ser,
    );
  }

  late final _InvoiceFeatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceFeaturesDecodeErrorZ Function(
              LDKu8slice)>>('InvoiceFeatures_read');
  late final _InvoiceFeatures_read = _InvoiceFeatures_readPtr.asFunction<
      LDKCResult_InvoiceFeaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the ChannelTypeFeatures object into a byte array which can be read by ChannelTypeFeatures_read
  LDKCVec_u8Z ChannelTypeFeatures_write(
    ffi.Pointer<LDKChannelTypeFeatures> obj,
  ) {
    return _ChannelTypeFeatures_write(
      obj,
    );
  }

  late final _ChannelTypeFeatures_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_write');
  late final _ChannelTypeFeatures_write = _ChannelTypeFeatures_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Read a ChannelTypeFeatures from a byte array, created by ChannelTypeFeatures_write
  LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(
    LDKu8slice ser,
  ) {
    return _ChannelTypeFeatures_read(
      ser,
    );
  }

  late final _ChannelTypeFeatures_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(
              LDKu8slice)>>('ChannelTypeFeatures_read');
  late final _ChannelTypeFeatures_read =
      _ChannelTypeFeatures_readPtr.asFunction<
          LDKCResult_ChannelTypeFeaturesDecodeErrorZ Function(LDKu8slice)>();

  /// Set this feature as optional.
  void InitFeatures_set_data_loss_protect_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_data_loss_protect_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_data_loss_protect_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_data_loss_protect_optional');
  late final _InitFeatures_set_data_loss_protect_optional =
      _InitFeatures_set_data_loss_protect_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_data_loss_protect_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_data_loss_protect_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_data_loss_protect_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_data_loss_protect_required');
  late final _InitFeatures_set_data_loss_protect_required =
      _InitFeatures_set_data_loss_protect_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_data_loss_protect(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_data_loss_protect(
      this_arg,
    );
  }

  late final _InitFeatures_supports_data_loss_protectPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_data_loss_protect');
  late final _InitFeatures_supports_data_loss_protect =
      _InitFeatures_supports_data_loss_protectPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_data_loss_protect_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_data_loss_protect_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_data_loss_protect_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_data_loss_protect_optional');
  late final _NodeFeatures_set_data_loss_protect_optional =
      _NodeFeatures_set_data_loss_protect_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_data_loss_protect_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_data_loss_protect_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_data_loss_protect_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_data_loss_protect_required');
  late final _NodeFeatures_set_data_loss_protect_required =
      _NodeFeatures_set_data_loss_protect_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_data_loss_protect(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_data_loss_protect(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_data_loss_protectPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_data_loss_protect');
  late final _NodeFeatures_supports_data_loss_protect =
      _NodeFeatures_supports_data_loss_protectPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_data_loss_protect(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_data_loss_protect(
      this_arg,
    );
  }

  late final _InitFeatures_requires_data_loss_protectPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_data_loss_protect');
  late final _InitFeatures_requires_data_loss_protect =
      _InitFeatures_requires_data_loss_protectPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_data_loss_protect(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_data_loss_protect(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_data_loss_protectPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_data_loss_protect');
  late final _NodeFeatures_requires_data_loss_protect =
      _NodeFeatures_requires_data_loss_protectPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_initial_routing_sync_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_initial_routing_sync_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_initial_routing_sync_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_initial_routing_sync_optional');
  late final _InitFeatures_set_initial_routing_sync_optional =
      _InitFeatures_set_initial_routing_sync_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_initial_routing_sync_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_initial_routing_sync_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_initial_routing_sync_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_initial_routing_sync_required');
  late final _InitFeatures_set_initial_routing_sync_required =
      _InitFeatures_set_initial_routing_sync_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_initial_routing_sync(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_initial_routing_sync(
      this_arg,
    );
  }

  late final _InitFeatures_initial_routing_syncPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_initial_routing_sync');
  late final _InitFeatures_initial_routing_sync =
      _InitFeatures_initial_routing_syncPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_upfront_shutdown_script_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_upfront_shutdown_script_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_upfront_shutdown_script_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_upfront_shutdown_script_optional');
  late final _InitFeatures_set_upfront_shutdown_script_optional =
      _InitFeatures_set_upfront_shutdown_script_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_upfront_shutdown_script_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_upfront_shutdown_script_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_upfront_shutdown_script_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_upfront_shutdown_script_required');
  late final _InitFeatures_set_upfront_shutdown_script_required =
      _InitFeatures_set_upfront_shutdown_script_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_upfront_shutdown_script(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_upfront_shutdown_script(
      this_arg,
    );
  }

  late final _InitFeatures_supports_upfront_shutdown_scriptPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_upfront_shutdown_script');
  late final _InitFeatures_supports_upfront_shutdown_script =
      _InitFeatures_supports_upfront_shutdown_scriptPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_upfront_shutdown_script_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_upfront_shutdown_script_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_upfront_shutdown_script_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_upfront_shutdown_script_optional');
  late final _NodeFeatures_set_upfront_shutdown_script_optional =
      _NodeFeatures_set_upfront_shutdown_script_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_upfront_shutdown_script_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_upfront_shutdown_script_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_upfront_shutdown_script_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_upfront_shutdown_script_required');
  late final _NodeFeatures_set_upfront_shutdown_script_required =
      _NodeFeatures_set_upfront_shutdown_script_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_upfront_shutdown_script(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_upfront_shutdown_script(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_upfront_shutdown_scriptPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_upfront_shutdown_script');
  late final _NodeFeatures_supports_upfront_shutdown_script =
      _NodeFeatures_supports_upfront_shutdown_scriptPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_upfront_shutdown_script(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_upfront_shutdown_script(
      this_arg,
    );
  }

  late final _InitFeatures_requires_upfront_shutdown_scriptPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_upfront_shutdown_script');
  late final _InitFeatures_requires_upfront_shutdown_script =
      _InitFeatures_requires_upfront_shutdown_scriptPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_upfront_shutdown_script(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_upfront_shutdown_script(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_upfront_shutdown_scriptPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_upfront_shutdown_script');
  late final _NodeFeatures_requires_upfront_shutdown_script =
      _NodeFeatures_requires_upfront_shutdown_scriptPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_gossip_queries_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_gossip_queries_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_gossip_queries_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_gossip_queries_optional');
  late final _InitFeatures_set_gossip_queries_optional =
      _InitFeatures_set_gossip_queries_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_gossip_queries_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_gossip_queries_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_gossip_queries_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_gossip_queries_required');
  late final _InitFeatures_set_gossip_queries_required =
      _InitFeatures_set_gossip_queries_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_gossip_queries(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_gossip_queries(
      this_arg,
    );
  }

  late final _InitFeatures_supports_gossip_queriesPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_gossip_queries');
  late final _InitFeatures_supports_gossip_queries =
      _InitFeatures_supports_gossip_queriesPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_gossip_queries_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_gossip_queries_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_gossip_queries_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_gossip_queries_optional');
  late final _NodeFeatures_set_gossip_queries_optional =
      _NodeFeatures_set_gossip_queries_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_gossip_queries_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_gossip_queries_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_gossip_queries_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_gossip_queries_required');
  late final _NodeFeatures_set_gossip_queries_required =
      _NodeFeatures_set_gossip_queries_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_gossip_queries(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_gossip_queries(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_gossip_queriesPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_gossip_queries');
  late final _NodeFeatures_supports_gossip_queries =
      _NodeFeatures_supports_gossip_queriesPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_gossip_queries(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_gossip_queries(
      this_arg,
    );
  }

  late final _InitFeatures_requires_gossip_queriesPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_gossip_queries');
  late final _InitFeatures_requires_gossip_queries =
      _InitFeatures_requires_gossip_queriesPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_gossip_queries(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_gossip_queries(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_gossip_queriesPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_gossip_queries');
  late final _NodeFeatures_requires_gossip_queries =
      _NodeFeatures_requires_gossip_queriesPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_variable_length_onion_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_variable_length_onion_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_variable_length_onion_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_variable_length_onion_optional');
  late final _InitFeatures_set_variable_length_onion_optional =
      _InitFeatures_set_variable_length_onion_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_variable_length_onion_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_variable_length_onion_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_variable_length_onion_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_variable_length_onion_required');
  late final _InitFeatures_set_variable_length_onion_required =
      _InitFeatures_set_variable_length_onion_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_variable_length_onion(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_variable_length_onion(
      this_arg,
    );
  }

  late final _InitFeatures_supports_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_variable_length_onion');
  late final _InitFeatures_supports_variable_length_onion =
      _InitFeatures_supports_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_variable_length_onion_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_variable_length_onion_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_variable_length_onion_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_variable_length_onion_optional');
  late final _NodeFeatures_set_variable_length_onion_optional =
      _NodeFeatures_set_variable_length_onion_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_variable_length_onion_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_variable_length_onion_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_variable_length_onion_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_variable_length_onion_required');
  late final _NodeFeatures_set_variable_length_onion_required =
      _NodeFeatures_set_variable_length_onion_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_variable_length_onion(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_variable_length_onion(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_variable_length_onion');
  late final _NodeFeatures_supports_variable_length_onion =
      _NodeFeatures_supports_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InvoiceFeatures_set_variable_length_onion_optional(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_variable_length_onion_optional(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_variable_length_onion_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_variable_length_onion_optional');
  late final _InvoiceFeatures_set_variable_length_onion_optional =
      _InvoiceFeatures_set_variable_length_onion_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as required.
  void InvoiceFeatures_set_variable_length_onion_required(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_variable_length_onion_required(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_variable_length_onion_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_variable_length_onion_required');
  late final _InvoiceFeatures_set_variable_length_onion_required =
      _InvoiceFeatures_set_variable_length_onion_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is supported.
  bool InvoiceFeatures_supports_variable_length_onion(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_supports_variable_length_onion(
      this_arg,
    );
  }

  late final _InvoiceFeatures_supports_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_supports_variable_length_onion');
  late final _InvoiceFeatures_supports_variable_length_onion =
      _InvoiceFeatures_supports_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_variable_length_onion(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_variable_length_onion(
      this_arg,
    );
  }

  late final _InitFeatures_requires_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_variable_length_onion');
  late final _InitFeatures_requires_variable_length_onion =
      _InitFeatures_requires_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_variable_length_onion(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_variable_length_onion(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_variable_length_onion');
  late final _NodeFeatures_requires_variable_length_onion =
      _NodeFeatures_requires_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InvoiceFeatures_requires_variable_length_onion(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_requires_variable_length_onion(
      this_arg,
    );
  }

  late final _InvoiceFeatures_requires_variable_length_onionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_requires_variable_length_onion');
  late final _InvoiceFeatures_requires_variable_length_onion =
      _InvoiceFeatures_requires_variable_length_onionPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_static_remote_key_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_static_remote_key_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_static_remote_key_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_static_remote_key_optional');
  late final _InitFeatures_set_static_remote_key_optional =
      _InitFeatures_set_static_remote_key_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_static_remote_key_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_static_remote_key_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_static_remote_key_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_static_remote_key_required');
  late final _InitFeatures_set_static_remote_key_required =
      _InitFeatures_set_static_remote_key_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_static_remote_key(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_static_remote_key(
      this_arg,
    );
  }

  late final _InitFeatures_supports_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_static_remote_key');
  late final _InitFeatures_supports_static_remote_key =
      _InitFeatures_supports_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_static_remote_key_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_static_remote_key_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_static_remote_key_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_static_remote_key_optional');
  late final _NodeFeatures_set_static_remote_key_optional =
      _NodeFeatures_set_static_remote_key_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_static_remote_key_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_static_remote_key_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_static_remote_key_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_static_remote_key_required');
  late final _NodeFeatures_set_static_remote_key_required =
      _NodeFeatures_set_static_remote_key_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_static_remote_key(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_static_remote_key(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_static_remote_key');
  late final _NodeFeatures_supports_static_remote_key =
      _NodeFeatures_supports_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void ChannelTypeFeatures_set_static_remote_key_optional(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_static_remote_key_optional(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_static_remote_key_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_static_remote_key_optional');
  late final _ChannelTypeFeatures_set_static_remote_key_optional =
      _ChannelTypeFeatures_set_static_remote_key_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as required.
  void ChannelTypeFeatures_set_static_remote_key_required(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_static_remote_key_required(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_static_remote_key_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_static_remote_key_required');
  late final _ChannelTypeFeatures_set_static_remote_key_required =
      _ChannelTypeFeatures_set_static_remote_key_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is supported.
  bool ChannelTypeFeatures_supports_static_remote_key(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_supports_static_remote_key(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_supports_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_supports_static_remote_key');
  late final _ChannelTypeFeatures_supports_static_remote_key =
      _ChannelTypeFeatures_supports_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_static_remote_key(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_static_remote_key(
      this_arg,
    );
  }

  late final _InitFeatures_requires_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_static_remote_key');
  late final _InitFeatures_requires_static_remote_key =
      _InitFeatures_requires_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_static_remote_key(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_static_remote_key(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_static_remote_key');
  late final _NodeFeatures_requires_static_remote_key =
      _NodeFeatures_requires_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool ChannelTypeFeatures_requires_static_remote_key(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_requires_static_remote_key(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_requires_static_remote_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_requires_static_remote_key');
  late final _ChannelTypeFeatures_requires_static_remote_key =
      _ChannelTypeFeatures_requires_static_remote_keyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_payment_secret_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_payment_secret_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_payment_secret_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_payment_secret_optional');
  late final _InitFeatures_set_payment_secret_optional =
      _InitFeatures_set_payment_secret_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_payment_secret_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_payment_secret_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_payment_secret_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_payment_secret_required');
  late final _InitFeatures_set_payment_secret_required =
      _InitFeatures_set_payment_secret_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_payment_secret(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_payment_secret(
      this_arg,
    );
  }

  late final _InitFeatures_supports_payment_secretPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_payment_secret');
  late final _InitFeatures_supports_payment_secret =
      _InitFeatures_supports_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_payment_secret_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_payment_secret_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_payment_secret_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_payment_secret_optional');
  late final _NodeFeatures_set_payment_secret_optional =
      _NodeFeatures_set_payment_secret_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_payment_secret_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_payment_secret_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_payment_secret_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_payment_secret_required');
  late final _NodeFeatures_set_payment_secret_required =
      _NodeFeatures_set_payment_secret_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_payment_secret(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_payment_secret(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_payment_secretPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_payment_secret');
  late final _NodeFeatures_supports_payment_secret =
      _NodeFeatures_supports_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InvoiceFeatures_set_payment_secret_optional(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_payment_secret_optional(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_payment_secret_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_payment_secret_optional');
  late final _InvoiceFeatures_set_payment_secret_optional =
      _InvoiceFeatures_set_payment_secret_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as required.
  void InvoiceFeatures_set_payment_secret_required(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_payment_secret_required(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_payment_secret_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_payment_secret_required');
  late final _InvoiceFeatures_set_payment_secret_required =
      _InvoiceFeatures_set_payment_secret_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is supported.
  bool InvoiceFeatures_supports_payment_secret(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_supports_payment_secret(
      this_arg,
    );
  }

  late final _InvoiceFeatures_supports_payment_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_supports_payment_secret');
  late final _InvoiceFeatures_supports_payment_secret =
      _InvoiceFeatures_supports_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_payment_secret(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_payment_secret(
      this_arg,
    );
  }

  late final _InitFeatures_requires_payment_secretPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_payment_secret');
  late final _InitFeatures_requires_payment_secret =
      _InitFeatures_requires_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_payment_secret(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_payment_secret(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_payment_secretPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_payment_secret');
  late final _NodeFeatures_requires_payment_secret =
      _NodeFeatures_requires_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InvoiceFeatures_requires_payment_secret(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_requires_payment_secret(
      this_arg,
    );
  }

  late final _InvoiceFeatures_requires_payment_secretPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_requires_payment_secret');
  late final _InvoiceFeatures_requires_payment_secret =
      _InvoiceFeatures_requires_payment_secretPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_basic_mpp_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_basic_mpp_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_basic_mpp_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_basic_mpp_optional');
  late final _InitFeatures_set_basic_mpp_optional =
      _InitFeatures_set_basic_mpp_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_basic_mpp_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_basic_mpp_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_basic_mpp_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_basic_mpp_required');
  late final _InitFeatures_set_basic_mpp_required =
      _InitFeatures_set_basic_mpp_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_basic_mpp(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_basic_mpp(
      this_arg,
    );
  }

  late final _InitFeatures_supports_basic_mppPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_basic_mpp');
  late final _InitFeatures_supports_basic_mpp =
      _InitFeatures_supports_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_basic_mpp_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_basic_mpp_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_basic_mpp_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_basic_mpp_optional');
  late final _NodeFeatures_set_basic_mpp_optional =
      _NodeFeatures_set_basic_mpp_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_basic_mpp_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_basic_mpp_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_basic_mpp_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_basic_mpp_required');
  late final _NodeFeatures_set_basic_mpp_required =
      _NodeFeatures_set_basic_mpp_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_basic_mpp(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_basic_mpp(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_basic_mppPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_basic_mpp');
  late final _NodeFeatures_supports_basic_mpp =
      _NodeFeatures_supports_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InvoiceFeatures_set_basic_mpp_optional(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_basic_mpp_optional(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_basic_mpp_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_basic_mpp_optional');
  late final _InvoiceFeatures_set_basic_mpp_optional =
      _InvoiceFeatures_set_basic_mpp_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as required.
  void InvoiceFeatures_set_basic_mpp_required(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_set_basic_mpp_required(
      this_arg,
    );
  }

  late final _InvoiceFeatures_set_basic_mpp_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_set_basic_mpp_required');
  late final _InvoiceFeatures_set_basic_mpp_required =
      _InvoiceFeatures_set_basic_mpp_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is supported.
  bool InvoiceFeatures_supports_basic_mpp(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_supports_basic_mpp(
      this_arg,
    );
  }

  late final _InvoiceFeatures_supports_basic_mppPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_supports_basic_mpp');
  late final _InvoiceFeatures_supports_basic_mpp =
      _InvoiceFeatures_supports_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_basic_mpp(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_basic_mpp(
      this_arg,
    );
  }

  late final _InitFeatures_requires_basic_mppPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_basic_mpp');
  late final _InitFeatures_requires_basic_mpp =
      _InitFeatures_requires_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_basic_mpp(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_basic_mpp(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_basic_mppPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_basic_mpp');
  late final _NodeFeatures_requires_basic_mpp =
      _NodeFeatures_requires_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InvoiceFeatures_requires_basic_mpp(
    ffi.Pointer<LDKInvoiceFeatures> this_arg,
  ) {
    return _InvoiceFeatures_requires_basic_mpp(
      this_arg,
    );
  }

  late final _InvoiceFeatures_requires_basic_mppPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKInvoiceFeatures>)>>(
      'InvoiceFeatures_requires_basic_mpp');
  late final _InvoiceFeatures_requires_basic_mpp =
      _InvoiceFeatures_requires_basic_mppPtr.asFunction<
          bool Function(ffi.Pointer<LDKInvoiceFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_wumbo_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_wumbo_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_wumbo_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_wumbo_optional');
  late final _InitFeatures_set_wumbo_optional =
      _InitFeatures_set_wumbo_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_wumbo_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_wumbo_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_wumbo_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_wumbo_required');
  late final _InitFeatures_set_wumbo_required =
      _InitFeatures_set_wumbo_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_wumbo(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_wumbo(
      this_arg,
    );
  }

  late final _InitFeatures_supports_wumboPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_wumbo');
  late final _InitFeatures_supports_wumbo = _InitFeatures_supports_wumboPtr
      .asFunction<bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_wumbo_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_wumbo_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_wumbo_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_wumbo_optional');
  late final _NodeFeatures_set_wumbo_optional =
      _NodeFeatures_set_wumbo_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_wumbo_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_wumbo_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_wumbo_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_wumbo_required');
  late final _NodeFeatures_set_wumbo_required =
      _NodeFeatures_set_wumbo_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_wumbo(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_wumbo(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_wumboPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_wumbo');
  late final _NodeFeatures_supports_wumbo = _NodeFeatures_supports_wumboPtr
      .asFunction<bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_wumbo(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_wumbo(
      this_arg,
    );
  }

  late final _InitFeatures_requires_wumboPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_wumbo');
  late final _InitFeatures_requires_wumbo = _InitFeatures_requires_wumboPtr
      .asFunction<bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_wumbo(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_wumbo(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_wumboPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_wumbo');
  late final _NodeFeatures_requires_wumbo = _NodeFeatures_requires_wumboPtr
      .asFunction<bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_shutdown_any_segwit_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_shutdown_any_segwit_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_shutdown_any_segwit_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_shutdown_any_segwit_optional');
  late final _InitFeatures_set_shutdown_any_segwit_optional =
      _InitFeatures_set_shutdown_any_segwit_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_shutdown_any_segwit_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_shutdown_any_segwit_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_shutdown_any_segwit_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_shutdown_any_segwit_required');
  late final _InitFeatures_set_shutdown_any_segwit_required =
      _InitFeatures_set_shutdown_any_segwit_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_shutdown_anysegwit(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_shutdown_anysegwit(
      this_arg,
    );
  }

  late final _InitFeatures_supports_shutdown_anysegwitPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_shutdown_anysegwit');
  late final _InitFeatures_supports_shutdown_anysegwit =
      _InitFeatures_supports_shutdown_anysegwitPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_shutdown_any_segwit_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_shutdown_any_segwit_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_shutdown_any_segwit_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_shutdown_any_segwit_optional');
  late final _NodeFeatures_set_shutdown_any_segwit_optional =
      _NodeFeatures_set_shutdown_any_segwit_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_shutdown_any_segwit_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_shutdown_any_segwit_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_shutdown_any_segwit_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_shutdown_any_segwit_required');
  late final _NodeFeatures_set_shutdown_any_segwit_required =
      _NodeFeatures_set_shutdown_any_segwit_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_shutdown_anysegwit(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_shutdown_anysegwit(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_shutdown_anysegwitPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_shutdown_anysegwit');
  late final _NodeFeatures_supports_shutdown_anysegwit =
      _NodeFeatures_supports_shutdown_anysegwitPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_shutdown_anysegwit(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_shutdown_anysegwit(
      this_arg,
    );
  }

  late final _InitFeatures_requires_shutdown_anysegwitPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_shutdown_anysegwit');
  late final _InitFeatures_requires_shutdown_anysegwit =
      _InitFeatures_requires_shutdown_anysegwitPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_shutdown_anysegwit(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_shutdown_anysegwit(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_shutdown_anysegwitPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_shutdown_anysegwit');
  late final _NodeFeatures_requires_shutdown_anysegwit =
      _NodeFeatures_requires_shutdown_anysegwitPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_channel_type_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_channel_type_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_channel_type_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_channel_type_optional');
  late final _InitFeatures_set_channel_type_optional =
      _InitFeatures_set_channel_type_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_channel_type_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_channel_type_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_channel_type_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_channel_type_required');
  late final _InitFeatures_set_channel_type_required =
      _InitFeatures_set_channel_type_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_channel_type(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_channel_type(
      this_arg,
    );
  }

  late final _InitFeatures_supports_channel_typePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_channel_type');
  late final _InitFeatures_supports_channel_type =
      _InitFeatures_supports_channel_typePtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_channel_type_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_channel_type_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_channel_type_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_channel_type_optional');
  late final _NodeFeatures_set_channel_type_optional =
      _NodeFeatures_set_channel_type_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_channel_type_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_channel_type_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_channel_type_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_channel_type_required');
  late final _NodeFeatures_set_channel_type_required =
      _NodeFeatures_set_channel_type_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_channel_type(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_channel_type(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_channel_typePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_channel_type');
  late final _NodeFeatures_supports_channel_type =
      _NodeFeatures_supports_channel_typePtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_channel_type(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_channel_type(
      this_arg,
    );
  }

  late final _InitFeatures_requires_channel_typePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_channel_type');
  late final _InitFeatures_requires_channel_type =
      _InitFeatures_requires_channel_typePtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_channel_type(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_channel_type(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_channel_typePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_channel_type');
  late final _NodeFeatures_requires_channel_type =
      _NodeFeatures_requires_channel_typePtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_scid_privacy_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_scid_privacy_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_scid_privacy_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_scid_privacy_optional');
  late final _InitFeatures_set_scid_privacy_optional =
      _InitFeatures_set_scid_privacy_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_scid_privacy_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_scid_privacy_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_scid_privacy_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_scid_privacy_required');
  late final _InitFeatures_set_scid_privacy_required =
      _InitFeatures_set_scid_privacy_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_scid_privacy(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_scid_privacy(
      this_arg,
    );
  }

  late final _InitFeatures_supports_scid_privacyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_scid_privacy');
  late final _InitFeatures_supports_scid_privacy =
      _InitFeatures_supports_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_scid_privacy_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_scid_privacy_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_scid_privacy_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_scid_privacy_optional');
  late final _NodeFeatures_set_scid_privacy_optional =
      _NodeFeatures_set_scid_privacy_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_scid_privacy_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_scid_privacy_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_scid_privacy_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_scid_privacy_required');
  late final _NodeFeatures_set_scid_privacy_required =
      _NodeFeatures_set_scid_privacy_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_scid_privacy(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_scid_privacy(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_scid_privacyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_scid_privacy');
  late final _NodeFeatures_supports_scid_privacy =
      _NodeFeatures_supports_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void ChannelTypeFeatures_set_scid_privacy_optional(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_scid_privacy_optional(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_scid_privacy_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_scid_privacy_optional');
  late final _ChannelTypeFeatures_set_scid_privacy_optional =
      _ChannelTypeFeatures_set_scid_privacy_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as required.
  void ChannelTypeFeatures_set_scid_privacy_required(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_scid_privacy_required(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_scid_privacy_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_scid_privacy_required');
  late final _ChannelTypeFeatures_set_scid_privacy_required =
      _ChannelTypeFeatures_set_scid_privacy_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is supported.
  bool ChannelTypeFeatures_supports_scid_privacy(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_supports_scid_privacy(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_supports_scid_privacyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_supports_scid_privacy');
  late final _ChannelTypeFeatures_supports_scid_privacy =
      _ChannelTypeFeatures_supports_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_scid_privacy(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_scid_privacy(
      this_arg,
    );
  }

  late final _InitFeatures_requires_scid_privacyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_scid_privacy');
  late final _InitFeatures_requires_scid_privacy =
      _InitFeatures_requires_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_scid_privacy(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_scid_privacy(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_scid_privacyPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_scid_privacy');
  late final _NodeFeatures_requires_scid_privacy =
      _NodeFeatures_requires_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool ChannelTypeFeatures_requires_scid_privacy(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_requires_scid_privacy(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_requires_scid_privacyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_requires_scid_privacy');
  late final _ChannelTypeFeatures_requires_scid_privacy =
      _ChannelTypeFeatures_requires_scid_privacyPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as optional.
  void InitFeatures_set_zero_conf_optional(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_zero_conf_optional(
      this_arg,
    );
  }

  late final _InitFeatures_set_zero_conf_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_zero_conf_optional');
  late final _InitFeatures_set_zero_conf_optional =
      _InitFeatures_set_zero_conf_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as required.
  void InitFeatures_set_zero_conf_required(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_set_zero_conf_required(
      this_arg,
    );
  }

  late final _InitFeatures_set_zero_conf_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_set_zero_conf_required');
  late final _InitFeatures_set_zero_conf_required =
      _InitFeatures_set_zero_conf_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is supported.
  bool InitFeatures_supports_zero_conf(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_supports_zero_conf(
      this_arg,
    );
  }

  late final _InitFeatures_supports_zero_confPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_supports_zero_conf');
  late final _InitFeatures_supports_zero_conf =
      _InitFeatures_supports_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_zero_conf_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_zero_conf_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_zero_conf_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_zero_conf_optional');
  late final _NodeFeatures_set_zero_conf_optional =
      _NodeFeatures_set_zero_conf_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_zero_conf_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_zero_conf_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_zero_conf_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_zero_conf_required');
  late final _NodeFeatures_set_zero_conf_required =
      _NodeFeatures_set_zero_conf_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_zero_conf(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_zero_conf(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_zero_confPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_zero_conf');
  late final _NodeFeatures_supports_zero_conf =
      _NodeFeatures_supports_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as optional.
  void ChannelTypeFeatures_set_zero_conf_optional(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_zero_conf_optional(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_zero_conf_optionalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_zero_conf_optional');
  late final _ChannelTypeFeatures_set_zero_conf_optional =
      _ChannelTypeFeatures_set_zero_conf_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as required.
  void ChannelTypeFeatures_set_zero_conf_required(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_set_zero_conf_required(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_set_zero_conf_requiredPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_set_zero_conf_required');
  late final _ChannelTypeFeatures_set_zero_conf_required =
      _ChannelTypeFeatures_set_zero_conf_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is supported.
  bool ChannelTypeFeatures_supports_zero_conf(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_supports_zero_conf(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_supports_zero_confPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_supports_zero_conf');
  late final _ChannelTypeFeatures_supports_zero_conf =
      _ChannelTypeFeatures_supports_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Checks if this feature is required.
  bool InitFeatures_requires_zero_conf(
    ffi.Pointer<LDKInitFeatures> this_arg,
  ) {
    return _InitFeatures_requires_zero_conf(
      this_arg,
    );
  }

  late final _InitFeatures_requires_zero_confPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInitFeatures>)>>(
      'InitFeatures_requires_zero_conf');
  late final _InitFeatures_requires_zero_conf =
      _InitFeatures_requires_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKInitFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_zero_conf(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_zero_conf(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_zero_confPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_zero_conf');
  late final _NodeFeatures_requires_zero_conf =
      _NodeFeatures_requires_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool ChannelTypeFeatures_requires_zero_conf(
    ffi.Pointer<LDKChannelTypeFeatures> this_arg,
  ) {
    return _ChannelTypeFeatures_requires_zero_conf(
      this_arg,
    );
  }

  late final _ChannelTypeFeatures_requires_zero_confPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>>(
      'ChannelTypeFeatures_requires_zero_conf');
  late final _ChannelTypeFeatures_requires_zero_conf =
      _ChannelTypeFeatures_requires_zero_confPtr.asFunction<
          bool Function(ffi.Pointer<LDKChannelTypeFeatures>)>();

  /// Set this feature as optional.
  void NodeFeatures_set_keysend_optional(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_keysend_optional(
      this_arg,
    );
  }

  late final _NodeFeatures_set_keysend_optionalPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_keysend_optional');
  late final _NodeFeatures_set_keysend_optional =
      _NodeFeatures_set_keysend_optionalPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Set this feature as required.
  void NodeFeatures_set_keysend_required(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_set_keysend_required(
      this_arg,
    );
  }

  late final _NodeFeatures_set_keysend_requiredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_set_keysend_required');
  late final _NodeFeatures_set_keysend_required =
      _NodeFeatures_set_keysend_requiredPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is supported.
  bool NodeFeatures_supports_keysend(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_supports_keysend(
      this_arg,
    );
  }

  late final _NodeFeatures_supports_keysendPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_supports_keysend');
  late final _NodeFeatures_supports_keysend = _NodeFeatures_supports_keysendPtr
      .asFunction<bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Checks if this feature is required.
  bool NodeFeatures_requires_keysend(
    ffi.Pointer<LDKNodeFeatures> this_arg,
  ) {
    return _NodeFeatures_requires_keysend(
      this_arg,
    );
  }

  late final _NodeFeatures_requires_keysendPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKNodeFeatures>)>>(
      'NodeFeatures_requires_keysend');
  late final _NodeFeatures_requires_keysend = _NodeFeatures_requires_keysendPtr
      .asFunction<bool Function(ffi.Pointer<LDKNodeFeatures>)>();

  /// Frees any resources used by the ShutdownScript, if is_owned is set and inner is non-NULL.
  void ShutdownScript_free(
    LDKShutdownScript this_obj,
  ) {
    return _ShutdownScript_free(
      this_obj,
    );
  }

  late final _ShutdownScript_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKShutdownScript)>>(
          'ShutdownScript_free');
  late final _ShutdownScript_free =
      _ShutdownScript_freePtr.asFunction<void Function(LDKShutdownScript)>();

  /// Creates a copy of the ShutdownScript
  LDKShutdownScript ShutdownScript_clone(
    ffi.Pointer<LDKShutdownScript> orig,
  ) {
    return _ShutdownScript_clone(
      orig,
    );
  }

  late final _ShutdownScript_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKShutdownScript Function(
              ffi.Pointer<LDKShutdownScript>)>>('ShutdownScript_clone');
  late final _ShutdownScript_clone = _ShutdownScript_clonePtr.asFunction<
      LDKShutdownScript Function(ffi.Pointer<LDKShutdownScript>)>();

  /// Frees any resources used by the InvalidShutdownScript, if is_owned is set and inner is non-NULL.
  void InvalidShutdownScript_free(
    LDKInvalidShutdownScript this_obj,
  ) {
    return _InvalidShutdownScript_free(
      this_obj,
    );
  }

  late final _InvalidShutdownScript_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInvalidShutdownScript)>>(
          'InvalidShutdownScript_free');
  late final _InvalidShutdownScript_free = _InvalidShutdownScript_freePtr
      .asFunction<void Function(LDKInvalidShutdownScript)>();

  /// The script that did not meet the requirements from [BOLT #2].
  ///
  /// [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
  LDKu8slice InvalidShutdownScript_get_script(
    ffi.Pointer<LDKInvalidShutdownScript> this_ptr,
  ) {
    return _InvalidShutdownScript_get_script(
      this_ptr,
    );
  }

  late final _InvalidShutdownScript_get_scriptPtr = _lookup<
          ffi.NativeFunction<
              LDKu8slice Function(ffi.Pointer<LDKInvalidShutdownScript>)>>(
      'InvalidShutdownScript_get_script');
  late final _InvalidShutdownScript_get_script =
      _InvalidShutdownScript_get_scriptPtr.asFunction<
          LDKu8slice Function(ffi.Pointer<LDKInvalidShutdownScript>)>();

  /// The script that did not meet the requirements from [BOLT #2].
  ///
  /// [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
  void InvalidShutdownScript_set_script(
    ffi.Pointer<LDKInvalidShutdownScript> this_ptr,
    LDKCVec_u8Z val,
  ) {
    return _InvalidShutdownScript_set_script(
      this_ptr,
      val,
    );
  }

  late final _InvalidShutdownScript_set_scriptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKInvalidShutdownScript>,
              LDKCVec_u8Z)>>('InvalidShutdownScript_set_script');
  late final _InvalidShutdownScript_set_script =
      _InvalidShutdownScript_set_scriptPtr.asFunction<
          void Function(ffi.Pointer<LDKInvalidShutdownScript>, LDKCVec_u8Z)>();

  /// Constructs a new InvalidShutdownScript given each field
  LDKInvalidShutdownScript InvalidShutdownScript_new(
    LDKCVec_u8Z script_arg,
  ) {
    return _InvalidShutdownScript_new(
      script_arg,
    );
  }

  late final _InvalidShutdownScript_newPtr = _lookup<
          ffi.NativeFunction<LDKInvalidShutdownScript Function(LDKCVec_u8Z)>>(
      'InvalidShutdownScript_new');
  late final _InvalidShutdownScript_new = _InvalidShutdownScript_newPtr
      .asFunction<LDKInvalidShutdownScript Function(LDKCVec_u8Z)>();

  /// Creates a copy of the InvalidShutdownScript
  LDKInvalidShutdownScript InvalidShutdownScript_clone(
    ffi.Pointer<LDKInvalidShutdownScript> orig,
  ) {
    return _InvalidShutdownScript_clone(
      orig,
    );
  }

  late final _InvalidShutdownScript_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKInvalidShutdownScript Function(
                  ffi.Pointer<LDKInvalidShutdownScript>)>>(
      'InvalidShutdownScript_clone');
  late final _InvalidShutdownScript_clone =
      _InvalidShutdownScript_clonePtr.asFunction<
          LDKInvalidShutdownScript Function(
              ffi.Pointer<LDKInvalidShutdownScript>)>();

  /// Serialize the ShutdownScript object into a byte array which can be read by ShutdownScript_read
  LDKCVec_u8Z ShutdownScript_write(
    ffi.Pointer<LDKShutdownScript> obj,
  ) {
    return _ShutdownScript_write(
      obj,
    );
  }

  late final _ShutdownScript_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKShutdownScript>)>>('ShutdownScript_write');
  late final _ShutdownScript_write = _ShutdownScript_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKShutdownScript>)>();

  /// Read a ShutdownScript from a byte array, created by ShutdownScript_write
  LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(
    LDKu8slice ser,
  ) {
    return _ShutdownScript_read(
      ser,
    );
  }

  late final _ShutdownScript_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownScriptDecodeErrorZ Function(
              LDKu8slice)>>('ShutdownScript_read');
  late final _ShutdownScript_read = _ShutdownScript_readPtr.asFunction<
      LDKCResult_ShutdownScriptDecodeErrorZ Function(LDKu8slice)>();

  /// Generates a P2WPKH script pubkey from the given [`WPubkeyHash`].
  LDKShutdownScript ShutdownScript_new_p2wpkh(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pubkey_hash,
  ) {
    return _ShutdownScript_new_p2wpkh(
      pubkey_hash,
    );
  }

  late final _ShutdownScript_new_p2wpkhPtr = _lookup<
          ffi.NativeFunction<
              LDKShutdownScript Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'ShutdownScript_new_p2wpkh');
  late final _ShutdownScript_new_p2wpkh =
      _ShutdownScript_new_p2wpkhPtr.asFunction<
          LDKShutdownScript Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Generates a P2WSH script pubkey from the given [`WScriptHash`].
  LDKShutdownScript ShutdownScript_new_p2wsh(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> script_hash,
  ) {
    return _ShutdownScript_new_p2wsh(
      script_hash,
    );
  }

  late final _ShutdownScript_new_p2wshPtr = _lookup<
          ffi.NativeFunction<
              LDKShutdownScript Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'ShutdownScript_new_p2wsh');
  late final _ShutdownScript_new_p2wsh =
      _ShutdownScript_new_p2wshPtr.asFunction<
          LDKShutdownScript Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Generates a witness script pubkey from the given segwit version and program.
  ///
  /// Note for version-zero witness scripts you must use [`ShutdownScript::new_p2wpkh`] or
  /// [`ShutdownScript::new_p2wsh`] instead.
  ///
  /// # Errors
  ///
  /// This function may return an error if `program` is invalid for the segwit `version`.
  LDKCResult_ShutdownScriptInvalidShutdownScriptZ
      ShutdownScript_new_witness_program(
    LDKWitnessVersion version,
    LDKu8slice program,
  ) {
    return _ShutdownScript_new_witness_program(
      version,
      program,
    );
  }

  late final _ShutdownScript_new_witness_programPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
              LDKWitnessVersion,
              LDKu8slice)>>('ShutdownScript_new_witness_program');
  late final _ShutdownScript_new_witness_program =
      _ShutdownScript_new_witness_programPtr.asFunction<
          LDKCResult_ShutdownScriptInvalidShutdownScriptZ Function(
              LDKWitnessVersion, LDKu8slice)>();

  /// Converts the shutdown script into the underlying [`Script`].
  LDKCVec_u8Z ShutdownScript_into_inner(
    LDKShutdownScript this_arg,
  ) {
    return _ShutdownScript_into_inner(
      this_arg,
    );
  }

  late final _ShutdownScript_into_innerPtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(LDKShutdownScript)>>(
          'ShutdownScript_into_inner');
  late final _ShutdownScript_into_inner = _ShutdownScript_into_innerPtr
      .asFunction<LDKCVec_u8Z Function(LDKShutdownScript)>();

  /// Returns the [`PublicKey`] used for a P2WPKH shutdown script if constructed directly from it.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKPublicKey ShutdownScript_as_legacy_pubkey(
    ffi.Pointer<LDKShutdownScript> this_arg,
  ) {
    return _ShutdownScript_as_legacy_pubkey(
      this_arg,
    );
  }

  late final _ShutdownScript_as_legacy_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKShutdownScript>)>>(
      'ShutdownScript_as_legacy_pubkey');
  late final _ShutdownScript_as_legacy_pubkey =
      _ShutdownScript_as_legacy_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKShutdownScript>)>();

  /// Returns whether the shutdown script is compatible with the features as defined by BOLT #2.
  ///
  /// Specifically, checks for compliance with feature `option_shutdown_anysegwit`.
  bool ShutdownScript_is_compatible(
    ffi.Pointer<LDKShutdownScript> this_arg,
    ffi.Pointer<LDKInitFeatures> features,
  ) {
    return _ShutdownScript_is_compatible(
      this_arg,
      features,
    );
  }

  late final _ShutdownScript_is_compatiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKShutdownScript>,
              ffi.Pointer<LDKInitFeatures>)>>('ShutdownScript_is_compatible');
  late final _ShutdownScript_is_compatible =
      _ShutdownScript_is_compatiblePtr.asFunction<
          bool Function(
              ffi.Pointer<LDKShutdownScript>, ffi.Pointer<LDKInitFeatures>)>();

  /// Calls the free function if one is set
  void CustomMessageReader_free(
    LDKCustomMessageReader this_ptr,
  ) {
    return _CustomMessageReader_free(
      this_ptr,
    );
  }

  late final _CustomMessageReader_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKCustomMessageReader)>>(
          'CustomMessageReader_free');
  late final _CustomMessageReader_free = _CustomMessageReader_freePtr
      .asFunction<void Function(LDKCustomMessageReader)>();

  /// Creates a copy of a Type
  LDKType Type_clone(
    ffi.Pointer<LDKType> orig,
  ) {
    return _Type_clone(
      orig,
    );
  }

  late final _Type_clonePtr =
      _lookup<ffi.NativeFunction<LDKType Function(ffi.Pointer<LDKType>)>>(
          'Type_clone');
  late final _Type_clone =
      _Type_clonePtr.asFunction<LDKType Function(ffi.Pointer<LDKType>)>();

  /// Calls the free function if one is set
  void Type_free(
    LDKType this_ptr,
  ) {
    return _Type_free(
      this_ptr,
    );
  }

  late final _Type_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKType)>>('Type_free');
  late final _Type_free = _Type_freePtr.asFunction<void Function(LDKType)>();

  /// Frees any resources used by the NodeId, if is_owned is set and inner is non-NULL.
  void NodeId_free(
    LDKNodeId this_obj,
  ) {
    return _NodeId_free(
      this_obj,
    );
  }

  late final _NodeId_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeId)>>('NodeId_free');
  late final _NodeId_free =
      _NodeId_freePtr.asFunction<void Function(LDKNodeId)>();

  /// Creates a copy of the NodeId
  LDKNodeId NodeId_clone(
    ffi.Pointer<LDKNodeId> orig,
  ) {
    return _NodeId_clone(
      orig,
    );
  }

  late final _NodeId_clonePtr =
      _lookup<ffi.NativeFunction<LDKNodeId Function(ffi.Pointer<LDKNodeId>)>>(
          'NodeId_clone');
  late final _NodeId_clone =
      _NodeId_clonePtr.asFunction<LDKNodeId Function(ffi.Pointer<LDKNodeId>)>();

  /// Create a new NodeId from a public key
  LDKNodeId NodeId_from_pubkey(
    LDKPublicKey pubkey,
  ) {
    return _NodeId_from_pubkey(
      pubkey,
    );
  }

  late final _NodeId_from_pubkeyPtr =
      _lookup<ffi.NativeFunction<LDKNodeId Function(LDKPublicKey)>>(
          'NodeId_from_pubkey');
  late final _NodeId_from_pubkey =
      _NodeId_from_pubkeyPtr.asFunction<LDKNodeId Function(LDKPublicKey)>();

  /// Get the public key slice from this NodeId
  LDKu8slice NodeId_as_slice(
    ffi.Pointer<LDKNodeId> this_arg,
  ) {
    return _NodeId_as_slice(
      this_arg,
    );
  }

  late final _NodeId_as_slicePtr =
      _lookup<ffi.NativeFunction<LDKu8slice Function(ffi.Pointer<LDKNodeId>)>>(
          'NodeId_as_slice');
  late final _NodeId_as_slice = _NodeId_as_slicePtr.asFunction<
      LDKu8slice Function(ffi.Pointer<LDKNodeId>)>();

  /// Checks if two NodeIds contain equal inner contents.
  int NodeId_hash(
    ffi.Pointer<LDKNodeId> o,
  ) {
    return _NodeId_hash(
      o,
    );
  }

  late final _NodeId_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKNodeId>)>>(
          'NodeId_hash');
  late final _NodeId_hash =
      _NodeId_hashPtr.asFunction<int Function(ffi.Pointer<LDKNodeId>)>();

  /// Serialize the NodeId object into a byte array which can be read by NodeId_read
  LDKCVec_u8Z NodeId_write(
    ffi.Pointer<LDKNodeId> obj,
  ) {
    return _NodeId_write(
      obj,
    );
  }

  late final _NodeId_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKNodeId>)>>(
          'NodeId_write');
  late final _NodeId_write = _NodeId_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNodeId>)>();

  /// Read a NodeId from a byte array, created by NodeId_write
  LDKCResult_NodeIdDecodeErrorZ NodeId_read(
    LDKu8slice ser,
  ) {
    return _NodeId_read(
      ser,
    );
  }

  late final _NodeId_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeIdDecodeErrorZ Function(LDKu8slice)>>('NodeId_read');
  late final _NodeId_read = _NodeId_readPtr.asFunction<
      LDKCResult_NodeIdDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
  void NetworkGraph_free(
    LDKNetworkGraph this_obj,
  ) {
    return _NetworkGraph_free(
      this_obj,
    );
  }

  late final _NetworkGraph_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNetworkGraph)>>(
          'NetworkGraph_free');
  late final _NetworkGraph_free =
      _NetworkGraph_freePtr.asFunction<void Function(LDKNetworkGraph)>();

  /// Frees any resources used by the ReadOnlyNetworkGraph, if is_owned is set and inner is non-NULL.
  void ReadOnlyNetworkGraph_free(
    LDKReadOnlyNetworkGraph this_obj,
  ) {
    return _ReadOnlyNetworkGraph_free(
      this_obj,
    );
  }

  late final _ReadOnlyNetworkGraph_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKReadOnlyNetworkGraph)>>(
          'ReadOnlyNetworkGraph_free');
  late final _ReadOnlyNetworkGraph_free = _ReadOnlyNetworkGraph_freePtr
      .asFunction<void Function(LDKReadOnlyNetworkGraph)>();

  /// Frees any resources used by the NetworkUpdate
  void NetworkUpdate_free(
    LDKNetworkUpdate this_ptr,
  ) {
    return _NetworkUpdate_free(
      this_ptr,
    );
  }

  late final _NetworkUpdate_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNetworkUpdate)>>(
          'NetworkUpdate_free');
  late final _NetworkUpdate_free =
      _NetworkUpdate_freePtr.asFunction<void Function(LDKNetworkUpdate)>();

  /// Creates a copy of the NetworkUpdate
  LDKNetworkUpdate NetworkUpdate_clone(
    ffi.Pointer<LDKNetworkUpdate> orig,
  ) {
    return _NetworkUpdate_clone(
      orig,
    );
  }

  late final _NetworkUpdate_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKNetworkUpdate Function(
              ffi.Pointer<LDKNetworkUpdate>)>>('NetworkUpdate_clone');
  late final _NetworkUpdate_clone = _NetworkUpdate_clonePtr.asFunction<
      LDKNetworkUpdate Function(ffi.Pointer<LDKNetworkUpdate>)>();

  /// Utility method to constructs a new ChannelUpdateMessage-variant NetworkUpdate
  LDKNetworkUpdate NetworkUpdate_channel_update_message(
    LDKChannelUpdate msg,
  ) {
    return _NetworkUpdate_channel_update_message(
      msg,
    );
  }

  late final _NetworkUpdate_channel_update_messagePtr =
      _lookup<ffi.NativeFunction<LDKNetworkUpdate Function(LDKChannelUpdate)>>(
          'NetworkUpdate_channel_update_message');
  late final _NetworkUpdate_channel_update_message =
      _NetworkUpdate_channel_update_messagePtr.asFunction<
          LDKNetworkUpdate Function(LDKChannelUpdate)>();

  /// Utility method to constructs a new ChannelFailure-variant NetworkUpdate
  LDKNetworkUpdate NetworkUpdate_channel_failure(
    int short_channel_id,
    bool is_permanent,
  ) {
    return _NetworkUpdate_channel_failure(
      short_channel_id,
      is_permanent,
    );
  }

  late final _NetworkUpdate_channel_failurePtr = _lookup<
          ffi.NativeFunction<LDKNetworkUpdate Function(ffi.Uint64, ffi.Bool)>>(
      'NetworkUpdate_channel_failure');
  late final _NetworkUpdate_channel_failure = _NetworkUpdate_channel_failurePtr
      .asFunction<LDKNetworkUpdate Function(int, bool)>();

  /// Utility method to constructs a new NodeFailure-variant NetworkUpdate
  LDKNetworkUpdate NetworkUpdate_node_failure(
    LDKPublicKey node_id,
    bool is_permanent,
  ) {
    return _NetworkUpdate_node_failure(
      node_id,
      is_permanent,
    );
  }

  late final _NetworkUpdate_node_failurePtr = _lookup<
      ffi.NativeFunction<
          LDKNetworkUpdate Function(
              LDKPublicKey, ffi.Bool)>>('NetworkUpdate_node_failure');
  late final _NetworkUpdate_node_failure = _NetworkUpdate_node_failurePtr
      .asFunction<LDKNetworkUpdate Function(LDKPublicKey, bool)>();

  /// Serialize the NetworkUpdate object into a byte array which can be read by NetworkUpdate_read
  LDKCVec_u8Z NetworkUpdate_write(
    ffi.Pointer<LDKNetworkUpdate> obj,
  ) {
    return _NetworkUpdate_write(
      obj,
    );
  }

  late final _NetworkUpdate_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKNetworkUpdate>)>>('NetworkUpdate_write');
  late final _NetworkUpdate_write = _NetworkUpdate_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNetworkUpdate>)>();

  /// Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
  LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(
    LDKu8slice ser,
  ) {
    return _NetworkUpdate_read(
      ser,
    );
  }

  late final _NetworkUpdate_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(
              LDKu8slice)>>('NetworkUpdate_read');
  late final _NetworkUpdate_read = _NetworkUpdate_readPtr.asFunction<
      LDKCResult_COption_NetworkUpdateZDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the P2PGossipSync, if is_owned is set and inner is non-NULL.
  void P2PGossipSync_free(
    LDKP2PGossipSync this_obj,
  ) {
    return _P2PGossipSync_free(
      this_obj,
    );
  }

  late final _P2PGossipSync_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKP2PGossipSync)>>(
          'P2PGossipSync_free');
  late final _P2PGossipSync_free =
      _P2PGossipSync_freePtr.asFunction<void Function(LDKP2PGossipSync)>();

  /// Creates a new tracker of the actual state of the network of channels and nodes,
  /// assuming an existing Network Graph.
  /// Chain monitor is used to make sure announced channels exist on-chain,
  /// channel data is correct, and that the announcement is signed with
  /// channel owners' keys.
  LDKP2PGossipSync P2PGossipSync_new(
    ffi.Pointer<LDKNetworkGraph> network_graph,
    LDKCOption_AccessZ chain_access,
    LDKLogger logger,
  ) {
    return _P2PGossipSync_new(
      network_graph,
      chain_access,
      logger,
    );
  }

  late final _P2PGossipSync_newPtr = _lookup<
      ffi.NativeFunction<
          LDKP2PGossipSync Function(ffi.Pointer<LDKNetworkGraph>,
              LDKCOption_AccessZ, LDKLogger)>>('P2PGossipSync_new');
  late final _P2PGossipSync_new = _P2PGossipSync_newPtr.asFunction<
      LDKP2PGossipSync Function(
          ffi.Pointer<LDKNetworkGraph>, LDKCOption_AccessZ, LDKLogger)>();

  /// Adds a provider used to check new announcements. Does not affect
  /// existing announcements unless they are updated.
  /// Add, update or remove the provider would replace the current one.
  void P2PGossipSync_add_chain_access(
    ffi.Pointer<LDKP2PGossipSync> this_arg,
    LDKCOption_AccessZ chain_access,
  ) {
    return _P2PGossipSync_add_chain_access(
      this_arg,
      chain_access,
    );
  }

  late final _P2PGossipSync_add_chain_accessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKP2PGossipSync>,
              LDKCOption_AccessZ)>>('P2PGossipSync_add_chain_access');
  late final _P2PGossipSync_add_chain_access =
      _P2PGossipSync_add_chain_accessPtr.asFunction<
          void Function(ffi.Pointer<LDKP2PGossipSync>, LDKCOption_AccessZ)>();

  /// Constructs a new EventHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
  LDKEventHandler NetworkGraph_as_EventHandler(
    ffi.Pointer<LDKNetworkGraph> this_arg,
  ) {
    return _NetworkGraph_as_EventHandler(
      this_arg,
    );
  }

  late final _NetworkGraph_as_EventHandlerPtr = _lookup<
      ffi.NativeFunction<
          LDKEventHandler Function(
              ffi.Pointer<LDKNetworkGraph>)>>('NetworkGraph_as_EventHandler');
  late final _NetworkGraph_as_EventHandler = _NetworkGraph_as_EventHandlerPtr
      .asFunction<LDKEventHandler Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
  LDKRoutingMessageHandler P2PGossipSync_as_RoutingMessageHandler(
    ffi.Pointer<LDKP2PGossipSync> this_arg,
  ) {
    return _P2PGossipSync_as_RoutingMessageHandler(
      this_arg,
    );
  }

  late final _P2PGossipSync_as_RoutingMessageHandlerPtr = _lookup<
          ffi.NativeFunction<
              LDKRoutingMessageHandler Function(
                  ffi.Pointer<LDKP2PGossipSync>)>>(
      'P2PGossipSync_as_RoutingMessageHandler');
  late final _P2PGossipSync_as_RoutingMessageHandler =
      _P2PGossipSync_as_RoutingMessageHandlerPtr.asFunction<
          LDKRoutingMessageHandler Function(ffi.Pointer<LDKP2PGossipSync>)>();

  /// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
  LDKMessageSendEventsProvider P2PGossipSync_as_MessageSendEventsProvider(
    ffi.Pointer<LDKP2PGossipSync> this_arg,
  ) {
    return _P2PGossipSync_as_MessageSendEventsProvider(
      this_arg,
    );
  }

  late final _P2PGossipSync_as_MessageSendEventsProviderPtr = _lookup<
          ffi.NativeFunction<
              LDKMessageSendEventsProvider Function(
                  ffi.Pointer<LDKP2PGossipSync>)>>(
      'P2PGossipSync_as_MessageSendEventsProvider');
  late final _P2PGossipSync_as_MessageSendEventsProvider =
      _P2PGossipSync_as_MessageSendEventsProviderPtr.asFunction<
          LDKMessageSendEventsProvider Function(
              ffi.Pointer<LDKP2PGossipSync>)>();

  /// Frees any resources used by the ChannelUpdateInfo, if is_owned is set and inner is non-NULL.
  void ChannelUpdateInfo_free(
    LDKChannelUpdateInfo this_obj,
  ) {
    return _ChannelUpdateInfo_free(
      this_obj,
    );
  }

  late final _ChannelUpdateInfo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelUpdateInfo)>>(
          'ChannelUpdateInfo_free');
  late final _ChannelUpdateInfo_free = _ChannelUpdateInfo_freePtr.asFunction<
      void Function(LDKChannelUpdateInfo)>();

  /// When the last update to the channel direction was issued.
  /// Value is opaque, as set in the announcement.
  int ChannelUpdateInfo_get_last_update(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_last_update(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_last_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_last_update');
  late final _ChannelUpdateInfo_get_last_update =
      _ChannelUpdateInfo_get_last_updatePtr.asFunction<
          int Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// When the last update to the channel direction was issued.
  /// Value is opaque, as set in the announcement.
  void ChannelUpdateInfo_set_last_update(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    int val,
  ) {
    return _ChannelUpdateInfo_set_last_update(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_last_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              ffi.Uint32)>>('ChannelUpdateInfo_set_last_update');
  late final _ChannelUpdateInfo_set_last_update =
      _ChannelUpdateInfo_set_last_updatePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, int)>();

  /// Whether the channel can be currently used for payments (in this one direction).
  bool ChannelUpdateInfo_get_enabled(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_enabled(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_enabledPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_enabled');
  late final _ChannelUpdateInfo_get_enabled = _ChannelUpdateInfo_get_enabledPtr
      .asFunction<bool Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// Whether the channel can be currently used for payments (in this one direction).
  void ChannelUpdateInfo_set_enabled(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    bool val,
  ) {
    return _ChannelUpdateInfo_set_enabled(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              ffi.Bool)>>('ChannelUpdateInfo_set_enabled');
  late final _ChannelUpdateInfo_set_enabled = _ChannelUpdateInfo_set_enabledPtr
      .asFunction<void Function(ffi.Pointer<LDKChannelUpdateInfo>, bool)>();

  /// The difference in CLTV values that you must have when routing through this channel.
  int ChannelUpdateInfo_get_cltv_expiry_delta(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_cltv_expiry_delta');
  late final _ChannelUpdateInfo_get_cltv_expiry_delta =
      _ChannelUpdateInfo_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// The difference in CLTV values that you must have when routing through this channel.
  void ChannelUpdateInfo_set_cltv_expiry_delta(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    int val,
  ) {
    return _ChannelUpdateInfo_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              ffi.Uint16)>>('ChannelUpdateInfo_set_cltv_expiry_delta');
  late final _ChannelUpdateInfo_set_cltv_expiry_delta =
      _ChannelUpdateInfo_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, int)>();

  /// The minimum value, which must be relayed to the next hop via the channel
  int ChannelUpdateInfo_get_htlc_minimum_msat(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_htlc_minimum_msat');
  late final _ChannelUpdateInfo_get_htlc_minimum_msat =
      _ChannelUpdateInfo_get_htlc_minimum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// The minimum value, which must be relayed to the next hop via the channel
  void ChannelUpdateInfo_set_htlc_minimum_msat(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    int val,
  ) {
    return _ChannelUpdateInfo_set_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              ffi.Uint64)>>('ChannelUpdateInfo_set_htlc_minimum_msat');
  late final _ChannelUpdateInfo_set_htlc_minimum_msat =
      _ChannelUpdateInfo_set_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, int)>();

  /// The maximum value which may be relayed to the next hop via the channel.
  int ChannelUpdateInfo_get_htlc_maximum_msat(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_htlc_maximum_msat(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_htlc_maximum_msat');
  late final _ChannelUpdateInfo_get_htlc_maximum_msat =
      _ChannelUpdateInfo_get_htlc_maximum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// The maximum value which may be relayed to the next hop via the channel.
  void ChannelUpdateInfo_set_htlc_maximum_msat(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    int val,
  ) {
    return _ChannelUpdateInfo_set_htlc_maximum_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_htlc_maximum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              ffi.Uint64)>>('ChannelUpdateInfo_set_htlc_maximum_msat');
  late final _ChannelUpdateInfo_set_htlc_maximum_msat =
      _ChannelUpdateInfo_set_htlc_maximum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, int)>();

  /// Fees charged when the channel is used for routing
  LDKRoutingFees ChannelUpdateInfo_get_fees(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_fees(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_feesPtr = _lookup<
          ffi.NativeFunction<
              LDKRoutingFees Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_fees');
  late final _ChannelUpdateInfo_get_fees = _ChannelUpdateInfo_get_feesPtr
      .asFunction<LDKRoutingFees Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// Fees charged when the channel is used for routing
  void ChannelUpdateInfo_set_fees(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    LDKRoutingFees val,
  ) {
    return _ChannelUpdateInfo_set_fees(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_feesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              LDKRoutingFees)>>('ChannelUpdateInfo_set_fees');
  late final _ChannelUpdateInfo_set_fees =
      _ChannelUpdateInfo_set_feesPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, LDKRoutingFees)>();

  /// Most recent update for the channel received from the network
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
  ) {
    return _ChannelUpdateInfo_get_last_update_message(
      this_ptr,
    );
  }

  late final _ChannelUpdateInfo_get_last_update_messagePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelUpdate Function(ffi.Pointer<LDKChannelUpdateInfo>)>>(
      'ChannelUpdateInfo_get_last_update_message');
  late final _ChannelUpdateInfo_get_last_update_message =
      _ChannelUpdateInfo_get_last_update_messagePtr.asFunction<
          LDKChannelUpdate Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// Most recent update for the channel received from the network
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelUpdateInfo_set_last_update_message(
    ffi.Pointer<LDKChannelUpdateInfo> this_ptr,
    LDKChannelUpdate val,
  ) {
    return _ChannelUpdateInfo_set_last_update_message(
      this_ptr,
      val,
    );
  }

  late final _ChannelUpdateInfo_set_last_update_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUpdateInfo>,
              LDKChannelUpdate)>>('ChannelUpdateInfo_set_last_update_message');
  late final _ChannelUpdateInfo_set_last_update_message =
      _ChannelUpdateInfo_set_last_update_messagePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUpdateInfo>, LDKChannelUpdate)>();

  /// Constructs a new ChannelUpdateInfo given each field
  LDKChannelUpdateInfo ChannelUpdateInfo_new(
    int last_update_arg,
    bool enabled_arg,
    int cltv_expiry_delta_arg,
    int htlc_minimum_msat_arg,
    int htlc_maximum_msat_arg,
    LDKRoutingFees fees_arg,
    LDKChannelUpdate last_update_message_arg,
  ) {
    return _ChannelUpdateInfo_new(
      last_update_arg,
      enabled_arg,
      cltv_expiry_delta_arg,
      htlc_minimum_msat_arg,
      htlc_maximum_msat_arg,
      fees_arg,
      last_update_message_arg,
    );
  }

  late final _ChannelUpdateInfo_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdateInfo Function(
              ffi.Uint32,
              ffi.Bool,
              ffi.Uint16,
              ffi.Uint64,
              ffi.Uint64,
              LDKRoutingFees,
              LDKChannelUpdate)>>('ChannelUpdateInfo_new');
  late final _ChannelUpdateInfo_new = _ChannelUpdateInfo_newPtr.asFunction<
      LDKChannelUpdateInfo Function(
          int, bool, int, int, int, LDKRoutingFees, LDKChannelUpdate)>();

  /// Creates a copy of the ChannelUpdateInfo
  LDKChannelUpdateInfo ChannelUpdateInfo_clone(
    ffi.Pointer<LDKChannelUpdateInfo> orig,
  ) {
    return _ChannelUpdateInfo_clone(
      orig,
    );
  }

  late final _ChannelUpdateInfo_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdateInfo Function(
              ffi.Pointer<LDKChannelUpdateInfo>)>>('ChannelUpdateInfo_clone');
  late final _ChannelUpdateInfo_clone = _ChannelUpdateInfo_clonePtr.asFunction<
      LDKChannelUpdateInfo Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// Serialize the ChannelUpdateInfo object into a byte array which can be read by ChannelUpdateInfo_read
  LDKCVec_u8Z ChannelUpdateInfo_write(
    ffi.Pointer<LDKChannelUpdateInfo> obj,
  ) {
    return _ChannelUpdateInfo_write(
      obj,
    );
  }

  late final _ChannelUpdateInfo_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelUpdateInfo>)>>('ChannelUpdateInfo_write');
  late final _ChannelUpdateInfo_write = _ChannelUpdateInfo_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelUpdateInfo>)>();

  /// Read a ChannelUpdateInfo from a byte array, created by ChannelUpdateInfo_write
  LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(
    LDKu8slice ser,
  ) {
    return _ChannelUpdateInfo_read(
      ser,
    );
  }

  late final _ChannelUpdateInfo_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(
              LDKu8slice)>>('ChannelUpdateInfo_read');
  late final _ChannelUpdateInfo_read = _ChannelUpdateInfo_readPtr.asFunction<
      LDKCResult_ChannelUpdateInfoDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
  void ChannelInfo_free(
    LDKChannelInfo this_obj,
  ) {
    return _ChannelInfo_free(
      this_obj,
    );
  }

  late final _ChannelInfo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelInfo)>>(
          'ChannelInfo_free');
  late final _ChannelInfo_free =
      _ChannelInfo_freePtr.asFunction<void Function(LDKChannelInfo)>();

  /// Protocol features of a channel communicated during its announcement
  LDKChannelFeatures ChannelInfo_get_features(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_features(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_featuresPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelFeatures Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_get_features');
  late final _ChannelInfo_get_features = _ChannelInfo_get_featuresPtr
      .asFunction<LDKChannelFeatures Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Protocol features of a channel communicated during its announcement
  void ChannelInfo_set_features(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKChannelFeatures val,
  ) {
    return _ChannelInfo_set_features(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKChannelFeatures)>>('ChannelInfo_set_features');
  late final _ChannelInfo_set_features =
      _ChannelInfo_set_featuresPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelInfo>, LDKChannelFeatures)>();

  /// Source node of the first direction of a channel
  LDKNodeId ChannelInfo_get_node_one(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_node_one(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_node_onePtr = _lookup<
          ffi.NativeFunction<LDKNodeId Function(ffi.Pointer<LDKChannelInfo>)>>(
      'ChannelInfo_get_node_one');
  late final _ChannelInfo_get_node_one = _ChannelInfo_get_node_onePtr
      .asFunction<LDKNodeId Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Source node of the first direction of a channel
  void ChannelInfo_set_node_one(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKNodeId val,
  ) {
    return _ChannelInfo_set_node_one(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_node_onePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKNodeId)>>('ChannelInfo_set_node_one');
  late final _ChannelInfo_set_node_one = _ChannelInfo_set_node_onePtr
      .asFunction<void Function(ffi.Pointer<LDKChannelInfo>, LDKNodeId)>();

  /// Details about the first direction of a channel
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelUpdateInfo ChannelInfo_get_one_to_two(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_one_to_two(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_one_to_twoPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdateInfo Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_get_one_to_two');
  late final _ChannelInfo_get_one_to_two = _ChannelInfo_get_one_to_twoPtr
      .asFunction<LDKChannelUpdateInfo Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Details about the first direction of a channel
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelInfo_set_one_to_two(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKChannelUpdateInfo val,
  ) {
    return _ChannelInfo_set_one_to_two(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_one_to_twoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKChannelUpdateInfo)>>('ChannelInfo_set_one_to_two');
  late final _ChannelInfo_set_one_to_two =
      _ChannelInfo_set_one_to_twoPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelInfo>, LDKChannelUpdateInfo)>();

  /// Source node of the second direction of a channel
  LDKNodeId ChannelInfo_get_node_two(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_node_two(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_node_twoPtr = _lookup<
          ffi.NativeFunction<LDKNodeId Function(ffi.Pointer<LDKChannelInfo>)>>(
      'ChannelInfo_get_node_two');
  late final _ChannelInfo_get_node_two = _ChannelInfo_get_node_twoPtr
      .asFunction<LDKNodeId Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Source node of the second direction of a channel
  void ChannelInfo_set_node_two(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKNodeId val,
  ) {
    return _ChannelInfo_set_node_two(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_node_twoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKNodeId)>>('ChannelInfo_set_node_two');
  late final _ChannelInfo_set_node_two = _ChannelInfo_set_node_twoPtr
      .asFunction<void Function(ffi.Pointer<LDKChannelInfo>, LDKNodeId)>();

  /// Details about the second direction of a channel
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelUpdateInfo ChannelInfo_get_two_to_one(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_two_to_one(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_two_to_onePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdateInfo Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_get_two_to_one');
  late final _ChannelInfo_get_two_to_one = _ChannelInfo_get_two_to_onePtr
      .asFunction<LDKChannelUpdateInfo Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Details about the second direction of a channel
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelInfo_set_two_to_one(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKChannelUpdateInfo val,
  ) {
    return _ChannelInfo_set_two_to_one(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_two_to_onePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKChannelUpdateInfo)>>('ChannelInfo_set_two_to_one');
  late final _ChannelInfo_set_two_to_one =
      _ChannelInfo_set_two_to_onePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelInfo>, LDKChannelUpdateInfo)>();

  /// The channel capacity as seen on-chain, if chain lookup is available.
  LDKCOption_u64Z ChannelInfo_get_capacity_sats(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_capacity_sats(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_capacity_satsPtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u64Z Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_get_capacity_sats');
  late final _ChannelInfo_get_capacity_sats = _ChannelInfo_get_capacity_satsPtr
      .asFunction<LDKCOption_u64Z Function(ffi.Pointer<LDKChannelInfo>)>();

  /// The channel capacity as seen on-chain, if chain lookup is available.
  void ChannelInfo_set_capacity_sats(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _ChannelInfo_set_capacity_sats(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_capacity_satsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKCOption_u64Z)>>('ChannelInfo_set_capacity_sats');
  late final _ChannelInfo_set_capacity_sats =
      _ChannelInfo_set_capacity_satsPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelInfo>, LDKCOption_u64Z)>();

  /// An initial announcement of the channel
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelAnnouncement ChannelInfo_get_announcement_message(
    ffi.Pointer<LDKChannelInfo> this_ptr,
  ) {
    return _ChannelInfo_get_announcement_message(
      this_ptr,
    );
  }

  late final _ChannelInfo_get_announcement_messagePtr = _lookup<
          ffi.NativeFunction<
              LDKChannelAnnouncement Function(ffi.Pointer<LDKChannelInfo>)>>(
      'ChannelInfo_get_announcement_message');
  late final _ChannelInfo_get_announcement_message =
      _ChannelInfo_get_announcement_messagePtr.asFunction<
          LDKChannelAnnouncement Function(ffi.Pointer<LDKChannelInfo>)>();

  /// An initial announcement of the channel
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void ChannelInfo_set_announcement_message(
    ffi.Pointer<LDKChannelInfo> this_ptr,
    LDKChannelAnnouncement val,
  ) {
    return _ChannelInfo_set_announcement_message(
      this_ptr,
      val,
    );
  }

  late final _ChannelInfo_set_announcement_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelInfo>,
              LDKChannelAnnouncement)>>('ChannelInfo_set_announcement_message');
  late final _ChannelInfo_set_announcement_message =
      _ChannelInfo_set_announcement_messagePtr.asFunction<
          void Function(ffi.Pointer<LDKChannelInfo>, LDKChannelAnnouncement)>();

  /// Creates a copy of the ChannelInfo
  LDKChannelInfo ChannelInfo_clone(
    ffi.Pointer<LDKChannelInfo> orig,
  ) {
    return _ChannelInfo_clone(
      orig,
    );
  }

  late final _ChannelInfo_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelInfo Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_clone');
  late final _ChannelInfo_clone = _ChannelInfo_clonePtr.asFunction<
      LDKChannelInfo Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Returns a [`ChannelUpdateInfo`] based on the direction implied by the channel_flag.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelUpdateInfo ChannelInfo_get_directional_info(
    ffi.Pointer<LDKChannelInfo> this_arg,
    int channel_flags,
  ) {
    return _ChannelInfo_get_directional_info(
      this_arg,
      channel_flags,
    );
  }

  late final _ChannelInfo_get_directional_infoPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUpdateInfo Function(ffi.Pointer<LDKChannelInfo>,
              ffi.Uint8)>>('ChannelInfo_get_directional_info');
  late final _ChannelInfo_get_directional_info =
      _ChannelInfo_get_directional_infoPtr.asFunction<
          LDKChannelUpdateInfo Function(ffi.Pointer<LDKChannelInfo>, int)>();

  /// Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
  LDKCVec_u8Z ChannelInfo_write(
    ffi.Pointer<LDKChannelInfo> obj,
  ) {
    return _ChannelInfo_write(
      obj,
    );
  }

  late final _ChannelInfo_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKChannelInfo>)>>('ChannelInfo_write');
  late final _ChannelInfo_write = _ChannelInfo_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKChannelInfo>)>();

  /// Read a ChannelInfo from a byte array, created by ChannelInfo_write
  LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(
    LDKu8slice ser,
  ) {
    return _ChannelInfo_read(
      ser,
    );
  }

  late final _ChannelInfo_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ChannelInfoDecodeErrorZ Function(
              LDKu8slice)>>('ChannelInfo_read');
  late final _ChannelInfo_read = _ChannelInfo_readPtr.asFunction<
      LDKCResult_ChannelInfoDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the DirectedChannelInfo, if is_owned is set and inner is non-NULL.
  void DirectedChannelInfo_free(
    LDKDirectedChannelInfo this_obj,
  ) {
    return _DirectedChannelInfo_free(
      this_obj,
    );
  }

  late final _DirectedChannelInfo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKDirectedChannelInfo)>>(
          'DirectedChannelInfo_free');
  late final _DirectedChannelInfo_free = _DirectedChannelInfo_freePtr
      .asFunction<void Function(LDKDirectedChannelInfo)>();

  /// Creates a copy of the DirectedChannelInfo
  LDKDirectedChannelInfo DirectedChannelInfo_clone(
    ffi.Pointer<LDKDirectedChannelInfo> orig,
  ) {
    return _DirectedChannelInfo_clone(
      orig,
    );
  }

  late final _DirectedChannelInfo_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKDirectedChannelInfo Function(
                  ffi.Pointer<LDKDirectedChannelInfo>)>>(
      'DirectedChannelInfo_clone');
  late final _DirectedChannelInfo_clone =
      _DirectedChannelInfo_clonePtr.asFunction<
          LDKDirectedChannelInfo Function(
              ffi.Pointer<LDKDirectedChannelInfo>)>();

  /// Returns information for the channel.
  LDKChannelInfo DirectedChannelInfo_channel(
    ffi.Pointer<LDKDirectedChannelInfo> this_arg,
  ) {
    return _DirectedChannelInfo_channel(
      this_arg,
    );
  }

  late final _DirectedChannelInfo_channelPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelInfo Function(ffi.Pointer<LDKDirectedChannelInfo>)>>(
      'DirectedChannelInfo_channel');
  late final _DirectedChannelInfo_channel =
      _DirectedChannelInfo_channelPtr.asFunction<
          LDKChannelInfo Function(ffi.Pointer<LDKDirectedChannelInfo>)>();

  /// Returns information for the direction.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelUpdateInfo DirectedChannelInfo_direction(
    ffi.Pointer<LDKDirectedChannelInfo> this_arg,
  ) {
    return _DirectedChannelInfo_direction(
      this_arg,
    );
  }

  late final _DirectedChannelInfo_directionPtr = _lookup<
          ffi.NativeFunction<
              LDKChannelUpdateInfo Function(
                  ffi.Pointer<LDKDirectedChannelInfo>)>>(
      'DirectedChannelInfo_direction');
  late final _DirectedChannelInfo_direction =
      _DirectedChannelInfo_directionPtr.asFunction<
          LDKChannelUpdateInfo Function(ffi.Pointer<LDKDirectedChannelInfo>)>();

  /// Returns the maximum HTLC amount allowed over the channel in the direction.
  int DirectedChannelInfo_htlc_maximum_msat(
    ffi.Pointer<LDKDirectedChannelInfo> this_arg,
  ) {
    return _DirectedChannelInfo_htlc_maximum_msat(
      this_arg,
    );
  }

  late final _DirectedChannelInfo_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKDirectedChannelInfo>)>>(
      'DirectedChannelInfo_htlc_maximum_msat');
  late final _DirectedChannelInfo_htlc_maximum_msat =
      _DirectedChannelInfo_htlc_maximum_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKDirectedChannelInfo>)>();

  /// Returns the [`EffectiveCapacity`] of the channel in the direction.
  ///
  /// This is either the total capacity from the funding transaction, if known, or the
  /// `htlc_maximum_msat` for the direction as advertised by the gossip network, if known,
  /// otherwise.
  LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(
    ffi.Pointer<LDKDirectedChannelInfo> this_arg,
  ) {
    return _DirectedChannelInfo_effective_capacity(
      this_arg,
    );
  }

  late final _DirectedChannelInfo_effective_capacityPtr = _lookup<
          ffi.NativeFunction<
              LDKEffectiveCapacity Function(
                  ffi.Pointer<LDKDirectedChannelInfo>)>>(
      'DirectedChannelInfo_effective_capacity');
  late final _DirectedChannelInfo_effective_capacity =
      _DirectedChannelInfo_effective_capacityPtr.asFunction<
          LDKEffectiveCapacity Function(ffi.Pointer<LDKDirectedChannelInfo>)>();

  /// Frees any resources used by the EffectiveCapacity
  void EffectiveCapacity_free(
    LDKEffectiveCapacity this_ptr,
  ) {
    return _EffectiveCapacity_free(
      this_ptr,
    );
  }

  late final _EffectiveCapacity_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKEffectiveCapacity)>>(
          'EffectiveCapacity_free');
  late final _EffectiveCapacity_free = _EffectiveCapacity_freePtr.asFunction<
      void Function(LDKEffectiveCapacity)>();

  /// Creates a copy of the EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_clone(
    ffi.Pointer<LDKEffectiveCapacity> orig,
  ) {
    return _EffectiveCapacity_clone(
      orig,
    );
  }

  late final _EffectiveCapacity_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKEffectiveCapacity Function(
              ffi.Pointer<LDKEffectiveCapacity>)>>('EffectiveCapacity_clone');
  late final _EffectiveCapacity_clone = _EffectiveCapacity_clonePtr.asFunction<
      LDKEffectiveCapacity Function(ffi.Pointer<LDKEffectiveCapacity>)>();

  /// Utility method to constructs a new ExactLiquidity-variant EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(
    int liquidity_msat,
  ) {
    return _EffectiveCapacity_exact_liquidity(
      liquidity_msat,
    );
  }

  late final _EffectiveCapacity_exact_liquidityPtr =
      _lookup<ffi.NativeFunction<LDKEffectiveCapacity Function(ffi.Uint64)>>(
          'EffectiveCapacity_exact_liquidity');
  late final _EffectiveCapacity_exact_liquidity =
      _EffectiveCapacity_exact_liquidityPtr.asFunction<
          LDKEffectiveCapacity Function(int)>();

  /// Utility method to constructs a new MaximumHTLC-variant EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_maximum_htlc(
    int amount_msat,
  ) {
    return _EffectiveCapacity_maximum_htlc(
      amount_msat,
    );
  }

  late final _EffectiveCapacity_maximum_htlcPtr =
      _lookup<ffi.NativeFunction<LDKEffectiveCapacity Function(ffi.Uint64)>>(
          'EffectiveCapacity_maximum_htlc');
  late final _EffectiveCapacity_maximum_htlc =
      _EffectiveCapacity_maximum_htlcPtr.asFunction<
          LDKEffectiveCapacity Function(int)>();

  /// Utility method to constructs a new Total-variant EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_total(
    int capacity_msat,
    LDKCOption_u64Z htlc_maximum_msat,
  ) {
    return _EffectiveCapacity_total(
      capacity_msat,
      htlc_maximum_msat,
    );
  }

  late final _EffectiveCapacity_totalPtr = _lookup<
      ffi.NativeFunction<
          LDKEffectiveCapacity Function(
              ffi.Uint64, LDKCOption_u64Z)>>('EffectiveCapacity_total');
  late final _EffectiveCapacity_total = _EffectiveCapacity_totalPtr.asFunction<
      LDKEffectiveCapacity Function(int, LDKCOption_u64Z)>();

  /// Utility method to constructs a new Infinite-variant EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_infinite() {
    return _EffectiveCapacity_infinite();
  }

  late final _EffectiveCapacity_infinitePtr =
      _lookup<ffi.NativeFunction<LDKEffectiveCapacity Function()>>(
          'EffectiveCapacity_infinite');
  late final _EffectiveCapacity_infinite = _EffectiveCapacity_infinitePtr
      .asFunction<LDKEffectiveCapacity Function()>();

  /// Utility method to constructs a new Unknown-variant EffectiveCapacity
  LDKEffectiveCapacity EffectiveCapacity_unknown() {
    return _EffectiveCapacity_unknown();
  }

  late final _EffectiveCapacity_unknownPtr =
      _lookup<ffi.NativeFunction<LDKEffectiveCapacity Function()>>(
          'EffectiveCapacity_unknown');
  late final _EffectiveCapacity_unknown = _EffectiveCapacity_unknownPtr
      .asFunction<LDKEffectiveCapacity Function()>();

  /// Returns the effective capacity denominated in millisatoshi.
  int EffectiveCapacity_as_msat(
    ffi.Pointer<LDKEffectiveCapacity> this_arg,
  ) {
    return _EffectiveCapacity_as_msat(
      this_arg,
    );
  }

  late final _EffectiveCapacity_as_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKEffectiveCapacity>)>>('EffectiveCapacity_as_msat');
  late final _EffectiveCapacity_as_msat = _EffectiveCapacity_as_msatPtr
      .asFunction<int Function(ffi.Pointer<LDKEffectiveCapacity>)>();

  /// Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
  void RoutingFees_free(
    LDKRoutingFees this_obj,
  ) {
    return _RoutingFees_free(
      this_obj,
    );
  }

  late final _RoutingFees_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRoutingFees)>>(
          'RoutingFees_free');
  late final _RoutingFees_free =
      _RoutingFees_freePtr.asFunction<void Function(LDKRoutingFees)>();

  /// Flat routing fee in satoshis
  int RoutingFees_get_base_msat(
    ffi.Pointer<LDKRoutingFees> this_ptr,
  ) {
    return _RoutingFees_get_base_msat(
      this_ptr,
    );
  }

  late final _RoutingFees_get_base_msatPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKRoutingFees>)>>(
      'RoutingFees_get_base_msat');
  late final _RoutingFees_get_base_msat = _RoutingFees_get_base_msatPtr
      .asFunction<int Function(ffi.Pointer<LDKRoutingFees>)>();

  /// Flat routing fee in satoshis
  void RoutingFees_set_base_msat(
    ffi.Pointer<LDKRoutingFees> this_ptr,
    int val,
  ) {
    return _RoutingFees_set_base_msat(
      this_ptr,
      val,
    );
  }

  late final _RoutingFees_set_base_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRoutingFees>,
              ffi.Uint32)>>('RoutingFees_set_base_msat');
  late final _RoutingFees_set_base_msat = _RoutingFees_set_base_msatPtr
      .asFunction<void Function(ffi.Pointer<LDKRoutingFees>, int)>();

  /// Liquidity-based routing fee in millionths of a routed amount.
  /// In other words, 10000 is 1%.
  int RoutingFees_get_proportional_millionths(
    ffi.Pointer<LDKRoutingFees> this_ptr,
  ) {
    return _RoutingFees_get_proportional_millionths(
      this_ptr,
    );
  }

  late final _RoutingFees_get_proportional_millionthsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKRoutingFees>)>>(
      'RoutingFees_get_proportional_millionths');
  late final _RoutingFees_get_proportional_millionths =
      _RoutingFees_get_proportional_millionthsPtr.asFunction<
          int Function(ffi.Pointer<LDKRoutingFees>)>();

  /// Liquidity-based routing fee in millionths of a routed amount.
  /// In other words, 10000 is 1%.
  void RoutingFees_set_proportional_millionths(
    ffi.Pointer<LDKRoutingFees> this_ptr,
    int val,
  ) {
    return _RoutingFees_set_proportional_millionths(
      this_ptr,
      val,
    );
  }

  late final _RoutingFees_set_proportional_millionthsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRoutingFees>,
              ffi.Uint32)>>('RoutingFees_set_proportional_millionths');
  late final _RoutingFees_set_proportional_millionths =
      _RoutingFees_set_proportional_millionthsPtr.asFunction<
          void Function(ffi.Pointer<LDKRoutingFees>, int)>();

  /// Constructs a new RoutingFees given each field
  LDKRoutingFees RoutingFees_new(
    int base_msat_arg,
    int proportional_millionths_arg,
  ) {
    return _RoutingFees_new(
      base_msat_arg,
      proportional_millionths_arg,
    );
  }

  late final _RoutingFees_newPtr = _lookup<
          ffi.NativeFunction<LDKRoutingFees Function(ffi.Uint32, ffi.Uint32)>>(
      'RoutingFees_new');
  late final _RoutingFees_new =
      _RoutingFees_newPtr.asFunction<LDKRoutingFees Function(int, int)>();

  /// Checks if two RoutingFeess contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RoutingFees_eq(
    ffi.Pointer<LDKRoutingFees> a,
    ffi.Pointer<LDKRoutingFees> b,
  ) {
    return _RoutingFees_eq(
      a,
      b,
    );
  }

  late final _RoutingFees_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRoutingFees>,
              ffi.Pointer<LDKRoutingFees>)>>('RoutingFees_eq');
  late final _RoutingFees_eq = _RoutingFees_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKRoutingFees>, ffi.Pointer<LDKRoutingFees>)>();

  /// Creates a copy of the RoutingFees
  LDKRoutingFees RoutingFees_clone(
    ffi.Pointer<LDKRoutingFees> orig,
  ) {
    return _RoutingFees_clone(
      orig,
    );
  }

  late final _RoutingFees_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRoutingFees Function(
              ffi.Pointer<LDKRoutingFees>)>>('RoutingFees_clone');
  late final _RoutingFees_clone = _RoutingFees_clonePtr.asFunction<
      LDKRoutingFees Function(ffi.Pointer<LDKRoutingFees>)>();

  /// Checks if two RoutingFeess contain equal inner contents.
  int RoutingFees_hash(
    ffi.Pointer<LDKRoutingFees> o,
  ) {
    return _RoutingFees_hash(
      o,
    );
  }

  late final _RoutingFees_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRoutingFees>)>>(
      'RoutingFees_hash');
  late final _RoutingFees_hash = _RoutingFees_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKRoutingFees>)>();

  /// Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
  LDKCVec_u8Z RoutingFees_write(
    ffi.Pointer<LDKRoutingFees> obj,
  ) {
    return _RoutingFees_write(
      obj,
    );
  }

  late final _RoutingFees_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKRoutingFees>)>>('RoutingFees_write');
  late final _RoutingFees_write = _RoutingFees_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRoutingFees>)>();

  /// Read a RoutingFees from a byte array, created by RoutingFees_write
  LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(
    LDKu8slice ser,
  ) {
    return _RoutingFees_read(
      ser,
    );
  }

  late final _RoutingFees_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RoutingFeesDecodeErrorZ Function(
              LDKu8slice)>>('RoutingFees_read');
  late final _RoutingFees_read = _RoutingFees_readPtr.asFunction<
      LDKCResult_RoutingFeesDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
  void NodeAnnouncementInfo_free(
    LDKNodeAnnouncementInfo this_obj,
  ) {
    return _NodeAnnouncementInfo_free(
      this_obj,
    );
  }

  late final _NodeAnnouncementInfo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeAnnouncementInfo)>>(
          'NodeAnnouncementInfo_free');
  late final _NodeAnnouncementInfo_free = _NodeAnnouncementInfo_freePtr
      .asFunction<void Function(LDKNodeAnnouncementInfo)>();

  /// Protocol features the node announced support for
  LDKNodeFeatures NodeAnnouncementInfo_get_features(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_features(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_featuresPtr = _lookup<
          ffi.NativeFunction<
              LDKNodeFeatures Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_features');
  late final _NodeAnnouncementInfo_get_features =
      _NodeAnnouncementInfo_get_featuresPtr.asFunction<
          LDKNodeFeatures Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Protocol features the node announced support for
  void NodeAnnouncementInfo_set_features(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    LDKNodeFeatures val,
  ) {
    return _NodeAnnouncementInfo_set_features(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncementInfo>,
              LDKNodeFeatures)>>('NodeAnnouncementInfo_set_features');
  late final _NodeAnnouncementInfo_set_features =
      _NodeAnnouncementInfo_set_featuresPtr.asFunction<
          void Function(
              ffi.Pointer<LDKNodeAnnouncementInfo>, LDKNodeFeatures)>();

  /// When the last known update to the node state was issued.
  /// Value is opaque, as set in the announcement.
  int NodeAnnouncementInfo_get_last_update(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_last_update(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_last_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_last_update');
  late final _NodeAnnouncementInfo_get_last_update =
      _NodeAnnouncementInfo_get_last_updatePtr.asFunction<
          int Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// When the last known update to the node state was issued.
  /// Value is opaque, as set in the announcement.
  void NodeAnnouncementInfo_set_last_update(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    int val,
  ) {
    return _NodeAnnouncementInfo_set_last_update(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_last_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncementInfo>,
              ffi.Uint32)>>('NodeAnnouncementInfo_set_last_update');
  late final _NodeAnnouncementInfo_set_last_update =
      _NodeAnnouncementInfo_set_last_updatePtr.asFunction<
          void Function(ffi.Pointer<LDKNodeAnnouncementInfo>, int)>();

  /// Color assigned to the node
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> NodeAnnouncementInfo_get_rgb(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_rgb(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_rgbPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
                  ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_rgb');
  late final _NodeAnnouncementInfo_get_rgb =
      _NodeAnnouncementInfo_get_rgbPtr.asFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Color assigned to the node
  void NodeAnnouncementInfo_set_rgb(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    LDKThreeBytes val,
  ) {
    return _NodeAnnouncementInfo_set_rgb(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_rgbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncementInfo>,
              LDKThreeBytes)>>('NodeAnnouncementInfo_set_rgb');
  late final _NodeAnnouncementInfo_set_rgb =
      _NodeAnnouncementInfo_set_rgbPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeAnnouncementInfo>, LDKThreeBytes)>();

  /// Moniker assigned to the node.
  /// May be invalid or malicious (eg control chars),
  /// should not be exposed to the user.
  LDKNodeAlias NodeAnnouncementInfo_get_alias(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_alias(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_aliasPtr = _lookup<
          ffi.NativeFunction<
              LDKNodeAlias Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_alias');
  late final _NodeAnnouncementInfo_get_alias =
      _NodeAnnouncementInfo_get_aliasPtr.asFunction<
          LDKNodeAlias Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Moniker assigned to the node.
  /// May be invalid or malicious (eg control chars),
  /// should not be exposed to the user.
  void NodeAnnouncementInfo_set_alias(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    LDKNodeAlias val,
  ) {
    return _NodeAnnouncementInfo_set_alias(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncementInfo>,
              LDKNodeAlias)>>('NodeAnnouncementInfo_set_alias');
  late final _NodeAnnouncementInfo_set_alias =
      _NodeAnnouncementInfo_set_aliasPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeAnnouncementInfo>, LDKNodeAlias)>();

  /// Internet-level addresses via which one can connect to the node
  ///
  /// Returns a copy of the field.
  LDKCVec_NetAddressZ NodeAnnouncementInfo_get_addresses(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_addresses(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_addressesPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_NetAddressZ Function(
                  ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_addresses');
  late final _NodeAnnouncementInfo_get_addresses =
      _NodeAnnouncementInfo_get_addressesPtr.asFunction<
          LDKCVec_NetAddressZ Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Internet-level addresses via which one can connect to the node
  void NodeAnnouncementInfo_set_addresses(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    LDKCVec_NetAddressZ val,
  ) {
    return _NodeAnnouncementInfo_set_addresses(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_addressesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAnnouncementInfo>,
              LDKCVec_NetAddressZ)>>('NodeAnnouncementInfo_set_addresses');
  late final _NodeAnnouncementInfo_set_addresses =
      _NodeAnnouncementInfo_set_addressesPtr.asFunction<
          void Function(
              ffi.Pointer<LDKNodeAnnouncementInfo>, LDKCVec_NetAddressZ)>();

  /// An initial announcement of the node
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
  ) {
    return _NodeAnnouncementInfo_get_announcement_message(
      this_ptr,
    );
  }

  late final _NodeAnnouncementInfo_get_announcement_messagePtr = _lookup<
          ffi.NativeFunction<
              LDKNodeAnnouncement Function(
                  ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_get_announcement_message');
  late final _NodeAnnouncementInfo_get_announcement_message =
      _NodeAnnouncementInfo_get_announcement_messagePtr.asFunction<
          LDKNodeAnnouncement Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// An initial announcement of the node
  /// Mostly redundant with the data we store in fields explicitly.
  /// Everything else is useful only for sending out for initial routing sync.
  /// Not stored if contains excess data to prevent DoS.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void NodeAnnouncementInfo_set_announcement_message(
    ffi.Pointer<LDKNodeAnnouncementInfo> this_ptr,
    LDKNodeAnnouncement val,
  ) {
    return _NodeAnnouncementInfo_set_announcement_message(
      this_ptr,
      val,
    );
  }

  late final _NodeAnnouncementInfo_set_announcement_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKNodeAnnouncementInfo>, LDKNodeAnnouncement)>>(
      'NodeAnnouncementInfo_set_announcement_message');
  late final _NodeAnnouncementInfo_set_announcement_message =
      _NodeAnnouncementInfo_set_announcement_messagePtr.asFunction<
          void Function(
              ffi.Pointer<LDKNodeAnnouncementInfo>, LDKNodeAnnouncement)>();

  /// Constructs a new NodeAnnouncementInfo given each field
  LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(
    LDKNodeFeatures features_arg,
    int last_update_arg,
    LDKThreeBytes rgb_arg,
    LDKNodeAlias alias_arg,
    LDKCVec_NetAddressZ addresses_arg,
    LDKNodeAnnouncement announcement_message_arg,
  ) {
    return _NodeAnnouncementInfo_new(
      features_arg,
      last_update_arg,
      rgb_arg,
      alias_arg,
      addresses_arg,
      announcement_message_arg,
    );
  }

  late final _NodeAnnouncementInfo_newPtr = _lookup<
      ffi.NativeFunction<
          LDKNodeAnnouncementInfo Function(
              LDKNodeFeatures,
              ffi.Uint32,
              LDKThreeBytes,
              LDKNodeAlias,
              LDKCVec_NetAddressZ,
              LDKNodeAnnouncement)>>('NodeAnnouncementInfo_new');
  late final _NodeAnnouncementInfo_new =
      _NodeAnnouncementInfo_newPtr.asFunction<
          LDKNodeAnnouncementInfo Function(LDKNodeFeatures, int, LDKThreeBytes,
              LDKNodeAlias, LDKCVec_NetAddressZ, LDKNodeAnnouncement)>();

  /// Creates a copy of the NodeAnnouncementInfo
  LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(
    ffi.Pointer<LDKNodeAnnouncementInfo> orig,
  ) {
    return _NodeAnnouncementInfo_clone(
      orig,
    );
  }

  late final _NodeAnnouncementInfo_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKNodeAnnouncementInfo Function(
                  ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_clone');
  late final _NodeAnnouncementInfo_clone =
      _NodeAnnouncementInfo_clonePtr.asFunction<
          LDKNodeAnnouncementInfo Function(
              ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
  LDKCVec_u8Z NodeAnnouncementInfo_write(
    ffi.Pointer<LDKNodeAnnouncementInfo> obj,
  ) {
    return _NodeAnnouncementInfo_write(
      obj,
    );
  }

  late final _NodeAnnouncementInfo_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>>(
      'NodeAnnouncementInfo_write');
  late final _NodeAnnouncementInfo_write = _NodeAnnouncementInfo_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKNodeAnnouncementInfo>)>();

  /// Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
  LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(
    LDKu8slice ser,
  ) {
    return _NodeAnnouncementInfo_read(
      ser,
    );
  }

  late final _NodeAnnouncementInfo_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(
              LDKu8slice)>>('NodeAnnouncementInfo_read');
  late final _NodeAnnouncementInfo_read =
      _NodeAnnouncementInfo_readPtr.asFunction<
          LDKCResult_NodeAnnouncementInfoDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the NodeAlias, if is_owned is set and inner is non-NULL.
  void NodeAlias_free(
    LDKNodeAlias this_obj,
  ) {
    return _NodeAlias_free(
      this_obj,
    );
  }

  late final _NodeAlias_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeAlias)>>(
          'NodeAlias_free');
  late final _NodeAlias_free =
      _NodeAlias_freePtr.asFunction<void Function(LDKNodeAlias)>();

  ffi.Pointer<ffi.Pointer<ffi.Uint8>> NodeAlias_get_a(
    ffi.Pointer<LDKNodeAlias> this_ptr,
  ) {
    return _NodeAlias_get_a(
      this_ptr,
    );
  }

  late final _NodeAlias_get_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKNodeAlias>)>>('NodeAlias_get_a');
  late final _NodeAlias_get_a = _NodeAlias_get_aPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
          ffi.Pointer<LDKNodeAlias>)>();

  void NodeAlias_set_a(
    ffi.Pointer<LDKNodeAlias> this_ptr,
    LDKThirtyTwoBytes val,
  ) {
    return _NodeAlias_set_a(
      this_ptr,
      val,
    );
  }

  late final _NodeAlias_set_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeAlias>,
              LDKThirtyTwoBytes)>>('NodeAlias_set_a');
  late final _NodeAlias_set_a = _NodeAlias_set_aPtr.asFunction<
      void Function(ffi.Pointer<LDKNodeAlias>, LDKThirtyTwoBytes)>();

  /// Constructs a new NodeAlias given each field
  LDKNodeAlias NodeAlias_new(
    LDKThirtyTwoBytes a_arg,
  ) {
    return _NodeAlias_new(
      a_arg,
    );
  }

  late final _NodeAlias_newPtr =
      _lookup<ffi.NativeFunction<LDKNodeAlias Function(LDKThirtyTwoBytes)>>(
          'NodeAlias_new');
  late final _NodeAlias_new =
      _NodeAlias_newPtr.asFunction<LDKNodeAlias Function(LDKThirtyTwoBytes)>();

  /// Creates a copy of the NodeAlias
  LDKNodeAlias NodeAlias_clone(
    ffi.Pointer<LDKNodeAlias> orig,
  ) {
    return _NodeAlias_clone(
      orig,
    );
  }

  late final _NodeAlias_clonePtr = _lookup<
          ffi.NativeFunction<LDKNodeAlias Function(ffi.Pointer<LDKNodeAlias>)>>(
      'NodeAlias_clone');
  late final _NodeAlias_clone = _NodeAlias_clonePtr.asFunction<
      LDKNodeAlias Function(ffi.Pointer<LDKNodeAlias>)>();

  /// Serialize the NodeAlias object into a byte array which can be read by NodeAlias_read
  LDKCVec_u8Z NodeAlias_write(
    ffi.Pointer<LDKNodeAlias> obj,
  ) {
    return _NodeAlias_write(
      obj,
    );
  }

  late final _NodeAlias_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKNodeAlias>)>>(
      'NodeAlias_write');
  late final _NodeAlias_write = _NodeAlias_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNodeAlias>)>();

  /// Read a NodeAlias from a byte array, created by NodeAlias_write
  LDKCResult_NodeAliasDecodeErrorZ NodeAlias_read(
    LDKu8slice ser,
  ) {
    return _NodeAlias_read(
      ser,
    );
  }

  late final _NodeAlias_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeAliasDecodeErrorZ Function(
              LDKu8slice)>>('NodeAlias_read');
  late final _NodeAlias_read = _NodeAlias_readPtr.asFunction<
      LDKCResult_NodeAliasDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
  void NodeInfo_free(
    LDKNodeInfo this_obj,
  ) {
    return _NodeInfo_free(
      this_obj,
    );
  }

  late final _NodeInfo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKNodeInfo)>>(
          'NodeInfo_free');
  late final _NodeInfo_free =
      _NodeInfo_freePtr.asFunction<void Function(LDKNodeInfo)>();

  /// All valid channels a node has announced
  ///
  /// Returns a copy of the field.
  LDKCVec_u64Z NodeInfo_get_channels(
    ffi.Pointer<LDKNodeInfo> this_ptr,
  ) {
    return _NodeInfo_get_channels(
      this_ptr,
    );
  }

  late final _NodeInfo_get_channelsPtr = _lookup<
          ffi.NativeFunction<LDKCVec_u64Z Function(ffi.Pointer<LDKNodeInfo>)>>(
      'NodeInfo_get_channels');
  late final _NodeInfo_get_channels = _NodeInfo_get_channelsPtr.asFunction<
      LDKCVec_u64Z Function(ffi.Pointer<LDKNodeInfo>)>();

  /// All valid channels a node has announced
  void NodeInfo_set_channels(
    ffi.Pointer<LDKNodeInfo> this_ptr,
    LDKCVec_u64Z val,
  ) {
    return _NodeInfo_set_channels(
      this_ptr,
      val,
    );
  }

  late final _NodeInfo_set_channelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeInfo>,
              LDKCVec_u64Z)>>('NodeInfo_set_channels');
  late final _NodeInfo_set_channels = _NodeInfo_set_channelsPtr.asFunction<
      void Function(ffi.Pointer<LDKNodeInfo>, LDKCVec_u64Z)>();

  /// Lowest fees enabling routing via any of the enabled, known channels to a node.
  /// The two fields (flat and proportional fee) are independent,
  /// meaning they don't have to refer to the same channel.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(
    ffi.Pointer<LDKNodeInfo> this_ptr,
  ) {
    return _NodeInfo_get_lowest_inbound_channel_fees(
      this_ptr,
    );
  }

  late final _NodeInfo_get_lowest_inbound_channel_feesPtr = _lookup<
          ffi.NativeFunction<
              LDKRoutingFees Function(ffi.Pointer<LDKNodeInfo>)>>(
      'NodeInfo_get_lowest_inbound_channel_fees');
  late final _NodeInfo_get_lowest_inbound_channel_fees =
      _NodeInfo_get_lowest_inbound_channel_feesPtr.asFunction<
          LDKRoutingFees Function(ffi.Pointer<LDKNodeInfo>)>();

  /// Lowest fees enabling routing via any of the enabled, known channels to a node.
  /// The two fields (flat and proportional fee) are independent,
  /// meaning they don't have to refer to the same channel.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void NodeInfo_set_lowest_inbound_channel_fees(
    ffi.Pointer<LDKNodeInfo> this_ptr,
    LDKRoutingFees val,
  ) {
    return _NodeInfo_set_lowest_inbound_channel_fees(
      this_ptr,
      val,
    );
  }

  late final _NodeInfo_set_lowest_inbound_channel_feesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeInfo>,
              LDKRoutingFees)>>('NodeInfo_set_lowest_inbound_channel_fees');
  late final _NodeInfo_set_lowest_inbound_channel_fees =
      _NodeInfo_set_lowest_inbound_channel_feesPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeInfo>, LDKRoutingFees)>();

  /// More information about a node from node_announcement.
  /// Optional because we store a Node entry after learning about it from
  /// a channel announcement, but before receiving a node announcement.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(
    ffi.Pointer<LDKNodeInfo> this_ptr,
  ) {
    return _NodeInfo_get_announcement_info(
      this_ptr,
    );
  }

  late final _NodeInfo_get_announcement_infoPtr = _lookup<
      ffi.NativeFunction<
          LDKNodeAnnouncementInfo Function(
              ffi.Pointer<LDKNodeInfo>)>>('NodeInfo_get_announcement_info');
  late final _NodeInfo_get_announcement_info =
      _NodeInfo_get_announcement_infoPtr.asFunction<
          LDKNodeAnnouncementInfo Function(ffi.Pointer<LDKNodeInfo>)>();

  /// More information about a node from node_announcement.
  /// Optional because we store a Node entry after learning about it from
  /// a channel announcement, but before receiving a node announcement.
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void NodeInfo_set_announcement_info(
    ffi.Pointer<LDKNodeInfo> this_ptr,
    LDKNodeAnnouncementInfo val,
  ) {
    return _NodeInfo_set_announcement_info(
      this_ptr,
      val,
    );
  }

  late final _NodeInfo_set_announcement_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNodeInfo>,
              LDKNodeAnnouncementInfo)>>('NodeInfo_set_announcement_info');
  late final _NodeInfo_set_announcement_info =
      _NodeInfo_set_announcement_infoPtr.asFunction<
          void Function(ffi.Pointer<LDKNodeInfo>, LDKNodeAnnouncementInfo)>();

  /// Constructs a new NodeInfo given each field
  LDKNodeInfo NodeInfo_new(
    LDKCVec_u64Z channels_arg,
    LDKRoutingFees lowest_inbound_channel_fees_arg,
    LDKNodeAnnouncementInfo announcement_info_arg,
  ) {
    return _NodeInfo_new(
      channels_arg,
      lowest_inbound_channel_fees_arg,
      announcement_info_arg,
    );
  }

  late final _NodeInfo_newPtr = _lookup<
      ffi.NativeFunction<
          LDKNodeInfo Function(LDKCVec_u64Z, LDKRoutingFees,
              LDKNodeAnnouncementInfo)>>('NodeInfo_new');
  late final _NodeInfo_new = _NodeInfo_newPtr.asFunction<
      LDKNodeInfo Function(
          LDKCVec_u64Z, LDKRoutingFees, LDKNodeAnnouncementInfo)>();

  /// Creates a copy of the NodeInfo
  LDKNodeInfo NodeInfo_clone(
    ffi.Pointer<LDKNodeInfo> orig,
  ) {
    return _NodeInfo_clone(
      orig,
    );
  }

  late final _NodeInfo_clonePtr = _lookup<
          ffi.NativeFunction<LDKNodeInfo Function(ffi.Pointer<LDKNodeInfo>)>>(
      'NodeInfo_clone');
  late final _NodeInfo_clone = _NodeInfo_clonePtr.asFunction<
      LDKNodeInfo Function(ffi.Pointer<LDKNodeInfo>)>();

  /// Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
  LDKCVec_u8Z NodeInfo_write(
    ffi.Pointer<LDKNodeInfo> obj,
  ) {
    return _NodeInfo_write(
      obj,
    );
  }

  late final _NodeInfo_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKNodeInfo>)>>(
      'NodeInfo_write');
  late final _NodeInfo_write = _NodeInfo_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNodeInfo>)>();

  /// Read a NodeInfo from a byte array, created by NodeInfo_write
  LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(
    LDKu8slice ser,
  ) {
    return _NodeInfo_read(
      ser,
    );
  }

  late final _NodeInfo_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NodeInfoDecodeErrorZ Function(
              LDKu8slice)>>('NodeInfo_read');
  late final _NodeInfo_read = _NodeInfo_readPtr.asFunction<
      LDKCResult_NodeInfoDecodeErrorZ Function(LDKu8slice)>();

  /// Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
  LDKCVec_u8Z NetworkGraph_write(
    ffi.Pointer<LDKNetworkGraph> obj,
  ) {
    return _NetworkGraph_write(
      obj,
    );
  }

  late final _NetworkGraph_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKNetworkGraph>)>>('NetworkGraph_write');
  late final _NetworkGraph_write = _NetworkGraph_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// Read a NetworkGraph from a byte array, created by NetworkGraph_write
  LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(
    LDKu8slice ser,
    LDKLogger arg,
  ) {
    return _NetworkGraph_read(
      ser,
      arg,
    );
  }

  late final _NetworkGraph_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NetworkGraphDecodeErrorZ Function(
              LDKu8slice, LDKLogger)>>('NetworkGraph_read');
  late final _NetworkGraph_read = _NetworkGraph_readPtr.asFunction<
      LDKCResult_NetworkGraphDecodeErrorZ Function(LDKu8slice, LDKLogger)>();

  /// Creates a new, empty, network graph.
  LDKNetworkGraph NetworkGraph_new(
    LDKThirtyTwoBytes genesis_hash,
    LDKLogger logger,
  ) {
    return _NetworkGraph_new(
      genesis_hash,
      logger,
    );
  }

  late final _NetworkGraph_newPtr = _lookup<
      ffi.NativeFunction<
          LDKNetworkGraph Function(
              LDKThirtyTwoBytes, LDKLogger)>>('NetworkGraph_new');
  late final _NetworkGraph_new = _NetworkGraph_newPtr.asFunction<
      LDKNetworkGraph Function(LDKThirtyTwoBytes, LDKLogger)>();

  /// Returns a read-only view of the network graph.
  LDKReadOnlyNetworkGraph NetworkGraph_read_only(
    ffi.Pointer<LDKNetworkGraph> this_arg,
  ) {
    return _NetworkGraph_read_only(
      this_arg,
    );
  }

  late final _NetworkGraph_read_onlyPtr = _lookup<
      ffi.NativeFunction<
          LDKReadOnlyNetworkGraph Function(
              ffi.Pointer<LDKNetworkGraph>)>>('NetworkGraph_read_only');
  late final _NetworkGraph_read_only = _NetworkGraph_read_onlyPtr.asFunction<
      LDKReadOnlyNetworkGraph Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// The unix timestamp provided by the most recent rapid gossip sync.
  /// It will be set by the rapid sync process after every sync completion.
  LDKCOption_u32Z NetworkGraph_get_last_rapid_gossip_sync_timestamp(
    ffi.Pointer<LDKNetworkGraph> this_arg,
  ) {
    return _NetworkGraph_get_last_rapid_gossip_sync_timestamp(
      this_arg,
    );
  }

  late final _NetworkGraph_get_last_rapid_gossip_sync_timestampPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u32Z Function(ffi.Pointer<LDKNetworkGraph>)>>(
      'NetworkGraph_get_last_rapid_gossip_sync_timestamp');
  late final _NetworkGraph_get_last_rapid_gossip_sync_timestamp =
      _NetworkGraph_get_last_rapid_gossip_sync_timestampPtr.asFunction<
          LDKCOption_u32Z Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// Update the unix timestamp provided by the most recent rapid gossip sync.
  /// This should be done automatically by the rapid sync process after every sync completion.
  void NetworkGraph_set_last_rapid_gossip_sync_timestamp(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    int last_rapid_gossip_sync_timestamp,
  ) {
    return _NetworkGraph_set_last_rapid_gossip_sync_timestamp(
      this_arg,
      last_rapid_gossip_sync_timestamp,
    );
  }

  late final _NetworkGraph_set_last_rapid_gossip_sync_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKNetworkGraph>, ffi.Uint32)>>(
      'NetworkGraph_set_last_rapid_gossip_sync_timestamp');
  late final _NetworkGraph_set_last_rapid_gossip_sync_timestamp =
      _NetworkGraph_set_last_rapid_gossip_sync_timestampPtr.asFunction<
          void Function(ffi.Pointer<LDKNetworkGraph>, int)>();

  /// For an already known node (from channel announcements), update its stored properties from a
  /// given node announcement.
  ///
  /// You probably don't want to call this directly, instead relying on a P2PGossipSync's
  /// RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
  /// routing messages from a source using a protocol other than the lightning P2P protocol.
  LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKNodeAnnouncement> msg,
  ) {
    return _NetworkGraph_update_node_from_announcement(
      this_arg,
      msg,
    );
  }

  late final _NetworkGraph_update_node_from_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKNetworkGraph>,
                  ffi.Pointer<LDKNodeAnnouncement>)>>(
      'NetworkGraph_update_node_from_announcement');
  late final _NetworkGraph_update_node_from_announcement =
      _NetworkGraph_update_node_from_announcementPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKNodeAnnouncement>)>();

  /// For an already known node (from channel announcements), update its stored properties from a
  /// given node announcement without verifying the associated signatures. Because we aren't
  /// given the associated signatures here we cannot relay the node announcement to any of our
  /// peers.
  LDKCResult_NoneLightningErrorZ
      NetworkGraph_update_node_from_unsigned_announcement(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKUnsignedNodeAnnouncement> msg,
  ) {
    return _NetworkGraph_update_node_from_unsigned_announcement(
      this_arg,
      msg,
    );
  }

  late final _NetworkGraph_update_node_from_unsigned_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKNetworkGraph>,
                  ffi.Pointer<LDKUnsignedNodeAnnouncement>)>>(
      'NetworkGraph_update_node_from_unsigned_announcement');
  late final _NetworkGraph_update_node_from_unsigned_announcement =
      _NetworkGraph_update_node_from_unsigned_announcementPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKUnsignedNodeAnnouncement>)>();

  /// Store or update channel info from a channel announcement.
  ///
  /// You probably don't want to call this directly, instead relying on a P2PGossipSync's
  /// RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
  /// routing messages from a source using a protocol other than the lightning P2P protocol.
  ///
  /// If a `chain::Access` object is provided via `chain_access`, it will be called to verify
  /// the corresponding UTXO exists on chain and is correctly-formatted.
  LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKChannelAnnouncement> msg,
    LDKCOption_AccessZ chain_access,
  ) {
    return _NetworkGraph_update_channel_from_announcement(
      this_arg,
      msg,
      chain_access,
    );
  }

  late final _NetworkGraph_update_channel_from_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKNetworkGraph>,
                  ffi.Pointer<LDKChannelAnnouncement>,
                  LDKCOption_AccessZ)>>(
      'NetworkGraph_update_channel_from_announcement');
  late final _NetworkGraph_update_channel_from_announcement =
      _NetworkGraph_update_channel_from_announcementPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKChannelAnnouncement>, LDKCOption_AccessZ)>();

  /// Store or update channel info from a channel announcement without verifying the associated
  /// signatures. Because we aren't given the associated signatures here we cannot relay the
  /// channel announcement to any of our peers.
  ///
  /// If a `chain::Access` object is provided via `chain_access`, it will be called to verify
  /// the corresponding UTXO exists on chain and is correctly-formatted.
  LDKCResult_NoneLightningErrorZ
      NetworkGraph_update_channel_from_unsigned_announcement(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKUnsignedChannelAnnouncement> msg,
    LDKCOption_AccessZ chain_access,
  ) {
    return _NetworkGraph_update_channel_from_unsigned_announcement(
      this_arg,
      msg,
      chain_access,
    );
  }

  late final _NetworkGraph_update_channel_from_unsigned_announcementPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_NoneLightningErrorZ Function(
                      ffi.Pointer<LDKNetworkGraph>,
                      ffi.Pointer<LDKUnsignedChannelAnnouncement>,
                      LDKCOption_AccessZ)>>(
          'NetworkGraph_update_channel_from_unsigned_announcement');
  late final _NetworkGraph_update_channel_from_unsigned_announcement =
      _NetworkGraph_update_channel_from_unsigned_announcementPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(
              ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKUnsignedChannelAnnouncement>,
              LDKCOption_AccessZ)>();

  /// Update channel from partial announcement data received via rapid gossip sync
  ///
  /// `timestamp: u64`: Timestamp emulating the backdated original announcement receipt (by the
  /// rapid gossip sync server)
  ///
  /// All other parameters as used in [`msgs::UnsignedChannelAnnouncement`] fields.
  LDKCResult_NoneLightningErrorZ
      NetworkGraph_add_channel_from_partial_announcement(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    int short_channel_id,
    int timestamp,
    LDKChannelFeatures features,
    LDKPublicKey node_id_1,
    LDKPublicKey node_id_2,
  ) {
    return _NetworkGraph_add_channel_from_partial_announcement(
      this_arg,
      short_channel_id,
      timestamp,
      features,
      node_id_1,
      node_id_2,
    );
  }

  late final _NetworkGraph_add_channel_from_partial_announcementPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKNetworkGraph>,
                  ffi.Uint64,
                  ffi.Uint64,
                  LDKChannelFeatures,
                  LDKPublicKey,
                  LDKPublicKey)>>(
      'NetworkGraph_add_channel_from_partial_announcement');
  late final _NetworkGraph_add_channel_from_partial_announcement =
      _NetworkGraph_add_channel_from_partial_announcementPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              int, int, LDKChannelFeatures, LDKPublicKey, LDKPublicKey)>();

  /// Marks a channel in the graph as failed if a corresponding HTLC fail was sent.
  /// If permanent, removes a channel from the local storage.
  /// May cause the removal of nodes too, if this was their last channel.
  /// If not permanent, makes channels unavailable for routing.
  void NetworkGraph_channel_failed(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    int short_channel_id,
    bool is_permanent,
  ) {
    return _NetworkGraph_channel_failed(
      this_arg,
      short_channel_id,
      is_permanent,
    );
  }

  late final _NetworkGraph_channel_failedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNetworkGraph>, ffi.Uint64,
              ffi.Bool)>>('NetworkGraph_channel_failed');
  late final _NetworkGraph_channel_failed = _NetworkGraph_channel_failedPtr
      .asFunction<void Function(ffi.Pointer<LDKNetworkGraph>, int, bool)>();

  /// Marks a node in the graph as failed.
  void NetworkGraph_node_failed(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    LDKPublicKey _node_id,
    bool is_permanent,
  ) {
    return _NetworkGraph_node_failed(
      this_arg,
      _node_id,
      is_permanent,
    );
  }

  late final _NetworkGraph_node_failedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNetworkGraph>, LDKPublicKey,
              ffi.Bool)>>('NetworkGraph_node_failed');
  late final _NetworkGraph_node_failed =
      _NetworkGraph_node_failedPtr.asFunction<
          void Function(ffi.Pointer<LDKNetworkGraph>, LDKPublicKey, bool)>();

  /// Removes information about channels that we haven't heard any updates about in some time.
  /// This can be used regularly to prune the network graph of channels that likely no longer
  /// exist.
  ///
  /// While there is no formal requirement that nodes regularly re-broadcast their channel
  /// updates every two weeks, the non-normative section of BOLT 7 currently suggests that
  /// pruning occur for updates which are at least two weeks old, which we implement here.
  ///
  /// Note that for users of the `lightning-background-processor` crate this method may be
  /// automatically called regularly for you.
  ///
  /// This method is only available with the `std` feature. See
  /// [`NetworkGraph::remove_stale_channels_with_time`] for `no-std` use.
  void NetworkGraph_remove_stale_channels(
    ffi.Pointer<LDKNetworkGraph> this_arg,
  ) {
    return _NetworkGraph_remove_stale_channels(
      this_arg,
    );
  }

  late final _NetworkGraph_remove_stale_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKNetworkGraph>)>>(
      'NetworkGraph_remove_stale_channels');
  late final _NetworkGraph_remove_stale_channels =
      _NetworkGraph_remove_stale_channelsPtr.asFunction<
          void Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// Removes information about channels that we haven't heard any updates about in some time.
  /// This can be used regularly to prune the network graph of channels that likely no longer
  /// exist.
  ///
  /// While there is no formal requirement that nodes regularly re-broadcast their channel
  /// updates every two weeks, the non-normative section of BOLT 7 currently suggests that
  /// pruning occur for updates which are at least two weeks old, which we implement here.
  ///
  /// This function takes the current unix time as an argument. For users with the `std` feature
  /// enabled, [`NetworkGraph::remove_stale_channels`] may be preferable.
  void NetworkGraph_remove_stale_channels_with_time(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    int current_time_unix,
  ) {
    return _NetworkGraph_remove_stale_channels_with_time(
      this_arg,
      current_time_unix,
    );
  }

  late final _NetworkGraph_remove_stale_channels_with_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Uint64)>>('NetworkGraph_remove_stale_channels_with_time');
  late final _NetworkGraph_remove_stale_channels_with_time =
      _NetworkGraph_remove_stale_channels_with_timePtr.asFunction<
          void Function(ffi.Pointer<LDKNetworkGraph>, int)>();

  /// For an already known (from announcement) channel, update info about one of the directions
  /// of the channel.
  ///
  /// You probably don't want to call this directly, instead relying on a P2PGossipSync's
  /// RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
  /// routing messages from a source using a protocol other than the lightning P2P protocol.
  ///
  /// If built with `no-std`, any updates with a timestamp more than two weeks in the past or
  /// materially in the future will be rejected.
  LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKChannelUpdate> msg,
  ) {
    return _NetworkGraph_update_channel(
      this_arg,
      msg,
    );
  }

  late final _NetworkGraph_update_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKChannelUpdate>)>>('NetworkGraph_update_channel');
  late final _NetworkGraph_update_channel =
      _NetworkGraph_update_channelPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(
              ffi.Pointer<LDKNetworkGraph>, ffi.Pointer<LDKChannelUpdate>)>();

  /// For an already known (from announcement) channel, update info about one of the directions
  /// of the channel without verifying the associated signatures. Because we aren't given the
  /// associated signatures here we cannot relay the channel update to any of our peers.
  ///
  /// If built with `no-std`, any updates with a timestamp more than two weeks in the past or
  /// materially in the future will be rejected.
  LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(
    ffi.Pointer<LDKNetworkGraph> this_arg,
    ffi.Pointer<LDKUnsignedChannelUpdate> msg,
  ) {
    return _NetworkGraph_update_channel_unsigned(
      this_arg,
      msg,
    );
  }

  late final _NetworkGraph_update_channel_unsignedPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<LDKNetworkGraph>,
                  ffi.Pointer<LDKUnsignedChannelUpdate>)>>(
      'NetworkGraph_update_channel_unsigned');
  late final _NetworkGraph_update_channel_unsigned =
      _NetworkGraph_update_channel_unsignedPtr.asFunction<
          LDKCResult_NoneLightningErrorZ Function(ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKUnsignedChannelUpdate>)>();

  /// Returns information on a channel with the given id.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKChannelInfo ReadOnlyNetworkGraph_channel(
    ffi.Pointer<LDKReadOnlyNetworkGraph> this_arg,
    int short_channel_id,
  ) {
    return _ReadOnlyNetworkGraph_channel(
      this_arg,
      short_channel_id,
    );
  }

  late final _ReadOnlyNetworkGraph_channelPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelInfo Function(ffi.Pointer<LDKReadOnlyNetworkGraph>,
              ffi.Uint64)>>('ReadOnlyNetworkGraph_channel');
  late final _ReadOnlyNetworkGraph_channel =
      _ReadOnlyNetworkGraph_channelPtr.asFunction<
          LDKChannelInfo Function(ffi.Pointer<LDKReadOnlyNetworkGraph>, int)>();

  /// Returns the list of channels in the graph
  LDKCVec_u64Z ReadOnlyNetworkGraph_list_channels(
    ffi.Pointer<LDKReadOnlyNetworkGraph> this_arg,
  ) {
    return _ReadOnlyNetworkGraph_list_channels(
      this_arg,
    );
  }

  late final _ReadOnlyNetworkGraph_list_channelsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u64Z Function(ffi.Pointer<LDKReadOnlyNetworkGraph>)>>(
      'ReadOnlyNetworkGraph_list_channels');
  late final _ReadOnlyNetworkGraph_list_channels =
      _ReadOnlyNetworkGraph_list_channelsPtr.asFunction<
          LDKCVec_u64Z Function(ffi.Pointer<LDKReadOnlyNetworkGraph>)>();

  /// Returns information on a node with the given id.
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKNodeInfo ReadOnlyNetworkGraph_node(
    ffi.Pointer<LDKReadOnlyNetworkGraph> this_arg,
    ffi.Pointer<LDKNodeId> node_id,
  ) {
    return _ReadOnlyNetworkGraph_node(
      this_arg,
      node_id,
    );
  }

  late final _ReadOnlyNetworkGraph_nodePtr = _lookup<
      ffi.NativeFunction<
          LDKNodeInfo Function(ffi.Pointer<LDKReadOnlyNetworkGraph>,
              ffi.Pointer<LDKNodeId>)>>('ReadOnlyNetworkGraph_node');
  late final _ReadOnlyNetworkGraph_node =
      _ReadOnlyNetworkGraph_nodePtr.asFunction<
          LDKNodeInfo Function(
              ffi.Pointer<LDKReadOnlyNetworkGraph>, ffi.Pointer<LDKNodeId>)>();

  /// Returns the list of nodes in the graph
  LDKCVec_NodeIdZ ReadOnlyNetworkGraph_list_nodes(
    ffi.Pointer<LDKReadOnlyNetworkGraph> this_arg,
  ) {
    return _ReadOnlyNetworkGraph_list_nodes(
      this_arg,
    );
  }

  late final _ReadOnlyNetworkGraph_list_nodesPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_NodeIdZ Function(ffi.Pointer<LDKReadOnlyNetworkGraph>)>>(
      'ReadOnlyNetworkGraph_list_nodes');
  late final _ReadOnlyNetworkGraph_list_nodes =
      _ReadOnlyNetworkGraph_list_nodesPtr.asFunction<
          LDKCVec_NodeIdZ Function(ffi.Pointer<LDKReadOnlyNetworkGraph>)>();

  /// Get network addresses by node id.
  /// Returns None if the requested node is completely unknown,
  /// or if node announcement for the node was never received.
  LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(
    ffi.Pointer<LDKReadOnlyNetworkGraph> this_arg,
    LDKPublicKey pubkey,
  ) {
    return _ReadOnlyNetworkGraph_get_addresses(
      this_arg,
      pubkey,
    );
  }

  late final _ReadOnlyNetworkGraph_get_addressesPtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_CVec_NetAddressZZ Function(
              ffi.Pointer<LDKReadOnlyNetworkGraph>,
              LDKPublicKey)>>('ReadOnlyNetworkGraph_get_addresses');
  late final _ReadOnlyNetworkGraph_get_addresses =
      _ReadOnlyNetworkGraph_get_addressesPtr.asFunction<
          LDKCOption_CVec_NetAddressZZ Function(
              ffi.Pointer<LDKReadOnlyNetworkGraph>, LDKPublicKey)>();

  /// Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
  void RouteHop_free(
    LDKRouteHop this_obj,
  ) {
    return _RouteHop_free(
      this_obj,
    );
  }

  late final _RouteHop_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRouteHop)>>(
          'RouteHop_free');
  late final _RouteHop_free =
      _RouteHop_freePtr.asFunction<void Function(LDKRouteHop)>();

  /// The node_id of the node at this hop.
  LDKPublicKey RouteHop_get_pubkey(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_pubkey(
      this_ptr,
    );
  }

  late final _RouteHop_get_pubkeyPtr = _lookup<
          ffi.NativeFunction<LDKPublicKey Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_get_pubkey');
  late final _RouteHop_get_pubkey = _RouteHop_get_pubkeyPtr.asFunction<
      LDKPublicKey Function(ffi.Pointer<LDKRouteHop>)>();

  /// The node_id of the node at this hop.
  void RouteHop_set_pubkey(
    ffi.Pointer<LDKRouteHop> this_ptr,
    LDKPublicKey val,
  ) {
    return _RouteHop_set_pubkey(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRouteHop>, LDKPublicKey)>>('RouteHop_set_pubkey');
  late final _RouteHop_set_pubkey = _RouteHop_set_pubkeyPtr.asFunction<
      void Function(ffi.Pointer<LDKRouteHop>, LDKPublicKey)>();

  /// The node_announcement features of the node at this hop. For the last hop, these may be
  /// amended to match the features present in the invoice this node generated.
  LDKNodeFeatures RouteHop_get_node_features(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_node_features(
      this_ptr,
    );
  }

  late final _RouteHop_get_node_featuresPtr = _lookup<
      ffi.NativeFunction<
          LDKNodeFeatures Function(
              ffi.Pointer<LDKRouteHop>)>>('RouteHop_get_node_features');
  late final _RouteHop_get_node_features = _RouteHop_get_node_featuresPtr
      .asFunction<LDKNodeFeatures Function(ffi.Pointer<LDKRouteHop>)>();

  /// The node_announcement features of the node at this hop. For the last hop, these may be
  /// amended to match the features present in the invoice this node generated.
  void RouteHop_set_node_features(
    ffi.Pointer<LDKRouteHop> this_ptr,
    LDKNodeFeatures val,
  ) {
    return _RouteHop_set_node_features(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_node_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHop>,
              LDKNodeFeatures)>>('RouteHop_set_node_features');
  late final _RouteHop_set_node_features = _RouteHop_set_node_featuresPtr
      .asFunction<void Function(ffi.Pointer<LDKRouteHop>, LDKNodeFeatures)>();

  /// The channel that should be used from the previous hop to reach this node.
  int RouteHop_get_short_channel_id(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_short_channel_id(
      this_ptr,
    );
  }

  late final _RouteHop_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_get_short_channel_id');
  late final _RouteHop_get_short_channel_id = _RouteHop_get_short_channel_idPtr
      .asFunction<int Function(ffi.Pointer<LDKRouteHop>)>();

  /// The channel that should be used from the previous hop to reach this node.
  void RouteHop_set_short_channel_id(
    ffi.Pointer<LDKRouteHop> this_ptr,
    int val,
  ) {
    return _RouteHop_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHop>,
              ffi.Uint64)>>('RouteHop_set_short_channel_id');
  late final _RouteHop_set_short_channel_id = _RouteHop_set_short_channel_idPtr
      .asFunction<void Function(ffi.Pointer<LDKRouteHop>, int)>();

  /// The channel_announcement features of the channel that should be used from the previous hop
  /// to reach this node.
  LDKChannelFeatures RouteHop_get_channel_features(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_channel_features(
      this_ptr,
    );
  }

  late final _RouteHop_get_channel_featuresPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelFeatures Function(
              ffi.Pointer<LDKRouteHop>)>>('RouteHop_get_channel_features');
  late final _RouteHop_get_channel_features = _RouteHop_get_channel_featuresPtr
      .asFunction<LDKChannelFeatures Function(ffi.Pointer<LDKRouteHop>)>();

  /// The channel_announcement features of the channel that should be used from the previous hop
  /// to reach this node.
  void RouteHop_set_channel_features(
    ffi.Pointer<LDKRouteHop> this_ptr,
    LDKChannelFeatures val,
  ) {
    return _RouteHop_set_channel_features(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_channel_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHop>,
              LDKChannelFeatures)>>('RouteHop_set_channel_features');
  late final _RouteHop_set_channel_features =
      _RouteHop_set_channel_featuresPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHop>, LDKChannelFeatures)>();

  /// The fee taken on this hop (for paying for the use of the *next* channel in the path).
  /// For the last hop, this should be the full value of the payment (might be more than
  /// requested if we had to match htlc_minimum_msat).
  int RouteHop_get_fee_msat(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_fee_msat(
      this_ptr,
    );
  }

  late final _RouteHop_get_fee_msatPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_get_fee_msat');
  late final _RouteHop_get_fee_msat = _RouteHop_get_fee_msatPtr.asFunction<
      int Function(ffi.Pointer<LDKRouteHop>)>();

  /// The fee taken on this hop (for paying for the use of the *next* channel in the path).
  /// For the last hop, this should be the full value of the payment (might be more than
  /// requested if we had to match htlc_minimum_msat).
  void RouteHop_set_fee_msat(
    ffi.Pointer<LDKRouteHop> this_ptr,
    int val,
  ) {
    return _RouteHop_set_fee_msat(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_fee_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKRouteHop>, ffi.Uint64)>>('RouteHop_set_fee_msat');
  late final _RouteHop_set_fee_msat = _RouteHop_set_fee_msatPtr.asFunction<
      void Function(ffi.Pointer<LDKRouteHop>, int)>();

  /// The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
  /// expected at the destination, in excess of the current block height.
  int RouteHop_get_cltv_expiry_delta(
    ffi.Pointer<LDKRouteHop> this_ptr,
  ) {
    return _RouteHop_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _RouteHop_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_get_cltv_expiry_delta');
  late final _RouteHop_get_cltv_expiry_delta =
      _RouteHop_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKRouteHop>)>();

  /// The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
  /// expected at the destination, in excess of the current block height.
  void RouteHop_set_cltv_expiry_delta(
    ffi.Pointer<LDKRouteHop> this_ptr,
    int val,
  ) {
    return _RouteHop_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _RouteHop_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHop>,
              ffi.Uint32)>>('RouteHop_set_cltv_expiry_delta');
  late final _RouteHop_set_cltv_expiry_delta =
      _RouteHop_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHop>, int)>();

  /// Constructs a new RouteHop given each field
  LDKRouteHop RouteHop_new(
    LDKPublicKey pubkey_arg,
    LDKNodeFeatures node_features_arg,
    int short_channel_id_arg,
    LDKChannelFeatures channel_features_arg,
    int fee_msat_arg,
    int cltv_expiry_delta_arg,
  ) {
    return _RouteHop_new(
      pubkey_arg,
      node_features_arg,
      short_channel_id_arg,
      channel_features_arg,
      fee_msat_arg,
      cltv_expiry_delta_arg,
    );
  }

  late final _RouteHop_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRouteHop Function(LDKPublicKey, LDKNodeFeatures, ffi.Uint64,
              LDKChannelFeatures, ffi.Uint64, ffi.Uint32)>>('RouteHop_new');
  late final _RouteHop_new = _RouteHop_newPtr.asFunction<
      LDKRouteHop Function(
          LDKPublicKey, LDKNodeFeatures, int, LDKChannelFeatures, int, int)>();

  /// Creates a copy of the RouteHop
  LDKRouteHop RouteHop_clone(
    ffi.Pointer<LDKRouteHop> orig,
  ) {
    return _RouteHop_clone(
      orig,
    );
  }

  late final _RouteHop_clonePtr = _lookup<
          ffi.NativeFunction<LDKRouteHop Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_clone');
  late final _RouteHop_clone = _RouteHop_clonePtr.asFunction<
      LDKRouteHop Function(ffi.Pointer<LDKRouteHop>)>();

  /// Checks if two RouteHops contain equal inner contents.
  int RouteHop_hash(
    ffi.Pointer<LDKRouteHop> o,
  ) {
    return _RouteHop_hash(
      o,
    );
  }

  late final _RouteHop_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_hash');
  late final _RouteHop_hash =
      _RouteHop_hashPtr.asFunction<int Function(ffi.Pointer<LDKRouteHop>)>();

  /// Checks if two RouteHops contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RouteHop_eq(
    ffi.Pointer<LDKRouteHop> a,
    ffi.Pointer<LDKRouteHop> b,
  ) {
    return _RouteHop_eq(
      a,
      b,
    );
  }

  late final _RouteHop_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRouteHop>,
              ffi.Pointer<LDKRouteHop>)>>('RouteHop_eq');
  late final _RouteHop_eq = _RouteHop_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKRouteHop>, ffi.Pointer<LDKRouteHop>)>();

  /// Serialize the RouteHop object into a byte array which can be read by RouteHop_read
  LDKCVec_u8Z RouteHop_write(
    ffi.Pointer<LDKRouteHop> obj,
  ) {
    return _RouteHop_write(
      obj,
    );
  }

  late final _RouteHop_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKRouteHop>)>>(
      'RouteHop_write');
  late final _RouteHop_write = _RouteHop_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRouteHop>)>();

  /// Read a RouteHop from a byte array, created by RouteHop_write
  LDKCResult_RouteHopDecodeErrorZ RouteHop_read(
    LDKu8slice ser,
  ) {
    return _RouteHop_read(
      ser,
    );
  }

  late final _RouteHop_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHopDecodeErrorZ Function(
              LDKu8slice)>>('RouteHop_read');
  late final _RouteHop_read = _RouteHop_readPtr.asFunction<
      LDKCResult_RouteHopDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
  void Route_free(
    LDKRoute this_obj,
  ) {
    return _Route_free(
      this_obj,
    );
  }

  late final _Route_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRoute)>>('Route_free');
  late final _Route_free = _Route_freePtr.asFunction<void Function(LDKRoute)>();

  /// The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
  /// last RouteHop in each path must be the same. Each entry represents a list of hops, NOT
  /// INCLUDING our own, where the last hop is the destination. Thus, this must always be at
  /// least length one. While the maximum length of any given path is variable, keeping the length
  /// of any path less or equal to 19 should currently ensure it is viable.
  LDKCVec_CVec_RouteHopZZ Route_get_paths(
    ffi.Pointer<LDKRoute> this_ptr,
  ) {
    return _Route_get_paths(
      this_ptr,
    );
  }

  late final _Route_get_pathsPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_CVec_RouteHopZZ Function(
              ffi.Pointer<LDKRoute>)>>('Route_get_paths');
  late final _Route_get_paths = _Route_get_pathsPtr.asFunction<
      LDKCVec_CVec_RouteHopZZ Function(ffi.Pointer<LDKRoute>)>();

  /// The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
  /// last RouteHop in each path must be the same. Each entry represents a list of hops, NOT
  /// INCLUDING our own, where the last hop is the destination. Thus, this must always be at
  /// least length one. While the maximum length of any given path is variable, keeping the length
  /// of any path less or equal to 19 should currently ensure it is viable.
  void Route_set_paths(
    ffi.Pointer<LDKRoute> this_ptr,
    LDKCVec_CVec_RouteHopZZ val,
  ) {
    return _Route_set_paths(
      this_ptr,
      val,
    );
  }

  late final _Route_set_pathsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRoute>,
              LDKCVec_CVec_RouteHopZZ)>>('Route_set_paths');
  late final _Route_set_paths = _Route_set_pathsPtr.asFunction<
      void Function(ffi.Pointer<LDKRoute>, LDKCVec_CVec_RouteHopZZ)>();

  /// The `payment_params` parameter passed to [`find_route`].
  /// This is used by `ChannelManager` to track information which may be required for retries,
  /// provided back to you via [`Event::PaymentPathFailed`].
  ///
  /// [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKPaymentParameters Route_get_payment_params(
    ffi.Pointer<LDKRoute> this_ptr,
  ) {
    return _Route_get_payment_params(
      this_ptr,
    );
  }

  late final _Route_get_payment_paramsPtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentParameters Function(
              ffi.Pointer<LDKRoute>)>>('Route_get_payment_params');
  late final _Route_get_payment_params = _Route_get_payment_paramsPtr
      .asFunction<LDKPaymentParameters Function(ffi.Pointer<LDKRoute>)>();

  /// The `payment_params` parameter passed to [`find_route`].
  /// This is used by `ChannelManager` to track information which may be required for retries,
  /// provided back to you via [`Event::PaymentPathFailed`].
  ///
  /// [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void Route_set_payment_params(
    ffi.Pointer<LDKRoute> this_ptr,
    LDKPaymentParameters val,
  ) {
    return _Route_set_payment_params(
      this_ptr,
      val,
    );
  }

  late final _Route_set_payment_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRoute>,
              LDKPaymentParameters)>>('Route_set_payment_params');
  late final _Route_set_payment_params = _Route_set_payment_paramsPtr
      .asFunction<void Function(ffi.Pointer<LDKRoute>, LDKPaymentParameters)>();

  /// Constructs a new Route given each field
  LDKRoute Route_new(
    LDKCVec_CVec_RouteHopZZ paths_arg,
    LDKPaymentParameters payment_params_arg,
  ) {
    return _Route_new(
      paths_arg,
      payment_params_arg,
    );
  }

  late final _Route_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRoute Function(
              LDKCVec_CVec_RouteHopZZ, LDKPaymentParameters)>>('Route_new');
  late final _Route_new = _Route_newPtr.asFunction<
      LDKRoute Function(LDKCVec_CVec_RouteHopZZ, LDKPaymentParameters)>();

  /// Creates a copy of the Route
  LDKRoute Route_clone(
    ffi.Pointer<LDKRoute> orig,
  ) {
    return _Route_clone(
      orig,
    );
  }

  late final _Route_clonePtr =
      _lookup<ffi.NativeFunction<LDKRoute Function(ffi.Pointer<LDKRoute>)>>(
          'Route_clone');
  late final _Route_clone =
      _Route_clonePtr.asFunction<LDKRoute Function(ffi.Pointer<LDKRoute>)>();

  /// Checks if two Routes contain equal inner contents.
  int Route_hash(
    ffi.Pointer<LDKRoute> o,
  ) {
    return _Route_hash(
      o,
    );
  }

  late final _Route_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRoute>)>>(
          'Route_hash');
  late final _Route_hash =
      _Route_hashPtr.asFunction<int Function(ffi.Pointer<LDKRoute>)>();

  /// Checks if two Routes contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool Route_eq(
    ffi.Pointer<LDKRoute> a,
    ffi.Pointer<LDKRoute> b,
  ) {
    return _Route_eq(
      a,
      b,
    );
  }

  late final _Route_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKRoute>, ffi.Pointer<LDKRoute>)>>('Route_eq');
  late final _Route_eq = _Route_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKRoute>, ffi.Pointer<LDKRoute>)>();

  /// Returns the total amount of fees paid on this [`Route`].
  ///
  /// This doesn't include any extra payment made to the recipient, which can happen in excess of
  /// the amount passed to [`find_route`]'s `params.final_value_msat`.
  int Route_get_total_fees(
    ffi.Pointer<LDKRoute> this_arg,
  ) {
    return _Route_get_total_fees(
      this_arg,
    );
  }

  late final _Route_get_total_feesPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRoute>)>>(
          'Route_get_total_fees');
  late final _Route_get_total_fees = _Route_get_total_feesPtr.asFunction<
      int Function(ffi.Pointer<LDKRoute>)>();

  /// Returns the total amount paid on this [`Route`], excluding the fees.
  int Route_get_total_amount(
    ffi.Pointer<LDKRoute> this_arg,
  ) {
    return _Route_get_total_amount(
      this_arg,
    );
  }

  late final _Route_get_total_amountPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRoute>)>>(
          'Route_get_total_amount');
  late final _Route_get_total_amount = _Route_get_total_amountPtr.asFunction<
      int Function(ffi.Pointer<LDKRoute>)>();

  /// Serialize the Route object into a byte array which can be read by Route_read
  LDKCVec_u8Z Route_write(
    ffi.Pointer<LDKRoute> obj,
  ) {
    return _Route_write(
      obj,
    );
  }

  late final _Route_writePtr =
      _lookup<ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKRoute>)>>(
          'Route_write');
  late final _Route_write =
      _Route_writePtr.asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKRoute>)>();

  /// Read a Route from a byte array, created by Route_write
  LDKCResult_RouteDecodeErrorZ Route_read(
    LDKu8slice ser,
  ) {
    return _Route_read(
      ser,
    );
  }

  late final _Route_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteDecodeErrorZ Function(LDKu8slice)>>('Route_read');
  late final _Route_read = _Route_readPtr.asFunction<
      LDKCResult_RouteDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the RouteParameters, if is_owned is set and inner is non-NULL.
  void RouteParameters_free(
    LDKRouteParameters this_obj,
  ) {
    return _RouteParameters_free(
      this_obj,
    );
  }

  late final _RouteParameters_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRouteParameters)>>(
          'RouteParameters_free');
  late final _RouteParameters_free =
      _RouteParameters_freePtr.asFunction<void Function(LDKRouteParameters)>();

  /// The parameters of the failed payment path.
  LDKPaymentParameters RouteParameters_get_payment_params(
    ffi.Pointer<LDKRouteParameters> this_ptr,
  ) {
    return _RouteParameters_get_payment_params(
      this_ptr,
    );
  }

  late final _RouteParameters_get_payment_paramsPtr = _lookup<
          ffi.NativeFunction<
              LDKPaymentParameters Function(ffi.Pointer<LDKRouteParameters>)>>(
      'RouteParameters_get_payment_params');
  late final _RouteParameters_get_payment_params =
      _RouteParameters_get_payment_paramsPtr.asFunction<
          LDKPaymentParameters Function(ffi.Pointer<LDKRouteParameters>)>();

  /// The parameters of the failed payment path.
  void RouteParameters_set_payment_params(
    ffi.Pointer<LDKRouteParameters> this_ptr,
    LDKPaymentParameters val,
  ) {
    return _RouteParameters_set_payment_params(
      this_ptr,
      val,
    );
  }

  late final _RouteParameters_set_payment_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteParameters>,
              LDKPaymentParameters)>>('RouteParameters_set_payment_params');
  late final _RouteParameters_set_payment_params =
      _RouteParameters_set_payment_paramsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKRouteParameters>, LDKPaymentParameters)>();

  /// The amount in msats sent on the failed payment path.
  int RouteParameters_get_final_value_msat(
    ffi.Pointer<LDKRouteParameters> this_ptr,
  ) {
    return _RouteParameters_get_final_value_msat(
      this_ptr,
    );
  }

  late final _RouteParameters_get_final_value_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKRouteParameters>)>>(
      'RouteParameters_get_final_value_msat');
  late final _RouteParameters_get_final_value_msat =
      _RouteParameters_get_final_value_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKRouteParameters>)>();

  /// The amount in msats sent on the failed payment path.
  void RouteParameters_set_final_value_msat(
    ffi.Pointer<LDKRouteParameters> this_ptr,
    int val,
  ) {
    return _RouteParameters_set_final_value_msat(
      this_ptr,
      val,
    );
  }

  late final _RouteParameters_set_final_value_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteParameters>,
              ffi.Uint64)>>('RouteParameters_set_final_value_msat');
  late final _RouteParameters_set_final_value_msat =
      _RouteParameters_set_final_value_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteParameters>, int)>();

  /// The CLTV on the final hop of the failed payment path.
  int RouteParameters_get_final_cltv_expiry_delta(
    ffi.Pointer<LDKRouteParameters> this_ptr,
  ) {
    return _RouteParameters_get_final_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _RouteParameters_get_final_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKRouteParameters>)>>(
      'RouteParameters_get_final_cltv_expiry_delta');
  late final _RouteParameters_get_final_cltv_expiry_delta =
      _RouteParameters_get_final_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKRouteParameters>)>();

  /// The CLTV on the final hop of the failed payment path.
  void RouteParameters_set_final_cltv_expiry_delta(
    ffi.Pointer<LDKRouteParameters> this_ptr,
    int val,
  ) {
    return _RouteParameters_set_final_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _RouteParameters_set_final_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteParameters>,
              ffi.Uint32)>>('RouteParameters_set_final_cltv_expiry_delta');
  late final _RouteParameters_set_final_cltv_expiry_delta =
      _RouteParameters_set_final_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteParameters>, int)>();

  /// Constructs a new RouteParameters given each field
  LDKRouteParameters RouteParameters_new(
    LDKPaymentParameters payment_params_arg,
    int final_value_msat_arg,
    int final_cltv_expiry_delta_arg,
  ) {
    return _RouteParameters_new(
      payment_params_arg,
      final_value_msat_arg,
      final_cltv_expiry_delta_arg,
    );
  }

  late final _RouteParameters_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRouteParameters Function(LDKPaymentParameters, ffi.Uint64,
              ffi.Uint32)>>('RouteParameters_new');
  late final _RouteParameters_new = _RouteParameters_newPtr.asFunction<
      LDKRouteParameters Function(LDKPaymentParameters, int, int)>();

  /// Creates a copy of the RouteParameters
  LDKRouteParameters RouteParameters_clone(
    ffi.Pointer<LDKRouteParameters> orig,
  ) {
    return _RouteParameters_clone(
      orig,
    );
  }

  late final _RouteParameters_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRouteParameters Function(
              ffi.Pointer<LDKRouteParameters>)>>('RouteParameters_clone');
  late final _RouteParameters_clone = _RouteParameters_clonePtr.asFunction<
      LDKRouteParameters Function(ffi.Pointer<LDKRouteParameters>)>();

  /// Serialize the RouteParameters object into a byte array which can be read by RouteParameters_read
  LDKCVec_u8Z RouteParameters_write(
    ffi.Pointer<LDKRouteParameters> obj,
  ) {
    return _RouteParameters_write(
      obj,
    );
  }

  late final _RouteParameters_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKRouteParameters>)>>('RouteParameters_write');
  late final _RouteParameters_write = _RouteParameters_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRouteParameters>)>();

  /// Read a RouteParameters from a byte array, created by RouteParameters_write
  LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(
    LDKu8slice ser,
  ) {
    return _RouteParameters_read(
      ser,
    );
  }

  late final _RouteParameters_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteParametersDecodeErrorZ Function(
              LDKu8slice)>>('RouteParameters_read');
  late final _RouteParameters_read = _RouteParameters_readPtr.asFunction<
      LDKCResult_RouteParametersDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the PaymentParameters, if is_owned is set and inner is non-NULL.
  void PaymentParameters_free(
    LDKPaymentParameters this_obj,
  ) {
    return _PaymentParameters_free(
      this_obj,
    );
  }

  late final _PaymentParameters_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPaymentParameters)>>(
          'PaymentParameters_free');
  late final _PaymentParameters_free = _PaymentParameters_freePtr.asFunction<
      void Function(LDKPaymentParameters)>();

  /// The node id of the payee.
  LDKPublicKey PaymentParameters_get_payee_pubkey(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_payee_pubkey(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_payee_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_payee_pubkey');
  late final _PaymentParameters_get_payee_pubkey =
      _PaymentParameters_get_payee_pubkeyPtr.asFunction<
          LDKPublicKey Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// The node id of the payee.
  void PaymentParameters_set_payee_pubkey(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    LDKPublicKey val,
  ) {
    return _PaymentParameters_set_payee_pubkey(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_payee_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPaymentParameters>,
              LDKPublicKey)>>('PaymentParameters_set_payee_pubkey');
  late final _PaymentParameters_set_payee_pubkey =
      _PaymentParameters_set_payee_pubkeyPtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, LDKPublicKey)>();

  /// Features supported by the payee.
  ///
  /// May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
  /// does not contain any features.
  ///
  /// [`for_keysend`]: Self::for_keysend
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKInvoiceFeatures PaymentParameters_get_features(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_features(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_featuresPtr = _lookup<
          ffi.NativeFunction<
              LDKInvoiceFeatures Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_features');
  late final _PaymentParameters_get_features =
      _PaymentParameters_get_featuresPtr.asFunction<
          LDKInvoiceFeatures Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Features supported by the payee.
  ///
  /// May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
  /// does not contain any features.
  ///
  /// [`for_keysend`]: Self::for_keysend
  ///
  /// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
  void PaymentParameters_set_features(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    LDKInvoiceFeatures val,
  ) {
    return _PaymentParameters_set_features(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_featuresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPaymentParameters>,
              LDKInvoiceFeatures)>>('PaymentParameters_set_features');
  late final _PaymentParameters_set_features =
      _PaymentParameters_set_featuresPtr.asFunction<
          void Function(
              ffi.Pointer<LDKPaymentParameters>, LDKInvoiceFeatures)>();

  /// Hints for routing to the payee, containing channels connecting the payee to public nodes.
  LDKCVec_RouteHintZ PaymentParameters_get_route_hints(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_route_hints(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_route_hintsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_RouteHintZ Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_route_hints');
  late final _PaymentParameters_get_route_hints =
      _PaymentParameters_get_route_hintsPtr.asFunction<
          LDKCVec_RouteHintZ Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Hints for routing to the payee, containing channels connecting the payee to public nodes.
  void PaymentParameters_set_route_hints(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    LDKCVec_RouteHintZ val,
  ) {
    return _PaymentParameters_set_route_hints(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_route_hintsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPaymentParameters>,
              LDKCVec_RouteHintZ)>>('PaymentParameters_set_route_hints');
  late final _PaymentParameters_set_route_hints =
      _PaymentParameters_set_route_hintsPtr.asFunction<
          void Function(
              ffi.Pointer<LDKPaymentParameters>, LDKCVec_RouteHintZ)>();

  /// Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
  LDKCOption_u64Z PaymentParameters_get_expiry_time(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_expiry_time(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_expiry_timePtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_expiry_time');
  late final _PaymentParameters_get_expiry_time =
      _PaymentParameters_get_expiry_timePtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
  void PaymentParameters_set_expiry_time(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _PaymentParameters_set_expiry_time(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_expiry_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPaymentParameters>,
              LDKCOption_u64Z)>>('PaymentParameters_set_expiry_time');
  late final _PaymentParameters_set_expiry_time =
      _PaymentParameters_set_expiry_timePtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, LDKCOption_u64Z)>();

  /// The maximum total CLTV delta we accept for the route.
  /// Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
  int PaymentParameters_get_max_total_cltv_expiry_delta(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_max_total_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_max_total_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_max_total_cltv_expiry_delta');
  late final _PaymentParameters_get_max_total_cltv_expiry_delta =
      _PaymentParameters_get_max_total_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// The maximum total CLTV delta we accept for the route.
  /// Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
  void PaymentParameters_set_max_total_cltv_expiry_delta(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    int val,
  ) {
    return _PaymentParameters_set_max_total_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_max_total_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKPaymentParameters>, ffi.Uint32)>>(
      'PaymentParameters_set_max_total_cltv_expiry_delta');
  late final _PaymentParameters_set_max_total_cltv_expiry_delta =
      _PaymentParameters_set_max_total_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, int)>();

  /// The maximum number of paths that may be used by (MPP) payments.
  /// Defaults to [`DEFAULT_MAX_PATH_COUNT`].
  int PaymentParameters_get_max_path_count(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_max_path_count(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_max_path_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_max_path_count');
  late final _PaymentParameters_get_max_path_count =
      _PaymentParameters_get_max_path_countPtr.asFunction<
          int Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// The maximum number of paths that may be used by (MPP) payments.
  /// Defaults to [`DEFAULT_MAX_PATH_COUNT`].
  void PaymentParameters_set_max_path_count(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    int val,
  ) {
    return _PaymentParameters_set_max_path_count(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_max_path_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKPaymentParameters>,
              ffi.Uint8)>>('PaymentParameters_set_max_path_count');
  late final _PaymentParameters_set_max_path_count =
      _PaymentParameters_set_max_path_countPtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, int)>();

  /// Selects the maximum share of a channel's total capacity which will be sent over a channel,
  /// as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
  /// a lower value prefers to send larger MPP parts, potentially saturating channels and
  /// increasing failure probability for those paths.
  ///
  /// Note that this restriction will be relaxed during pathfinding after paths which meet this
  /// restriction have been found. While paths which meet this criteria will be searched for, it
  /// is ultimately up to the scorer to select them over other paths.
  ///
  /// A value of 0 will allow payments up to and including a channel's total announced usable
  /// capacity, a value of one will only use up to half its capacity, two 1/4, etc.
  ///
  /// Default value: 2
  int PaymentParameters_get_max_channel_saturation_power_of_half(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_max_channel_saturation_power_of_half(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_max_channel_saturation_power_of_halfPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<LDKPaymentParameters>)>>(
          'PaymentParameters_get_max_channel_saturation_power_of_half');
  late final _PaymentParameters_get_max_channel_saturation_power_of_half =
      _PaymentParameters_get_max_channel_saturation_power_of_halfPtr.asFunction<
          int Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Selects the maximum share of a channel's total capacity which will be sent over a channel,
  /// as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
  /// a lower value prefers to send larger MPP parts, potentially saturating channels and
  /// increasing failure probability for those paths.
  ///
  /// Note that this restriction will be relaxed during pathfinding after paths which meet this
  /// restriction have been found. While paths which meet this criteria will be searched for, it
  /// is ultimately up to the scorer to select them over other paths.
  ///
  /// A value of 0 will allow payments up to and including a channel's total announced usable
  /// capacity, a value of one will only use up to half its capacity, two 1/4, etc.
  ///
  /// Default value: 2
  void PaymentParameters_set_max_channel_saturation_power_of_half(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    int val,
  ) {
    return _PaymentParameters_set_max_channel_saturation_power_of_half(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_max_channel_saturation_power_of_halfPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKPaymentParameters>, ffi.Uint8)>>(
          'PaymentParameters_set_max_channel_saturation_power_of_half');
  late final _PaymentParameters_set_max_channel_saturation_power_of_half =
      _PaymentParameters_set_max_channel_saturation_power_of_halfPtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, int)>();

  /// A list of SCIDs which this payment was previously attempted over and which caused the
  /// payment to fail. Future attempts for the same payment shouldn't be relayed through any of
  /// these SCIDs.
  ///
  /// Returns a copy of the field.
  LDKCVec_u64Z PaymentParameters_get_previously_failed_channels(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
  ) {
    return _PaymentParameters_get_previously_failed_channels(
      this_ptr,
    );
  }

  late final _PaymentParameters_get_previously_failed_channelsPtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u64Z Function(ffi.Pointer<LDKPaymentParameters>)>>(
      'PaymentParameters_get_previously_failed_channels');
  late final _PaymentParameters_get_previously_failed_channels =
      _PaymentParameters_get_previously_failed_channelsPtr.asFunction<
          LDKCVec_u64Z Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// A list of SCIDs which this payment was previously attempted over and which caused the
  /// payment to fail. Future attempts for the same payment shouldn't be relayed through any of
  /// these SCIDs.
  void PaymentParameters_set_previously_failed_channels(
    ffi.Pointer<LDKPaymentParameters> this_ptr,
    LDKCVec_u64Z val,
  ) {
    return _PaymentParameters_set_previously_failed_channels(
      this_ptr,
      val,
    );
  }

  late final _PaymentParameters_set_previously_failed_channelsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKPaymentParameters>, LDKCVec_u64Z)>>(
      'PaymentParameters_set_previously_failed_channels');
  late final _PaymentParameters_set_previously_failed_channels =
      _PaymentParameters_set_previously_failed_channelsPtr.asFunction<
          void Function(ffi.Pointer<LDKPaymentParameters>, LDKCVec_u64Z)>();

  /// Constructs a new PaymentParameters given each field
  LDKPaymentParameters PaymentParameters_new(
    LDKPublicKey payee_pubkey_arg,
    LDKInvoiceFeatures features_arg,
    LDKCVec_RouteHintZ route_hints_arg,
    LDKCOption_u64Z expiry_time_arg,
    int max_total_cltv_expiry_delta_arg,
    int max_path_count_arg,
    int max_channel_saturation_power_of_half_arg,
    LDKCVec_u64Z previously_failed_channels_arg,
  ) {
    return _PaymentParameters_new(
      payee_pubkey_arg,
      features_arg,
      route_hints_arg,
      expiry_time_arg,
      max_total_cltv_expiry_delta_arg,
      max_path_count_arg,
      max_channel_saturation_power_of_half_arg,
      previously_failed_channels_arg,
    );
  }

  late final _PaymentParameters_newPtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentParameters Function(
              LDKPublicKey,
              LDKInvoiceFeatures,
              LDKCVec_RouteHintZ,
              LDKCOption_u64Z,
              ffi.Uint32,
              ffi.Uint8,
              ffi.Uint8,
              LDKCVec_u64Z)>>('PaymentParameters_new');
  late final _PaymentParameters_new = _PaymentParameters_newPtr.asFunction<
      LDKPaymentParameters Function(LDKPublicKey, LDKInvoiceFeatures,
          LDKCVec_RouteHintZ, LDKCOption_u64Z, int, int, int, LDKCVec_u64Z)>();

  /// Creates a copy of the PaymentParameters
  LDKPaymentParameters PaymentParameters_clone(
    ffi.Pointer<LDKPaymentParameters> orig,
  ) {
    return _PaymentParameters_clone(
      orig,
    );
  }

  late final _PaymentParameters_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentParameters Function(
              ffi.Pointer<LDKPaymentParameters>)>>('PaymentParameters_clone');
  late final _PaymentParameters_clone = _PaymentParameters_clonePtr.asFunction<
      LDKPaymentParameters Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Checks if two PaymentParameterss contain equal inner contents.
  int PaymentParameters_hash(
    ffi.Pointer<LDKPaymentParameters> o,
  ) {
    return _PaymentParameters_hash(
      o,
    );
  }

  late final _PaymentParameters_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKPaymentParameters>)>>('PaymentParameters_hash');
  late final _PaymentParameters_hash = _PaymentParameters_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Checks if two PaymentParameterss contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool PaymentParameters_eq(
    ffi.Pointer<LDKPaymentParameters> a,
    ffi.Pointer<LDKPaymentParameters> b,
  ) {
    return _PaymentParameters_eq(
      a,
      b,
    );
  }

  late final _PaymentParameters_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKPaymentParameters>,
              ffi.Pointer<LDKPaymentParameters>)>>('PaymentParameters_eq');
  late final _PaymentParameters_eq = _PaymentParameters_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKPaymentParameters>,
          ffi.Pointer<LDKPaymentParameters>)>();

  /// Serialize the PaymentParameters object into a byte array which can be read by PaymentParameters_read
  LDKCVec_u8Z PaymentParameters_write(
    ffi.Pointer<LDKPaymentParameters> obj,
  ) {
    return _PaymentParameters_write(
      obj,
    );
  }

  late final _PaymentParameters_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKPaymentParameters>)>>('PaymentParameters_write');
  late final _PaymentParameters_write = _PaymentParameters_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKPaymentParameters>)>();

  /// Read a PaymentParameters from a byte array, created by PaymentParameters_write
  LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(
    LDKu8slice ser,
  ) {
    return _PaymentParameters_read(
      ser,
    );
  }

  late final _PaymentParameters_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentParametersDecodeErrorZ Function(
              LDKu8slice)>>('PaymentParameters_read');
  late final _PaymentParameters_read = _PaymentParameters_readPtr.asFunction<
      LDKCResult_PaymentParametersDecodeErrorZ Function(LDKu8slice)>();

  /// Creates a payee with the node id of the given `pubkey`.
  LDKPaymentParameters PaymentParameters_from_node_id(
    LDKPublicKey payee_pubkey,
  ) {
    return _PaymentParameters_from_node_id(
      payee_pubkey,
    );
  }

  late final _PaymentParameters_from_node_idPtr =
      _lookup<ffi.NativeFunction<LDKPaymentParameters Function(LDKPublicKey)>>(
          'PaymentParameters_from_node_id');
  late final _PaymentParameters_from_node_id =
      _PaymentParameters_from_node_idPtr.asFunction<
          LDKPaymentParameters Function(LDKPublicKey)>();

  /// Creates a payee with the node id of the given `pubkey` to use for keysend payments.
  LDKPaymentParameters PaymentParameters_for_keysend(
    LDKPublicKey payee_pubkey,
  ) {
    return _PaymentParameters_for_keysend(
      payee_pubkey,
    );
  }

  late final _PaymentParameters_for_keysendPtr =
      _lookup<ffi.NativeFunction<LDKPaymentParameters Function(LDKPublicKey)>>(
          'PaymentParameters_for_keysend');
  late final _PaymentParameters_for_keysend = _PaymentParameters_for_keysendPtr
      .asFunction<LDKPaymentParameters Function(LDKPublicKey)>();

  /// Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
  void RouteHint_free(
    LDKRouteHint this_obj,
  ) {
    return _RouteHint_free(
      this_obj,
    );
  }

  late final _RouteHint_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRouteHint)>>(
          'RouteHint_free');
  late final _RouteHint_free =
      _RouteHint_freePtr.asFunction<void Function(LDKRouteHint)>();

  LDKCVec_RouteHintHopZ RouteHint_get_a(
    ffi.Pointer<LDKRouteHint> this_ptr,
  ) {
    return _RouteHint_get_a(
      this_ptr,
    );
  }

  late final _RouteHint_get_aPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_RouteHintHopZ Function(
              ffi.Pointer<LDKRouteHint>)>>('RouteHint_get_a');
  late final _RouteHint_get_a = _RouteHint_get_aPtr.asFunction<
      LDKCVec_RouteHintHopZ Function(ffi.Pointer<LDKRouteHint>)>();

  void RouteHint_set_a(
    ffi.Pointer<LDKRouteHint> this_ptr,
    LDKCVec_RouteHintHopZ val,
  ) {
    return _RouteHint_set_a(
      this_ptr,
      val,
    );
  }

  late final _RouteHint_set_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHint>,
              LDKCVec_RouteHintHopZ)>>('RouteHint_set_a');
  late final _RouteHint_set_a = _RouteHint_set_aPtr.asFunction<
      void Function(ffi.Pointer<LDKRouteHint>, LDKCVec_RouteHintHopZ)>();

  /// Constructs a new RouteHint given each field
  LDKRouteHint RouteHint_new(
    LDKCVec_RouteHintHopZ a_arg,
  ) {
    return _RouteHint_new(
      a_arg,
    );
  }

  late final _RouteHint_newPtr =
      _lookup<ffi.NativeFunction<LDKRouteHint Function(LDKCVec_RouteHintHopZ)>>(
          'RouteHint_new');
  late final _RouteHint_new = _RouteHint_newPtr.asFunction<
      LDKRouteHint Function(LDKCVec_RouteHintHopZ)>();

  /// Creates a copy of the RouteHint
  LDKRouteHint RouteHint_clone(
    ffi.Pointer<LDKRouteHint> orig,
  ) {
    return _RouteHint_clone(
      orig,
    );
  }

  late final _RouteHint_clonePtr = _lookup<
          ffi.NativeFunction<LDKRouteHint Function(ffi.Pointer<LDKRouteHint>)>>(
      'RouteHint_clone');
  late final _RouteHint_clone = _RouteHint_clonePtr.asFunction<
      LDKRouteHint Function(ffi.Pointer<LDKRouteHint>)>();

  /// Checks if two RouteHints contain equal inner contents.
  int RouteHint_hash(
    ffi.Pointer<LDKRouteHint> o,
  ) {
    return _RouteHint_hash(
      o,
    );
  }

  late final _RouteHint_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRouteHint>)>>(
      'RouteHint_hash');
  late final _RouteHint_hash =
      _RouteHint_hashPtr.asFunction<int Function(ffi.Pointer<LDKRouteHint>)>();

  /// Checks if two RouteHints contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RouteHint_eq(
    ffi.Pointer<LDKRouteHint> a,
    ffi.Pointer<LDKRouteHint> b,
  ) {
    return _RouteHint_eq(
      a,
      b,
    );
  }

  late final _RouteHint_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRouteHint>,
              ffi.Pointer<LDKRouteHint>)>>('RouteHint_eq');
  late final _RouteHint_eq = _RouteHint_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKRouteHint>, ffi.Pointer<LDKRouteHint>)>();

  /// Serialize the RouteHint object into a byte array which can be read by RouteHint_read
  LDKCVec_u8Z RouteHint_write(
    ffi.Pointer<LDKRouteHint> obj,
  ) {
    return _RouteHint_write(
      obj,
    );
  }

  late final _RouteHint_writePtr = _lookup<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKRouteHint>)>>(
      'RouteHint_write');
  late final _RouteHint_write = _RouteHint_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRouteHint>)>();

  /// Read a RouteHint from a byte array, created by RouteHint_write
  LDKCResult_RouteHintDecodeErrorZ RouteHint_read(
    LDKu8slice ser,
  ) {
    return _RouteHint_read(
      ser,
    );
  }

  late final _RouteHint_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintDecodeErrorZ Function(
              LDKu8slice)>>('RouteHint_read');
  late final _RouteHint_read = _RouteHint_readPtr.asFunction<
      LDKCResult_RouteHintDecodeErrorZ Function(LDKu8slice)>();

  /// Frees any resources used by the RouteHintHop, if is_owned is set and inner is non-NULL.
  void RouteHintHop_free(
    LDKRouteHintHop this_obj,
  ) {
    return _RouteHintHop_free(
      this_obj,
    );
  }

  late final _RouteHintHop_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRouteHintHop)>>(
          'RouteHintHop_free');
  late final _RouteHintHop_free =
      _RouteHintHop_freePtr.asFunction<void Function(LDKRouteHintHop)>();

  /// The node_id of the non-target end of the route
  LDKPublicKey RouteHintHop_get_src_node_id(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_src_node_id(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_src_node_idPtr = _lookup<
      ffi.NativeFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_get_src_node_id');
  late final _RouteHintHop_get_src_node_id = _RouteHintHop_get_src_node_idPtr
      .asFunction<LDKPublicKey Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The node_id of the non-target end of the route
  void RouteHintHop_set_src_node_id(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    LDKPublicKey val,
  ) {
    return _RouteHintHop_set_src_node_id(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_src_node_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              LDKPublicKey)>>('RouteHintHop_set_src_node_id');
  late final _RouteHintHop_set_src_node_id = _RouteHintHop_set_src_node_idPtr
      .asFunction<void Function(ffi.Pointer<LDKRouteHintHop>, LDKPublicKey)>();

  /// The short_channel_id of this channel
  int RouteHintHop_get_short_channel_id(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_short_channel_id(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_short_channel_idPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKRouteHintHop>)>>(
      'RouteHintHop_get_short_channel_id');
  late final _RouteHintHop_get_short_channel_id =
      _RouteHintHop_get_short_channel_idPtr.asFunction<
          int Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The short_channel_id of this channel
  void RouteHintHop_set_short_channel_id(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    int val,
  ) {
    return _RouteHintHop_set_short_channel_id(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_short_channel_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              ffi.Uint64)>>('RouteHintHop_set_short_channel_id');
  late final _RouteHintHop_set_short_channel_id =
      _RouteHintHop_set_short_channel_idPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHintHop>, int)>();

  /// The fees which must be paid to use this channel
  LDKRoutingFees RouteHintHop_get_fees(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_fees(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_feesPtr = _lookup<
      ffi.NativeFunction<
          LDKRoutingFees Function(
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_get_fees');
  late final _RouteHintHop_get_fees = _RouteHintHop_get_feesPtr.asFunction<
      LDKRoutingFees Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The fees which must be paid to use this channel
  void RouteHintHop_set_fees(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    LDKRoutingFees val,
  ) {
    return _RouteHintHop_set_fees(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_feesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              LDKRoutingFees)>>('RouteHintHop_set_fees');
  late final _RouteHintHop_set_fees = _RouteHintHop_set_feesPtr.asFunction<
      void Function(ffi.Pointer<LDKRouteHintHop>, LDKRoutingFees)>();

  /// The difference in CLTV values between this node and the next node.
  int RouteHintHop_get_cltv_expiry_delta(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_cltv_expiry_delta(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_cltv_expiry_deltaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint16 Function(ffi.Pointer<LDKRouteHintHop>)>>(
      'RouteHintHop_get_cltv_expiry_delta');
  late final _RouteHintHop_get_cltv_expiry_delta =
      _RouteHintHop_get_cltv_expiry_deltaPtr.asFunction<
          int Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The difference in CLTV values between this node and the next node.
  void RouteHintHop_set_cltv_expiry_delta(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    int val,
  ) {
    return _RouteHintHop_set_cltv_expiry_delta(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_cltv_expiry_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              ffi.Uint16)>>('RouteHintHop_set_cltv_expiry_delta');
  late final _RouteHintHop_set_cltv_expiry_delta =
      _RouteHintHop_set_cltv_expiry_deltaPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHintHop>, int)>();

  /// The minimum value, in msat, which must be relayed to the next hop.
  LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_htlc_minimum_msat(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_htlc_minimum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKRouteHintHop>)>>(
      'RouteHintHop_get_htlc_minimum_msat');
  late final _RouteHintHop_get_htlc_minimum_msat =
      _RouteHintHop_get_htlc_minimum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The minimum value, in msat, which must be relayed to the next hop.
  void RouteHintHop_set_htlc_minimum_msat(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _RouteHintHop_set_htlc_minimum_msat(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_htlc_minimum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              LDKCOption_u64Z)>>('RouteHintHop_set_htlc_minimum_msat');
  late final _RouteHintHop_set_htlc_minimum_msat =
      _RouteHintHop_set_htlc_minimum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHintHop>, LDKCOption_u64Z)>();

  /// The maximum value in msat available for routing with a single HTLC.
  LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
  ) {
    return _RouteHintHop_get_htlc_maximum_msat(
      this_ptr,
    );
  }

  late final _RouteHintHop_get_htlc_maximum_msatPtr = _lookup<
          ffi.NativeFunction<
              LDKCOption_u64Z Function(ffi.Pointer<LDKRouteHintHop>)>>(
      'RouteHintHop_get_htlc_maximum_msat');
  late final _RouteHintHop_get_htlc_maximum_msat =
      _RouteHintHop_get_htlc_maximum_msatPtr.asFunction<
          LDKCOption_u64Z Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// The maximum value in msat available for routing with a single HTLC.
  void RouteHintHop_set_htlc_maximum_msat(
    ffi.Pointer<LDKRouteHintHop> this_ptr,
    LDKCOption_u64Z val,
  ) {
    return _RouteHintHop_set_htlc_maximum_msat(
      this_ptr,
      val,
    );
  }

  late final _RouteHintHop_set_htlc_maximum_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRouteHintHop>,
              LDKCOption_u64Z)>>('RouteHintHop_set_htlc_maximum_msat');
  late final _RouteHintHop_set_htlc_maximum_msat =
      _RouteHintHop_set_htlc_maximum_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKRouteHintHop>, LDKCOption_u64Z)>();

  /// Constructs a new RouteHintHop given each field
  LDKRouteHintHop RouteHintHop_new(
    LDKPublicKey src_node_id_arg,
    int short_channel_id_arg,
    LDKRoutingFees fees_arg,
    int cltv_expiry_delta_arg,
    LDKCOption_u64Z htlc_minimum_msat_arg,
    LDKCOption_u64Z htlc_maximum_msat_arg,
  ) {
    return _RouteHintHop_new(
      src_node_id_arg,
      short_channel_id_arg,
      fees_arg,
      cltv_expiry_delta_arg,
      htlc_minimum_msat_arg,
      htlc_maximum_msat_arg,
    );
  }

  late final _RouteHintHop_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRouteHintHop Function(
              LDKPublicKey,
              ffi.Uint64,
              LDKRoutingFees,
              ffi.Uint16,
              LDKCOption_u64Z,
              LDKCOption_u64Z)>>('RouteHintHop_new');
  late final _RouteHintHop_new = _RouteHintHop_newPtr.asFunction<
      LDKRouteHintHop Function(LDKPublicKey, int, LDKRoutingFees, int,
          LDKCOption_u64Z, LDKCOption_u64Z)>();

  /// Creates a copy of the RouteHintHop
  LDKRouteHintHop RouteHintHop_clone(
    ffi.Pointer<LDKRouteHintHop> orig,
  ) {
    return _RouteHintHop_clone(
      orig,
    );
  }

  late final _RouteHintHop_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRouteHintHop Function(
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_clone');
  late final _RouteHintHop_clone = _RouteHintHop_clonePtr.asFunction<
      LDKRouteHintHop Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// Checks if two RouteHintHops contain equal inner contents.
  int RouteHintHop_hash(
    ffi.Pointer<LDKRouteHintHop> o,
  ) {
    return _RouteHintHop_hash(
      o,
    );
  }

  late final _RouteHintHop_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_hash');
  late final _RouteHintHop_hash = _RouteHintHop_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// Checks if two RouteHintHops contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RouteHintHop_eq(
    ffi.Pointer<LDKRouteHintHop> a,
    ffi.Pointer<LDKRouteHintHop> b,
  ) {
    return _RouteHintHop_eq(
      a,
      b,
    );
  }

  late final _RouteHintHop_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRouteHintHop>,
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_eq');
  late final _RouteHintHop_eq = _RouteHintHop_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKRouteHintHop>, ffi.Pointer<LDKRouteHintHop>)>();

  /// Serialize the RouteHintHop object into a byte array which can be read by RouteHintHop_read
  LDKCVec_u8Z RouteHintHop_write(
    ffi.Pointer<LDKRouteHintHop> obj,
  ) {
    return _RouteHintHop_write(
      obj,
    );
  }

  late final _RouteHintHop_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKRouteHintHop>)>>('RouteHintHop_write');
  late final _RouteHintHop_write = _RouteHintHop_writePtr.asFunction<
      LDKCVec_u8Z Function(ffi.Pointer<LDKRouteHintHop>)>();

  /// Read a RouteHintHop from a byte array, created by RouteHintHop_write
  LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(
    LDKu8slice ser,
  ) {
    return _RouteHintHop_read(
      ser,
    );
  }

  late final _RouteHintHop_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteHintHopDecodeErrorZ Function(
              LDKu8slice)>>('RouteHintHop_read');
  late final _RouteHintHop_read = _RouteHintHop_readPtr.asFunction<
      LDKCResult_RouteHintHopDecodeErrorZ Function(LDKu8slice)>();

  /// Finds a route from us (payer) to the given target node (payee).
  ///
  /// If the payee provided features in their invoice, they should be provided via `params.payee`.
  /// Without this, MPP will only be used if the payee's features are available in the network graph.
  ///
  /// Private routing paths between a public node and the target may be included in `params.payee`.
  ///
  /// If some channels aren't announced, it may be useful to fill in `first_hops` with the results
  /// from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of these channels
  /// from `network_graph` will be ignored, and only those in `first_hops` will be used.
  ///
  /// The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
  /// However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
  /// `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
  ///
  /// # Note
  ///
  /// May be used to re-compute a [`Route`] when handling a [`Event::PaymentPathFailed`]. Any
  /// adjustments to the [`NetworkGraph`] and channel scores should be made prior to calling this
  /// function.
  ///
  /// # Panics
  ///
  /// Panics if first_hops contains channels without short_channel_ids;
  /// [`ChannelManager::list_usable_channels`] will never include such channels.
  ///
  /// [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
  /// [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
  /// [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
  ///
  /// Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult_RouteLightningErrorZ find_route(
    LDKPublicKey our_node_pubkey,
    ffi.Pointer<LDKRouteParameters> route_params,
    ffi.Pointer<LDKNetworkGraph> network_graph,
    ffi.Pointer<LDKCVec_ChannelDetailsZ> first_hops,
    LDKLogger logger,
    ffi.Pointer<LDKScore> scorer,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> random_seed_bytes,
  ) {
    return _find_route(
      our_node_pubkey,
      route_params,
      network_graph,
      first_hops,
      logger,
      scorer,
      random_seed_bytes,
    );
  }

  late final _find_routePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteLightningErrorZ Function(
              LDKPublicKey,
              ffi.Pointer<LDKRouteParameters>,
              ffi.Pointer<LDKNetworkGraph>,
              ffi.Pointer<LDKCVec_ChannelDetailsZ>,
              LDKLogger,
              ffi.Pointer<LDKScore>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('find_route');
  late final _find_route = _find_routePtr.asFunction<
      LDKCResult_RouteLightningErrorZ Function(
          LDKPublicKey,
          ffi.Pointer<LDKRouteParameters>,
          ffi.Pointer<LDKNetworkGraph>,
          ffi.Pointer<LDKCVec_ChannelDetailsZ>,
          LDKLogger,
          ffi.Pointer<LDKScore>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Construct a route from us (payer) to the target node (payee) via the given hops (which should
  /// exclude the payer, but include the payee). This may be useful, e.g., for probing the chosen path.
  ///
  /// Re-uses logic from `find_route`, so the restrictions described there also apply here.
  LDKCResult_RouteLightningErrorZ build_route_from_hops(
    LDKPublicKey our_node_pubkey,
    LDKCVec_PublicKeyZ hops,
    ffi.Pointer<LDKRouteParameters> route_params,
    ffi.Pointer<LDKNetworkGraph> network_graph,
    LDKLogger logger,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> random_seed_bytes,
  ) {
    return _build_route_from_hops(
      our_node_pubkey,
      hops,
      route_params,
      network_graph,
      logger,
      random_seed_bytes,
    );
  }

  late final _build_route_from_hopsPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_RouteLightningErrorZ Function(
              LDKPublicKey,
              LDKCVec_PublicKeyZ,
              ffi.Pointer<LDKRouteParameters>,
              ffi.Pointer<LDKNetworkGraph>,
              LDKLogger,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('build_route_from_hops');
  late final _build_route_from_hops = _build_route_from_hopsPtr.asFunction<
      LDKCResult_RouteLightningErrorZ Function(
          LDKPublicKey,
          LDKCVec_PublicKeyZ,
          ffi.Pointer<LDKRouteParameters>,
          ffi.Pointer<LDKNetworkGraph>,
          LDKLogger,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Calls the free function if one is set
  void Score_free(
    LDKScore this_ptr,
  ) {
    return _Score_free(
      this_ptr,
    );
  }

  late final _Score_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKScore)>>('Score_free');
  late final _Score_free = _Score_freePtr.asFunction<void Function(LDKScore)>();

  /// Calls the free function if one is set
  void LockableScore_free(
    LDKLockableScore this_ptr,
  ) {
    return _LockableScore_free(
      this_ptr,
    );
  }

  late final _LockableScore_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKLockableScore)>>(
          'LockableScore_free');
  late final _LockableScore_free =
      _LockableScore_freePtr.asFunction<void Function(LDKLockableScore)>();

  /// Frees any resources used by the MultiThreadedLockableScore, if is_owned is set and inner is non-NULL.
  void MultiThreadedLockableScore_free(
    LDKMultiThreadedLockableScore this_obj,
  ) {
    return _MultiThreadedLockableScore_free(
      this_obj,
    );
  }

  late final _MultiThreadedLockableScore_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(LDKMultiThreadedLockableScore)>>(
      'MultiThreadedLockableScore_free');
  late final _MultiThreadedLockableScore_free =
      _MultiThreadedLockableScore_freePtr.asFunction<
          void Function(LDKMultiThreadedLockableScore)>();

  /// Serialize the MultiThreadedLockableScore object into a byte array which can be read by MultiThreadedLockableScore_read
  LDKCVec_u8Z MultiThreadedLockableScore_write(
    ffi.Pointer<LDKMultiThreadedLockableScore> obj,
  ) {
    return _MultiThreadedLockableScore_write(
      obj,
    );
  }

  late final _MultiThreadedLockableScore_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(
                  ffi.Pointer<LDKMultiThreadedLockableScore>)>>(
      'MultiThreadedLockableScore_write');
  late final _MultiThreadedLockableScore_write =
      _MultiThreadedLockableScore_writePtr.asFunction<
          LDKCVec_u8Z Function(ffi.Pointer<LDKMultiThreadedLockableScore>)>();

  /// Creates a new [`MultiThreadedLockableScore`] given an underlying [`Score`].
  LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(
    LDKScore score,
  ) {
    return _MultiThreadedLockableScore_new(
      score,
    );
  }

  late final _MultiThreadedLockableScore_newPtr = _lookup<
          ffi.NativeFunction<LDKMultiThreadedLockableScore Function(LDKScore)>>(
      'MultiThreadedLockableScore_new');
  late final _MultiThreadedLockableScore_new =
      _MultiThreadedLockableScore_newPtr.asFunction<
          LDKMultiThreadedLockableScore Function(LDKScore)>();

  /// Frees any resources used by the ChannelUsage, if is_owned is set and inner is non-NULL.
  void ChannelUsage_free(
    LDKChannelUsage this_obj,
  ) {
    return _ChannelUsage_free(
      this_obj,
    );
  }

  late final _ChannelUsage_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKChannelUsage)>>(
          'ChannelUsage_free');
  late final _ChannelUsage_free =
      _ChannelUsage_freePtr.asFunction<void Function(LDKChannelUsage)>();

  /// The amount to send through the channel, denominated in millisatoshis.
  int ChannelUsage_get_amount_msat(
    ffi.Pointer<LDKChannelUsage> this_ptr,
  ) {
    return _ChannelUsage_get_amount_msat(
      this_ptr,
    );
  }

  late final _ChannelUsage_get_amount_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKChannelUsage>)>>('ChannelUsage_get_amount_msat');
  late final _ChannelUsage_get_amount_msat = _ChannelUsage_get_amount_msatPtr
      .asFunction<int Function(ffi.Pointer<LDKChannelUsage>)>();

  /// The amount to send through the channel, denominated in millisatoshis.
  void ChannelUsage_set_amount_msat(
    ffi.Pointer<LDKChannelUsage> this_ptr,
    int val,
  ) {
    return _ChannelUsage_set_amount_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelUsage_set_amount_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUsage>,
              ffi.Uint64)>>('ChannelUsage_set_amount_msat');
  late final _ChannelUsage_set_amount_msat = _ChannelUsage_set_amount_msatPtr
      .asFunction<void Function(ffi.Pointer<LDKChannelUsage>, int)>();

  /// Total amount, denominated in millisatoshis, already allocated to send through the channel
  /// as part of a multi-path payment.
  int ChannelUsage_get_inflight_htlc_msat(
    ffi.Pointer<LDKChannelUsage> this_ptr,
  ) {
    return _ChannelUsage_get_inflight_htlc_msat(
      this_ptr,
    );
  }

  late final _ChannelUsage_get_inflight_htlc_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKChannelUsage>)>>(
      'ChannelUsage_get_inflight_htlc_msat');
  late final _ChannelUsage_get_inflight_htlc_msat =
      _ChannelUsage_get_inflight_htlc_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKChannelUsage>)>();

  /// Total amount, denominated in millisatoshis, already allocated to send through the channel
  /// as part of a multi-path payment.
  void ChannelUsage_set_inflight_htlc_msat(
    ffi.Pointer<LDKChannelUsage> this_ptr,
    int val,
  ) {
    return _ChannelUsage_set_inflight_htlc_msat(
      this_ptr,
      val,
    );
  }

  late final _ChannelUsage_set_inflight_htlc_msatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUsage>,
              ffi.Uint64)>>('ChannelUsage_set_inflight_htlc_msat');
  late final _ChannelUsage_set_inflight_htlc_msat =
      _ChannelUsage_set_inflight_htlc_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUsage>, int)>();

  /// The effective capacity of the channel.
  LDKEffectiveCapacity ChannelUsage_get_effective_capacity(
    ffi.Pointer<LDKChannelUsage> this_ptr,
  ) {
    return _ChannelUsage_get_effective_capacity(
      this_ptr,
    );
  }

  late final _ChannelUsage_get_effective_capacityPtr = _lookup<
          ffi.NativeFunction<
              LDKEffectiveCapacity Function(ffi.Pointer<LDKChannelUsage>)>>(
      'ChannelUsage_get_effective_capacity');
  late final _ChannelUsage_get_effective_capacity =
      _ChannelUsage_get_effective_capacityPtr.asFunction<
          LDKEffectiveCapacity Function(ffi.Pointer<LDKChannelUsage>)>();

  /// The effective capacity of the channel.
  void ChannelUsage_set_effective_capacity(
    ffi.Pointer<LDKChannelUsage> this_ptr,
    LDKEffectiveCapacity val,
  ) {
    return _ChannelUsage_set_effective_capacity(
      this_ptr,
      val,
    );
  }

  late final _ChannelUsage_set_effective_capacityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKChannelUsage>,
              LDKEffectiveCapacity)>>('ChannelUsage_set_effective_capacity');
  late final _ChannelUsage_set_effective_capacity =
      _ChannelUsage_set_effective_capacityPtr.asFunction<
          void Function(ffi.Pointer<LDKChannelUsage>, LDKEffectiveCapacity)>();

  /// Constructs a new ChannelUsage given each field
  LDKChannelUsage ChannelUsage_new(
    int amount_msat_arg,
    int inflight_htlc_msat_arg,
    LDKEffectiveCapacity effective_capacity_arg,
  ) {
    return _ChannelUsage_new(
      amount_msat_arg,
      inflight_htlc_msat_arg,
      effective_capacity_arg,
    );
  }

  late final _ChannelUsage_newPtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUsage Function(ffi.Uint64, ffi.Uint64,
              LDKEffectiveCapacity)>>('ChannelUsage_new');
  late final _ChannelUsage_new = _ChannelUsage_newPtr.asFunction<
      LDKChannelUsage Function(int, int, LDKEffectiveCapacity)>();

  /// Creates a copy of the ChannelUsage
  LDKChannelUsage ChannelUsage_clone(
    ffi.Pointer<LDKChannelUsage> orig,
  ) {
    return _ChannelUsage_clone(
      orig,
    );
  }

  late final _ChannelUsage_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKChannelUsage Function(
              ffi.Pointer<LDKChannelUsage>)>>('ChannelUsage_clone');
  late final _ChannelUsage_clone = _ChannelUsage_clonePtr.asFunction<
      LDKChannelUsage Function(ffi.Pointer<LDKChannelUsage>)>();

  /// Frees any resources used by the FixedPenaltyScorer, if is_owned is set and inner is non-NULL.
  void FixedPenaltyScorer_free(
    LDKFixedPenaltyScorer this_obj,
  ) {
    return _FixedPenaltyScorer_free(
      this_obj,
    );
  }

  late final _FixedPenaltyScorer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFixedPenaltyScorer)>>(
          'FixedPenaltyScorer_free');
  late final _FixedPenaltyScorer_free = _FixedPenaltyScorer_freePtr.asFunction<
      void Function(LDKFixedPenaltyScorer)>();

  /// Creates a copy of the FixedPenaltyScorer
  LDKFixedPenaltyScorer FixedPenaltyScorer_clone(
    ffi.Pointer<LDKFixedPenaltyScorer> orig,
  ) {
    return _FixedPenaltyScorer_clone(
      orig,
    );
  }

  late final _FixedPenaltyScorer_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKFixedPenaltyScorer Function(
              ffi.Pointer<LDKFixedPenaltyScorer>)>>('FixedPenaltyScorer_clone');
  late final _FixedPenaltyScorer_clone =
      _FixedPenaltyScorer_clonePtr.asFunction<
          LDKFixedPenaltyScorer Function(ffi.Pointer<LDKFixedPenaltyScorer>)>();

  /// Creates a new scorer using `penalty_msat`.
  LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(
    int penalty_msat,
  ) {
    return _FixedPenaltyScorer_with_penalty(
      penalty_msat,
    );
  }

  late final _FixedPenaltyScorer_with_penaltyPtr =
      _lookup<ffi.NativeFunction<LDKFixedPenaltyScorer Function(ffi.Uint64)>>(
          'FixedPenaltyScorer_with_penalty');
  late final _FixedPenaltyScorer_with_penalty =
      _FixedPenaltyScorer_with_penaltyPtr.asFunction<
          LDKFixedPenaltyScorer Function(int)>();

  /// Constructs a new Score which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
  LDKScore FixedPenaltyScorer_as_Score(
    ffi.Pointer<LDKFixedPenaltyScorer> this_arg,
  ) {
    return _FixedPenaltyScorer_as_Score(
      this_arg,
    );
  }

  late final _FixedPenaltyScorer_as_ScorePtr = _lookup<
          ffi.NativeFunction<
              LDKScore Function(ffi.Pointer<LDKFixedPenaltyScorer>)>>(
      'FixedPenaltyScorer_as_Score');
  late final _FixedPenaltyScorer_as_Score = _FixedPenaltyScorer_as_ScorePtr
      .asFunction<LDKScore Function(ffi.Pointer<LDKFixedPenaltyScorer>)>();

  /// Serialize the FixedPenaltyScorer object into a byte array which can be read by FixedPenaltyScorer_read
  LDKCVec_u8Z FixedPenaltyScorer_write(
    ffi.Pointer<LDKFixedPenaltyScorer> obj,
  ) {
    return _FixedPenaltyScorer_write(
      obj,
    );
  }

  late final _FixedPenaltyScorer_writePtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_u8Z Function(
              ffi.Pointer<LDKFixedPenaltyScorer>)>>('FixedPenaltyScorer_write');
  late final _FixedPenaltyScorer_write = _FixedPenaltyScorer_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKFixedPenaltyScorer>)>();

  /// Read a FixedPenaltyScorer from a byte array, created by FixedPenaltyScorer_write
  LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(
    LDKu8slice ser,
    int arg,
  ) {
    return _FixedPenaltyScorer_read(
      ser,
      arg,
    );
  }

  late final _FixedPenaltyScorer_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(
              LDKu8slice, ffi.Uint64)>>('FixedPenaltyScorer_read');
  late final _FixedPenaltyScorer_read = _FixedPenaltyScorer_readPtr.asFunction<
      LDKCResult_FixedPenaltyScorerDecodeErrorZ Function(LDKu8slice, int)>();

  /// Frees any resources used by the ProbabilisticScorer, if is_owned is set and inner is non-NULL.
  void ProbabilisticScorer_free(
    LDKProbabilisticScorer this_obj,
  ) {
    return _ProbabilisticScorer_free(
      this_obj,
    );
  }

  late final _ProbabilisticScorer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKProbabilisticScorer)>>(
          'ProbabilisticScorer_free');
  late final _ProbabilisticScorer_free = _ProbabilisticScorer_freePtr
      .asFunction<void Function(LDKProbabilisticScorer)>();

  /// Frees any resources used by the ProbabilisticScoringParameters, if is_owned is set and inner is non-NULL.
  void ProbabilisticScoringParameters_free(
    LDKProbabilisticScoringParameters this_obj,
  ) {
    return _ProbabilisticScoringParameters_free(
      this_obj,
    );
  }

  late final _ProbabilisticScoringParameters_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(LDKProbabilisticScoringParameters)>>(
      'ProbabilisticScoringParameters_free');
  late final _ProbabilisticScoringParameters_free =
      _ProbabilisticScoringParameters_freePtr.asFunction<
          void Function(LDKProbabilisticScoringParameters)>();

  /// A fixed penalty in msats to apply to each channel.
  ///
  /// Default value: 500 msat
  int ProbabilisticScoringParameters_get_base_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_base_penalty_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_base_penalty_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
      'ProbabilisticScoringParameters_get_base_penalty_msat');
  late final _ProbabilisticScoringParameters_get_base_penalty_msat =
      _ProbabilisticScoringParameters_get_base_penalty_msatPtr.asFunction<
          int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// A fixed penalty in msats to apply to each channel.
  ///
  /// Default value: 500 msat
  void ProbabilisticScoringParameters_set_base_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_base_penalty_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_base_penalty_msatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, ffi.Uint64)>>(
      'ProbabilisticScoringParameters_set_base_penalty_msat');
  late final _ProbabilisticScoringParameters_set_base_penalty_msat =
      _ProbabilisticScoringParameters_set_base_penalty_msatPtr.asFunction<
          void Function(ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// A multiplier used with the payment amount to calculate a fixed penalty applied to each
  /// channel, in excess of the [`base_penalty_msat`].
  ///
  /// The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
  /// fees plus penalty) for large payments. The penalty is computed as the product of this
  /// multiplier and `2^30`ths of the payment amount.
  ///
  /// ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
  ///
  /// Default value: 8,192 msat
  ///
  /// [`base_penalty_msat`]: Self::base_penalty_msat
  int ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msat');
  late final _ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msat =
      _ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msatPtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// A multiplier used with the payment amount to calculate a fixed penalty applied to each
  /// channel, in excess of the [`base_penalty_msat`].
  ///
  /// The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
  /// fees plus penalty) for large payments. The penalty is computed as the product of this
  /// multiplier and `2^30`ths of the payment amount.
  ///
  /// ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
  ///
  /// Default value: 8,192 msat
  ///
  /// [`base_penalty_msat`]: Self::base_penalty_msat
  void ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msat');
  late final _ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msat =
      _ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msatPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// A multiplier used in conjunction with the negative `log10` of the channel's success
  /// probability for a payment to determine the liquidity penalty.
  ///
  /// The penalty is based in part on the knowledge learned from prior successful and unsuccessful
  /// payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
  /// penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
  /// lower bounding the success probability to `0.01`) when the amount falls within the
  /// uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
  /// result in a `u64::max_value` penalty, however.
  ///
  /// Default value: 40,000 msat
  ///
  /// [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
  int ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat');
  late final _ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat =
      _ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msatPtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// A multiplier used in conjunction with the negative `log10` of the channel's success
  /// probability for a payment to determine the liquidity penalty.
  ///
  /// The penalty is based in part on the knowledge learned from prior successful and unsuccessful
  /// payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
  /// penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
  /// lower bounding the success probability to `0.01`) when the amount falls within the
  /// uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
  /// result in a `u64::max_value` penalty, however.
  ///
  /// Default value: 40,000 msat
  ///
  /// [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
  void ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat');
  late final _ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat =
      _ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msatPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// The time required to elapse before any knowledge learned about channel liquidity balances is
  /// cut in half.
  ///
  /// The bounds are defined in terms of offsets and are initially zero. Increasing the offsets
  /// gives tighter bounds on the channel liquidity balance. Thus, halving the offsets decreases
  /// the certainty of the channel liquidity balance.
  ///
  /// Default value: 1 hour
  ///
  /// # Note
  ///
  /// When built with the `no-std` feature, time will never elapse. Therefore, the channel
  /// liquidity knowledge will never decay except when the bounds cross.
  int ProbabilisticScoringParameters_get_liquidity_offset_half_life(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_liquidity_offset_half_life(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_liquidity_offset_half_lifePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_liquidity_offset_half_life');
  late final _ProbabilisticScoringParameters_get_liquidity_offset_half_life =
      _ProbabilisticScoringParameters_get_liquidity_offset_half_lifePtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// The time required to elapse before any knowledge learned about channel liquidity balances is
  /// cut in half.
  ///
  /// The bounds are defined in terms of offsets and are initially zero. Increasing the offsets
  /// gives tighter bounds on the channel liquidity balance. Thus, halving the offsets decreases
  /// the certainty of the channel liquidity balance.
  ///
  /// Default value: 1 hour
  ///
  /// # Note
  ///
  /// When built with the `no-std` feature, time will never elapse. Therefore, the channel
  /// liquidity knowledge will never decay except when the bounds cross.
  void ProbabilisticScoringParameters_set_liquidity_offset_half_life(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_liquidity_offset_half_life(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_liquidity_offset_half_lifePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_liquidity_offset_half_life');
  late final _ProbabilisticScoringParameters_set_liquidity_offset_half_life =
      _ProbabilisticScoringParameters_set_liquidity_offset_half_lifePtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// A multiplier used in conjunction with a payment amount and the negative `log10` of the
  /// channel's success probability for the payment to determine the amount penalty.
  ///
  /// The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
  /// fees plus penalty) for large payments. The penalty is computed as the product of this
  /// multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
  /// success probability.
  ///
  /// `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
  ///
  /// In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
  /// the amount will result in a penalty of the multiplier. And, as the success probability
  /// decreases, the negative `log10` weighting will increase dramatically. For higher success
  /// probabilities, the multiplier will have a decreasing effect as the negative `log10` will
  /// fall below `1`.
  ///
  /// Default value: 256 msat
  int ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msat');
  late final _ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msat =
      _ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msatPtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// A multiplier used in conjunction with a payment amount and the negative `log10` of the
  /// channel's success probability for the payment to determine the amount penalty.
  ///
  /// The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
  /// fees plus penalty) for large payments. The penalty is computed as the product of this
  /// multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
  /// success probability.
  ///
  /// `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
  ///
  /// In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
  /// the amount will result in a penalty of the multiplier. And, as the success probability
  /// decreases, the negative `log10` weighting will increase dramatically. For higher success
  /// probabilities, the multiplier will have a decreasing effect as the negative `log10` will
  /// fall below `1`.
  ///
  /// Default value: 256 msat
  void
      ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msat');
  late final _ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msat =
      _ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msatPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
  /// channel's capacity, which makes us prefer nodes with a smaller `htlc_maximum_msat`. We
  /// treat such nodes preferentially as this makes balance discovery attacks harder to execute,
  /// thereby creating an incentive to restrict `htlc_maximum_msat` and improve privacy.
  ///
  /// Default value: 250 msat
  int ProbabilisticScoringParameters_get_anti_probing_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_anti_probing_penalty_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_anti_probing_penalty_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_anti_probing_penalty_msat');
  late final _ProbabilisticScoringParameters_get_anti_probing_penalty_msat =
      _ProbabilisticScoringParameters_get_anti_probing_penalty_msatPtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
  /// channel's capacity, which makes us prefer nodes with a smaller `htlc_maximum_msat`. We
  /// treat such nodes preferentially as this makes balance discovery attacks harder to execute,
  /// thereby creating an incentive to restrict `htlc_maximum_msat` and improve privacy.
  ///
  /// Default value: 250 msat
  void ProbabilisticScoringParameters_set_anti_probing_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_anti_probing_penalty_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_anti_probing_penalty_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_anti_probing_penalty_msat');
  late final _ProbabilisticScoringParameters_set_anti_probing_penalty_msat =
      _ProbabilisticScoringParameters_set_anti_probing_penalty_msatPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// This penalty is applied when the amount we're attempting to send over a channel exceeds our
  /// current estimate of the channel's available liquidity.
  ///
  /// Note that in this case all other penalties, including the
  /// [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
  /// penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
  /// applicable, are still included in the overall penalty.
  ///
  /// If you wish to avoid creating paths with such channels entirely, setting this to a value of
  /// `u64::max_value()` will guarantee that.
  ///
  /// Default value: 1_0000_0000_000 msat (1 Bitcoin)
  ///
  /// [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
  /// [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
  /// [`base_penalty_msat`]: Self::base_penalty_msat
  /// [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
  int ProbabilisticScoringParameters_get_considered_impossible_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
  ) {
    return _ProbabilisticScoringParameters_get_considered_impossible_penalty_msat(
      this_ptr,
    );
  }

  late final _ProbabilisticScoringParameters_get_considered_impossible_penalty_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Uint64 Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
          'ProbabilisticScoringParameters_get_considered_impossible_penalty_msat');
  late final _ProbabilisticScoringParameters_get_considered_impossible_penalty_msat =
      _ProbabilisticScoringParameters_get_considered_impossible_penalty_msatPtr
          .asFunction<
              int Function(ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// This penalty is applied when the amount we're attempting to send over a channel exceeds our
  /// current estimate of the channel's available liquidity.
  ///
  /// Note that in this case all other penalties, including the
  /// [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
  /// penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
  /// applicable, are still included in the overall penalty.
  ///
  /// If you wish to avoid creating paths with such channels entirely, setting this to a value of
  /// `u64::max_value()` will guarantee that.
  ///
  /// Default value: 1_0000_0000_000 msat (1 Bitcoin)
  ///
  /// [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
  /// [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
  /// [`base_penalty_msat`]: Self::base_penalty_msat
  /// [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
  void ProbabilisticScoringParameters_set_considered_impossible_penalty_msat(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_ptr,
    int val,
  ) {
    return _ProbabilisticScoringParameters_set_considered_impossible_penalty_msat(
      this_ptr,
      val,
    );
  }

  late final _ProbabilisticScoringParameters_set_considered_impossible_penalty_msatPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<LDKProbabilisticScoringParameters>,
                      ffi.Uint64)>>(
          'ProbabilisticScoringParameters_set_considered_impossible_penalty_msat');
  late final _ProbabilisticScoringParameters_set_considered_impossible_penalty_msat =
      _ProbabilisticScoringParameters_set_considered_impossible_penalty_msatPtr
          .asFunction<
              void Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>, int)>();

  /// Creates a copy of the ProbabilisticScoringParameters
  LDKProbabilisticScoringParameters ProbabilisticScoringParameters_clone(
    ffi.Pointer<LDKProbabilisticScoringParameters> orig,
  ) {
    return _ProbabilisticScoringParameters_clone(
      orig,
    );
  }

  late final _ProbabilisticScoringParameters_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKProbabilisticScoringParameters Function(
                  ffi.Pointer<LDKProbabilisticScoringParameters>)>>(
      'ProbabilisticScoringParameters_clone');
  late final _ProbabilisticScoringParameters_clone =
      _ProbabilisticScoringParameters_clonePtr.asFunction<
          LDKProbabilisticScoringParameters Function(
              ffi.Pointer<LDKProbabilisticScoringParameters>)>();

  /// Creates a new scorer using the given scoring parameters for sending payments from a node
  /// through a network graph.
  LDKProbabilisticScorer ProbabilisticScorer_new(
    LDKProbabilisticScoringParameters params,
    ffi.Pointer<LDKNetworkGraph> network_graph,
    LDKLogger logger,
  ) {
    return _ProbabilisticScorer_new(
      params,
      network_graph,
      logger,
    );
  }

  late final _ProbabilisticScorer_newPtr = _lookup<
      ffi.NativeFunction<
          LDKProbabilisticScorer Function(
              LDKProbabilisticScoringParameters,
              ffi.Pointer<LDKNetworkGraph>,
              LDKLogger)>>('ProbabilisticScorer_new');
  late final _ProbabilisticScorer_new = _ProbabilisticScorer_newPtr.asFunction<
      LDKProbabilisticScorer Function(LDKProbabilisticScoringParameters,
          ffi.Pointer<LDKNetworkGraph>, LDKLogger)>();

  /// Dump the contents of this scorer into the configured logger.
  ///
  /// Note that this writes roughly one line per channel for which we have a liquidity estimate,
  /// which may be a substantial amount of log output.
  void ProbabilisticScorer_debug_log_liquidity_stats(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
  ) {
    return _ProbabilisticScorer_debug_log_liquidity_stats(
      this_arg,
    );
  }

  late final _ProbabilisticScorer_debug_log_liquidity_statsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKProbabilisticScorer>)>>(
      'ProbabilisticScorer_debug_log_liquidity_stats');
  late final _ProbabilisticScorer_debug_log_liquidity_stats =
      _ProbabilisticScorer_debug_log_liquidity_statsPtr.asFunction<
          void Function(ffi.Pointer<LDKProbabilisticScorer>)>();

  /// Query the estimated minimum and maximum liquidity available for sending a payment over the
  /// channel with `scid` towards the given `target` node.
  LDKCOption_C2Tuple_u64u64ZZ
      ProbabilisticScorer_estimated_channel_liquidity_range(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
    int scid,
    ffi.Pointer<LDKNodeId> target,
  ) {
    return _ProbabilisticScorer_estimated_channel_liquidity_range(
      this_arg,
      scid,
      target,
    );
  }

  late final _ProbabilisticScorer_estimated_channel_liquidity_rangePtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCOption_C2Tuple_u64u64ZZ Function(
                      ffi.Pointer<LDKProbabilisticScorer>,
                      ffi.Uint64,
                      ffi.Pointer<LDKNodeId>)>>(
          'ProbabilisticScorer_estimated_channel_liquidity_range');
  late final _ProbabilisticScorer_estimated_channel_liquidity_range =
      _ProbabilisticScorer_estimated_channel_liquidity_rangePtr.asFunction<
          LDKCOption_C2Tuple_u64u64ZZ Function(
              ffi.Pointer<LDKProbabilisticScorer>,
              int,
              ffi.Pointer<LDKNodeId>)>();

  /// Marks the node with the given `node_id` as banned, i.e.,
  /// it will be avoided during path finding.
  void ProbabilisticScorer_add_banned(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
    ffi.Pointer<LDKNodeId> node_id,
  ) {
    return _ProbabilisticScorer_add_banned(
      this_arg,
      node_id,
    );
  }

  late final _ProbabilisticScorer_add_bannedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKProbabilisticScorer>,
              ffi.Pointer<LDKNodeId>)>>('ProbabilisticScorer_add_banned');
  late final _ProbabilisticScorer_add_banned =
      _ProbabilisticScorer_add_bannedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKProbabilisticScorer>, ffi.Pointer<LDKNodeId>)>();

  /// Removes the node with the given `node_id` from the list of nodes to avoid.
  void ProbabilisticScorer_remove_banned(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
    ffi.Pointer<LDKNodeId> node_id,
  ) {
    return _ProbabilisticScorer_remove_banned(
      this_arg,
      node_id,
    );
  }

  late final _ProbabilisticScorer_remove_bannedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKProbabilisticScorer>,
              ffi.Pointer<LDKNodeId>)>>('ProbabilisticScorer_remove_banned');
  late final _ProbabilisticScorer_remove_banned =
      _ProbabilisticScorer_remove_bannedPtr.asFunction<
          void Function(
              ffi.Pointer<LDKProbabilisticScorer>, ffi.Pointer<LDKNodeId>)>();

  /// Sets a manual penalty for the given node.
  void ProbabilisticScorer_set_manual_penalty(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
    ffi.Pointer<LDKNodeId> node_id,
    int penalty,
  ) {
    return _ProbabilisticScorer_set_manual_penalty(
      this_arg,
      node_id,
      penalty,
    );
  }

  late final _ProbabilisticScorer_set_manual_penaltyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKProbabilisticScorer>,
              ffi.Pointer<LDKNodeId>,
              ffi.Uint64)>>('ProbabilisticScorer_set_manual_penalty');
  late final _ProbabilisticScorer_set_manual_penalty =
      _ProbabilisticScorer_set_manual_penaltyPtr.asFunction<
          void Function(ffi.Pointer<LDKProbabilisticScorer>,
              ffi.Pointer<LDKNodeId>, int)>();

  /// Removes the node with the given `node_id` from the list of manual penalties.
  void ProbabilisticScorer_remove_manual_penalty(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
    ffi.Pointer<LDKNodeId> node_id,
  ) {
    return _ProbabilisticScorer_remove_manual_penalty(
      this_arg,
      node_id,
    );
  }

  late final _ProbabilisticScorer_remove_manual_penaltyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKProbabilisticScorer>,
                  ffi.Pointer<LDKNodeId>)>>(
      'ProbabilisticScorer_remove_manual_penalty');
  late final _ProbabilisticScorer_remove_manual_penalty =
      _ProbabilisticScorer_remove_manual_penaltyPtr.asFunction<
          void Function(
              ffi.Pointer<LDKProbabilisticScorer>, ffi.Pointer<LDKNodeId>)>();

  /// Clears the list of manual penalties that are applied during path finding.
  void ProbabilisticScorer_clear_manual_penalties(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
  ) {
    return _ProbabilisticScorer_clear_manual_penalties(
      this_arg,
    );
  }

  late final _ProbabilisticScorer_clear_manual_penaltiesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKProbabilisticScorer>)>>(
      'ProbabilisticScorer_clear_manual_penalties');
  late final _ProbabilisticScorer_clear_manual_penalties =
      _ProbabilisticScorer_clear_manual_penaltiesPtr.asFunction<
          void Function(ffi.Pointer<LDKProbabilisticScorer>)>();

  /// Marks all nodes in the given list as banned, i.e.,
  /// they will be avoided during path finding.
  void ProbabilisticScoringParameters_add_banned_from_list(
    ffi.Pointer<LDKProbabilisticScoringParameters> this_arg,
    LDKCVec_NodeIdZ node_ids,
  ) {
    return _ProbabilisticScoringParameters_add_banned_from_list(
      this_arg,
      node_ids,
    );
  }

  late final _ProbabilisticScoringParameters_add_banned_from_listPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKProbabilisticScoringParameters>,
                  LDKCVec_NodeIdZ)>>(
      'ProbabilisticScoringParameters_add_banned_from_list');
  late final _ProbabilisticScoringParameters_add_banned_from_list =
      _ProbabilisticScoringParameters_add_banned_from_listPtr.asFunction<
          void Function(ffi.Pointer<LDKProbabilisticScoringParameters>,
              LDKCVec_NodeIdZ)>();

  /// Creates a "default" ProbabilisticScoringParameters. See struct and individual field documentaiton for details on which values are used.
  LDKProbabilisticScoringParameters ProbabilisticScoringParameters_default() {
    return _ProbabilisticScoringParameters_default();
  }

  late final _ProbabilisticScoringParameters_defaultPtr =
      _lookup<ffi.NativeFunction<LDKProbabilisticScoringParameters Function()>>(
          'ProbabilisticScoringParameters_default');
  late final _ProbabilisticScoringParameters_default =
      _ProbabilisticScoringParameters_defaultPtr.asFunction<
          LDKProbabilisticScoringParameters Function()>();

  /// Constructs a new Score which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
  LDKScore ProbabilisticScorer_as_Score(
    ffi.Pointer<LDKProbabilisticScorer> this_arg,
  ) {
    return _ProbabilisticScorer_as_Score(
      this_arg,
    );
  }

  late final _ProbabilisticScorer_as_ScorePtr = _lookup<
          ffi.NativeFunction<
              LDKScore Function(ffi.Pointer<LDKProbabilisticScorer>)>>(
      'ProbabilisticScorer_as_Score');
  late final _ProbabilisticScorer_as_Score = _ProbabilisticScorer_as_ScorePtr
      .asFunction<LDKScore Function(ffi.Pointer<LDKProbabilisticScorer>)>();

  /// Serialize the ProbabilisticScorer object into a byte array which can be read by ProbabilisticScorer_read
  LDKCVec_u8Z ProbabilisticScorer_write(
    ffi.Pointer<LDKProbabilisticScorer> obj,
  ) {
    return _ProbabilisticScorer_write(
      obj,
    );
  }

  late final _ProbabilisticScorer_writePtr = _lookup<
          ffi.NativeFunction<
              LDKCVec_u8Z Function(ffi.Pointer<LDKProbabilisticScorer>)>>(
      'ProbabilisticScorer_write');
  late final _ProbabilisticScorer_write = _ProbabilisticScorer_writePtr
      .asFunction<LDKCVec_u8Z Function(ffi.Pointer<LDKProbabilisticScorer>)>();

  /// Read a ProbabilisticScorer from a byte array, created by ProbabilisticScorer_write
  LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(
    LDKu8slice ser,
    LDKProbabilisticScoringParameters arg_a,
    ffi.Pointer<LDKNetworkGraph> arg_b,
    LDKLogger arg_c,
  ) {
    return _ProbabilisticScorer_read(
      ser,
      arg_a,
      arg_b,
      arg_c,
    );
  }

  late final _ProbabilisticScorer_readPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
              LDKu8slice,
              LDKProbabilisticScoringParameters,
              ffi.Pointer<LDKNetworkGraph>,
              LDKLogger)>>('ProbabilisticScorer_read');
  late final _ProbabilisticScorer_read =
      _ProbabilisticScorer_readPtr.asFunction<
          LDKCResult_ProbabilisticScorerDecodeErrorZ Function(
              LDKu8slice,
              LDKProbabilisticScoringParameters,
              ffi.Pointer<LDKNetworkGraph>,
              LDKLogger)>();

  /// Frees any resources used by the FilesystemPersister, if is_owned is set and inner is non-NULL.
  void FilesystemPersister_free(
    LDKFilesystemPersister this_obj,
  ) {
    return _FilesystemPersister_free(
      this_obj,
    );
  }

  late final _FilesystemPersister_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFilesystemPersister)>>(
          'FilesystemPersister_free');
  late final _FilesystemPersister_free = _FilesystemPersister_freePtr
      .asFunction<void Function(LDKFilesystemPersister)>();

  /// Initialize a new FilesystemPersister and set the path to the individual channels'
  /// files.
  LDKFilesystemPersister FilesystemPersister_new(
    LDKStr path_to_channel_data,
  ) {
    return _FilesystemPersister_new(
      path_to_channel_data,
    );
  }

  late final _FilesystemPersister_newPtr =
      _lookup<ffi.NativeFunction<LDKFilesystemPersister Function(LDKStr)>>(
          'FilesystemPersister_new');
  late final _FilesystemPersister_new = _FilesystemPersister_newPtr.asFunction<
      LDKFilesystemPersister Function(LDKStr)>();

  /// Get the directory which was provided when this persister was initialized.
  LDKStr FilesystemPersister_get_data_dir(
    ffi.Pointer<LDKFilesystemPersister> this_arg,
  ) {
    return _FilesystemPersister_get_data_dir(
      this_arg,
    );
  }

  late final _FilesystemPersister_get_data_dirPtr = _lookup<
          ffi.NativeFunction<
              LDKStr Function(ffi.Pointer<LDKFilesystemPersister>)>>(
      'FilesystemPersister_get_data_dir');
  late final _FilesystemPersister_get_data_dir =
      _FilesystemPersister_get_data_dirPtr.asFunction<
          LDKStr Function(ffi.Pointer<LDKFilesystemPersister>)>();

  /// Read `ChannelMonitor`s from disk.
  LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
      FilesystemPersister_read_channelmonitors(
    ffi.Pointer<LDKFilesystemPersister> this_arg,
    LDKKeysInterface keys_manager,
  ) {
    return _FilesystemPersister_read_channelmonitors(
      this_arg,
      keys_manager,
    );
  }

  late final _FilesystemPersister_read_channelmonitorsPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
              ffi.Pointer<LDKFilesystemPersister>,
              LDKKeysInterface)>>('FilesystemPersister_read_channelmonitors');
  late final _FilesystemPersister_read_channelmonitors =
      _FilesystemPersister_read_channelmonitorsPtr.asFunction<
          LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ Function(
              ffi.Pointer<LDKFilesystemPersister>, LDKKeysInterface)>();

  /// Frees any resources used by the BackgroundProcessor, if is_owned is set and inner is non-NULL.
  void BackgroundProcessor_free(
    LDKBackgroundProcessor this_obj,
  ) {
    return _BackgroundProcessor_free(
      this_obj,
    );
  }

  late final _BackgroundProcessor_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKBackgroundProcessor)>>(
          'BackgroundProcessor_free');
  late final _BackgroundProcessor_free = _BackgroundProcessor_freePtr
      .asFunction<void Function(LDKBackgroundProcessor)>();

  /// Frees any resources used by the GossipSync
  void GossipSync_free(
    LDKGossipSync this_ptr,
  ) {
    return _GossipSync_free(
      this_ptr,
    );
  }

  late final _GossipSync_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKGossipSync)>>(
          'GossipSync_free');
  late final _GossipSync_free =
      _GossipSync_freePtr.asFunction<void Function(LDKGossipSync)>();

  /// Utility method to constructs a new P2P-variant GossipSync
  LDKGossipSync GossipSync_p2_p(
    ffi.Pointer<LDKP2PGossipSync> a,
  ) {
    return _GossipSync_p2_p(
      a,
    );
  }

  late final _GossipSync_p2_pPtr = _lookup<
      ffi.NativeFunction<
          LDKGossipSync Function(
              ffi.Pointer<LDKP2PGossipSync>)>>('GossipSync_p2_p');
  late final _GossipSync_p2_p = _GossipSync_p2_pPtr.asFunction<
      LDKGossipSync Function(ffi.Pointer<LDKP2PGossipSync>)>();

  /// Utility method to constructs a new Rapid-variant GossipSync
  LDKGossipSync GossipSync_rapid(
    ffi.Pointer<LDKRapidGossipSync> a,
  ) {
    return _GossipSync_rapid(
      a,
    );
  }

  late final _GossipSync_rapidPtr = _lookup<
      ffi.NativeFunction<
          LDKGossipSync Function(
              ffi.Pointer<LDKRapidGossipSync>)>>('GossipSync_rapid');
  late final _GossipSync_rapid = _GossipSync_rapidPtr.asFunction<
      LDKGossipSync Function(ffi.Pointer<LDKRapidGossipSync>)>();

  /// Utility method to constructs a new None-variant GossipSync
  LDKGossipSync GossipSync_none() {
    return _GossipSync_none();
  }

  late final _GossipSync_nonePtr =
      _lookup<ffi.NativeFunction<LDKGossipSync Function()>>('GossipSync_none');
  late final _GossipSync_none =
      _GossipSync_nonePtr.asFunction<LDKGossipSync Function()>();

  /// Start a background thread that takes care of responsibilities enumerated in the [top-level
  /// documentation].
  ///
  /// The thread runs indefinitely unless the object is dropped, [`stop`] is called, or
  /// [`Persister::persist_manager`] returns an error. In case of an error, the error is retrieved by calling
  /// either [`join`] or [`stop`].
  ///
  /// # Data Persistence
  ///
  /// [`Persister::persist_manager`] is responsible for writing out the [`ChannelManager`] to disk, and/or
  /// uploading to one or more backup services. See [`ChannelManager::write`] for writing out a
  /// [`ChannelManager`]. See the `lightning-persister` crate for LDK's
  /// provided implementation.
  ///
  /// [`Persister::persist_graph`] is responsible for writing out the [`NetworkGraph`] to disk, if
  /// [`GossipSync`] is supplied. See [`NetworkGraph::write`] for writing out a [`NetworkGraph`].
  /// See the `lightning-persister` crate for LDK's provided implementation.
  ///
  /// Typically, users should either implement [`Persister::persist_manager`] to never return an
  /// error or call [`join`] and handle any error that may arise. For the latter case,
  /// `BackgroundProcessor` must be restarted by calling `start` again after handling the error.
  ///
  /// # Event Handling
  ///
  /// `event_handler` is responsible for handling events that users should be notified of (e.g.,
  /// payment failed). [`BackgroundProcessor`] may decorate the given [`EventHandler`] with common
  /// functionality implemented by other handlers.
  /// * [`P2PGossipSync`] if given will update the [`NetworkGraph`] based on payment failures.
  ///
  /// # Rapid Gossip Sync
  ///
  /// If rapid gossip sync is meant to run at startup, pass [`RapidGossipSync`] via `gossip_sync`
  /// to indicate that the [`BackgroundProcessor`] should not prune the [`NetworkGraph`] instance
  /// until the [`RapidGossipSync`] instance completes its first sync.
  ///
  /// [top-level documentation]: BackgroundProcessor
  /// [`join`]: Self::join
  /// [`stop`]: Self::stop
  /// [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
  /// [`ChannelManager::write`]: lightning::ln::channelmanager::ChannelManager#impl-Writeable
  /// [`Persister::persist_manager`]: lightning::util::persist::Persister::persist_manager
  /// [`Persister::persist_graph`]: lightning::util::persist::Persister::persist_graph
  /// [`NetworkGraph`]: lightning::routing::gossip::NetworkGraph
  /// [`NetworkGraph::write`]: lightning::routing::gossip::NetworkGraph#impl-Writeable
  ///
  /// Note that scorer (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKBackgroundProcessor BackgroundProcessor_start(
    LDKPersister persister,
    LDKEventHandler event_handler,
    ffi.Pointer<LDKChainMonitor> chain_monitor,
    ffi.Pointer<LDKChannelManager> channel_manager,
    LDKGossipSync gossip_sync,
    ffi.Pointer<LDKPeerManager> peer_manager,
    LDKLogger logger,
    LDKMultiThreadedLockableScore scorer,
  ) {
    return _BackgroundProcessor_start(
      persister,
      event_handler,
      chain_monitor,
      channel_manager,
      gossip_sync,
      peer_manager,
      logger,
      scorer,
    );
  }

  late final _BackgroundProcessor_startPtr = _lookup<
      ffi.NativeFunction<
          LDKBackgroundProcessor Function(
              LDKPersister,
              LDKEventHandler,
              ffi.Pointer<LDKChainMonitor>,
              ffi.Pointer<LDKChannelManager>,
              LDKGossipSync,
              ffi.Pointer<LDKPeerManager>,
              LDKLogger,
              LDKMultiThreadedLockableScore)>>('BackgroundProcessor_start');
  late final _BackgroundProcessor_start =
      _BackgroundProcessor_startPtr.asFunction<
          LDKBackgroundProcessor Function(
              LDKPersister,
              LDKEventHandler,
              ffi.Pointer<LDKChainMonitor>,
              ffi.Pointer<LDKChannelManager>,
              LDKGossipSync,
              ffi.Pointer<LDKPeerManager>,
              LDKLogger,
              LDKMultiThreadedLockableScore)>();

  /// Join `BackgroundProcessor`'s thread, returning any error that occurred while persisting
  /// [`ChannelManager`].
  ///
  /// # Panics
  ///
  /// This function panics if the background thread has panicked such as while persisting or
  /// handling events.
  ///
  /// [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
  LDKCResult_NoneErrorZ BackgroundProcessor_join(
    LDKBackgroundProcessor this_arg,
  ) {
    return _BackgroundProcessor_join(
      this_arg,
    );
  }

  late final _BackgroundProcessor_joinPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneErrorZ Function(
              LDKBackgroundProcessor)>>('BackgroundProcessor_join');
  late final _BackgroundProcessor_join = _BackgroundProcessor_joinPtr
      .asFunction<LDKCResult_NoneErrorZ Function(LDKBackgroundProcessor)>();

  /// Stop `BackgroundProcessor`'s thread, returning any error that occurred while persisting
  /// [`ChannelManager`].
  ///
  /// # Panics
  ///
  /// This function panics if the background thread has panicked such as while persisting or
  /// handling events.
  ///
  /// [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
  LDKCResult_NoneErrorZ BackgroundProcessor_stop(
    LDKBackgroundProcessor this_arg,
  ) {
    return _BackgroundProcessor_stop(
      this_arg,
    );
  }

  late final _BackgroundProcessor_stopPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneErrorZ Function(
              LDKBackgroundProcessor)>>('BackgroundProcessor_stop');
  late final _BackgroundProcessor_stop = _BackgroundProcessor_stopPtr
      .asFunction<LDKCResult_NoneErrorZ Function(LDKBackgroundProcessor)>();

  /// Frees any resources used by the ParseError
  void ParseError_free(
    LDKParseError this_ptr,
  ) {
    return _ParseError_free(
      this_ptr,
    );
  }

  late final _ParseError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKParseError)>>(
          'ParseError_free');
  late final _ParseError_free =
      _ParseError_freePtr.asFunction<void Function(LDKParseError)>();

  /// Creates a copy of the ParseError
  LDKParseError ParseError_clone(
    ffi.Pointer<LDKParseError> orig,
  ) {
    return _ParseError_clone(
      orig,
    );
  }

  late final _ParseError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKParseError Function(
              ffi.Pointer<LDKParseError>)>>('ParseError_clone');
  late final _ParseError_clone = _ParseError_clonePtr.asFunction<
      LDKParseError Function(ffi.Pointer<LDKParseError>)>();

  /// Utility method to constructs a new Bech32Error-variant ParseError
  LDKParseError ParseError_bech32_error(
    LDKBech32Error a,
  ) {
    return _ParseError_bech32_error(
      a,
    );
  }

  late final _ParseError_bech32_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function(LDKBech32Error)>>(
          'ParseError_bech32_error');
  late final _ParseError_bech32_error = _ParseError_bech32_errorPtr.asFunction<
      LDKParseError Function(LDKBech32Error)>();

  /// Utility method to constructs a new ParseAmountError-variant ParseError
  LDKParseError ParseError_parse_amount_error(
    LDKError a,
  ) {
    return _ParseError_parse_amount_error(
      a,
    );
  }

  late final _ParseError_parse_amount_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function(LDKError)>>(
          'ParseError_parse_amount_error');
  late final _ParseError_parse_amount_error = _ParseError_parse_amount_errorPtr
      .asFunction<LDKParseError Function(LDKError)>();

  /// Utility method to constructs a new MalformedSignature-variant ParseError
  LDKParseError ParseError_malformed_signature(
    int a,
  ) {
    return _ParseError_malformed_signature(
      a,
    );
  }

  late final _ParseError_malformed_signaturePtr =
      _lookup<ffi.NativeFunction<LDKParseError Function(ffi.Int32)>>(
          'ParseError_malformed_signature');
  late final _ParseError_malformed_signature =
      _ParseError_malformed_signaturePtr.asFunction<
          LDKParseError Function(int)>();

  /// Utility method to constructs a new BadPrefix-variant ParseError
  LDKParseError ParseError_bad_prefix() {
    return _ParseError_bad_prefix();
  }

  late final _ParseError_bad_prefixPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_bad_prefix');
  late final _ParseError_bad_prefix =
      _ParseError_bad_prefixPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new UnknownCurrency-variant ParseError
  LDKParseError ParseError_unknown_currency() {
    return _ParseError_unknown_currency();
  }

  late final _ParseError_unknown_currencyPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_unknown_currency');
  late final _ParseError_unknown_currency =
      _ParseError_unknown_currencyPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new UnknownSiPrefix-variant ParseError
  LDKParseError ParseError_unknown_si_prefix() {
    return _ParseError_unknown_si_prefix();
  }

  late final _ParseError_unknown_si_prefixPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_unknown_si_prefix');
  late final _ParseError_unknown_si_prefix =
      _ParseError_unknown_si_prefixPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new MalformedHRP-variant ParseError
  LDKParseError ParseError_malformed_hrp() {
    return _ParseError_malformed_hrp();
  }

  late final _ParseError_malformed_hrpPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_malformed_hrp');
  late final _ParseError_malformed_hrp =
      _ParseError_malformed_hrpPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new TooShortDataPart-variant ParseError
  LDKParseError ParseError_too_short_data_part() {
    return _ParseError_too_short_data_part();
  }

  late final _ParseError_too_short_data_partPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_too_short_data_part');
  late final _ParseError_too_short_data_part =
      _ParseError_too_short_data_partPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new UnexpectedEndOfTaggedFields-variant ParseError
  LDKParseError ParseError_unexpected_end_of_tagged_fields() {
    return _ParseError_unexpected_end_of_tagged_fields();
  }

  late final _ParseError_unexpected_end_of_tagged_fieldsPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_unexpected_end_of_tagged_fields');
  late final _ParseError_unexpected_end_of_tagged_fields =
      _ParseError_unexpected_end_of_tagged_fieldsPtr.asFunction<
          LDKParseError Function()>();

  /// Utility method to constructs a new DescriptionDecodeError-variant ParseError
  LDKParseError ParseError_description_decode_error(
    LDKError a,
  ) {
    return _ParseError_description_decode_error(
      a,
    );
  }

  late final _ParseError_description_decode_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function(LDKError)>>(
          'ParseError_description_decode_error');
  late final _ParseError_description_decode_error =
      _ParseError_description_decode_errorPtr.asFunction<
          LDKParseError Function(LDKError)>();

  /// Utility method to constructs a new PaddingError-variant ParseError
  LDKParseError ParseError_padding_error() {
    return _ParseError_padding_error();
  }

  late final _ParseError_padding_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_padding_error');
  late final _ParseError_padding_error =
      _ParseError_padding_errorPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new IntegerOverflowError-variant ParseError
  LDKParseError ParseError_integer_overflow_error() {
    return _ParseError_integer_overflow_error();
  }

  late final _ParseError_integer_overflow_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_integer_overflow_error');
  late final _ParseError_integer_overflow_error =
      _ParseError_integer_overflow_errorPtr.asFunction<
          LDKParseError Function()>();

  /// Utility method to constructs a new InvalidSegWitProgramLength-variant ParseError
  LDKParseError ParseError_invalid_seg_wit_program_length() {
    return _ParseError_invalid_seg_wit_program_length();
  }

  late final _ParseError_invalid_seg_wit_program_lengthPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_invalid_seg_wit_program_length');
  late final _ParseError_invalid_seg_wit_program_length =
      _ParseError_invalid_seg_wit_program_lengthPtr.asFunction<
          LDKParseError Function()>();

  /// Utility method to constructs a new InvalidPubKeyHashLength-variant ParseError
  LDKParseError ParseError_invalid_pub_key_hash_length() {
    return _ParseError_invalid_pub_key_hash_length();
  }

  late final _ParseError_invalid_pub_key_hash_lengthPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_invalid_pub_key_hash_length');
  late final _ParseError_invalid_pub_key_hash_length =
      _ParseError_invalid_pub_key_hash_lengthPtr.asFunction<
          LDKParseError Function()>();

  /// Utility method to constructs a new InvalidScriptHashLength-variant ParseError
  LDKParseError ParseError_invalid_script_hash_length() {
    return _ParseError_invalid_script_hash_length();
  }

  late final _ParseError_invalid_script_hash_lengthPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_invalid_script_hash_length');
  late final _ParseError_invalid_script_hash_length =
      _ParseError_invalid_script_hash_lengthPtr.asFunction<
          LDKParseError Function()>();

  /// Utility method to constructs a new InvalidRecoveryId-variant ParseError
  LDKParseError ParseError_invalid_recovery_id() {
    return _ParseError_invalid_recovery_id();
  }

  late final _ParseError_invalid_recovery_idPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>(
          'ParseError_invalid_recovery_id');
  late final _ParseError_invalid_recovery_id =
      _ParseError_invalid_recovery_idPtr.asFunction<LDKParseError Function()>();

  /// Utility method to constructs a new InvalidSliceLength-variant ParseError
  LDKParseError ParseError_invalid_slice_length(
    LDKStr a,
  ) {
    return _ParseError_invalid_slice_length(
      a,
    );
  }

  late final _ParseError_invalid_slice_lengthPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function(LDKStr)>>(
          'ParseError_invalid_slice_length');
  late final _ParseError_invalid_slice_length =
      _ParseError_invalid_slice_lengthPtr.asFunction<
          LDKParseError Function(LDKStr)>();

  /// Utility method to constructs a new Skip-variant ParseError
  LDKParseError ParseError_skip() {
    return _ParseError_skip();
  }

  late final _ParseError_skipPtr =
      _lookup<ffi.NativeFunction<LDKParseError Function()>>('ParseError_skip');
  late final _ParseError_skip =
      _ParseError_skipPtr.asFunction<LDKParseError Function()>();

  /// Frees any resources used by the ParseOrSemanticError
  void ParseOrSemanticError_free(
    LDKParseOrSemanticError this_ptr,
  ) {
    return _ParseOrSemanticError_free(
      this_ptr,
    );
  }

  late final _ParseOrSemanticError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKParseOrSemanticError)>>(
          'ParseOrSemanticError_free');
  late final _ParseOrSemanticError_free = _ParseOrSemanticError_freePtr
      .asFunction<void Function(LDKParseOrSemanticError)>();

  /// Creates a copy of the ParseOrSemanticError
  LDKParseOrSemanticError ParseOrSemanticError_clone(
    ffi.Pointer<LDKParseOrSemanticError> orig,
  ) {
    return _ParseOrSemanticError_clone(
      orig,
    );
  }

  late final _ParseOrSemanticError_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKParseOrSemanticError Function(
                  ffi.Pointer<LDKParseOrSemanticError>)>>(
      'ParseOrSemanticError_clone');
  late final _ParseOrSemanticError_clone =
      _ParseOrSemanticError_clonePtr.asFunction<
          LDKParseOrSemanticError Function(
              ffi.Pointer<LDKParseOrSemanticError>)>();

  /// Utility method to constructs a new ParseError-variant ParseOrSemanticError
  LDKParseOrSemanticError ParseOrSemanticError_parse_error(
    LDKParseError a,
  ) {
    return _ParseOrSemanticError_parse_error(
      a,
    );
  }

  late final _ParseOrSemanticError_parse_errorPtr = _lookup<
          ffi.NativeFunction<LDKParseOrSemanticError Function(LDKParseError)>>(
      'ParseOrSemanticError_parse_error');
  late final _ParseOrSemanticError_parse_error =
      _ParseOrSemanticError_parse_errorPtr.asFunction<
          LDKParseOrSemanticError Function(LDKParseError)>();

  /// Utility method to constructs a new SemanticError-variant ParseOrSemanticError
  LDKParseOrSemanticError ParseOrSemanticError_semantic_error(
    int a,
  ) {
    return _ParseOrSemanticError_semantic_error(
      a,
    );
  }

  late final _ParseOrSemanticError_semantic_errorPtr =
      _lookup<ffi.NativeFunction<LDKParseOrSemanticError Function(ffi.Int32)>>(
          'ParseOrSemanticError_semantic_error');
  late final _ParseOrSemanticError_semantic_error =
      _ParseOrSemanticError_semantic_errorPtr.asFunction<
          LDKParseOrSemanticError Function(int)>();

  /// Frees any resources used by the Invoice, if is_owned is set and inner is non-NULL.
  void Invoice_free(
    LDKInvoice this_obj,
  ) {
    return _Invoice_free(
      this_obj,
    );
  }

  late final _Invoice_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInvoice)>>(
          'Invoice_free');
  late final _Invoice_free =
      _Invoice_freePtr.asFunction<void Function(LDKInvoice)>();

  /// Checks if two Invoices contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool Invoice_eq(
    ffi.Pointer<LDKInvoice> a,
    ffi.Pointer<LDKInvoice> b,
  ) {
    return _Invoice_eq(
      a,
      b,
    );
  }

  late final _Invoice_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKInvoice>, ffi.Pointer<LDKInvoice>)>>('Invoice_eq');
  late final _Invoice_eq = _Invoice_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKInvoice>, ffi.Pointer<LDKInvoice>)>();

  /// Creates a copy of the Invoice
  LDKInvoice Invoice_clone(
    ffi.Pointer<LDKInvoice> orig,
  ) {
    return _Invoice_clone(
      orig,
    );
  }

  late final _Invoice_clonePtr =
      _lookup<ffi.NativeFunction<LDKInvoice Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_clone');
  late final _Invoice_clone = _Invoice_clonePtr.asFunction<
      LDKInvoice Function(ffi.Pointer<LDKInvoice>)>();

  /// Frees any resources used by the SignedRawInvoice, if is_owned is set and inner is non-NULL.
  void SignedRawInvoice_free(
    LDKSignedRawInvoice this_obj,
  ) {
    return _SignedRawInvoice_free(
      this_obj,
    );
  }

  late final _SignedRawInvoice_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKSignedRawInvoice)>>(
          'SignedRawInvoice_free');
  late final _SignedRawInvoice_free = _SignedRawInvoice_freePtr.asFunction<
      void Function(LDKSignedRawInvoice)>();

  /// Checks if two SignedRawInvoices contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool SignedRawInvoice_eq(
    ffi.Pointer<LDKSignedRawInvoice> a,
    ffi.Pointer<LDKSignedRawInvoice> b,
  ) {
    return _SignedRawInvoice_eq(
      a,
      b,
    );
  }

  late final _SignedRawInvoice_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKSignedRawInvoice>,
              ffi.Pointer<LDKSignedRawInvoice>)>>('SignedRawInvoice_eq');
  late final _SignedRawInvoice_eq = _SignedRawInvoice_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKSignedRawInvoice>,
          ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Creates a copy of the SignedRawInvoice
  LDKSignedRawInvoice SignedRawInvoice_clone(
    ffi.Pointer<LDKSignedRawInvoice> orig,
  ) {
    return _SignedRawInvoice_clone(
      orig,
    );
  }

  late final _SignedRawInvoice_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKSignedRawInvoice Function(
              ffi.Pointer<LDKSignedRawInvoice>)>>('SignedRawInvoice_clone');
  late final _SignedRawInvoice_clone = _SignedRawInvoice_clonePtr.asFunction<
      LDKSignedRawInvoice Function(ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Frees any resources used by the RawInvoice, if is_owned is set and inner is non-NULL.
  void RawInvoice_free(
    LDKRawInvoice this_obj,
  ) {
    return _RawInvoice_free(
      this_obj,
    );
  }

  late final _RawInvoice_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRawInvoice)>>(
          'RawInvoice_free');
  late final _RawInvoice_free =
      _RawInvoice_freePtr.asFunction<void Function(LDKRawInvoice)>();

  /// data part
  LDKRawDataPart RawInvoice_get_data(
    ffi.Pointer<LDKRawInvoice> this_ptr,
  ) {
    return _RawInvoice_get_data(
      this_ptr,
    );
  }

  late final _RawInvoice_get_dataPtr = _lookup<
      ffi.NativeFunction<
          LDKRawDataPart Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_get_data');
  late final _RawInvoice_get_data = _RawInvoice_get_dataPtr.asFunction<
      LDKRawDataPart Function(ffi.Pointer<LDKRawInvoice>)>();

  /// data part
  void RawInvoice_set_data(
    ffi.Pointer<LDKRawInvoice> this_ptr,
    LDKRawDataPart val,
  ) {
    return _RawInvoice_set_data(
      this_ptr,
      val,
    );
  }

  late final _RawInvoice_set_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRawInvoice>,
              LDKRawDataPart)>>('RawInvoice_set_data');
  late final _RawInvoice_set_data = _RawInvoice_set_dataPtr.asFunction<
      void Function(ffi.Pointer<LDKRawInvoice>, LDKRawDataPart)>();

  /// Checks if two RawInvoices contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RawInvoice_eq(
    ffi.Pointer<LDKRawInvoice> a,
    ffi.Pointer<LDKRawInvoice> b,
  ) {
    return _RawInvoice_eq(
      a,
      b,
    );
  }

  late final _RawInvoice_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRawInvoice>,
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_eq');
  late final _RawInvoice_eq = _RawInvoice_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKRawInvoice>, ffi.Pointer<LDKRawInvoice>)>();

  /// Creates a copy of the RawInvoice
  LDKRawInvoice RawInvoice_clone(
    ffi.Pointer<LDKRawInvoice> orig,
  ) {
    return _RawInvoice_clone(
      orig,
    );
  }

  late final _RawInvoice_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRawInvoice Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_clone');
  late final _RawInvoice_clone = _RawInvoice_clonePtr.asFunction<
      LDKRawInvoice Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Frees any resources used by the RawDataPart, if is_owned is set and inner is non-NULL.
  void RawDataPart_free(
    LDKRawDataPart this_obj,
  ) {
    return _RawDataPart_free(
      this_obj,
    );
  }

  late final _RawDataPart_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRawDataPart)>>(
          'RawDataPart_free');
  late final _RawDataPart_free =
      _RawDataPart_freePtr.asFunction<void Function(LDKRawDataPart)>();

  /// generation time of the invoice
  LDKPositiveTimestamp RawDataPart_get_timestamp(
    ffi.Pointer<LDKRawDataPart> this_ptr,
  ) {
    return _RawDataPart_get_timestamp(
      this_ptr,
    );
  }

  late final _RawDataPart_get_timestampPtr = _lookup<
      ffi.NativeFunction<
          LDKPositiveTimestamp Function(
              ffi.Pointer<LDKRawDataPart>)>>('RawDataPart_get_timestamp');
  late final _RawDataPart_get_timestamp = _RawDataPart_get_timestampPtr
      .asFunction<LDKPositiveTimestamp Function(ffi.Pointer<LDKRawDataPart>)>();

  /// generation time of the invoice
  void RawDataPart_set_timestamp(
    ffi.Pointer<LDKRawDataPart> this_ptr,
    LDKPositiveTimestamp val,
  ) {
    return _RawDataPart_set_timestamp(
      this_ptr,
      val,
    );
  }

  late final _RawDataPart_set_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKRawDataPart>,
              LDKPositiveTimestamp)>>('RawDataPart_set_timestamp');
  late final _RawDataPart_set_timestamp =
      _RawDataPart_set_timestampPtr.asFunction<
          void Function(ffi.Pointer<LDKRawDataPart>, LDKPositiveTimestamp)>();

  /// Checks if two RawDataParts contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool RawDataPart_eq(
    ffi.Pointer<LDKRawDataPart> a,
    ffi.Pointer<LDKRawDataPart> b,
  ) {
    return _RawDataPart_eq(
      a,
      b,
    );
  }

  late final _RawDataPart_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKRawDataPart>,
              ffi.Pointer<LDKRawDataPart>)>>('RawDataPart_eq');
  late final _RawDataPart_eq = _RawDataPart_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKRawDataPart>, ffi.Pointer<LDKRawDataPart>)>();

  /// Creates a copy of the RawDataPart
  LDKRawDataPart RawDataPart_clone(
    ffi.Pointer<LDKRawDataPart> orig,
  ) {
    return _RawDataPart_clone(
      orig,
    );
  }

  late final _RawDataPart_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKRawDataPart Function(
              ffi.Pointer<LDKRawDataPart>)>>('RawDataPart_clone');
  late final _RawDataPart_clone = _RawDataPart_clonePtr.asFunction<
      LDKRawDataPart Function(ffi.Pointer<LDKRawDataPart>)>();

  /// Frees any resources used by the PositiveTimestamp, if is_owned is set and inner is non-NULL.
  void PositiveTimestamp_free(
    LDKPositiveTimestamp this_obj,
  ) {
    return _PositiveTimestamp_free(
      this_obj,
    );
  }

  late final _PositiveTimestamp_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPositiveTimestamp)>>(
          'PositiveTimestamp_free');
  late final _PositiveTimestamp_free = _PositiveTimestamp_freePtr.asFunction<
      void Function(LDKPositiveTimestamp)>();

  /// Checks if two PositiveTimestamps contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool PositiveTimestamp_eq(
    ffi.Pointer<LDKPositiveTimestamp> a,
    ffi.Pointer<LDKPositiveTimestamp> b,
  ) {
    return _PositiveTimestamp_eq(
      a,
      b,
    );
  }

  late final _PositiveTimestamp_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKPositiveTimestamp>,
              ffi.Pointer<LDKPositiveTimestamp>)>>('PositiveTimestamp_eq');
  late final _PositiveTimestamp_eq = _PositiveTimestamp_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKPositiveTimestamp>,
          ffi.Pointer<LDKPositiveTimestamp>)>();

  /// Creates a copy of the PositiveTimestamp
  LDKPositiveTimestamp PositiveTimestamp_clone(
    ffi.Pointer<LDKPositiveTimestamp> orig,
  ) {
    return _PositiveTimestamp_clone(
      orig,
    );
  }

  late final _PositiveTimestamp_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPositiveTimestamp Function(
              ffi.Pointer<LDKPositiveTimestamp>)>>('PositiveTimestamp_clone');
  late final _PositiveTimestamp_clone = _PositiveTimestamp_clonePtr.asFunction<
      LDKPositiveTimestamp Function(ffi.Pointer<LDKPositiveTimestamp>)>();

  /// Creates a copy of the SiPrefix
  int SiPrefix_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _SiPrefix_clone(
      orig,
    );
  }

  late final _SiPrefix_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'SiPrefix_clone');
  late final _SiPrefix_clone =
      _SiPrefix_clonePtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new Milli-variant SiPrefix
  int SiPrefix_milli() {
    return _SiPrefix_milli();
  }

  late final _SiPrefix_milliPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SiPrefix_milli');
  late final _SiPrefix_milli = _SiPrefix_milliPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Micro-variant SiPrefix
  int SiPrefix_micro() {
    return _SiPrefix_micro();
  }

  late final _SiPrefix_microPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SiPrefix_micro');
  late final _SiPrefix_micro = _SiPrefix_microPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Nano-variant SiPrefix
  int SiPrefix_nano() {
    return _SiPrefix_nano();
  }

  late final _SiPrefix_nanoPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SiPrefix_nano');
  late final _SiPrefix_nano = _SiPrefix_nanoPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Pico-variant SiPrefix
  int SiPrefix_pico() {
    return _SiPrefix_pico();
  }

  late final _SiPrefix_picoPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('SiPrefix_pico');
  late final _SiPrefix_pico = _SiPrefix_picoPtr.asFunction<int Function()>();

  /// Checks if two SiPrefixs contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool SiPrefix_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _SiPrefix_eq(
      a,
      b,
    );
  }

  late final _SiPrefix_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>>('SiPrefix_eq');
  late final _SiPrefix_eq = _SiPrefix_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Returns the multiplier to go from a BTC value to picoBTC implied by this SiPrefix.
  /// This is effectively 10^12 * the prefix multiplier
  int SiPrefix_multiplier(
    ffi.Pointer<ffi.Int32> this_arg,
  ) {
    return _SiPrefix_multiplier(
      this_arg,
    );
  }

  late final _SiPrefix_multiplierPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<ffi.Int32>)>>(
          'SiPrefix_multiplier');
  late final _SiPrefix_multiplier = _SiPrefix_multiplierPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>)>();

  /// Creates a copy of the Currency
  int Currency_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _Currency_clone(
      orig,
    );
  }

  late final _Currency_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'Currency_clone');
  late final _Currency_clone =
      _Currency_clonePtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new Bitcoin-variant Currency
  int Currency_bitcoin() {
    return _Currency_bitcoin();
  }

  late final _Currency_bitcoinPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Currency_bitcoin');
  late final _Currency_bitcoin =
      _Currency_bitcoinPtr.asFunction<int Function()>();

  /// Utility method to constructs a new BitcoinTestnet-variant Currency
  int Currency_bitcoin_testnet() {
    return _Currency_bitcoin_testnet();
  }

  late final _Currency_bitcoin_testnetPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'Currency_bitcoin_testnet');
  late final _Currency_bitcoin_testnet =
      _Currency_bitcoin_testnetPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Regtest-variant Currency
  int Currency_regtest() {
    return _Currency_regtest();
  }

  late final _Currency_regtestPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Currency_regtest');
  late final _Currency_regtest =
      _Currency_regtestPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Simnet-variant Currency
  int Currency_simnet() {
    return _Currency_simnet();
  }

  late final _Currency_simnetPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Currency_simnet');
  late final _Currency_simnet =
      _Currency_simnetPtr.asFunction<int Function()>();

  /// Utility method to constructs a new Signet-variant Currency
  int Currency_signet() {
    return _Currency_signet();
  }

  late final _Currency_signetPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('Currency_signet');
  late final _Currency_signet =
      _Currency_signetPtr.asFunction<int Function()>();

  /// Checks if two Currencys contain equal inner contents.
  int Currency_hash(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _Currency_hash(
      o,
    );
  }

  late final _Currency_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<ffi.Int32>)>>(
          'Currency_hash');
  late final _Currency_hash =
      _Currency_hashPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>)>();

  /// Checks if two Currencys contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool Currency_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _Currency_eq(
      a,
      b,
    );
  }

  late final _Currency_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>>('Currency_eq');
  late final _Currency_eq = _Currency_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Frees any resources used by the Sha256, if is_owned is set and inner is non-NULL.
  void Sha256_free(
    LDKSha256 this_obj,
  ) {
    return _Sha256_free(
      this_obj,
    );
  }

  late final _Sha256_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKSha256)>>('Sha256_free');
  late final _Sha256_free =
      _Sha256_freePtr.asFunction<void Function(LDKSha256)>();

  /// Creates a copy of the Sha256
  LDKSha256 Sha256_clone(
    ffi.Pointer<LDKSha256> orig,
  ) {
    return _Sha256_clone(
      orig,
    );
  }

  late final _Sha256_clonePtr =
      _lookup<ffi.NativeFunction<LDKSha256 Function(ffi.Pointer<LDKSha256>)>>(
          'Sha256_clone');
  late final _Sha256_clone =
      _Sha256_clonePtr.asFunction<LDKSha256 Function(ffi.Pointer<LDKSha256>)>();

  /// Checks if two Sha256s contain equal inner contents.
  int Sha256_hash(
    ffi.Pointer<LDKSha256> o,
  ) {
    return _Sha256_hash(
      o,
    );
  }

  late final _Sha256_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKSha256>)>>(
          'Sha256_hash');
  late final _Sha256_hash =
      _Sha256_hashPtr.asFunction<int Function(ffi.Pointer<LDKSha256>)>();

  /// Checks if two Sha256s contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool Sha256_eq(
    ffi.Pointer<LDKSha256> a,
    ffi.Pointer<LDKSha256> b,
  ) {
    return _Sha256_eq(
      a,
      b,
    );
  }

  late final _Sha256_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKSha256>, ffi.Pointer<LDKSha256>)>>('Sha256_eq');
  late final _Sha256_eq = _Sha256_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKSha256>, ffi.Pointer<LDKSha256>)>();

  /// Frees any resources used by the Description, if is_owned is set and inner is non-NULL.
  void Description_free(
    LDKDescription this_obj,
  ) {
    return _Description_free(
      this_obj,
    );
  }

  late final _Description_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKDescription)>>(
          'Description_free');
  late final _Description_free =
      _Description_freePtr.asFunction<void Function(LDKDescription)>();

  /// Creates a copy of the Description
  LDKDescription Description_clone(
    ffi.Pointer<LDKDescription> orig,
  ) {
    return _Description_clone(
      orig,
    );
  }

  late final _Description_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKDescription Function(
              ffi.Pointer<LDKDescription>)>>('Description_clone');
  late final _Description_clone = _Description_clonePtr.asFunction<
      LDKDescription Function(ffi.Pointer<LDKDescription>)>();

  /// Checks if two Descriptions contain equal inner contents.
  int Description_hash(
    ffi.Pointer<LDKDescription> o,
  ) {
    return _Description_hash(
      o,
    );
  }

  late final _Description_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKDescription>)>>(
      'Description_hash');
  late final _Description_hash = _Description_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKDescription>)>();

  /// Checks if two Descriptions contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool Description_eq(
    ffi.Pointer<LDKDescription> a,
    ffi.Pointer<LDKDescription> b,
  ) {
    return _Description_eq(
      a,
      b,
    );
  }

  late final _Description_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKDescription>,
              ffi.Pointer<LDKDescription>)>>('Description_eq');
  late final _Description_eq = _Description_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKDescription>, ffi.Pointer<LDKDescription>)>();

  /// Frees any resources used by the PayeePubKey, if is_owned is set and inner is non-NULL.
  void PayeePubKey_free(
    LDKPayeePubKey this_obj,
  ) {
    return _PayeePubKey_free(
      this_obj,
    );
  }

  late final _PayeePubKey_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPayeePubKey)>>(
          'PayeePubKey_free');
  late final _PayeePubKey_free =
      _PayeePubKey_freePtr.asFunction<void Function(LDKPayeePubKey)>();

  LDKPublicKey PayeePubKey_get_a(
    ffi.Pointer<LDKPayeePubKey> this_ptr,
  ) {
    return _PayeePubKey_get_a(
      this_ptr,
    );
  }

  late final _PayeePubKey_get_aPtr = _lookup<
      ffi.NativeFunction<
          LDKPublicKey Function(
              ffi.Pointer<LDKPayeePubKey>)>>('PayeePubKey_get_a');
  late final _PayeePubKey_get_a = _PayeePubKey_get_aPtr.asFunction<
      LDKPublicKey Function(ffi.Pointer<LDKPayeePubKey>)>();

  void PayeePubKey_set_a(
    ffi.Pointer<LDKPayeePubKey> this_ptr,
    LDKPublicKey val,
  ) {
    return _PayeePubKey_set_a(
      this_ptr,
      val,
    );
  }

  late final _PayeePubKey_set_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<LDKPayeePubKey>, LDKPublicKey)>>('PayeePubKey_set_a');
  late final _PayeePubKey_set_a = _PayeePubKey_set_aPtr.asFunction<
      void Function(ffi.Pointer<LDKPayeePubKey>, LDKPublicKey)>();

  /// Constructs a new PayeePubKey given each field
  LDKPayeePubKey PayeePubKey_new(
    LDKPublicKey a_arg,
  ) {
    return _PayeePubKey_new(
      a_arg,
    );
  }

  late final _PayeePubKey_newPtr =
      _lookup<ffi.NativeFunction<LDKPayeePubKey Function(LDKPublicKey)>>(
          'PayeePubKey_new');
  late final _PayeePubKey_new =
      _PayeePubKey_newPtr.asFunction<LDKPayeePubKey Function(LDKPublicKey)>();

  /// Creates a copy of the PayeePubKey
  LDKPayeePubKey PayeePubKey_clone(
    ffi.Pointer<LDKPayeePubKey> orig,
  ) {
    return _PayeePubKey_clone(
      orig,
    );
  }

  late final _PayeePubKey_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPayeePubKey Function(
              ffi.Pointer<LDKPayeePubKey>)>>('PayeePubKey_clone');
  late final _PayeePubKey_clone = _PayeePubKey_clonePtr.asFunction<
      LDKPayeePubKey Function(ffi.Pointer<LDKPayeePubKey>)>();

  /// Checks if two PayeePubKeys contain equal inner contents.
  int PayeePubKey_hash(
    ffi.Pointer<LDKPayeePubKey> o,
  ) {
    return _PayeePubKey_hash(
      o,
    );
  }

  late final _PayeePubKey_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKPayeePubKey>)>>(
      'PayeePubKey_hash');
  late final _PayeePubKey_hash = _PayeePubKey_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKPayeePubKey>)>();

  /// Checks if two PayeePubKeys contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool PayeePubKey_eq(
    ffi.Pointer<LDKPayeePubKey> a,
    ffi.Pointer<LDKPayeePubKey> b,
  ) {
    return _PayeePubKey_eq(
      a,
      b,
    );
  }

  late final _PayeePubKey_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKPayeePubKey>,
              ffi.Pointer<LDKPayeePubKey>)>>('PayeePubKey_eq');
  late final _PayeePubKey_eq = _PayeePubKey_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKPayeePubKey>, ffi.Pointer<LDKPayeePubKey>)>();

  /// Frees any resources used by the ExpiryTime, if is_owned is set and inner is non-NULL.
  void ExpiryTime_free(
    LDKExpiryTime this_obj,
  ) {
    return _ExpiryTime_free(
      this_obj,
    );
  }

  late final _ExpiryTime_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKExpiryTime)>>(
          'ExpiryTime_free');
  late final _ExpiryTime_free =
      _ExpiryTime_freePtr.asFunction<void Function(LDKExpiryTime)>();

  /// Creates a copy of the ExpiryTime
  LDKExpiryTime ExpiryTime_clone(
    ffi.Pointer<LDKExpiryTime> orig,
  ) {
    return _ExpiryTime_clone(
      orig,
    );
  }

  late final _ExpiryTime_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKExpiryTime Function(
              ffi.Pointer<LDKExpiryTime>)>>('ExpiryTime_clone');
  late final _ExpiryTime_clone = _ExpiryTime_clonePtr.asFunction<
      LDKExpiryTime Function(ffi.Pointer<LDKExpiryTime>)>();

  /// Checks if two ExpiryTimes contain equal inner contents.
  int ExpiryTime_hash(
    ffi.Pointer<LDKExpiryTime> o,
  ) {
    return _ExpiryTime_hash(
      o,
    );
  }

  late final _ExpiryTime_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKExpiryTime>)>>(
      'ExpiryTime_hash');
  late final _ExpiryTime_hash = _ExpiryTime_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKExpiryTime>)>();

  /// Checks if two ExpiryTimes contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool ExpiryTime_eq(
    ffi.Pointer<LDKExpiryTime> a,
    ffi.Pointer<LDKExpiryTime> b,
  ) {
    return _ExpiryTime_eq(
      a,
      b,
    );
  }

  late final _ExpiryTime_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKExpiryTime>,
              ffi.Pointer<LDKExpiryTime>)>>('ExpiryTime_eq');
  late final _ExpiryTime_eq = _ExpiryTime_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKExpiryTime>, ffi.Pointer<LDKExpiryTime>)>();

  /// Frees any resources used by the MinFinalCltvExpiry, if is_owned is set and inner is non-NULL.
  void MinFinalCltvExpiry_free(
    LDKMinFinalCltvExpiry this_obj,
  ) {
    return _MinFinalCltvExpiry_free(
      this_obj,
    );
  }

  late final _MinFinalCltvExpiry_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKMinFinalCltvExpiry)>>(
          'MinFinalCltvExpiry_free');
  late final _MinFinalCltvExpiry_free = _MinFinalCltvExpiry_freePtr.asFunction<
      void Function(LDKMinFinalCltvExpiry)>();

  int MinFinalCltvExpiry_get_a(
    ffi.Pointer<LDKMinFinalCltvExpiry> this_ptr,
  ) {
    return _MinFinalCltvExpiry_get_a(
      this_ptr,
    );
  }

  late final _MinFinalCltvExpiry_get_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKMinFinalCltvExpiry>)>>('MinFinalCltvExpiry_get_a');
  late final _MinFinalCltvExpiry_get_a = _MinFinalCltvExpiry_get_aPtr
      .asFunction<int Function(ffi.Pointer<LDKMinFinalCltvExpiry>)>();

  void MinFinalCltvExpiry_set_a(
    ffi.Pointer<LDKMinFinalCltvExpiry> this_ptr,
    int val,
  ) {
    return _MinFinalCltvExpiry_set_a(
      this_ptr,
      val,
    );
  }

  late final _MinFinalCltvExpiry_set_aPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKMinFinalCltvExpiry>,
              ffi.Uint64)>>('MinFinalCltvExpiry_set_a');
  late final _MinFinalCltvExpiry_set_a = _MinFinalCltvExpiry_set_aPtr
      .asFunction<void Function(ffi.Pointer<LDKMinFinalCltvExpiry>, int)>();

  /// Constructs a new MinFinalCltvExpiry given each field
  LDKMinFinalCltvExpiry MinFinalCltvExpiry_new(
    int a_arg,
  ) {
    return _MinFinalCltvExpiry_new(
      a_arg,
    );
  }

  late final _MinFinalCltvExpiry_newPtr =
      _lookup<ffi.NativeFunction<LDKMinFinalCltvExpiry Function(ffi.Uint64)>>(
          'MinFinalCltvExpiry_new');
  late final _MinFinalCltvExpiry_new = _MinFinalCltvExpiry_newPtr.asFunction<
      LDKMinFinalCltvExpiry Function(int)>();

  /// Creates a copy of the MinFinalCltvExpiry
  LDKMinFinalCltvExpiry MinFinalCltvExpiry_clone(
    ffi.Pointer<LDKMinFinalCltvExpiry> orig,
  ) {
    return _MinFinalCltvExpiry_clone(
      orig,
    );
  }

  late final _MinFinalCltvExpiry_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKMinFinalCltvExpiry Function(
              ffi.Pointer<LDKMinFinalCltvExpiry>)>>('MinFinalCltvExpiry_clone');
  late final _MinFinalCltvExpiry_clone =
      _MinFinalCltvExpiry_clonePtr.asFunction<
          LDKMinFinalCltvExpiry Function(ffi.Pointer<LDKMinFinalCltvExpiry>)>();

  /// Checks if two MinFinalCltvExpirys contain equal inner contents.
  int MinFinalCltvExpiry_hash(
    ffi.Pointer<LDKMinFinalCltvExpiry> o,
  ) {
    return _MinFinalCltvExpiry_hash(
      o,
    );
  }

  late final _MinFinalCltvExpiry_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKMinFinalCltvExpiry>)>>('MinFinalCltvExpiry_hash');
  late final _MinFinalCltvExpiry_hash = _MinFinalCltvExpiry_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKMinFinalCltvExpiry>)>();

  /// Checks if two MinFinalCltvExpirys contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool MinFinalCltvExpiry_eq(
    ffi.Pointer<LDKMinFinalCltvExpiry> a,
    ffi.Pointer<LDKMinFinalCltvExpiry> b,
  ) {
    return _MinFinalCltvExpiry_eq(
      a,
      b,
    );
  }

  late final _MinFinalCltvExpiry_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKMinFinalCltvExpiry>,
              ffi.Pointer<LDKMinFinalCltvExpiry>)>>('MinFinalCltvExpiry_eq');
  late final _MinFinalCltvExpiry_eq = _MinFinalCltvExpiry_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKMinFinalCltvExpiry>,
          ffi.Pointer<LDKMinFinalCltvExpiry>)>();

  /// Frees any resources used by the Fallback
  void Fallback_free(
    LDKFallback this_ptr,
  ) {
    return _Fallback_free(
      this_ptr,
    );
  }

  late final _Fallback_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKFallback)>>(
          'Fallback_free');
  late final _Fallback_free =
      _Fallback_freePtr.asFunction<void Function(LDKFallback)>();

  /// Creates a copy of the Fallback
  LDKFallback Fallback_clone(
    ffi.Pointer<LDKFallback> orig,
  ) {
    return _Fallback_clone(
      orig,
    );
  }

  late final _Fallback_clonePtr = _lookup<
          ffi.NativeFunction<LDKFallback Function(ffi.Pointer<LDKFallback>)>>(
      'Fallback_clone');
  late final _Fallback_clone = _Fallback_clonePtr.asFunction<
      LDKFallback Function(ffi.Pointer<LDKFallback>)>();

  /// Utility method to constructs a new SegWitProgram-variant Fallback
  LDKFallback Fallback_seg_wit_program(
    LDKu5 version,
    LDKCVec_u8Z program,
  ) {
    return _Fallback_seg_wit_program(
      version,
      program,
    );
  }

  late final _Fallback_seg_wit_programPtr =
      _lookup<ffi.NativeFunction<LDKFallback Function(LDKu5, LDKCVec_u8Z)>>(
          'Fallback_seg_wit_program');
  late final _Fallback_seg_wit_program = _Fallback_seg_wit_programPtr
      .asFunction<LDKFallback Function(LDKu5, LDKCVec_u8Z)>();

  /// Utility method to constructs a new PubKeyHash-variant Fallback
  LDKFallback Fallback_pub_key_hash(
    LDKTwentyBytes a,
  ) {
    return _Fallback_pub_key_hash(
      a,
    );
  }

  late final _Fallback_pub_key_hashPtr =
      _lookup<ffi.NativeFunction<LDKFallback Function(LDKTwentyBytes)>>(
          'Fallback_pub_key_hash');
  late final _Fallback_pub_key_hash = _Fallback_pub_key_hashPtr.asFunction<
      LDKFallback Function(LDKTwentyBytes)>();

  /// Utility method to constructs a new ScriptHash-variant Fallback
  LDKFallback Fallback_script_hash(
    LDKTwentyBytes a,
  ) {
    return _Fallback_script_hash(
      a,
    );
  }

  late final _Fallback_script_hashPtr =
      _lookup<ffi.NativeFunction<LDKFallback Function(LDKTwentyBytes)>>(
          'Fallback_script_hash');
  late final _Fallback_script_hash = _Fallback_script_hashPtr.asFunction<
      LDKFallback Function(LDKTwentyBytes)>();

  /// Checks if two Fallbacks contain equal inner contents.
  int Fallback_hash(
    ffi.Pointer<LDKFallback> o,
  ) {
    return _Fallback_hash(
      o,
    );
  }

  late final _Fallback_hashPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKFallback>)>>(
      'Fallback_hash');
  late final _Fallback_hash =
      _Fallback_hashPtr.asFunction<int Function(ffi.Pointer<LDKFallback>)>();

  /// Checks if two Fallbacks contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool Fallback_eq(
    ffi.Pointer<LDKFallback> a,
    ffi.Pointer<LDKFallback> b,
  ) {
    return _Fallback_eq(
      a,
      b,
    );
  }

  late final _Fallback_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKFallback>,
              ffi.Pointer<LDKFallback>)>>('Fallback_eq');
  late final _Fallback_eq = _Fallback_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKFallback>, ffi.Pointer<LDKFallback>)>();

  /// Frees any resources used by the InvoiceSignature, if is_owned is set and inner is non-NULL.
  void InvoiceSignature_free(
    LDKInvoiceSignature this_obj,
  ) {
    return _InvoiceSignature_free(
      this_obj,
    );
  }

  late final _InvoiceSignature_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInvoiceSignature)>>(
          'InvoiceSignature_free');
  late final _InvoiceSignature_free = _InvoiceSignature_freePtr.asFunction<
      void Function(LDKInvoiceSignature)>();

  /// Creates a copy of the InvoiceSignature
  LDKInvoiceSignature InvoiceSignature_clone(
    ffi.Pointer<LDKInvoiceSignature> orig,
  ) {
    return _InvoiceSignature_clone(
      orig,
    );
  }

  late final _InvoiceSignature_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKInvoiceSignature Function(
              ffi.Pointer<LDKInvoiceSignature>)>>('InvoiceSignature_clone');
  late final _InvoiceSignature_clone = _InvoiceSignature_clonePtr.asFunction<
      LDKInvoiceSignature Function(ffi.Pointer<LDKInvoiceSignature>)>();

  /// Checks if two InvoiceSignatures contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool InvoiceSignature_eq(
    ffi.Pointer<LDKInvoiceSignature> a,
    ffi.Pointer<LDKInvoiceSignature> b,
  ) {
    return _InvoiceSignature_eq(
      a,
      b,
    );
  }

  late final _InvoiceSignature_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKInvoiceSignature>,
              ffi.Pointer<LDKInvoiceSignature>)>>('InvoiceSignature_eq');
  late final _InvoiceSignature_eq = _InvoiceSignature_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKInvoiceSignature>,
          ffi.Pointer<LDKInvoiceSignature>)>();

  /// Frees any resources used by the PrivateRoute, if is_owned is set and inner is non-NULL.
  void PrivateRoute_free(
    LDKPrivateRoute this_obj,
  ) {
    return _PrivateRoute_free(
      this_obj,
    );
  }

  late final _PrivateRoute_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPrivateRoute)>>(
          'PrivateRoute_free');
  late final _PrivateRoute_free =
      _PrivateRoute_freePtr.asFunction<void Function(LDKPrivateRoute)>();

  /// Creates a copy of the PrivateRoute
  LDKPrivateRoute PrivateRoute_clone(
    ffi.Pointer<LDKPrivateRoute> orig,
  ) {
    return _PrivateRoute_clone(
      orig,
    );
  }

  late final _PrivateRoute_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPrivateRoute Function(
              ffi.Pointer<LDKPrivateRoute>)>>('PrivateRoute_clone');
  late final _PrivateRoute_clone = _PrivateRoute_clonePtr.asFunction<
      LDKPrivateRoute Function(ffi.Pointer<LDKPrivateRoute>)>();

  /// Checks if two PrivateRoutes contain equal inner contents.
  int PrivateRoute_hash(
    ffi.Pointer<LDKPrivateRoute> o,
  ) {
    return _PrivateRoute_hash(
      o,
    );
  }

  late final _PrivateRoute_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKPrivateRoute>)>>('PrivateRoute_hash');
  late final _PrivateRoute_hash = _PrivateRoute_hashPtr.asFunction<
      int Function(ffi.Pointer<LDKPrivateRoute>)>();

  /// Checks if two PrivateRoutes contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  /// Two objects with NULL inner values will be considered "equal" here.
  bool PrivateRoute_eq(
    ffi.Pointer<LDKPrivateRoute> a,
    ffi.Pointer<LDKPrivateRoute> b,
  ) {
    return _PrivateRoute_eq(
      a,
      b,
    );
  }

  late final _PrivateRoute_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKPrivateRoute>,
              ffi.Pointer<LDKPrivateRoute>)>>('PrivateRoute_eq');
  late final _PrivateRoute_eq = _PrivateRoute_eqPtr.asFunction<
      bool Function(
          ffi.Pointer<LDKPrivateRoute>, ffi.Pointer<LDKPrivateRoute>)>();

  /// Disassembles the `SignedRawInvoice` into its three parts:
  /// 1. raw invoice
  /// 2. hash of the raw invoice
  /// 3. signature
  LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ SignedRawInvoice_into_parts(
    LDKSignedRawInvoice this_arg,
  ) {
    return _SignedRawInvoice_into_parts(
      this_arg,
    );
  }

  late final _SignedRawInvoice_into_partsPtr = _lookup<
      ffi.NativeFunction<
          LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
              LDKSignedRawInvoice)>>('SignedRawInvoice_into_parts');
  late final _SignedRawInvoice_into_parts =
      _SignedRawInvoice_into_partsPtr.asFunction<
          LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ Function(
              LDKSignedRawInvoice)>();

  /// The `RawInvoice` which was signed.
  LDKRawInvoice SignedRawInvoice_raw_invoice(
    ffi.Pointer<LDKSignedRawInvoice> this_arg,
  ) {
    return _SignedRawInvoice_raw_invoice(
      this_arg,
    );
  }

  late final _SignedRawInvoice_raw_invoicePtr = _lookup<
          ffi.NativeFunction<
              LDKRawInvoice Function(ffi.Pointer<LDKSignedRawInvoice>)>>(
      'SignedRawInvoice_raw_invoice');
  late final _SignedRawInvoice_raw_invoice = _SignedRawInvoice_raw_invoicePtr
      .asFunction<LDKRawInvoice Function(ffi.Pointer<LDKSignedRawInvoice>)>();

  /// The hash of the `RawInvoice` that was signed.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> SignedRawInvoice_hash(
    ffi.Pointer<LDKSignedRawInvoice> this_arg,
  ) {
    return _SignedRawInvoice_hash(
      this_arg,
    );
  }

  late final _SignedRawInvoice_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKSignedRawInvoice>)>>('SignedRawInvoice_hash');
  late final _SignedRawInvoice_hash = _SignedRawInvoice_hashPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
          ffi.Pointer<LDKSignedRawInvoice>)>();

  /// InvoiceSignature for the invoice.
  LDKInvoiceSignature SignedRawInvoice_signature(
    ffi.Pointer<LDKSignedRawInvoice> this_arg,
  ) {
    return _SignedRawInvoice_signature(
      this_arg,
    );
  }

  late final _SignedRawInvoice_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKInvoiceSignature Function(
              ffi.Pointer<LDKSignedRawInvoice>)>>('SignedRawInvoice_signature');
  late final _SignedRawInvoice_signature =
      _SignedRawInvoice_signaturePtr.asFunction<
          LDKInvoiceSignature Function(ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Recovers the public key used for signing the invoice from the recoverable signature.
  LDKCResult_PayeePubKeyErrorZ SignedRawInvoice_recover_payee_pub_key(
    ffi.Pointer<LDKSignedRawInvoice> this_arg,
  ) {
    return _SignedRawInvoice_recover_payee_pub_key(
      this_arg,
    );
  }

  late final _SignedRawInvoice_recover_payee_pub_keyPtr = _lookup<
          ffi.NativeFunction<
              LDKCResult_PayeePubKeyErrorZ Function(
                  ffi.Pointer<LDKSignedRawInvoice>)>>(
      'SignedRawInvoice_recover_payee_pub_key');
  late final _SignedRawInvoice_recover_payee_pub_key =
      _SignedRawInvoice_recover_payee_pub_keyPtr.asFunction<
          LDKCResult_PayeePubKeyErrorZ Function(
              ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Checks if the signature is valid for the included payee public key or if none exists if it's
  /// valid for the recovered signature (which should always be true?).
  bool SignedRawInvoice_check_signature(
    ffi.Pointer<LDKSignedRawInvoice> this_arg,
  ) {
    return _SignedRawInvoice_check_signature(
      this_arg,
    );
  }

  late final _SignedRawInvoice_check_signaturePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKSignedRawInvoice>)>>(
      'SignedRawInvoice_check_signature');
  late final _SignedRawInvoice_check_signature =
      _SignedRawInvoice_check_signaturePtr.asFunction<
          bool Function(ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Calculate the hash of the encoded `RawInvoice`
  LDKThirtyTwoBytes RawInvoice_hash(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_hash(
      this_arg,
    );
  }

  late final _RawInvoice_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_hash');
  late final _RawInvoice_hash = _RawInvoice_hashPtr.asFunction<
      LDKThirtyTwoBytes Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKSha256 RawInvoice_payment_hash(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_payment_hash(
      this_arg,
    );
  }

  late final _RawInvoice_payment_hashPtr = _lookup<
          ffi.NativeFunction<LDKSha256 Function(ffi.Pointer<LDKRawInvoice>)>>(
      'RawInvoice_payment_hash');
  late final _RawInvoice_payment_hash = _RawInvoice_payment_hashPtr.asFunction<
      LDKSha256 Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKDescription RawInvoice_description(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_description(
      this_arg,
    );
  }

  late final _RawInvoice_descriptionPtr = _lookup<
      ffi.NativeFunction<
          LDKDescription Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_description');
  late final _RawInvoice_description = _RawInvoice_descriptionPtr.asFunction<
      LDKDescription Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKPayeePubKey RawInvoice_payee_pub_key(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_payee_pub_key(
      this_arg,
    );
  }

  late final _RawInvoice_payee_pub_keyPtr = _lookup<
      ffi.NativeFunction<
          LDKPayeePubKey Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_payee_pub_key');
  late final _RawInvoice_payee_pub_key = _RawInvoice_payee_pub_keyPtr
      .asFunction<LDKPayeePubKey Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKSha256 RawInvoice_description_hash(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_description_hash(
      this_arg,
    );
  }

  late final _RawInvoice_description_hashPtr = _lookup<
          ffi.NativeFunction<LDKSha256 Function(ffi.Pointer<LDKRawInvoice>)>>(
      'RawInvoice_description_hash');
  late final _RawInvoice_description_hash = _RawInvoice_description_hashPtr
      .asFunction<LDKSha256 Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKExpiryTime RawInvoice_expiry_time(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_expiry_time(
      this_arg,
    );
  }

  late final _RawInvoice_expiry_timePtr = _lookup<
      ffi.NativeFunction<
          LDKExpiryTime Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_expiry_time');
  late final _RawInvoice_expiry_time = _RawInvoice_expiry_timePtr.asFunction<
      LDKExpiryTime Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKMinFinalCltvExpiry RawInvoice_min_final_cltv_expiry(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_min_final_cltv_expiry(
      this_arg,
    );
  }

  late final _RawInvoice_min_final_cltv_expiryPtr = _lookup<
      ffi.NativeFunction<
          LDKMinFinalCltvExpiry Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_min_final_cltv_expiry');
  late final _RawInvoice_min_final_cltv_expiry =
      _RawInvoice_min_final_cltv_expiryPtr.asFunction<
          LDKMinFinalCltvExpiry Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKThirtyTwoBytes RawInvoice_payment_secret(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_payment_secret(
      this_arg,
    );
  }

  late final _RawInvoice_payment_secretPtr = _lookup<
      ffi.NativeFunction<
          LDKThirtyTwoBytes Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_payment_secret');
  late final _RawInvoice_payment_secret = _RawInvoice_payment_secretPtr
      .asFunction<LDKThirtyTwoBytes Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKInvoiceFeatures RawInvoice_features(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_features(
      this_arg,
    );
  }

  late final _RawInvoice_featuresPtr = _lookup<
      ffi.NativeFunction<
          LDKInvoiceFeatures Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_features');
  late final _RawInvoice_features = _RawInvoice_featuresPtr.asFunction<
      LDKInvoiceFeatures Function(ffi.Pointer<LDKRawInvoice>)>();

  LDKCVec_PrivateRouteZ RawInvoice_private_routes(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_private_routes(
      this_arg,
    );
  }

  late final _RawInvoice_private_routesPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_PrivateRouteZ Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_private_routes');
  late final _RawInvoice_private_routes = _RawInvoice_private_routesPtr
      .asFunction<LDKCVec_PrivateRouteZ Function(ffi.Pointer<LDKRawInvoice>)>();

  LDKCOption_u64Z RawInvoice_amount_pico_btc(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_amount_pico_btc(
      this_arg,
    );
  }

  late final _RawInvoice_amount_pico_btcPtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u64Z Function(
              ffi.Pointer<LDKRawInvoice>)>>('RawInvoice_amount_pico_btc');
  late final _RawInvoice_amount_pico_btc = _RawInvoice_amount_pico_btcPtr
      .asFunction<LDKCOption_u64Z Function(ffi.Pointer<LDKRawInvoice>)>();

  int RawInvoice_currency(
    ffi.Pointer<LDKRawInvoice> this_arg,
  ) {
    return _RawInvoice_currency(
      this_arg,
    );
  }

  late final _RawInvoice_currencyPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<LDKRawInvoice>)>>(
      'RawInvoice_currency');
  late final _RawInvoice_currency = _RawInvoice_currencyPtr.asFunction<
      int Function(ffi.Pointer<LDKRawInvoice>)>();

  /// Creates a `PositiveTimestamp` from a Unix timestamp in the range `0..=MAX_TIMESTAMP`.
  ///
  /// Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
  LDKCResult_PositiveTimestampCreationErrorZ
      PositiveTimestamp_from_unix_timestamp(
    int unix_seconds,
  ) {
    return _PositiveTimestamp_from_unix_timestamp(
      unix_seconds,
    );
  }

  late final _PositiveTimestamp_from_unix_timestampPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              ffi.Uint64)>>('PositiveTimestamp_from_unix_timestamp');
  late final _PositiveTimestamp_from_unix_timestamp =
      _PositiveTimestamp_from_unix_timestampPtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(int)>();

  /// Creates a `PositiveTimestamp` from a [`SystemTime`] with a corresponding Unix timestamp in
  /// the range `0..=MAX_TIMESTAMP`.
  ///
  /// Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
  LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_system_time(
    int time,
  ) {
    return _PositiveTimestamp_from_system_time(
      time,
    );
  }

  late final _PositiveTimestamp_from_system_timePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              ffi.Uint64)>>('PositiveTimestamp_from_system_time');
  late final _PositiveTimestamp_from_system_time =
      _PositiveTimestamp_from_system_timePtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(int)>();

  /// Creates a `PositiveTimestamp` from a [`Duration`] since the Unix epoch in the range
  /// `0..=MAX_TIMESTAMP`.
  ///
  /// Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
  LDKCResult_PositiveTimestampCreationErrorZ
      PositiveTimestamp_from_duration_since_epoch(
    int duration,
  ) {
    return _PositiveTimestamp_from_duration_since_epoch(
      duration,
    );
  }

  late final _PositiveTimestamp_from_duration_since_epochPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(
              ffi.Uint64)>>('PositiveTimestamp_from_duration_since_epoch');
  late final _PositiveTimestamp_from_duration_since_epoch =
      _PositiveTimestamp_from_duration_since_epochPtr.asFunction<
          LDKCResult_PositiveTimestampCreationErrorZ Function(int)>();

  /// Returns the Unix timestamp representing the stored time
  int PositiveTimestamp_as_unix_timestamp(
    ffi.Pointer<LDKPositiveTimestamp> this_arg,
  ) {
    return _PositiveTimestamp_as_unix_timestamp(
      this_arg,
    );
  }

  late final _PositiveTimestamp_as_unix_timestampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKPositiveTimestamp>)>>(
      'PositiveTimestamp_as_unix_timestamp');
  late final _PositiveTimestamp_as_unix_timestamp =
      _PositiveTimestamp_as_unix_timestampPtr.asFunction<
          int Function(ffi.Pointer<LDKPositiveTimestamp>)>();

  /// Returns the duration of the stored time since the Unix epoch
  int PositiveTimestamp_as_duration_since_epoch(
    ffi.Pointer<LDKPositiveTimestamp> this_arg,
  ) {
    return _PositiveTimestamp_as_duration_since_epoch(
      this_arg,
    );
  }

  late final _PositiveTimestamp_as_duration_since_epochPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<LDKPositiveTimestamp>)>>(
      'PositiveTimestamp_as_duration_since_epoch');
  late final _PositiveTimestamp_as_duration_since_epoch =
      _PositiveTimestamp_as_duration_since_epochPtr.asFunction<
          int Function(ffi.Pointer<LDKPositiveTimestamp>)>();

  /// Returns the [`SystemTime`] representing the stored time
  int PositiveTimestamp_as_time(
    ffi.Pointer<LDKPositiveTimestamp> this_arg,
  ) {
    return _PositiveTimestamp_as_time(
      this_arg,
    );
  }

  late final _PositiveTimestamp_as_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<LDKPositiveTimestamp>)>>('PositiveTimestamp_as_time');
  late final _PositiveTimestamp_as_time = _PositiveTimestamp_as_timePtr
      .asFunction<int Function(ffi.Pointer<LDKPositiveTimestamp>)>();

  /// Transform the `Invoice` into it's unchecked version
  LDKSignedRawInvoice Invoice_into_signed_raw(
    LDKInvoice this_arg,
  ) {
    return _Invoice_into_signed_raw(
      this_arg,
    );
  }

  late final _Invoice_into_signed_rawPtr =
      _lookup<ffi.NativeFunction<LDKSignedRawInvoice Function(LDKInvoice)>>(
          'Invoice_into_signed_raw');
  late final _Invoice_into_signed_raw = _Invoice_into_signed_rawPtr.asFunction<
      LDKSignedRawInvoice Function(LDKInvoice)>();

  /// Check that the invoice is signed correctly and that key recovery works
  LDKCResult_NoneSemanticErrorZ Invoice_check_signature(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_check_signature(
      this_arg,
    );
  }

  late final _Invoice_check_signaturePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_NoneSemanticErrorZ Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_check_signature');
  late final _Invoice_check_signature = _Invoice_check_signaturePtr.asFunction<
      LDKCResult_NoneSemanticErrorZ Function(ffi.Pointer<LDKInvoice>)>();

  /// Constructs an `Invoice` from a `SignedRawInvoice` by checking all its invariants.
  /// ```
  /// use lightning_invoice::*;
  ///
  /// let invoice = \"lnbc100p1psj9jhxdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4q0d3p2sfluzdx45tqcs\\
  /// h2pu5qc7lgq0xs578ngs6s0s68ua4h7cvspp5q6rmq35js88zp5dvwrv9m459tnk2zunwj5jalqtyxqulh0l\\
  /// 5gflssp5nf55ny5gcrfl30xuhzj3nphgj27rstekmr9fw3ny5989s300gyus9qyysgqcqpcrzjqw2sxwe993\\
  /// h5pcm4dxzpvttgza8zhkqxpgffcrf5v25nwpr3cmfg7z54kuqq8rgqqqqqqqq2qqqqq9qq9qrzjqd0ylaqcl\\
  /// j9424x9m8h2vcukcgnm6s56xfgu3j78zyqzhgs4hlpzvznlugqq9vsqqqqqqqlgqqqqqeqq9qrzjqwldmj9d\\
  /// ha74df76zhx6l9we0vjdquygcdt3kssupehe64g6yyp5yz5rhuqqwccqqyqqqqlgqqqqjcqq9qrzjqf9e58a\\
  /// guqr0rcun0ajlvmzq3ek63cw2w282gv3z5uupmuwvgjtq2z55qsqqg6qqqyqqqrtnqqqzq3cqygrzjqvphms\\
  /// ywntrrhqjcraumvc4y6r8v4z5v593trte429v4hredj7ms5z52usqq9ngqqqqqqqlgqqqqqqgq9qrzjq2v0v\\
  /// p62g49p7569ev48cmulecsxe59lvaw3wlxm7r982zxa9zzj7z5l0cqqxusqqyqqqqlgqqqqqzsqygarl9fh3\\
  /// 8s0gyuxjjgux34w75dnc6xp2l35j7es3jd4ugt3lu0xzre26yg5m7ke54n2d5sym4xcmxtl8238xxvw5h5h5\\
  /// j5r6drg6k6zcqj0fcwg\";
  ///
  /// let signed = invoice.parse::<SignedRawInvoice>().unwrap();
  ///
  /// assert!(Invoice::from_signed(signed).is_ok());
  /// ```
  LDKCResult_InvoiceSemanticErrorZ Invoice_from_signed(
    LDKSignedRawInvoice signed_invoice,
  ) {
    return _Invoice_from_signed(
      signed_invoice,
    );
  }

  late final _Invoice_from_signedPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSemanticErrorZ Function(
              LDKSignedRawInvoice)>>('Invoice_from_signed');
  late final _Invoice_from_signed = _Invoice_from_signedPtr.asFunction<
      LDKCResult_InvoiceSemanticErrorZ Function(LDKSignedRawInvoice)>();

  /// Returns the `Invoice`'s timestamp (should equal its creation time)
  int Invoice_timestamp(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_timestamp(
      this_arg,
    );
  }

  late final _Invoice_timestampPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_timestamp');
  late final _Invoice_timestamp =
      _Invoice_timestampPtr.asFunction<int Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns the `Invoice`'s timestamp as a duration since the Unix epoch
  int Invoice_duration_since_epoch(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_duration_since_epoch(
      this_arg,
    );
  }

  late final _Invoice_duration_since_epochPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_duration_since_epoch');
  late final _Invoice_duration_since_epoch = _Invoice_duration_since_epochPtr
      .asFunction<int Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns the hash to which we will receive the preimage on completion of the payment
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> Invoice_payment_hash(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_payment_hash(
      this_arg,
    );
  }

  late final _Invoice_payment_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_payment_hash');
  late final _Invoice_payment_hash = _Invoice_payment_hashPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(ffi.Pointer<LDKInvoice>)>();

  /// Get the payee's public key if one was included in the invoice
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKPublicKey Invoice_payee_pub_key(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_payee_pub_key(
      this_arg,
    );
  }

  late final _Invoice_payee_pub_keyPtr = _lookup<
          ffi.NativeFunction<LDKPublicKey Function(ffi.Pointer<LDKInvoice>)>>(
      'Invoice_payee_pub_key');
  late final _Invoice_payee_pub_key = _Invoice_payee_pub_keyPtr.asFunction<
      LDKPublicKey Function(ffi.Pointer<LDKInvoice>)>();

  /// Get the payment secret if one was included in the invoice
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> Invoice_payment_secret(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_payment_secret(
      this_arg,
    );
  }

  late final _Invoice_payment_secretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_payment_secret');
  late final _Invoice_payment_secret = _Invoice_payment_secretPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> Function(ffi.Pointer<LDKInvoice>)>();

  /// Get the invoice features if they were included in the invoice
  ///
  /// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKInvoiceFeatures Invoice_features(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_features(
      this_arg,
    );
  }

  late final _Invoice_featuresPtr = _lookup<
      ffi.NativeFunction<
          LDKInvoiceFeatures Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_features');
  late final _Invoice_features = _Invoice_featuresPtr.asFunction<
      LDKInvoiceFeatures Function(ffi.Pointer<LDKInvoice>)>();

  /// Recover the payee's public key (only to be used if none was included in the invoice)
  LDKPublicKey Invoice_recover_payee_pub_key(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_recover_payee_pub_key(
      this_arg,
    );
  }

  late final _Invoice_recover_payee_pub_keyPtr = _lookup<
          ffi.NativeFunction<LDKPublicKey Function(ffi.Pointer<LDKInvoice>)>>(
      'Invoice_recover_payee_pub_key');
  late final _Invoice_recover_payee_pub_key = _Invoice_recover_payee_pub_keyPtr
      .asFunction<LDKPublicKey Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
  int Invoice_expiry_time(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_expiry_time(
      this_arg,
    );
  }

  late final _Invoice_expiry_timePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_expiry_time');
  late final _Invoice_expiry_time = _Invoice_expiry_timePtr.asFunction<
      int Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns whether the invoice has expired.
  bool Invoice_is_expired(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_is_expired(
      this_arg,
    );
  }

  late final _Invoice_is_expiredPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_is_expired');
  late final _Invoice_is_expired = _Invoice_is_expiredPtr.asFunction<
      bool Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns whether the expiry time would pass at the given point in time.
  /// `at_time` is the timestamp as a duration since the Unix epoch.
  bool Invoice_would_expire(
    ffi.Pointer<LDKInvoice> this_arg,
    int at_time,
  ) {
    return _Invoice_would_expire(
      this_arg,
      at_time,
    );
  }

  late final _Invoice_would_expirePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKInvoice>, ffi.Uint64)>>('Invoice_would_expire');
  late final _Invoice_would_expire = _Invoice_would_expirePtr.asFunction<
      bool Function(ffi.Pointer<LDKInvoice>, int)>();

  /// Returns the invoice's `min_final_cltv_expiry` time, if present, otherwise
  /// [`DEFAULT_MIN_FINAL_CLTV_EXPIRY`].
  int Invoice_min_final_cltv_expiry(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_min_final_cltv_expiry(
      this_arg,
    );
  }

  late final _Invoice_min_final_cltv_expiryPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_min_final_cltv_expiry');
  late final _Invoice_min_final_cltv_expiry = _Invoice_min_final_cltv_expiryPtr
      .asFunction<int Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns a list of all routes included in the invoice
  LDKCVec_PrivateRouteZ Invoice_private_routes(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_private_routes(
      this_arg,
    );
  }

  late final _Invoice_private_routesPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_PrivateRouteZ Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_private_routes');
  late final _Invoice_private_routes = _Invoice_private_routesPtr.asFunction<
      LDKCVec_PrivateRouteZ Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns a list of all routes included in the invoice as the underlying hints
  LDKCVec_RouteHintZ Invoice_route_hints(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_route_hints(
      this_arg,
    );
  }

  late final _Invoice_route_hintsPtr = _lookup<
      ffi.NativeFunction<
          LDKCVec_RouteHintZ Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_route_hints');
  late final _Invoice_route_hints = _Invoice_route_hintsPtr.asFunction<
      LDKCVec_RouteHintZ Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns the currency for which the invoice was issued
  int Invoice_currency(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_currency(
      this_arg,
    );
  }

  late final _Invoice_currencyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_currency');
  late final _Invoice_currency =
      _Invoice_currencyPtr.asFunction<int Function(ffi.Pointer<LDKInvoice>)>();

  /// Returns the amount if specified in the invoice as millisatoshis.
  LDKCOption_u64Z Invoice_amount_milli_satoshis(
    ffi.Pointer<LDKInvoice> this_arg,
  ) {
    return _Invoice_amount_milli_satoshis(
      this_arg,
    );
  }

  late final _Invoice_amount_milli_satoshisPtr = _lookup<
      ffi.NativeFunction<
          LDKCOption_u64Z Function(
              ffi.Pointer<LDKInvoice>)>>('Invoice_amount_milli_satoshis');
  late final _Invoice_amount_milli_satoshis = _Invoice_amount_milli_satoshisPtr
      .asFunction<LDKCOption_u64Z Function(ffi.Pointer<LDKInvoice>)>();

  /// Creates a new `Description` if `description` is at most 1023 __bytes__ long,
  /// returns `CreationError::DescriptionTooLong` otherwise
  ///
  /// Please note that single characters may use more than one byte due to UTF8 encoding.
  LDKCResult_DescriptionCreationErrorZ Description_new(
    LDKStr description,
  ) {
    return _Description_new(
      description,
    );
  }

  late final _Description_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_DescriptionCreationErrorZ Function(
              LDKStr)>>('Description_new');
  late final _Description_new = _Description_newPtr.asFunction<
      LDKCResult_DescriptionCreationErrorZ Function(LDKStr)>();

  /// Returns the underlying description `String`
  LDKStr Description_into_inner(
    LDKDescription this_arg,
  ) {
    return _Description_into_inner(
      this_arg,
    );
  }

  late final _Description_into_innerPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(LDKDescription)>>(
          'Description_into_inner');
  late final _Description_into_inner =
      _Description_into_innerPtr.asFunction<LDKStr Function(LDKDescription)>();

  /// Construct an `ExpiryTime` from seconds.
  LDKExpiryTime ExpiryTime_from_seconds(
    int seconds,
  ) {
    return _ExpiryTime_from_seconds(
      seconds,
    );
  }

  late final _ExpiryTime_from_secondsPtr =
      _lookup<ffi.NativeFunction<LDKExpiryTime Function(ffi.Uint64)>>(
          'ExpiryTime_from_seconds');
  late final _ExpiryTime_from_seconds =
      _ExpiryTime_from_secondsPtr.asFunction<LDKExpiryTime Function(int)>();

  /// Construct an `ExpiryTime` from a `Duration`.
  LDKExpiryTime ExpiryTime_from_duration(
    int duration,
  ) {
    return _ExpiryTime_from_duration(
      duration,
    );
  }

  late final _ExpiryTime_from_durationPtr =
      _lookup<ffi.NativeFunction<LDKExpiryTime Function(ffi.Uint64)>>(
          'ExpiryTime_from_duration');
  late final _ExpiryTime_from_duration =
      _ExpiryTime_from_durationPtr.asFunction<LDKExpiryTime Function(int)>();

  /// Returns the expiry time in seconds
  int ExpiryTime_as_seconds(
    ffi.Pointer<LDKExpiryTime> this_arg,
  ) {
    return _ExpiryTime_as_seconds(
      this_arg,
    );
  }

  late final _ExpiryTime_as_secondsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKExpiryTime>)>>(
      'ExpiryTime_as_seconds');
  late final _ExpiryTime_as_seconds = _ExpiryTime_as_secondsPtr.asFunction<
      int Function(ffi.Pointer<LDKExpiryTime>)>();

  /// Returns a reference to the underlying `Duration` (=expiry time)
  int ExpiryTime_as_duration(
    ffi.Pointer<LDKExpiryTime> this_arg,
  ) {
    return _ExpiryTime_as_duration(
      this_arg,
    );
  }

  late final _ExpiryTime_as_durationPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKExpiryTime>)>>(
      'ExpiryTime_as_duration');
  late final _ExpiryTime_as_duration = _ExpiryTime_as_durationPtr.asFunction<
      int Function(ffi.Pointer<LDKExpiryTime>)>();

  /// Creates a new (partial) route from a list of hops
  LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(
    LDKRouteHint hops,
  ) {
    return _PrivateRoute_new(
      hops,
    );
  }

  late final _PrivateRoute_newPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PrivateRouteCreationErrorZ Function(
              LDKRouteHint)>>('PrivateRoute_new');
  late final _PrivateRoute_new = _PrivateRoute_newPtr.asFunction<
      LDKCResult_PrivateRouteCreationErrorZ Function(LDKRouteHint)>();

  /// Returns the underlying list of hops
  LDKRouteHint PrivateRoute_into_inner(
    LDKPrivateRoute this_arg,
  ) {
    return _PrivateRoute_into_inner(
      this_arg,
    );
  }

  late final _PrivateRoute_into_innerPtr =
      _lookup<ffi.NativeFunction<LDKRouteHint Function(LDKPrivateRoute)>>(
          'PrivateRoute_into_inner');
  late final _PrivateRoute_into_inner = _PrivateRoute_into_innerPtr.asFunction<
      LDKRouteHint Function(LDKPrivateRoute)>();

  /// Creates a copy of the CreationError
  int CreationError_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _CreationError_clone(
      orig,
    );
  }

  late final _CreationError_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'CreationError_clone');
  late final _CreationError_clone = _CreationError_clonePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new DescriptionTooLong-variant CreationError
  int CreationError_description_too_long() {
    return _CreationError_description_too_long();
  }

  late final _CreationError_description_too_longPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'CreationError_description_too_long');
  late final _CreationError_description_too_long =
      _CreationError_description_too_longPtr.asFunction<int Function()>();

  /// Utility method to constructs a new RouteTooLong-variant CreationError
  int CreationError_route_too_long() {
    return _CreationError_route_too_long();
  }

  late final _CreationError_route_too_longPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'CreationError_route_too_long');
  late final _CreationError_route_too_long =
      _CreationError_route_too_longPtr.asFunction<int Function()>();

  /// Utility method to constructs a new TimestampOutOfBounds-variant CreationError
  int CreationError_timestamp_out_of_bounds() {
    return _CreationError_timestamp_out_of_bounds();
  }

  late final _CreationError_timestamp_out_of_boundsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'CreationError_timestamp_out_of_bounds');
  late final _CreationError_timestamp_out_of_bounds =
      _CreationError_timestamp_out_of_boundsPtr.asFunction<int Function()>();

  /// Utility method to constructs a new InvalidAmount-variant CreationError
  int CreationError_invalid_amount() {
    return _CreationError_invalid_amount();
  }

  late final _CreationError_invalid_amountPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'CreationError_invalid_amount');
  late final _CreationError_invalid_amount =
      _CreationError_invalid_amountPtr.asFunction<int Function()>();

  /// Utility method to constructs a new MissingRouteHints-variant CreationError
  int CreationError_missing_route_hints() {
    return _CreationError_missing_route_hints();
  }

  late final _CreationError_missing_route_hintsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'CreationError_missing_route_hints');
  late final _CreationError_missing_route_hints =
      _CreationError_missing_route_hintsPtr.asFunction<int Function()>();

  /// Checks if two CreationErrors contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool CreationError_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _CreationError_eq(
      a,
      b,
    );
  }

  late final _CreationError_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('CreationError_eq');
  late final _CreationError_eq = _CreationError_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Get the string representation of a CreationError object
  LDKStr CreationError_to_str(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _CreationError_to_str(
      o,
    );
  }

  late final _CreationError_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>>(
          'CreationError_to_str');
  late final _CreationError_to_str = _CreationError_to_strPtr.asFunction<
      LDKStr Function(ffi.Pointer<ffi.Int32>)>();

  /// Creates a copy of the SemanticError
  int SemanticError_clone(
    ffi.Pointer<ffi.Int32> orig,
  ) {
    return _SemanticError_clone(
      orig,
    );
  }

  late final _SemanticError_clonePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int32>)>>(
          'SemanticError_clone');
  late final _SemanticError_clone = _SemanticError_clonePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>)>();

  /// Utility method to constructs a new NoPaymentHash-variant SemanticError
  int SemanticError_no_payment_hash() {
    return _SemanticError_no_payment_hash();
  }

  late final _SemanticError_no_payment_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_no_payment_hash');
  late final _SemanticError_no_payment_hash =
      _SemanticError_no_payment_hashPtr.asFunction<int Function()>();

  /// Utility method to constructs a new MultiplePaymentHashes-variant SemanticError
  int SemanticError_multiple_payment_hashes() {
    return _SemanticError_multiple_payment_hashes();
  }

  late final _SemanticError_multiple_payment_hashesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_multiple_payment_hashes');
  late final _SemanticError_multiple_payment_hashes =
      _SemanticError_multiple_payment_hashesPtr.asFunction<int Function()>();

  /// Utility method to constructs a new NoDescription-variant SemanticError
  int SemanticError_no_description() {
    return _SemanticError_no_description();
  }

  late final _SemanticError_no_descriptionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_no_description');
  late final _SemanticError_no_description =
      _SemanticError_no_descriptionPtr.asFunction<int Function()>();

  /// Utility method to constructs a new MultipleDescriptions-variant SemanticError
  int SemanticError_multiple_descriptions() {
    return _SemanticError_multiple_descriptions();
  }

  late final _SemanticError_multiple_descriptionsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_multiple_descriptions');
  late final _SemanticError_multiple_descriptions =
      _SemanticError_multiple_descriptionsPtr.asFunction<int Function()>();

  /// Utility method to constructs a new NoPaymentSecret-variant SemanticError
  int SemanticError_no_payment_secret() {
    return _SemanticError_no_payment_secret();
  }

  late final _SemanticError_no_payment_secretPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_no_payment_secret');
  late final _SemanticError_no_payment_secret =
      _SemanticError_no_payment_secretPtr.asFunction<int Function()>();

  /// Utility method to constructs a new MultiplePaymentSecrets-variant SemanticError
  int SemanticError_multiple_payment_secrets() {
    return _SemanticError_multiple_payment_secrets();
  }

  late final _SemanticError_multiple_payment_secretsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_multiple_payment_secrets');
  late final _SemanticError_multiple_payment_secrets =
      _SemanticError_multiple_payment_secretsPtr.asFunction<int Function()>();

  /// Utility method to constructs a new InvalidFeatures-variant SemanticError
  int SemanticError_invalid_features() {
    return _SemanticError_invalid_features();
  }

  late final _SemanticError_invalid_featuresPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_invalid_features');
  late final _SemanticError_invalid_features =
      _SemanticError_invalid_featuresPtr.asFunction<int Function()>();

  /// Utility method to constructs a new InvalidRecoveryId-variant SemanticError
  int SemanticError_invalid_recovery_id() {
    return _SemanticError_invalid_recovery_id();
  }

  late final _SemanticError_invalid_recovery_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_invalid_recovery_id');
  late final _SemanticError_invalid_recovery_id =
      _SemanticError_invalid_recovery_idPtr.asFunction<int Function()>();

  /// Utility method to constructs a new InvalidSignature-variant SemanticError
  int SemanticError_invalid_signature() {
    return _SemanticError_invalid_signature();
  }

  late final _SemanticError_invalid_signaturePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_invalid_signature');
  late final _SemanticError_invalid_signature =
      _SemanticError_invalid_signaturePtr.asFunction<int Function()>();

  /// Utility method to constructs a new ImpreciseAmount-variant SemanticError
  int SemanticError_imprecise_amount() {
    return _SemanticError_imprecise_amount();
  }

  late final _SemanticError_imprecise_amountPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SemanticError_imprecise_amount');
  late final _SemanticError_imprecise_amount =
      _SemanticError_imprecise_amountPtr.asFunction<int Function()>();

  /// Checks if two SemanticErrors contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool SemanticError_eq(
    ffi.Pointer<ffi.Int32> a,
    ffi.Pointer<ffi.Int32> b,
  ) {
    return _SemanticError_eq(
      a,
      b,
    );
  }

  late final _SemanticError_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('SemanticError_eq');
  late final _SemanticError_eq = _SemanticError_eqPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  /// Get the string representation of a SemanticError object
  LDKStr SemanticError_to_str(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _SemanticError_to_str(
      o,
    );
  }

  late final _SemanticError_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>>(
          'SemanticError_to_str');
  late final _SemanticError_to_str = _SemanticError_to_strPtr.asFunction<
      LDKStr Function(ffi.Pointer<ffi.Int32>)>();

  /// Frees any resources used by the SignOrCreationError
  void SignOrCreationError_free(
    LDKSignOrCreationError this_ptr,
  ) {
    return _SignOrCreationError_free(
      this_ptr,
    );
  }

  late final _SignOrCreationError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKSignOrCreationError)>>(
          'SignOrCreationError_free');
  late final _SignOrCreationError_free = _SignOrCreationError_freePtr
      .asFunction<void Function(LDKSignOrCreationError)>();

  /// Creates a copy of the SignOrCreationError
  LDKSignOrCreationError SignOrCreationError_clone(
    ffi.Pointer<LDKSignOrCreationError> orig,
  ) {
    return _SignOrCreationError_clone(
      orig,
    );
  }

  late final _SignOrCreationError_clonePtr = _lookup<
          ffi.NativeFunction<
              LDKSignOrCreationError Function(
                  ffi.Pointer<LDKSignOrCreationError>)>>(
      'SignOrCreationError_clone');
  late final _SignOrCreationError_clone =
      _SignOrCreationError_clonePtr.asFunction<
          LDKSignOrCreationError Function(
              ffi.Pointer<LDKSignOrCreationError>)>();

  /// Utility method to constructs a new SignError-variant SignOrCreationError
  LDKSignOrCreationError SignOrCreationError_sign_error() {
    return _SignOrCreationError_sign_error();
  }

  late final _SignOrCreationError_sign_errorPtr =
      _lookup<ffi.NativeFunction<LDKSignOrCreationError Function()>>(
          'SignOrCreationError_sign_error');
  late final _SignOrCreationError_sign_error =
      _SignOrCreationError_sign_errorPtr.asFunction<
          LDKSignOrCreationError Function()>();

  /// Utility method to constructs a new CreationError-variant SignOrCreationError
  LDKSignOrCreationError SignOrCreationError_creation_error(
    int a,
  ) {
    return _SignOrCreationError_creation_error(
      a,
    );
  }

  late final _SignOrCreationError_creation_errorPtr =
      _lookup<ffi.NativeFunction<LDKSignOrCreationError Function(ffi.Int32)>>(
          'SignOrCreationError_creation_error');
  late final _SignOrCreationError_creation_error =
      _SignOrCreationError_creation_errorPtr.asFunction<
          LDKSignOrCreationError Function(int)>();

  /// Checks if two SignOrCreationErrors contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool SignOrCreationError_eq(
    ffi.Pointer<LDKSignOrCreationError> a,
    ffi.Pointer<LDKSignOrCreationError> b,
  ) {
    return _SignOrCreationError_eq(
      a,
      b,
    );
  }

  late final _SignOrCreationError_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<LDKSignOrCreationError>,
              ffi.Pointer<LDKSignOrCreationError>)>>('SignOrCreationError_eq');
  late final _SignOrCreationError_eq = _SignOrCreationError_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKSignOrCreationError>,
          ffi.Pointer<LDKSignOrCreationError>)>();

  /// Get the string representation of a SignOrCreationError object
  LDKStr SignOrCreationError_to_str(
    ffi.Pointer<LDKSignOrCreationError> o,
  ) {
    return _SignOrCreationError_to_str(
      o,
    );
  }

  late final _SignOrCreationError_to_strPtr = _lookup<
          ffi.NativeFunction<
              LDKStr Function(ffi.Pointer<LDKSignOrCreationError>)>>(
      'SignOrCreationError_to_str');
  late final _SignOrCreationError_to_str = _SignOrCreationError_to_strPtr
      .asFunction<LDKStr Function(ffi.Pointer<LDKSignOrCreationError>)>();

  /// Frees any resources used by the InvoicePayer, if is_owned is set and inner is non-NULL.
  void InvoicePayer_free(
    LDKInvoicePayer this_obj,
  ) {
    return _InvoicePayer_free(
      this_obj,
    );
  }

  late final _InvoicePayer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKInvoicePayer)>>(
          'InvoicePayer_free');
  late final _InvoicePayer_free =
      _InvoicePayer_freePtr.asFunction<void Function(LDKInvoicePayer)>();

  /// Calls the free function if one is set
  void Payer_free(
    LDKPayer this_ptr,
  ) {
    return _Payer_free(
      this_ptr,
    );
  }

  late final _Payer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPayer)>>('Payer_free');
  late final _Payer_free = _Payer_freePtr.asFunction<void Function(LDKPayer)>();

  /// Calls the free function if one is set
  void Router_free(
    LDKRouter this_ptr,
  ) {
    return _Router_free(
      this_ptr,
    );
  }

  late final _Router_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRouter)>>('Router_free');
  late final _Router_free =
      _Router_freePtr.asFunction<void Function(LDKRouter)>();

  /// Frees any resources used by the Retry
  void Retry_free(
    LDKRetry this_ptr,
  ) {
    return _Retry_free(
      this_ptr,
    );
  }

  late final _Retry_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRetry)>>('Retry_free');
  late final _Retry_free = _Retry_freePtr.asFunction<void Function(LDKRetry)>();

  /// Creates a copy of the Retry
  LDKRetry Retry_clone(
    ffi.Pointer<LDKRetry> orig,
  ) {
    return _Retry_clone(
      orig,
    );
  }

  late final _Retry_clonePtr =
      _lookup<ffi.NativeFunction<LDKRetry Function(ffi.Pointer<LDKRetry>)>>(
          'Retry_clone');
  late final _Retry_clone =
      _Retry_clonePtr.asFunction<LDKRetry Function(ffi.Pointer<LDKRetry>)>();

  /// Utility method to constructs a new Attempts-variant Retry
  LDKRetry Retry_attempts(
    int a,
  ) {
    return _Retry_attempts(
      a,
    );
  }

  late final _Retry_attemptsPtr =
      _lookup<ffi.NativeFunction<LDKRetry Function(uintptr_t)>>(
          'Retry_attempts');
  late final _Retry_attempts =
      _Retry_attemptsPtr.asFunction<LDKRetry Function(int)>();

  /// Utility method to constructs a new Timeout-variant Retry
  LDKRetry Retry_timeout(
    int a,
  ) {
    return _Retry_timeout(
      a,
    );
  }

  late final _Retry_timeoutPtr =
      _lookup<ffi.NativeFunction<LDKRetry Function(ffi.Uint64)>>(
          'Retry_timeout');
  late final _Retry_timeout =
      _Retry_timeoutPtr.asFunction<LDKRetry Function(int)>();

  /// Checks if two Retrys contain equal inner contents.
  /// This ignores pointers and is_owned flags and looks at the values in fields.
  bool Retry_eq(
    ffi.Pointer<LDKRetry> a,
    ffi.Pointer<LDKRetry> b,
  ) {
    return _Retry_eq(
      a,
      b,
    );
  }

  late final _Retry_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<LDKRetry>, ffi.Pointer<LDKRetry>)>>('Retry_eq');
  late final _Retry_eq = _Retry_eqPtr.asFunction<
      bool Function(ffi.Pointer<LDKRetry>, ffi.Pointer<LDKRetry>)>();

  /// Checks if two Retrys contain equal inner contents.
  int Retry_hash(
    ffi.Pointer<LDKRetry> o,
  ) {
    return _Retry_hash(
      o,
    );
  }

  late final _Retry_hashPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<LDKRetry>)>>(
          'Retry_hash');
  late final _Retry_hash =
      _Retry_hashPtr.asFunction<int Function(ffi.Pointer<LDKRetry>)>();

  /// Frees any resources used by the PaymentError
  void PaymentError_free(
    LDKPaymentError this_ptr,
  ) {
    return _PaymentError_free(
      this_ptr,
    );
  }

  late final _PaymentError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKPaymentError)>>(
          'PaymentError_free');
  late final _PaymentError_free =
      _PaymentError_freePtr.asFunction<void Function(LDKPaymentError)>();

  /// Creates a copy of the PaymentError
  LDKPaymentError PaymentError_clone(
    ffi.Pointer<LDKPaymentError> orig,
  ) {
    return _PaymentError_clone(
      orig,
    );
  }

  late final _PaymentError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKPaymentError Function(
              ffi.Pointer<LDKPaymentError>)>>('PaymentError_clone');
  late final _PaymentError_clone = _PaymentError_clonePtr.asFunction<
      LDKPaymentError Function(ffi.Pointer<LDKPaymentError>)>();

  /// Utility method to constructs a new Invoice-variant PaymentError
  LDKPaymentError PaymentError_invoice(
    LDKStr a,
  ) {
    return _PaymentError_invoice(
      a,
    );
  }

  late final _PaymentError_invoicePtr =
      _lookup<ffi.NativeFunction<LDKPaymentError Function(LDKStr)>>(
          'PaymentError_invoice');
  late final _PaymentError_invoice =
      _PaymentError_invoicePtr.asFunction<LDKPaymentError Function(LDKStr)>();

  /// Utility method to constructs a new Routing-variant PaymentError
  LDKPaymentError PaymentError_routing(
    LDKLightningError a,
  ) {
    return _PaymentError_routing(
      a,
    );
  }

  late final _PaymentError_routingPtr =
      _lookup<ffi.NativeFunction<LDKPaymentError Function(LDKLightningError)>>(
          'PaymentError_routing');
  late final _PaymentError_routing = _PaymentError_routingPtr.asFunction<
      LDKPaymentError Function(LDKLightningError)>();

  /// Utility method to constructs a new Sending-variant PaymentError
  LDKPaymentError PaymentError_sending(
    LDKPaymentSendFailure a,
  ) {
    return _PaymentError_sending(
      a,
    );
  }

  late final _PaymentError_sendingPtr = _lookup<
          ffi.NativeFunction<LDKPaymentError Function(LDKPaymentSendFailure)>>(
      'PaymentError_sending');
  late final _PaymentError_sending = _PaymentError_sendingPtr.asFunction<
      LDKPaymentError Function(LDKPaymentSendFailure)>();

  /// Creates an invoice payer that retries failed payment paths.
  ///
  /// Will forward any [`Event::PaymentPathFailed`] events to the decorated `event_handler` once
  /// `retry` has been exceeded for a given [`Invoice`].
  LDKInvoicePayer InvoicePayer_new(
    LDKPayer payer,
    LDKRouter router,
    ffi.Pointer<LDKMultiThreadedLockableScore> scorer,
    LDKLogger logger,
    LDKEventHandler event_handler,
    LDKRetry retry,
  ) {
    return _InvoicePayer_new(
      payer,
      router,
      scorer,
      logger,
      event_handler,
      retry,
    );
  }

  late final _InvoicePayer_newPtr = _lookup<
      ffi.NativeFunction<
          LDKInvoicePayer Function(
              LDKPayer,
              LDKRouter,
              ffi.Pointer<LDKMultiThreadedLockableScore>,
              LDKLogger,
              LDKEventHandler,
              LDKRetry)>>('InvoicePayer_new');
  late final _InvoicePayer_new = _InvoicePayer_newPtr.asFunction<
      LDKInvoicePayer Function(
          LDKPayer,
          LDKRouter,
          ffi.Pointer<LDKMultiThreadedLockableScore>,
          LDKLogger,
          LDKEventHandler,
          LDKRetry)>();

  /// Pays the given [`Invoice`], caching it for later use in case a retry is needed.
  ///
  /// You should ensure that the `invoice.payment_hash()` is unique and the same payment_hash has
  /// never been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so
  /// for you.
  LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_invoice(
    ffi.Pointer<LDKInvoicePayer> this_arg,
    ffi.Pointer<LDKInvoice> invoice,
  ) {
    return _InvoicePayer_pay_invoice(
      this_arg,
      invoice,
    );
  }

  late final _InvoicePayer_pay_invoicePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKInvoicePayer>,
              ffi.Pointer<LDKInvoice>)>>('InvoicePayer_pay_invoice');
  late final _InvoicePayer_pay_invoice =
      _InvoicePayer_pay_invoicePtr.asFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKInvoicePayer>, ffi.Pointer<LDKInvoice>)>();

  /// Pays the given zero-value [`Invoice`] using the given amount, caching it for later use in
  /// case a retry is needed.
  ///
  /// You should ensure that the `invoice.payment_hash()` is unique and the same payment_hash has
  /// never been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so
  /// for you.
  LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_zero_value_invoice(
    ffi.Pointer<LDKInvoicePayer> this_arg,
    ffi.Pointer<LDKInvoice> invoice,
    int amount_msats,
  ) {
    return _InvoicePayer_pay_zero_value_invoice(
      this_arg,
      invoice,
      amount_msats,
    );
  }

  late final _InvoicePayer_pay_zero_value_invoicePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKInvoicePayer>,
              ffi.Pointer<LDKInvoice>,
              ffi.Uint64)>>('InvoicePayer_pay_zero_value_invoice');
  late final _InvoicePayer_pay_zero_value_invoice =
      _InvoicePayer_pay_zero_value_invoicePtr.asFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKInvoicePayer>, ffi.Pointer<LDKInvoice>, int)>();

  /// Pays `pubkey` an amount using the hash of the given preimage, caching it for later use in
  /// case a retry is needed.
  ///
  /// You should ensure that `payment_preimage` is unique and that its `payment_hash` has never
  /// been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so for you.
  LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_pubkey(
    ffi.Pointer<LDKInvoicePayer> this_arg,
    LDKPublicKey pubkey,
    LDKThirtyTwoBytes payment_preimage,
    int amount_msats,
    int final_cltv_expiry_delta,
  ) {
    return _InvoicePayer_pay_pubkey(
      this_arg,
      pubkey,
      payment_preimage,
      amount_msats,
      final_cltv_expiry_delta,
    );
  }

  late final _InvoicePayer_pay_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentErrorZ Function(
              ffi.Pointer<LDKInvoicePayer>,
              LDKPublicKey,
              LDKThirtyTwoBytes,
              ffi.Uint64,
              ffi.Uint32)>>('InvoicePayer_pay_pubkey');
  late final _InvoicePayer_pay_pubkey = _InvoicePayer_pay_pubkeyPtr.asFunction<
      LDKCResult_PaymentIdPaymentErrorZ Function(ffi.Pointer<LDKInvoicePayer>,
          LDKPublicKey, LDKThirtyTwoBytes, int, int)>();

  /// Removes the payment cached by the given payment hash.
  ///
  /// Should be called once a payment has failed or succeeded if not using [`InvoicePayer`] as an
  /// [`EventHandler`]. Otherwise, calling this method is unnecessary.
  void InvoicePayer_remove_cached_payment(
    ffi.Pointer<LDKInvoicePayer> this_arg,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> payment_hash,
  ) {
    return _InvoicePayer_remove_cached_payment(
      this_arg,
      payment_hash,
    );
  }

  late final _InvoicePayer_remove_cached_paymentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<LDKInvoicePayer>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>(
      'InvoicePayer_remove_cached_payment');
  late final _InvoicePayer_remove_cached_payment =
      _InvoicePayer_remove_cached_paymentPtr.asFunction<
          void Function(ffi.Pointer<LDKInvoicePayer>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Constructs a new EventHandler which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
  LDKEventHandler InvoicePayer_as_EventHandler(
    ffi.Pointer<LDKInvoicePayer> this_arg,
  ) {
    return _InvoicePayer_as_EventHandler(
      this_arg,
    );
  }

  late final _InvoicePayer_as_EventHandlerPtr = _lookup<
      ffi.NativeFunction<
          LDKEventHandler Function(
              ffi.Pointer<LDKInvoicePayer>)>>('InvoicePayer_as_EventHandler');
  late final _InvoicePayer_as_EventHandler = _InvoicePayer_as_EventHandlerPtr
      .asFunction<LDKEventHandler Function(ffi.Pointer<LDKInvoicePayer>)>();

  /// Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
  /// See [`PhantomKeysManager`] for more information on phantom node payments.
  ///
  /// `phantom_route_hints` parameter:
  /// * Contains channel info for all nodes participating in the phantom invoice
  /// * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
  /// participating node
  /// * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
  /// updated when a channel becomes disabled or closes
  /// * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
  /// may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
  /// down
  ///
  /// `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
  /// between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
  /// If `None` is provided for `payment_hash`, then one will be created.
  ///
  /// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
  /// in excess of the current time.
  ///
  /// Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
  /// invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
  /// requirement).
  ///
  /// [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
  /// [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
  /// [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
  /// [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
  /// [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
  ///
  /// Note that payment_hash (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult_InvoiceSignOrCreationErrorZ create_phantom_invoice(
    LDKCOption_u64Z amt_msat,
    LDKThirtyTwoBytes payment_hash,
    LDKStr description,
    int invoice_expiry_delta_secs,
    LDKCVec_PhantomRouteHintsZ phantom_route_hints,
    LDKKeysInterface keys_manager,
    int network,
  ) {
    return _create_phantom_invoice(
      amt_msat,
      payment_hash,
      description,
      invoice_expiry_delta_secs,
      phantom_route_hints,
      keys_manager,
      network,
    );
  }

  late final _create_phantom_invoicePtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              LDKCOption_u64Z,
              LDKThirtyTwoBytes,
              LDKStr,
              ffi.Uint32,
              LDKCVec_PhantomRouteHintsZ,
              LDKKeysInterface,
              ffi.Int32)>>('create_phantom_invoice');
  late final _create_phantom_invoice = _create_phantom_invoicePtr.asFunction<
      LDKCResult_InvoiceSignOrCreationErrorZ Function(
          LDKCOption_u64Z,
          LDKThirtyTwoBytes,
          LDKStr,
          int,
          LDKCVec_PhantomRouteHintsZ,
          LDKKeysInterface,
          int)>();

  /// Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
  /// See [`PhantomKeysManager`] for more information on phantom node payments.
  ///
  /// `phantom_route_hints` parameter:
  /// * Contains channel info for all nodes participating in the phantom invoice
  /// * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
  /// participating node
  /// * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
  /// updated when a channel becomes disabled or closes
  /// * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
  /// may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
  /// down
  ///
  /// `description_hash` is a SHA-256 hash of the description text
  ///
  /// `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
  /// between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
  /// If `None` is provided for `payment_hash`, then one will be created.
  ///
  /// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
  /// in excess of the current time.
  ///
  /// Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
  /// invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
  /// requirement).
  ///
  /// [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
  /// [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
  /// [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
  /// [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
  /// [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
  ///
  /// Note that payment_hash (or a relevant inner pointer) may be NULL or all-0s to represent None
  LDKCResult_InvoiceSignOrCreationErrorZ
      create_phantom_invoice_with_description_hash(
    LDKCOption_u64Z amt_msat,
    LDKThirtyTwoBytes payment_hash,
    int invoice_expiry_delta_secs,
    LDKSha256 description_hash,
    LDKCVec_PhantomRouteHintsZ phantom_route_hints,
    LDKKeysInterface keys_manager,
    int network,
  ) {
    return _create_phantom_invoice_with_description_hash(
      amt_msat,
      payment_hash,
      invoice_expiry_delta_secs,
      description_hash,
      phantom_route_hints,
      keys_manager,
      network,
    );
  }

  late final _create_phantom_invoice_with_description_hashPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              LDKCOption_u64Z,
              LDKThirtyTwoBytes,
              ffi.Uint32,
              LDKSha256,
              LDKCVec_PhantomRouteHintsZ,
              LDKKeysInterface,
              ffi.Int32)>>('create_phantom_invoice_with_description_hash');
  late final _create_phantom_invoice_with_description_hash =
      _create_phantom_invoice_with_description_hashPtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              LDKCOption_u64Z,
              LDKThirtyTwoBytes,
              int,
              LDKSha256,
              LDKCVec_PhantomRouteHintsZ,
              LDKKeysInterface,
              int)>();

  /// Utility to construct an invoice. Generally, unless you want to do something like a custom
  /// cltv_expiry, this is what you should be using to create an invoice. The reason being, this
  /// method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
  /// doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
  /// that the payment secret is valid when the invoice is paid.
  ///
  /// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
  /// in excess of the current time.
  LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager(
    ffi.Pointer<LDKChannelManager> channelmanager,
    LDKKeysInterface keys_manager,
    int network,
    LDKCOption_u64Z amt_msat,
    LDKStr description,
    int invoice_expiry_delta_secs,
  ) {
    return _create_invoice_from_channelmanager(
      channelmanager,
      keys_manager,
      network,
      amt_msat,
      description,
      invoice_expiry_delta_secs,
    );
  }

  late final _create_invoice_from_channelmanagerPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKKeysInterface,
              ffi.Int32,
              LDKCOption_u64Z,
              LDKStr,
              ffi.Uint32)>>('create_invoice_from_channelmanager');
  late final _create_invoice_from_channelmanager =
      _create_invoice_from_channelmanagerPtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKKeysInterface,
              int,
              LDKCOption_u64Z,
              LDKStr,
              int)>();

  /// Utility to construct an invoice. Generally, unless you want to do something like a custom
  /// cltv_expiry, this is what you should be using to create an invoice. The reason being, this
  /// method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
  /// doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
  /// that the payment secret is valid when the invoice is paid.
  /// Use this variant if you want to pass the `description_hash` to the invoice.
  ///
  /// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
  /// in excess of the current time.
  LDKCResult_InvoiceSignOrCreationErrorZ
      create_invoice_from_channelmanager_with_description_hash(
    ffi.Pointer<LDKChannelManager> channelmanager,
    LDKKeysInterface keys_manager,
    int network,
    LDKCOption_u64Z amt_msat,
    LDKSha256 description_hash,
    int invoice_expiry_delta_secs,
  ) {
    return _create_invoice_from_channelmanager_with_description_hash(
      channelmanager,
      keys_manager,
      network,
      amt_msat,
      description_hash,
      invoice_expiry_delta_secs,
    );
  }

  late final _create_invoice_from_channelmanager_with_description_hashPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_InvoiceSignOrCreationErrorZ Function(
                      ffi.Pointer<LDKChannelManager>,
                      LDKKeysInterface,
                      ffi.Int32,
                      LDKCOption_u64Z,
                      LDKSha256,
                      ffi.Uint32)>>(
          'create_invoice_from_channelmanager_with_description_hash');
  late final _create_invoice_from_channelmanager_with_description_hash =
      _create_invoice_from_channelmanager_with_description_hashPtr.asFunction<
          LDKCResult_InvoiceSignOrCreationErrorZ Function(
              ffi.Pointer<LDKChannelManager>,
              LDKKeysInterface,
              int,
              LDKCOption_u64Z,
              LDKSha256,
              int)>();

  /// See [`create_invoice_from_channelmanager_with_description_hash`]
  /// This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
  /// available and the current time is supplied by the caller.
  LDKCResult_InvoiceSignOrCreationErrorZ
      create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(
    ffi.Pointer<LDKChannelManager> channelmanager,
    LDKKeysInterface keys_manager,
    int network,
    LDKCOption_u64Z amt_msat,
    LDKSha256 description_hash,
    int duration_since_epoch,
    int invoice_expiry_delta_secs,
  ) {
    return _create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(
      channelmanager,
      keys_manager,
      network,
      amt_msat,
      description_hash,
      duration_since_epoch,
      invoice_expiry_delta_secs,
    );
  }

  late final _create_invoice_from_channelmanager_with_description_hash_and_duration_since_epochPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_InvoiceSignOrCreationErrorZ Function(
                      ffi.Pointer<LDKChannelManager>,
                      LDKKeysInterface,
                      ffi.Int32,
                      LDKCOption_u64Z,
                      LDKSha256,
                      ffi.Uint64,
                      ffi.Uint32)>>(
          'create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch');
  late final _create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch =
      _create_invoice_from_channelmanager_with_description_hash_and_duration_since_epochPtr
          .asFunction<
              LDKCResult_InvoiceSignOrCreationErrorZ Function(
                  ffi.Pointer<LDKChannelManager>,
                  LDKKeysInterface,
                  int,
                  LDKCOption_u64Z,
                  LDKSha256,
                  int,
                  int)>();

  /// See [`create_invoice_from_channelmanager`]
  /// This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
  /// available and the current time is supplied by the caller.
  LDKCResult_InvoiceSignOrCreationErrorZ
      create_invoice_from_channelmanager_and_duration_since_epoch(
    ffi.Pointer<LDKChannelManager> channelmanager,
    LDKKeysInterface keys_manager,
    int network,
    LDKCOption_u64Z amt_msat,
    LDKStr description,
    int duration_since_epoch,
    int invoice_expiry_delta_secs,
  ) {
    return _create_invoice_from_channelmanager_and_duration_since_epoch(
      channelmanager,
      keys_manager,
      network,
      amt_msat,
      description,
      duration_since_epoch,
      invoice_expiry_delta_secs,
    );
  }

  late final _create_invoice_from_channelmanager_and_duration_since_epochPtr =
      _lookup<
              ffi.NativeFunction<
                  LDKCResult_InvoiceSignOrCreationErrorZ Function(
                      ffi.Pointer<LDKChannelManager>,
                      LDKKeysInterface,
                      ffi.Int32,
                      LDKCOption_u64Z,
                      LDKStr,
                      ffi.Uint64,
                      ffi.Uint32)>>(
          'create_invoice_from_channelmanager_and_duration_since_epoch');
  late final _create_invoice_from_channelmanager_and_duration_since_epoch =
      _create_invoice_from_channelmanager_and_duration_since_epochPtr
          .asFunction<
              LDKCResult_InvoiceSignOrCreationErrorZ Function(
                  ffi.Pointer<LDKChannelManager>,
                  LDKKeysInterface,
                  int,
                  LDKCOption_u64Z,
                  LDKStr,
                  int,
                  int)>();

  /// Frees any resources used by the DefaultRouter, if is_owned is set and inner is non-NULL.
  void DefaultRouter_free(
    LDKDefaultRouter this_obj,
  ) {
    return _DefaultRouter_free(
      this_obj,
    );
  }

  late final _DefaultRouter_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKDefaultRouter)>>(
          'DefaultRouter_free');
  late final _DefaultRouter_free =
      _DefaultRouter_freePtr.asFunction<void Function(LDKDefaultRouter)>();

  /// Creates a new router using the given [`NetworkGraph`], a [`Logger`], and a randomness source
  /// `random_seed_bytes`.
  LDKDefaultRouter DefaultRouter_new(
    ffi.Pointer<LDKNetworkGraph> network_graph,
    LDKLogger logger,
    LDKThirtyTwoBytes random_seed_bytes,
  ) {
    return _DefaultRouter_new(
      network_graph,
      logger,
      random_seed_bytes,
    );
  }

  late final _DefaultRouter_newPtr = _lookup<
      ffi.NativeFunction<
          LDKDefaultRouter Function(ffi.Pointer<LDKNetworkGraph>, LDKLogger,
              LDKThirtyTwoBytes)>>('DefaultRouter_new');
  late final _DefaultRouter_new = _DefaultRouter_newPtr.asFunction<
      LDKDefaultRouter Function(
          ffi.Pointer<LDKNetworkGraph>, LDKLogger, LDKThirtyTwoBytes)>();

  /// Constructs a new Router which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Router must be freed before this_arg is
  LDKRouter DefaultRouter_as_Router(
    ffi.Pointer<LDKDefaultRouter> this_arg,
  ) {
    return _DefaultRouter_as_Router(
      this_arg,
    );
  }

  late final _DefaultRouter_as_RouterPtr = _lookup<
      ffi.NativeFunction<
          LDKRouter Function(
              ffi.Pointer<LDKDefaultRouter>)>>('DefaultRouter_as_Router');
  late final _DefaultRouter_as_Router = _DefaultRouter_as_RouterPtr.asFunction<
      LDKRouter Function(ffi.Pointer<LDKDefaultRouter>)>();

  /// Constructs a new Payer which calls the relevant methods on this_arg.
  /// This copies the `inner` pointer in this_arg and thus the returned Payer must be freed before this_arg is
  LDKPayer ChannelManager_as_Payer(
    ffi.Pointer<LDKChannelManager> this_arg,
  ) {
    return _ChannelManager_as_Payer(
      this_arg,
    );
  }

  late final _ChannelManager_as_PayerPtr = _lookup<
      ffi.NativeFunction<
          LDKPayer Function(
              ffi.Pointer<LDKChannelManager>)>>('ChannelManager_as_Payer');
  late final _ChannelManager_as_Payer = _ChannelManager_as_PayerPtr.asFunction<
      LDKPayer Function(ffi.Pointer<LDKChannelManager>)>();

  /// Read a SiPrefix object from a string
  LDKCResult_SiPrefixParseErrorZ SiPrefix_from_str(
    LDKStr s,
  ) {
    return _SiPrefix_from_str(
      s,
    );
  }

  late final _SiPrefix_from_strPtr = _lookup<
          ffi.NativeFunction<LDKCResult_SiPrefixParseErrorZ Function(LDKStr)>>(
      'SiPrefix_from_str');
  late final _SiPrefix_from_str = _SiPrefix_from_strPtr.asFunction<
      LDKCResult_SiPrefixParseErrorZ Function(LDKStr)>();

  /// Read a Invoice object from a string
  LDKCResult_InvoiceParseOrSemanticErrorZ Invoice_from_str(
    LDKStr s,
  ) {
    return _Invoice_from_str(
      s,
    );
  }

  late final _Invoice_from_strPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_InvoiceParseOrSemanticErrorZ Function(
              LDKStr)>>('Invoice_from_str');
  late final _Invoice_from_str = _Invoice_from_strPtr.asFunction<
      LDKCResult_InvoiceParseOrSemanticErrorZ Function(LDKStr)>();

  /// Read a SignedRawInvoice object from a string
  LDKCResult_SignedRawInvoiceParseErrorZ SignedRawInvoice_from_str(
    LDKStr s,
  ) {
    return _SignedRawInvoice_from_str(
      s,
    );
  }

  late final _SignedRawInvoice_from_strPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_SignedRawInvoiceParseErrorZ Function(
              LDKStr)>>('SignedRawInvoice_from_str');
  late final _SignedRawInvoice_from_str = _SignedRawInvoice_from_strPtr
      .asFunction<LDKCResult_SignedRawInvoiceParseErrorZ Function(LDKStr)>();

  /// Get the string representation of a ParseError object
  LDKStr ParseError_to_str(
    ffi.Pointer<LDKParseError> o,
  ) {
    return _ParseError_to_str(
      o,
    );
  }

  late final _ParseError_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKParseError>)>>(
          'ParseError_to_str');
  late final _ParseError_to_str = _ParseError_to_strPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKParseError>)>();

  /// Get the string representation of a ParseOrSemanticError object
  LDKStr ParseOrSemanticError_to_str(
    ffi.Pointer<LDKParseOrSemanticError> o,
  ) {
    return _ParseOrSemanticError_to_str(
      o,
    );
  }

  late final _ParseOrSemanticError_to_strPtr = _lookup<
          ffi.NativeFunction<
              LDKStr Function(ffi.Pointer<LDKParseOrSemanticError>)>>(
      'ParseOrSemanticError_to_str');
  late final _ParseOrSemanticError_to_str = _ParseOrSemanticError_to_strPtr
      .asFunction<LDKStr Function(ffi.Pointer<LDKParseOrSemanticError>)>();

  /// Get the string representation of a Invoice object
  LDKStr Invoice_to_str(
    ffi.Pointer<LDKInvoice> o,
  ) {
    return _Invoice_to_str(
      o,
    );
  }

  late final _Invoice_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<LDKInvoice>)>>(
          'Invoice_to_str');
  late final _Invoice_to_str =
      _Invoice_to_strPtr.asFunction<LDKStr Function(ffi.Pointer<LDKInvoice>)>();

  /// Get the string representation of a SignedRawInvoice object
  LDKStr SignedRawInvoice_to_str(
    ffi.Pointer<LDKSignedRawInvoice> o,
  ) {
    return _SignedRawInvoice_to_str(
      o,
    );
  }

  late final _SignedRawInvoice_to_strPtr = _lookup<
      ffi.NativeFunction<
          LDKStr Function(
              ffi.Pointer<LDKSignedRawInvoice>)>>('SignedRawInvoice_to_str');
  late final _SignedRawInvoice_to_str = _SignedRawInvoice_to_strPtr.asFunction<
      LDKStr Function(ffi.Pointer<LDKSignedRawInvoice>)>();

  /// Get the string representation of a Currency object
  LDKStr Currency_to_str(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _Currency_to_str(
      o,
    );
  }

  late final _Currency_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>>(
          'Currency_to_str');
  late final _Currency_to_str =
      _Currency_to_strPtr.asFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>();

  /// Get the string representation of a SiPrefix object
  LDKStr SiPrefix_to_str(
    ffi.Pointer<ffi.Int32> o,
  ) {
    return _SiPrefix_to_str(
      o,
    );
  }

  late final _SiPrefix_to_strPtr =
      _lookup<ffi.NativeFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>>(
          'SiPrefix_to_str');
  late final _SiPrefix_to_str =
      _SiPrefix_to_strPtr.asFunction<LDKStr Function(ffi.Pointer<ffi.Int32>)>();

  /// Frees any resources used by the RapidGossipSync, if is_owned is set and inner is non-NULL.
  void RapidGossipSync_free(
    LDKRapidGossipSync this_obj,
  ) {
    return _RapidGossipSync_free(
      this_obj,
    );
  }

  late final _RapidGossipSync_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKRapidGossipSync)>>(
          'RapidGossipSync_free');
  late final _RapidGossipSync_free =
      _RapidGossipSync_freePtr.asFunction<void Function(LDKRapidGossipSync)>();

  /// Instantiate a new [`RapidGossipSync`] instance
  LDKRapidGossipSync RapidGossipSync_new(
    ffi.Pointer<LDKNetworkGraph> network_graph,
  ) {
    return _RapidGossipSync_new(
      network_graph,
    );
  }

  late final _RapidGossipSync_newPtr = _lookup<
      ffi.NativeFunction<
          LDKRapidGossipSync Function(
              ffi.Pointer<LDKNetworkGraph>)>>('RapidGossipSync_new');
  late final _RapidGossipSync_new = _RapidGossipSync_newPtr.asFunction<
      LDKRapidGossipSync Function(ffi.Pointer<LDKNetworkGraph>)>();

  /// Sync gossip data from a file
  /// Returns the last sync timestamp to be used the next time rapid sync data is queried.
  ///
  /// `network_graph`: The network graph to apply the updates to
  ///
  /// `sync_path`: Path to the file where the gossip update data is located
  LDKCResult_u32GraphSyncErrorZ
      RapidGossipSync_sync_network_graph_with_file_path(
    ffi.Pointer<LDKRapidGossipSync> this_arg,
    LDKStr sync_path,
  ) {
    return _RapidGossipSync_sync_network_graph_with_file_path(
      this_arg,
      sync_path,
    );
  }

  late final _RapidGossipSync_sync_network_graph_with_file_pathPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              ffi.Pointer<LDKRapidGossipSync>,
              LDKStr)>>('RapidGossipSync_sync_network_graph_with_file_path');
  late final _RapidGossipSync_sync_network_graph_with_file_path =
      _RapidGossipSync_sync_network_graph_with_file_pathPtr.asFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              ffi.Pointer<LDKRapidGossipSync>, LDKStr)>();

  /// Returns whether a rapid gossip sync has completed at least once
  bool RapidGossipSync_is_initial_sync_complete(
    ffi.Pointer<LDKRapidGossipSync> this_arg,
  ) {
    return _RapidGossipSync_is_initial_sync_complete(
      this_arg,
    );
  }

  late final _RapidGossipSync_is_initial_sync_completePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<LDKRapidGossipSync>)>>(
      'RapidGossipSync_is_initial_sync_complete');
  late final _RapidGossipSync_is_initial_sync_complete =
      _RapidGossipSync_is_initial_sync_completePtr.asFunction<
          bool Function(ffi.Pointer<LDKRapidGossipSync>)>();

  /// Frees any resources used by the GraphSyncError
  void GraphSyncError_free(
    LDKGraphSyncError this_ptr,
  ) {
    return _GraphSyncError_free(
      this_ptr,
    );
  }

  late final _GraphSyncError_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(LDKGraphSyncError)>>(
          'GraphSyncError_free');
  late final _GraphSyncError_free =
      _GraphSyncError_freePtr.asFunction<void Function(LDKGraphSyncError)>();

  /// Creates a copy of the GraphSyncError
  LDKGraphSyncError GraphSyncError_clone(
    ffi.Pointer<LDKGraphSyncError> orig,
  ) {
    return _GraphSyncError_clone(
      orig,
    );
  }

  late final _GraphSyncError_clonePtr = _lookup<
      ffi.NativeFunction<
          LDKGraphSyncError Function(
              ffi.Pointer<LDKGraphSyncError>)>>('GraphSyncError_clone');
  late final _GraphSyncError_clone = _GraphSyncError_clonePtr.asFunction<
      LDKGraphSyncError Function(ffi.Pointer<LDKGraphSyncError>)>();

  /// Utility method to constructs a new DecodeError-variant GraphSyncError
  LDKGraphSyncError GraphSyncError_decode_error(
    LDKDecodeError a,
  ) {
    return _GraphSyncError_decode_error(
      a,
    );
  }

  late final _GraphSyncError_decode_errorPtr =
      _lookup<ffi.NativeFunction<LDKGraphSyncError Function(LDKDecodeError)>>(
          'GraphSyncError_decode_error');
  late final _GraphSyncError_decode_error = _GraphSyncError_decode_errorPtr
      .asFunction<LDKGraphSyncError Function(LDKDecodeError)>();

  /// Utility method to constructs a new LightningError-variant GraphSyncError
  LDKGraphSyncError GraphSyncError_lightning_error(
    LDKLightningError a,
  ) {
    return _GraphSyncError_lightning_error(
      a,
    );
  }

  late final _GraphSyncError_lightning_errorPtr = _lookup<
          ffi.NativeFunction<LDKGraphSyncError Function(LDKLightningError)>>(
      'GraphSyncError_lightning_error');
  late final _GraphSyncError_lightning_error =
      _GraphSyncError_lightning_errorPtr.asFunction<
          LDKGraphSyncError Function(LDKLightningError)>();

  /// Update network graph from binary data.
  /// Returns the last sync timestamp to be used the next time rapid sync data is queried.
  ///
  /// `network_graph`: network graph to be updated
  ///
  /// `update_data`: `&[u8]` binary stream that comprises the update data
  LDKCResult_u32GraphSyncErrorZ RapidGossipSync_update_network_graph(
    ffi.Pointer<LDKRapidGossipSync> this_arg,
    LDKu8slice update_data,
  ) {
    return _RapidGossipSync_update_network_graph(
      this_arg,
      update_data,
    );
  }

  late final _RapidGossipSync_update_network_graphPtr = _lookup<
      ffi.NativeFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              ffi.Pointer<LDKRapidGossipSync>,
              LDKu8slice)>>('RapidGossipSync_update_network_graph');
  late final _RapidGossipSync_update_network_graph =
      _RapidGossipSync_update_network_graphPtr.asFunction<
          LDKCResult_u32GraphSyncErrorZ Function(
              ffi.Pointer<LDKRapidGossipSync>, LDKu8slice)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

class nativeCounterpartyCommitmentSecretsOpaque extends ffi.Opaque {}

class nativeTxCreationKeysOpaque extends ffi.Opaque {}

class nativeChannelPublicKeysOpaque extends ffi.Opaque {}

class nativeHTLCOutputInCommitmentOpaque extends ffi.Opaque {}

class nativeChannelTransactionParametersOpaque extends ffi.Opaque {}

class nativeCounterpartyChannelTransactionParametersOpaque extends ffi.Opaque {}

class nativeDirectedChannelTransactionParametersOpaque extends ffi.Opaque {}

class nativeHolderCommitmentTransactionOpaque extends ffi.Opaque {}

class nativeBuiltCommitmentTransactionOpaque extends ffi.Opaque {}

class nativeClosingTransactionOpaque extends ffi.Opaque {}

class nativeTrustedClosingTransactionOpaque extends ffi.Opaque {}

class nativeCommitmentTransactionOpaque extends ffi.Opaque {}

class nativeTrustedCommitmentTransactionOpaque extends ffi.Opaque {}

class nativeShutdownScriptOpaque extends ffi.Opaque {}

class nativeInvalidShutdownScriptOpaque extends ffi.Opaque {}

class nativeBackgroundProcessorOpaque extends ffi.Opaque {}

class nativeRouteHopOpaque extends ffi.Opaque {}

class nativeRouteOpaque extends ffi.Opaque {}

class nativeRouteParametersOpaque extends ffi.Opaque {}

class nativePaymentParametersOpaque extends ffi.Opaque {}

class nativeRouteHintOpaque extends ffi.Opaque {}

class nativeRouteHintHopOpaque extends ffi.Opaque {}

class nativeBestBlockOpaque extends ffi.Opaque {}

class nativeWatchedOutputOpaque extends ffi.Opaque {}

class nativeMultiThreadedLockableScoreOpaque extends ffi.Opaque {}

class nativeChannelUsageOpaque extends ffi.Opaque {}

class nativeFixedPenaltyScorerOpaque extends ffi.Opaque {}

class nativeProbabilisticScorerOpaque extends ffi.Opaque {}

class nativeProbabilisticScoringParametersOpaque extends ffi.Opaque {}

class nativeInitFeaturesOpaque extends ffi.Opaque {}

class nativeNodeFeaturesOpaque extends ffi.Opaque {}

class nativeChannelFeaturesOpaque extends ffi.Opaque {}

class nativeInvoiceFeaturesOpaque extends ffi.Opaque {}

class nativeChannelTypeFeaturesOpaque extends ffi.Opaque {}

class nativeNodeIdOpaque extends ffi.Opaque {}

class nativeNetworkGraphOpaque extends ffi.Opaque {}

class nativeReadOnlyNetworkGraphOpaque extends ffi.Opaque {}

class nativeP2PGossipSyncOpaque extends ffi.Opaque {}

class nativeChannelUpdateInfoOpaque extends ffi.Opaque {}

class nativeChannelInfoOpaque extends ffi.Opaque {}

class nativeDirectedChannelInfoOpaque extends ffi.Opaque {}

class nativeRoutingFeesOpaque extends ffi.Opaque {}

class nativeNodeAnnouncementInfoOpaque extends ffi.Opaque {}

class nativeNodeAliasOpaque extends ffi.Opaque {}

class nativeNodeInfoOpaque extends ffi.Opaque {}

class nativeDelayedPaymentOutputDescriptorOpaque extends ffi.Opaque {}

class nativeStaticPaymentOutputDescriptorOpaque extends ffi.Opaque {}

/// A trait to sign lightning channel transactions as described in BOLT 3.
///
/// Signing services could be implemented on a hardware wallet. In this case,
/// the current Sign would be a front-end on top of a communication
/// channel connected to your secure device and lightning key material wouldn't
/// reside on a hot server. Nevertheless, a this deployment would still need
/// to trust the ChannelManager to avoid loss of funds as this latest component
/// could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
///
/// A more secure iteration would be to use hashlock (or payment points) to pair
/// invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
/// at the price of more state and computation on the hardware wallet side. In the future,
/// we are looking forward to design such interface.
///
/// In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
/// to act, as liveness and breach reply correctness are always going to be hard requirements
/// of LN security model, orthogonal of key management issues.
class LDKBaseSign extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Gets the per-commitment point for a specific commitment number
  ///
  /// Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKPublicKey Function(ffi.Pointer<ffi.Void>, ffi.Uint64)>>
      get_per_commitment_point;

  /// Gets the commitment secret for a specific commitment number as part of the revocation process
  ///
  /// An external signer implementation should error here if the commitment was already signed
  /// and should refuse to sign it in the future.
  ///
  /// May be called more than once for the same index.
  ///
  /// Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Void>, ffi.Uint64)>>
      release_commitment_secret;

  /// Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
  ///
  /// This is required in order for the signer to make sure that releasing a commitment
  /// secret won't leave us without a broadcastable holder transaction.
  /// Policy checks should be implemented in this function, including checking the amount
  /// sent to us and checking the HTLCs.
  ///
  /// The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
  /// A validating signer should ensure that an HTLC output is removed only when the matching
  /// preimage is provided, or when the value to holder is restored.
  ///
  /// NOTE: all the relevant preimages will be provided, but there may also be additional
  /// irrelevant or duplicate preimages.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneNoneZ Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKHolderCommitmentTransaction>,
              LDKCVec_PaymentPreimageZ)>> validate_holder_commitment;

  /// Gets the holder's channel public keys and basepoints
  external LDKChannelPublicKeys pubkeys;

  /// Fill in the pubkeys field as a reference to it will be given to Rust after this returns
  /// Note that this takes a pointer to this object, not the this_ptr like other methods do
  /// This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKBaseSign>)>>
      set_pubkeys;

  /// Gets an arbitrary identifier describing the set of keys which are provided back to you in
  /// some SpendableOutputDescriptor types. This should be sufficient to identify this
  /// Sign object uniquely and lookup or re-derive its keys.
  external ffi.Pointer<
          ffi.NativeFunction<LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Void>)>>
      channel_keys_id;

  /// Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
  ///
  /// Note that if signing fails or is rejected, the channel will be force-closed.
  ///
  /// Policy checks should be implemented in this function, including checking the amount
  /// sent to us and checking the HTLCs.
  ///
  /// The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
  /// A validating signer should ensure that an HTLC output is removed only when the matching
  /// preimage is provided, or when the value to holder is restored.
  ///
  /// NOTE: all the relevant preimages will be provided, but there may also be additional
  /// irrelevant or duplicate preimages.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKCommitmentTransaction>,
              LDKCVec_PaymentPreimageZ)>> sign_counterparty_commitment;

  /// Validate the counterparty's revocation.
  ///
  /// This is required in order for the signer to make sure that the state has moved
  /// forward and it is safe to sign the next counterparty commitment.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneNoneZ Function(ffi.Pointer<ffi.Void>, ffi.Uint64,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>
      validate_counterparty_revocation;

  /// Create a signatures for a holder's commitment transaction and its claiming HTLC transactions.
  /// This will only ever be called with a non-revoked commitment_tx.  This will be called with the
  /// latest commitment_tx when we initiate a force-close.
  /// This will be called with the previous latest, just to get claiming HTLC signatures, if we are
  /// reacting to a ChannelMonitor replica that decided to broadcast before it had been updated to
  /// the latest.
  /// This may be called multiple times for the same transaction.
  ///
  /// An external signer implementation should check that the commitment has not been revoked.
  ///
  /// May return Err if key derivation fails.  Callers, such as ChannelMonitor, will panic in such a case.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<LDKHolderCommitmentTransaction>)>>
      sign_holder_commitment_and_htlcs;

  /// Create a signature for the given input in a transaction spending an HTLC transaction output
  /// or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
  ///
  /// A justice transaction may claim multiple outputs at the same time if timelocks are
  /// similar, but only a signature for the input at index `input` should be signed for here.
  /// It may be called multiple times for same output(s) if a fee-bump is needed with regards
  /// to an upcoming timelock expiration.
  ///
  /// Amount is value of the output spent by this input, committed to in the BIP 143 signature.
  ///
  /// per_commitment_key is revocation secret which was provided by our counterparty when they
  /// revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
  /// not allow the spending of any funds by itself (you need our holder revocation_secret to do
  /// so).
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_SignatureNoneZ Function(
                  ffi.Pointer<ffi.Void>,
                  LDKTransaction,
                  uintptr_t,
                  ffi.Uint64,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>
      sign_justice_revoked_output;

  /// Create a signature for the given input in a transaction spending a commitment transaction
  /// HTLC output when our counterparty broadcasts an old state.
  ///
  /// A justice transaction may claim multiple outputs at the same time if timelocks are
  /// similar, but only a signature for the input at index `input` should be signed for here.
  /// It may be called multiple times for same output(s) if a fee-bump is needed with regards
  /// to an upcoming timelock expiration.
  ///
  /// Amount is value of the output spent by this input, committed to in the BIP 143 signature.
  ///
  /// per_commitment_key is revocation secret which was provided by our counterparty when they
  /// revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
  /// not allow the spending of any funds by itself (you need our holder revocation_secret to do
  /// so).
  ///
  /// htlc holds HTLC elements (hash, timelock), thus changing the format of the witness script
  /// (which is committed to in the BIP 143 signatures).
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_SignatureNoneZ Function(
                  ffi.Pointer<ffi.Void>,
                  LDKTransaction,
                  uintptr_t,
                  ffi.Uint64,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<LDKHTLCOutputInCommitment>)>>
      sign_justice_revoked_htlc;

  /// Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
  /// transaction, either offered or received.
  ///
  /// Such a transaction may claim multiples offered outputs at same time if we know the
  /// preimage for each when we create it, but only the input at index `input` should be
  /// signed for here. It may be called multiple times for same output(s) if a fee-bump is
  /// needed with regards to an upcoming timelock expiration.
  ///
  /// Witness_script is either a offered or received script as defined in BOLT3 for HTLC
  /// outputs.
  ///
  /// Amount is value of the output spent by this input, committed to in the BIP 143 signature.
  ///
  /// Per_commitment_point is the dynamic point corresponding to the channel state
  /// detected onchain. It has been generated by our counterparty and is used to derive
  /// channel state keys, which are then included in the witness script and committed to in the
  /// BIP 143 signature.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_SignatureNoneZ Function(
                  ffi.Pointer<ffi.Void>,
                  LDKTransaction,
                  uintptr_t,
                  ffi.Uint64,
                  LDKPublicKey,
                  ffi.Pointer<LDKHTLCOutputInCommitment>)>>
      sign_counterparty_htlc_transaction;

  /// Create a signature for a (proposed) closing transaction.
  ///
  /// Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
  /// chosen to forgo their output as dust.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_SignatureNoneZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKClosingTransaction>)>>
      sign_closing_transaction;

  /// Signs a channel announcement message with our funding key and our node secret key (aka
  /// node_id or network_key), proving it comes from one of the channel participants.
  ///
  /// The first returned signature should be from our node secret key, the second from our
  /// funding key.
  ///
  /// Note that if this fails or is rejected, the channel will not be publicly announced and
  /// our counterparty may (though likely will not) close the channel on us for violating the
  /// protocol.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_C2Tuple_SignatureSignatureZNoneZ Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<LDKUnsignedChannelAnnouncement>)>>
      sign_channel_announcement;

  /// Set the counterparty static channel data, including basepoints,
  /// counterparty_selected/holder_selected_contest_delay and funding outpoint.
  /// This is done as soon as the funding outpoint is known.  Since these are static channel data,
  /// they MUST NOT be allowed to change to different values once set.
  ///
  /// channel_parameters.is_populated() MUST be true.
  ///
  /// We bind holder_selected_contest_delay late here for API convenience.
  ///
  /// Will be called before any signatures are applied.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKChannelTransactionParameters>)>> ready_channel;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Represents a valid secp256k1 public key serialized in "compressed form" as a 33 byte array.
class LDKPublicKey extends ffi.Struct {
  @ffi.Array.multi([33])
  external ffi.Array<ffi.Uint8> compressed_form;
}

/// Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
/// look up the corresponding function in rust-lightning's docs.
class LDKThirtyTwoBytes extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Uint8> data;
}

/// A CResult_NoneNoneZ represents the result of a fallible operation,
/// containing a () on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneNoneZ extends ffi.Struct {
  /// The contents of this CResult_NoneNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneNoneZPtr contents;

  /// Whether this CResult_NoneNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NoneNoneZ
class LDKCResult_NoneNoneZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// Information needed to build and sign a holder's commitment transaction.
///
/// The transaction is only signed once we are ready to broadcast.
class LDKHolderCommitmentTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeHolderCommitmentTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeHolderCommitmentTransaction
    = nativeHolderCommitmentTransactionOpaque;

/// A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_PaymentPreimageZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKThirtyTwoBytes> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

typedef uintptr_t = ffi.UnsignedLong;

/// One counterparty's public keys which do not change over the life of a channel.
class LDKChannelPublicKeys extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelPublicKeys> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelPublicKeys = nativeChannelPublicKeysOpaque;

/// A CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_SignatureCVec_SignatureZZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr contents;

  /// Whether this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
class LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_SignatureCVec_SignatureZZ> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_SignatureCVec_SignatureZZ extends ffi.Struct {
  /// The element at position 0
  external LDKSignature a;

  /// The element at position 1
  external LDKCVec_SignatureZ b;
}

/// Represents a secp256k1 signature serialized as two 32-byte numbers
class LDKSignature extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> compact_form;
}

/// A dynamically-allocated array of crate::c_types::Signatures of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_SignatureZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKSignature> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// This class tracks the per-transaction information needed to build a commitment transaction and will
/// actually build it and sign.  It is used for holder transactions that we sign only when needed
/// and for transactions we sign for the counterparty.
///
/// This class can be used inside a signer implementation to generate a signature given the relevant
/// secret key.
class LDKCommitmentTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCommitmentTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCommitmentTransaction = nativeCommitmentTransactionOpaque;

/// A CResult_SignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Signature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SignatureNoneZ extends ffi.Struct {
  /// The contents of this CResult_SignatureNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SignatureNoneZPtr contents;

  /// Whether this CResult_SignatureNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_SignatureNoneZ
class LDKCResult_SignatureNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSignature> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A serialized transaction, in (pointer, length) form.
///
/// This type optionally owns its own memory, and thus the semantics around access change based on
/// the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
/// the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
/// access to the buffer after the scope in which the object was provided to you is invalid. eg,
/// access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
/// you would be invalid.
///
/// Note that, while it may change in the future, because transactions on the Rust side are stored
/// in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
/// set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
/// `data_is_owned` either set or unset at your discretion.
class LDKTransaction extends ffi.Struct {
  /// The serialized transaction data.
  ///
  /// This is non-const for your convenience, an object passed to Rust is never written to.
  external ffi.Pointer<ffi.Uint8> data;

  /// The length of the serialized transaction
  @uintptr_t()
  external int datalen;

  /// Whether the data pointed to by `data` should be freed or not.
  @ffi.Bool()
  external bool data_is_owned;
}

/// Information about an HTLC as it appears in a commitment transaction
class LDKHTLCOutputInCommitment extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeHTLCOutputInCommitment> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeHTLCOutputInCommitment = nativeHTLCOutputInCommitmentOpaque;

/// This class tracks the per-transaction information needed to build a closing transaction and will
/// actually build it and sign.
///
/// This class can be used inside a signer implementation to generate a signature given the relevant
/// secret key.
class LDKClosingTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeClosingTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeClosingTransaction = nativeClosingTransactionOpaque;

/// A CResult_C2Tuple_SignatureSignatureZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_SignatureSignatureZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_SignatureSignatureZNoneZ extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_SignatureSignatureZNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr contents;

  /// Whether this CResult_C2Tuple_SignatureSignatureZNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_C2Tuple_SignatureSignatureZNoneZ
class LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_SignatureSignatureZ> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_SignatureSignatureZ extends ffi.Struct {
  /// The element at position 0
  external LDKSignature a;

  /// The element at position 1
  external LDKSignature b;
}

/// The unsigned part of a channel_announcement
class LDKUnsignedChannelAnnouncement extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUnsignedChannelAnnouncement> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUnsignedChannelAnnouncement
    = nativeUnsignedChannelAnnouncementOpaque;

class nativeUnsignedChannelAnnouncementOpaque extends ffi.Opaque {}

/// Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
/// The fields are organized by holder/counterparty.
///
/// Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
/// before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
class LDKChannelTransactionParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelTransactionParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelTransactionParameters
    = nativeChannelTransactionParametersOpaque;

class nativeInMemorySignerOpaque extends ffi.Opaque {}

class nativeKeysManagerOpaque extends ffi.Opaque {}

class nativePhantomKeysManagerOpaque extends ffi.Opaque {}

class nativeFilesystemPersisterOpaque extends ffi.Opaque {}

class nativeChannelManagerOpaque extends ffi.Opaque {}

class nativeChainParametersOpaque extends ffi.Opaque {}

class nativeCounterpartyForwardingInfoOpaque extends ffi.Opaque {}

class nativeChannelCounterpartyOpaque extends ffi.Opaque {}

class nativeChannelDetailsOpaque extends ffi.Opaque {}

class nativePhantomRouteHintsOpaque extends ffi.Opaque {}

class nativeChannelManagerReadArgsOpaque extends ffi.Opaque {}

class nativeChannelHandshakeConfigOpaque extends ffi.Opaque {}

class nativeChannelHandshakeLimitsOpaque extends ffi.Opaque {}

class nativeChannelConfigOpaque extends ffi.Opaque {}

class nativeUserConfigOpaque extends ffi.Opaque {}

class nativeBigSizeOpaque extends ffi.Opaque {}

class nativeHostnameOpaque extends ffi.Opaque {}

class nativeOutPointOpaque extends ffi.Opaque {}

class nativeInvoicePayerOpaque extends ffi.Opaque {}

class nativeInvoiceOpaque extends ffi.Opaque {}

class nativeSignedRawInvoiceOpaque extends ffi.Opaque {}

class nativeRawInvoiceOpaque extends ffi.Opaque {}

class nativeRawDataPartOpaque extends ffi.Opaque {}

class nativePositiveTimestampOpaque extends ffi.Opaque {}

class nativeSha256Opaque extends ffi.Opaque {}

class nativeDescriptionOpaque extends ffi.Opaque {}

class nativePayeePubKeyOpaque extends ffi.Opaque {}

class nativeExpiryTimeOpaque extends ffi.Opaque {}

class nativeMinFinalCltvExpiryOpaque extends ffi.Opaque {}

class nativeInvoiceSignatureOpaque extends ffi.Opaque {}

class nativePrivateRouteOpaque extends ffi.Opaque {}

class nativeChannelMonitorUpdateOpaque extends ffi.Opaque {}

class nativeHTLCUpdateOpaque extends ffi.Opaque {}

class nativeChannelMonitorOpaque extends ffi.Opaque {}

class nativeExpandedKeyOpaque extends ffi.Opaque {}

class nativeIgnoringMessageHandlerOpaque extends ffi.Opaque {}

class nativeErroringMessageHandlerOpaque extends ffi.Opaque {}

class nativeMessageHandlerOpaque extends ffi.Opaque {}

class nativePeerHandleErrorOpaque extends ffi.Opaque {}

class nativePeerManagerOpaque extends ffi.Opaque {}

class nativeRapidGossipSyncOpaque extends ffi.Opaque {}

class nativeDecodeErrorOpaque extends ffi.Opaque {}

class nativeInitOpaque extends ffi.Opaque {}

class nativeErrorMessageOpaque extends ffi.Opaque {}

class nativeWarningMessageOpaque extends ffi.Opaque {}

class nativePingOpaque extends ffi.Opaque {}

class nativePongOpaque extends ffi.Opaque {}

class nativeOpenChannelOpaque extends ffi.Opaque {}

class nativeAcceptChannelOpaque extends ffi.Opaque {}

class nativeFundingCreatedOpaque extends ffi.Opaque {}

class nativeFundingSignedOpaque extends ffi.Opaque {}

class nativeChannelReadyOpaque extends ffi.Opaque {}

class nativeShutdownOpaque extends ffi.Opaque {}

class nativeClosingSignedFeeRangeOpaque extends ffi.Opaque {}

class nativeClosingSignedOpaque extends ffi.Opaque {}

class nativeUpdateAddHTLCOpaque extends ffi.Opaque {}

class nativeUpdateFulfillHTLCOpaque extends ffi.Opaque {}

class nativeUpdateFailHTLCOpaque extends ffi.Opaque {}

class nativeUpdateFailMalformedHTLCOpaque extends ffi.Opaque {}

class nativeCommitmentSignedOpaque extends ffi.Opaque {}

class nativeRevokeAndACKOpaque extends ffi.Opaque {}

class nativeUpdateFeeOpaque extends ffi.Opaque {}

class nativeDataLossProtectOpaque extends ffi.Opaque {}

class nativeChannelReestablishOpaque extends ffi.Opaque {}

class nativeAnnouncementSignaturesOpaque extends ffi.Opaque {}

class nativeUnsignedNodeAnnouncementOpaque extends ffi.Opaque {}

class nativeNodeAnnouncementOpaque extends ffi.Opaque {}

class nativeChannelAnnouncementOpaque extends ffi.Opaque {}

class nativeUnsignedChannelUpdateOpaque extends ffi.Opaque {}

class nativeChannelUpdateOpaque extends ffi.Opaque {}

class nativeQueryChannelRangeOpaque extends ffi.Opaque {}

class nativeReplyChannelRangeOpaque extends ffi.Opaque {}

class nativeQueryShortChannelIdsOpaque extends ffi.Opaque {}

class nativeReplyShortChannelIdsEndOpaque extends ffi.Opaque {}

class nativeGossipTimestampFilterOpaque extends ffi.Opaque {}

class nativeLightningErrorOpaque extends ffi.Opaque {}

class nativeCommitmentUpdateOpaque extends ffi.Opaque {}

class nativeDefaultRouterOpaque extends ffi.Opaque {}

class nativeRecordOpaque extends ffi.Opaque {}

class nativeMonitorUpdateIdOpaque extends ffi.Opaque {}

class nativeLockedChannelMonitorOpaque extends ffi.Opaque {}

class nativeChainMonitorOpaque extends ffi.Opaque {}

/// An error when accessing the chain via [`Access`].
abstract class LDKAccessError {
  /// The requested chain is unknown.
  static const int LDKAccessError_UnknownChain = 0;

  /// The requested transaction doesn't exist or hasn't confirmed.
  static const int LDKAccessError_UnknownTx = 1;

  /// Must be last for serialization purposes
  static const int LDKAccessError_Sentinel = 2;
}

/// An enum which can either contain a  or not
abstract class LDKCOption_NoneZ {
  /// When we're in this state, this COption_NoneZ contains a
  static const int LDKCOption_NoneZ_Some = 0;

  /// When we're in this state, this COption_NoneZ contains nothing
  static const int LDKCOption_NoneZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_NoneZ_Sentinel = 2;
}

/// An error enum representing a failure to persist a channel monitor update.
abstract class LDKChannelMonitorUpdateErr {
  /// Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
  /// our state failed, but is expected to succeed at some point in the future).
  ///
  /// Such a failure will \"freeze\" a channel, preventing us from revoking old states or
  /// submitting new commitment transactions to the counterparty. Once the update(s) that failed
  /// have been successfully applied, a [`MonitorEvent::UpdateCompleted`] event should be returned
  /// via [`Watch::release_pending_monitor_events`] which will then restore the channel to an
  /// operational state.
  ///
  /// Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
  /// you return a TemporaryFailure you must ensure that it is written to disk safely before
  /// writing out the latest ChannelManager state.
  ///
  /// Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
  /// (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
  /// to claim it on this channel) and those updates must be applied wherever they can be. At
  /// least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
  /// be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
  /// the channel which would invalidate previous ChannelMonitors are not made when a channel has
  /// been \"frozen\".
  ///
  /// Note that even if updates made after TemporaryFailure succeed you must still provide a
  /// [`MonitorEvent::UpdateCompleted`] to ensure you have the latest monitor and re-enable
  /// normal channel operation. Note that this is normally generated through a call to
  /// [`ChainMonitor::channel_monitor_updated`].
  ///
  /// Note that the update being processed here will not be replayed for you when you return a
  /// [`MonitorEvent::UpdateCompleted`] event via [`Watch::release_pending_monitor_events`], so
  /// you must store the update itself on your own local disk prior to returning a
  /// TemporaryFailure. You may, of course, employ a journaling approach, storing only the
  /// ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
  /// reload-time.
  ///
  /// For deployments where a copy of ChannelMonitors and other local state are backed up in a
  /// remote location (with local copies persisted immediately), it is anticipated that all
  /// updates will return TemporaryFailure until the remote copies could be updated.
  ///
  /// [`ChainMonitor::channel_monitor_updated`]: chainmonitor::ChainMonitor::channel_monitor_updated
  static const int LDKChannelMonitorUpdateErr_TemporaryFailure = 0;

  /// Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
  /// different watchtower and cannot update with all watchtowers that were previously informed
  /// of this channel).
  ///
  /// At reception of this error, ChannelManager will force-close the channel and return at
  /// least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
  /// least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
  /// update must be rejected.
  ///
  /// This failure may also signal a failure to update the local persisted copy of one of
  /// the channel monitor instance.
  ///
  /// Note that even when you fail a holder commitment transaction update, you must store the
  /// update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
  /// broadcasts it (e.g distributed channel-monitor deployment)
  ///
  /// In case of distributed watchtowers deployment, the new version must be written to disk, as
  /// state may have been stored but rejected due to a block forcing a commitment broadcast. This
  /// storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
  /// lagging behind on block processing.
  static const int LDKChannelMonitorUpdateErr_PermanentFailure = 1;

  /// Must be last for serialization purposes
  static const int LDKChannelMonitorUpdateErr_Sentinel = 2;
}

/// An enum that represents the speed at which we want a transaction to confirm used for feerate
/// estimation.
abstract class LDKConfirmationTarget {
  /// We are happy with this transaction confirming slowly when feerate drops some.
  static const int LDKConfirmationTarget_Background = 0;

  /// We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
  static const int LDKConfirmationTarget_Normal = 1;

  /// We'd like this transaction to confirm in the next few blocks.
  static const int LDKConfirmationTarget_HighPriority = 2;

  /// Must be last for serialization purposes
  static const int LDKConfirmationTarget_Sentinel = 3;
}

/// Errors that may occur when constructing a new `RawInvoice` or `Invoice`
abstract class LDKCreationError {
  /// The supplied description string was longer than 639 __bytes__ (see [`Description::new()`](./struct.Description.html#method.new))
  static const int LDKCreationError_DescriptionTooLong = 0;

  /// The specified route has too many hops and can't be encoded
  static const int LDKCreationError_RouteTooLong = 1;

  /// The Unix timestamp of the supplied date is less than zero or greater than 35-bits
  static const int LDKCreationError_TimestampOutOfBounds = 2;

  /// The supplied millisatoshi amount was greater than the total bitcoin supply.
  static const int LDKCreationError_InvalidAmount = 3;

  /// Route hints were required for this invoice and were missing. Applies to
  /// [phantom invoices].
  ///
  /// [phantom invoices]: crate::utils::create_phantom_invoice
  static const int LDKCreationError_MissingRouteHints = 4;

  /// Must be last for serialization purposes
  static const int LDKCreationError_Sentinel = 5;
}

/// Enum representing the crypto currencies (or networks) supported by this library
abstract class LDKCurrency {
  /// Bitcoin mainnet
  static const int LDKCurrency_Bitcoin = 0;

  /// Bitcoin testnet
  static const int LDKCurrency_BitcoinTestnet = 1;

  /// Bitcoin regtest
  static const int LDKCurrency_Regtest = 2;

  /// Bitcoin simnet
  static const int LDKCurrency_Simnet = 3;

  /// Bitcoin signet
  static const int LDKCurrency_Signet = 4;

  /// Must be last for serialization purposes
  static const int LDKCurrency_Sentinel = 5;
}

/// Represents an IO Error. Note that some information is lost in the conversion from Rust.
abstract class LDKIOError {
  static const int LDKIOError_NotFound = 0;
  static const int LDKIOError_PermissionDenied = 1;
  static const int LDKIOError_ConnectionRefused = 2;
  static const int LDKIOError_ConnectionReset = 3;
  static const int LDKIOError_ConnectionAborted = 4;
  static const int LDKIOError_NotConnected = 5;
  static const int LDKIOError_AddrInUse = 6;
  static const int LDKIOError_AddrNotAvailable = 7;
  static const int LDKIOError_BrokenPipe = 8;
  static const int LDKIOError_AlreadyExists = 9;
  static const int LDKIOError_WouldBlock = 10;
  static const int LDKIOError_InvalidInput = 11;
  static const int LDKIOError_InvalidData = 12;
  static const int LDKIOError_TimedOut = 13;
  static const int LDKIOError_WriteZero = 14;
  static const int LDKIOError_Interrupted = 15;
  static const int LDKIOError_Other = 16;
  static const int LDKIOError_UnexpectedEof = 17;

  /// Must be last for serialization purposes
  static const int LDKIOError_Sentinel = 18;
}

/// An enum representing the available verbosity levels of the logger.
abstract class LDKLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  static const int LDKLevel_Gossip = 0;

  /// Designates very low priority, often extremely verbose, information
  static const int LDKLevel_Trace = 1;

  /// Designates lower priority information
  static const int LDKLevel_Debug = 2;

  /// Designates useful information
  static const int LDKLevel_Info = 3;

  /// Designates hazardous situations
  static const int LDKLevel_Warn = 4;

  /// Designates very serious errors
  static const int LDKLevel_Error = 5;

  /// Must be last for serialization purposes
  static const int LDKLevel_Sentinel = 6;
}

/// An enum representing the possible Bitcoin or test networks which we can run on
abstract class LDKNetwork {
  /// The main Bitcoin blockchain.
  static const int LDKNetwork_Bitcoin = 0;

  /// The testnet3 blockchain.
  static const int LDKNetwork_Testnet = 1;

  /// A local test blockchain.
  static const int LDKNetwork_Regtest = 2;

  /// A blockchain on which blocks are signed instead of mined.
  static const int LDKNetwork_Signet = 3;

  /// Must be last for serialization purposes
  static const int LDKNetwork_Sentinel = 4;
}

/// Specifies the recipient of an invoice, to indicate to [`KeysInterface::sign_invoice`] what node
/// secret key should be used to sign the invoice.
abstract class LDKRecipient {
  /// The invoice should be signed with the local node secret key.
  static const int LDKRecipient_Node = 0;

  /// The invoice should be signed with the phantom node secret key. This secret key must be the
  /// same for all nodes participating in the [phantom node payment].
  ///
  /// [phantom node payment]: PhantomKeysManager
  static const int LDKRecipient_PhantomNode = 1;

  /// Must be last for serialization purposes
  static const int LDKRecipient_Sentinel = 2;
}

/// Represents an error returned from libsecp256k1 during validation of some secp256k1 data
abstract class LDKSecp256k1Error {
  /// Signature failed verification
  static const int LDKSecp256k1Error_IncorrectSignature = 0;

  /// Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
  static const int LDKSecp256k1Error_InvalidMessage = 1;

  /// Bad public key
  static const int LDKSecp256k1Error_InvalidPublicKey = 2;

  /// Bad signature
  static const int LDKSecp256k1Error_InvalidSignature = 3;

  /// Bad secret key
  static const int LDKSecp256k1Error_InvalidSecretKey = 4;

  /// Bad shared secret.
  static const int LDKSecp256k1Error_InvalidSharedSecret = 5;

  /// Bad recovery id
  static const int LDKSecp256k1Error_InvalidRecoveryId = 6;

  /// Invalid tweak for add_assign or mul_assign
  static const int LDKSecp256k1Error_InvalidTweak = 7;

  /// Didn't pass enough memory to context creation with preallocated memory
  static const int LDKSecp256k1Error_NotEnoughMemory = 8;

  /// Bad set of public keys.
  static const int LDKSecp256k1Error_InvalidPublicKeySum = 9;

  /// The only valid parity values are 0 or 1.
  static const int LDKSecp256k1Error_InvalidParityValue = 10;

  /// Must be last for serialization purposes
  static const int LDKSecp256k1Error_Sentinel = 11;
}

/// Errors that may occur when converting a `RawInvoice` to an `Invoice`. They relate to the
/// requirements sections in BOLT #11
abstract class LDKSemanticError {
  /// The invoice is missing the mandatory payment hash
  static const int LDKSemanticError_NoPaymentHash = 0;

  /// The invoice has multiple payment hashes which isn't allowed
  static const int LDKSemanticError_MultiplePaymentHashes = 1;

  /// No description or description hash are part of the invoice
  static const int LDKSemanticError_NoDescription = 2;

  /// The invoice contains multiple descriptions and/or description hashes which isn't allowed
  static const int LDKSemanticError_MultipleDescriptions = 3;

  /// The invoice is missing the mandatory payment secret, which all modern lightning nodes
  /// should provide.
  static const int LDKSemanticError_NoPaymentSecret = 4;

  /// The invoice contains multiple payment secrets
  static const int LDKSemanticError_MultiplePaymentSecrets = 5;

  /// The invoice's features are invalid
  static const int LDKSemanticError_InvalidFeatures = 6;

  /// The recovery id doesn't fit the signature/pub key
  static const int LDKSemanticError_InvalidRecoveryId = 7;

  /// The invoice's signature is invalid
  static const int LDKSemanticError_InvalidSignature = 8;

  /// The invoice's amount was not a whole number of millisatoshis
  static const int LDKSemanticError_ImpreciseAmount = 9;

  /// Must be last for serialization purposes
  static const int LDKSemanticError_Sentinel = 10;
}

/// SI prefixes for the human readable part
abstract class LDKSiPrefix {
  /// 10^-3
  static const int LDKSiPrefix_Milli = 0;

  /// 10^-6
  static const int LDKSiPrefix_Micro = 1;

  /// 10^-9
  static const int LDKSiPrefix_Nano = 2;

  /// 10^-12
  static const int LDKSiPrefix_Pico = 3;

  /// Must be last for serialization purposes
  static const int LDKSiPrefix_Sentinel = 4;
}

/// A Rust str object, ie a reference to a UTF8-valid string.
/// This is *not* null-terminated so cannot be used directly as a C string!
class LDKStr extends ffi.Struct {
  /// A pointer to the string's bytes, in UTF8 encoding
  external ffi.Pointer<ffi.Uint8> chars;

  /// The number of bytes (not characters!) pointed to by `chars`
  @uintptr_t()
  external int len;

  /// Whether the data pointed to by `chars` should be freed or not.
  @ffi.Bool()
  external bool chars_is_owned;
}

/// Represents an error returned from the bech32 library during validation of some bech32 data
abstract class LDKBech32Error_Tag {
  /// String does not contain the separator character
  static const int LDKBech32Error_MissingSeparator = 0;

  /// The checksum does not match the rest of the data
  static const int LDKBech32Error_InvalidChecksum = 1;

  /// The data or human-readable part is too long or too short
  static const int LDKBech32Error_InvalidLength = 2;

  /// Some part of the string contains an invalid character
  static const int LDKBech32Error_InvalidChar = 3;

  /// Some part of the data has an invalid value
  static const int LDKBech32Error_InvalidData = 4;

  /// The bit conversion failed due to a padding issue
  static const int LDKBech32Error_InvalidPadding = 5;

  /// The whole string must be of one case
  static const int LDKBech32Error_MixedCase = 6;

  /// Must be last for serialization purposes
  static const int LDKBech32Error_Sentinel = 7;
}

class LDKBech32Error extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of u8s of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_u8Z extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<ffi.Uint8> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A transaction output including a scriptPubKey and value.
/// This type *does* own its own memory, so must be free'd appropriately.
class LDKTxOut extends ffi.Struct {
  /// The script_pubkey in this output
  external LDKCVec_u8Z script_pubkey;

  /// The value, in satoshis, of this output
  @ffi.Uint64()
  external int value;
}

/// Implements the per-commitment secret storage scheme from
/// [BOLT 3](https://github.com/lightning/bolts/blob/dcbf8583976df087c79c3ce0b535311212e6812d/03-transactions.md#efficient-per-commitment-secret-storage).
///
/// Allows us to keep track of all of the revocation secrets of our counterparty in just 50*32 bytes
/// or so.
class LDKCounterpartyCommitmentSecrets extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCounterpartyCommitmentSecrets> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCounterpartyCommitmentSecrets
    = nativeCounterpartyCommitmentSecretsOpaque;

/// An error in decoding a message or struct.
class LDKDecodeError extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDecodeError> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDecodeError = nativeDecodeErrorOpaque;

/// The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
class LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCounterpartyCommitmentSecrets> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr contents;

  /// Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Represents a valid secp256k1 secret key serialized as a 32 byte array.
class LDKSecretKey extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Uint8> bytes;
}

/// The contents of CResult_SecretKeyErrorZ
class LDKCResult_SecretKeyErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSecretKey> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_SecretKeyErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::SecretKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SecretKeyErrorZ extends ffi.Struct {
  /// The contents of this CResult_SecretKeyErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SecretKeyErrorZPtr contents;

  /// Whether this CResult_SecretKeyErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_PublicKeyErrorZ
class LDKCResult_PublicKeyErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPublicKey> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_PublicKeyErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PublicKeyErrorZ extends ffi.Struct {
  /// The contents of this CResult_PublicKeyErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PublicKeyErrorZPtr contents;

  /// Whether this CResult_PublicKeyErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The set of public keys which are used in the creation of one commitment transaction.
/// These are derived from the channel base keys and per-commitment data.
///
/// A broadcaster key is provided from potential broadcaster of the computed transaction.
/// A countersignatory key is coming from a protocol participant unable to broadcast the
/// transaction.
///
/// These keys are assumed to be good, either because the code derived them from
/// channel basepoints via the new function, or they were obtained via
/// CommitmentTransaction.trust().keys() because we trusted the source of the
/// pre-calculated keys.
class LDKTxCreationKeys extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeTxCreationKeys> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeTxCreationKeys = nativeTxCreationKeysOpaque;

/// The contents of CResult_TxCreationKeysDecodeErrorZ
class LDKCResult_TxCreationKeysDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTxCreationKeys> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TxCreationKeysDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TxCreationKeysDecodeErrorZPtr contents;

  /// Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelPublicKeysDecodeErrorZ
class LDKCResult_ChannelPublicKeysDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelPublicKeys> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelPublicKeysDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_TxCreationKeysErrorZ
class LDKCResult_TxCreationKeysErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTxCreationKeys> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_TxCreationKeysErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TxCreationKeysErrorZ extends ffi.Struct {
  /// The contents of this CResult_TxCreationKeysErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TxCreationKeysErrorZPtr contents;

  /// Whether this CResult_TxCreationKeysErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An enum which can either contain a u32 or not
abstract class LDKCOption_u32Z_Tag {
  /// When we're in this state, this COption_u32Z contains a u32
  static const int LDKCOption_u32Z_Some = 0;

  /// When we're in this state, this COption_u32Z contains nothing
  static const int LDKCOption_u32Z_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_u32Z_Sentinel = 2;
}

class LDKCOption_u32Z extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
class LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKHTLCOutputInCommitment> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_HTLCOutputInCommitmentDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;

  /// Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Late-bound per-channel counterparty data used to build transactions.
class LDKCounterpartyChannelTransactionParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCounterpartyChannelTransactionParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCounterpartyChannelTransactionParameters
    = nativeCounterpartyChannelTransactionParametersOpaque;

/// The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
class LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCounterpartyChannelTransactionParameters> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ
    extends ffi.Struct {
  /// The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr
      contents;

  /// Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelTransactionParametersDecodeErrorZ
class LDKCResult_ChannelTransactionParametersDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelTransactionParameters> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelTransactionParametersDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
class LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKHolderCommitmentTransaction> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_HolderCommitmentTransactionDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;

  /// Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A pre-built Bitcoin commitment transaction and its txid.
class LDKBuiltCommitmentTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeBuiltCommitmentTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeBuiltCommitmentTransaction
    = nativeBuiltCommitmentTransactionOpaque;

/// The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
class LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKBuiltCommitmentTransaction> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_BuiltCommitmentTransactionDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;

  /// Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A wrapper on ClosingTransaction indicating that the built bitcoin
/// transaction is trusted.
///
/// See trust() and verify() functions on CommitmentTransaction.
///
/// This structure implements Deref.
class LDKTrustedClosingTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeTrustedClosingTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeTrustedClosingTransaction
    = nativeTrustedClosingTransactionOpaque;

/// The contents of CResult_TrustedClosingTransactionNoneZ
class LDKCResult_TrustedClosingTransactionNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTrustedClosingTransaction> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TrustedClosingTransactionNoneZ extends ffi.Struct {
  /// The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TrustedClosingTransactionNoneZPtr contents;

  /// Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_CommitmentTransactionDecodeErrorZ
class LDKCResult_CommitmentTransactionDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCommitmentTransaction> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CommitmentTransactionDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;

  /// Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
/// transaction and the transaction creation keys) are trusted.
///
/// See trust() and verify() functions on CommitmentTransaction.
///
/// This structure implements Deref.
class LDKTrustedCommitmentTransaction extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeTrustedCommitmentTransaction> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeTrustedCommitmentTransaction
    = nativeTrustedCommitmentTransactionOpaque;

/// The contents of CResult_TrustedCommitmentTransactionNoneZ
class LDKCResult_TrustedCommitmentTransactionNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTrustedCommitmentTransaction> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TrustedCommitmentTransactionNoneZ extends ffi.Struct {
  /// The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;

  /// Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_CVec_SignatureZNoneZ
class LDKCResult_CVec_SignatureZNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCVec_SignatureZ> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_CVec_SignatureZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_SignatureZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CVec_SignatureZNoneZ extends ffi.Struct {
  /// The contents of this CResult_CVec_SignatureZNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CVec_SignatureZNoneZPtr contents;

  /// Whether this CResult_CVec_SignatureZNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A script pubkey for shutting down a channel as defined by [BOLT #2].
///
/// [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
class LDKShutdownScript extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeShutdownScript> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeShutdownScript = nativeShutdownScriptOpaque;

/// The contents of CResult_ShutdownScriptDecodeErrorZ
class LDKCResult_ShutdownScriptDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKShutdownScript> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ShutdownScriptDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ShutdownScriptDecodeErrorZPtr contents;

  /// Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An error occurring when converting from [`Script`] to [`ShutdownScript`].
class LDKInvalidShutdownScript extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInvalidShutdownScript> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInvalidShutdownScript = nativeInvalidShutdownScriptOpaque;

/// The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
class LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKShutdownScript> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKInvalidShutdownScript> err;
}

/// A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ShutdownScriptInvalidShutdownScriptZ extends ffi.Struct {
  /// The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr contents;

  /// Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NoneErrorZ
class LDKCResult_NoneErrorZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_NoneErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneErrorZ extends ffi.Struct {
  /// The contents of this CResult_NoneErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneErrorZPtr contents;

  /// Whether this CResult_NoneErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A hop in a route
class LDKRouteHop extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRouteHop> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRouteHop = nativeRouteHopOpaque;

/// The contents of CResult_RouteHopDecodeErrorZ
class LDKCResult_RouteHopDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRouteHop> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteHopDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteHopDecodeErrorZPtr contents;

  /// Whether this CResult_RouteHopDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_RouteHopZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKRouteHop> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::c_types::derived::CVec_RouteHopZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_CVec_RouteHopZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKCVec_RouteHopZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
/// it can take multiple paths. Each path is composed of one or more hops through the network.
class LDKRoute extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRoute> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRoute = nativeRouteOpaque;

/// The contents of CResult_RouteDecodeErrorZ
class LDKCResult_RouteDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRoute> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteDecodeErrorZPtr contents;

  /// Whether this CResult_RouteDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Parameters needed to find a [`Route`].
///
/// Passed to [`find_route`] and [`build_route_from_hops`], but also provided in
/// [`Event::PaymentPathFailed`] for retrying a failed payment path.
///
/// [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
class LDKRouteParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRouteParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRouteParameters = nativeRouteParametersOpaque;

/// The contents of CResult_RouteParametersDecodeErrorZ
class LDKCResult_RouteParametersDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRouteParameters> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteParametersDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteParametersDecodeErrorZPtr contents;

  /// Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A list of hops along a payment path terminating with a channel to the recipient.
class LDKRouteHint extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRouteHint> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRouteHint = nativeRouteHintOpaque;

/// A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_RouteHintZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKRouteHint> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An enum which can either contain a u64 or not
abstract class LDKCOption_u64Z_Tag {
  /// When we're in this state, this COption_u64Z contains a u64
  static const int LDKCOption_u64Z_Some = 0;

  /// When we're in this state, this COption_u64Z contains nothing
  static const int LDKCOption_u64Z_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_u64Z_Sentinel = 2;
}

class LDKCOption_u64Z extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of u64s of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_u64Z extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<ffi.Uint64> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The recipient of a payment.
class LDKPaymentParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePaymentParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePaymentParameters = nativePaymentParametersOpaque;

/// The contents of CResult_PaymentParametersDecodeErrorZ
class LDKCResult_PaymentParametersDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPaymentParameters> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentParametersDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentParametersDecodeErrorZPtr contents;

  /// Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A channel descriptor for a hop along a payment path.
class LDKRouteHintHop extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRouteHintHop> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRouteHintHop = nativeRouteHintHopOpaque;

/// A dynamically-allocated array of crate::lightning::routing::router::RouteHintHops of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_RouteHintHopZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKRouteHintHop> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_RouteHintDecodeErrorZ
class LDKCResult_RouteHintDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRouteHint> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteHintDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteHintDecodeErrorZPtr contents;

  /// Whether this CResult_RouteHintDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_RouteHintHopDecodeErrorZ
class LDKCResult_RouteHintHopDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRouteHintHop> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteHintHopDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteHintHopDecodeErrorZPtr contents;

  /// Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
class LDKChannelDetails extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelDetails> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelDetails = nativeChannelDetailsOpaque;

/// A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_ChannelDetailsZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKChannelDetails> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An Err type for failure to process messages.
class LDKLightningError extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeLightningError> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeLightningError = nativeLightningErrorOpaque;

/// The contents of CResult_RouteLightningErrorZ
class LDKCResult_RouteLightningErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRoute> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKLightningError> err;
}

/// A CResult_RouteLightningErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RouteLightningErrorZ extends ffi.Struct {
  /// The contents of this CResult_RouteLightningErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RouteLightningErrorZPtr contents;

  /// Whether this CResult_RouteLightningErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_PublicKeyZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKPublicKey> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// Some information provided on receipt of payment depends on whether the payment received is a
/// spontaneous payment or a \"conventional\" lightning payment that's paying an invoice.
abstract class LDKPaymentPurpose_Tag {
  /// Information for receiving a payment that we generated an invoice for.
  static const int LDKPaymentPurpose_InvoicePayment = 0;

  /// Because this is a spontaneous payment, the payer generated their own preimage rather than us
  /// (the payee) providing a preimage.
  static const int LDKPaymentPurpose_SpontaneousPayment = 1;

  /// Must be last for serialization purposes
  static const int LDKPaymentPurpose_Sentinel = 2;
}

class LDKPaymentPurpose_LDKInvoicePayment_Body extends ffi.Struct {
  /// The preimage to the payment_hash, if the payment hash (and secret) were fetched via
  /// [`ChannelManager::create_inbound_payment`]. If provided, this can be handed directly to
  /// [`ChannelManager::claim_funds`].
  ///
  /// [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
  /// [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes payment_preimage;

  /// The \"payment secret\". This authenticates the sender to the recipient, preventing a
  /// number of deanonymization attacks during the routing process.
  /// It is provided here for your reference, however its accuracy is enforced directly by
  /// [`ChannelManager`] using the values you previously provided to
  /// [`ChannelManager::create_inbound_payment`] or
  /// [`ChannelManager::create_inbound_payment_for_hash`].
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  /// [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
  /// [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
  external LDKThirtyTwoBytes payment_secret;
}

class LDKPaymentPurpose extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_PaymentPurposeDecodeErrorZ
class LDKCResult_PaymentPurposeDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPaymentPurpose> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_PaymentPurposeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::events::PaymentPurpose on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentPurposeDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_PaymentPurposeDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentPurposeDecodeErrorZPtr contents;

  /// Whether this CResult_PaymentPurposeDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The reason the channel was closed. See individual variants more details.
abstract class LDKClosureReason_Tag {
  /// Closure generated from receiving a peer error message.
  ///
  /// Our counterparty may have broadcasted their latest commitment state, and we have
  /// as well.
  static const int LDKClosureReason_CounterpartyForceClosed = 0;

  /// Closure generated from [`ChannelManager::force_close_channel`], called by the user.
  ///
  /// [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
  static const int LDKClosureReason_HolderForceClosed = 1;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. Note the shutdown may have been initiated by us.
  static const int LDKClosureReason_CooperativeClosure = 2;

  /// A commitment transaction was confirmed on chain, closing the channel. Most likely this
  /// commitment transaction came from our counterparty, but it may also have come from
  /// a copy of our own `ChannelMonitor`.
  static const int LDKClosureReason_CommitmentTxConfirmed = 3;

  /// The funding transaction failed to confirm in a timely manner on an inbound channel.
  static const int LDKClosureReason_FundingTimedOut = 4;

  /// Closure generated from processing an event, likely a HTLC forward/relay/reception.
  static const int LDKClosureReason_ProcessingError = 5;

  /// The peer disconnected prior to funding completing. In this case the spec mandates that we
  /// forget the channel entirely - we can attempt again if the peer reconnects.
  ///
  /// In LDK versions prior to 0.0.107 this could also occur if we were unable to connect to the
  /// peer because of mutual incompatibility between us and our channel counterparty.
  static const int LDKClosureReason_DisconnectedPeer = 6;

  /// Closure generated from `ChannelManager::read` if the ChannelMonitor is newer than
  /// the ChannelManager deserialized.
  static const int LDKClosureReason_OutdatedChannelManager = 7;

  /// Must be last for serialization purposes
  static const int LDKClosureReason_Sentinel = 8;
}

class LDKClosureReason_LDKCounterpartyForceClosed_Body extends ffi.Struct {
  /// The error which the peer sent us.
  ///
  /// The string should be sanitized before it is used (e.g emitted to logs
  /// or printed to stdout). Otherwise, a well crafted error message may exploit
  /// a security vulnerability in the terminal emulator or the logging subsystem.
  external LDKStr peer_msg;
}

class LDKClosureReason_LDKProcessingError_Body extends ffi.Struct {
  /// A developer-readable error message which we generated.
  external LDKStr err;
}

class LDKClosureReason extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// An enum which can either contain a crate::lightning::util::events::ClosureReason or not
abstract class LDKCOption_ClosureReasonZ_Tag {
  /// When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::util::events::ClosureReason
  static const int LDKCOption_ClosureReasonZ_Some = 0;

  /// When we're in this state, this COption_ClosureReasonZ contains nothing
  static const int LDKCOption_ClosureReasonZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_ClosureReasonZ_Sentinel = 2;
}

class LDKCOption_ClosureReasonZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_COption_ClosureReasonZDecodeErrorZ
class LDKCResult_COption_ClosureReasonZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_ClosureReasonZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_ClosureReasonZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_ClosureReasonZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Intended destination of a failed HTLC as indicated in [`Event::HTLCHandlingFailed`].
abstract class LDKHTLCDestination_Tag {
  /// We tried forwarding to a channel but failed to do so. An example of such an instance is when
  /// there is insufficient capacity in our outbound channel.
  static const int LDKHTLCDestination_NextHopChannel = 0;

  /// Scenario where we are unsure of the next node to forward the HTLC to.
  static const int LDKHTLCDestination_UnknownNextHop = 1;

  /// Failure scenario where an HTLC may have been forwarded to be intended for us,
  /// but is invalid for some reason, so we reject it.
  ///
  /// Some of the reasons may include:
  /// * HTLC Timeouts
  /// * Expected MPP amount to claim does not equal HTLC total
  /// * Claimable amount does not match expected amount
  static const int LDKHTLCDestination_FailedPayment = 2;

  /// Must be last for serialization purposes
  static const int LDKHTLCDestination_Sentinel = 3;
}

class LDKHTLCDestination_LDKNextHopChannel_Body extends ffi.Struct {
  /// The `node_id` of the next node. For backwards compatibility, this field is
  /// marked as optional, versions prior to 0.0.110 may not always be able to provide
  /// counterparty node information.
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKPublicKey node_id;

  /// The outgoing `channel_id` between us and the next node.
  external LDKThirtyTwoBytes channel_id;
}

class LDKHTLCDestination_LDKUnknownNextHop_Body extends ffi.Struct {
  /// Short channel id we are requesting to forward an HTLC to.
  @ffi.Uint64()
  external int requested_forward_scid;
}

class LDKHTLCDestination_LDKFailedPayment_Body extends ffi.Struct {
  /// The payment hash of the payment we attempted to process.
  external LDKThirtyTwoBytes payment_hash;
}

class LDKHTLCDestination extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// An enum which can either contain a crate::lightning::util::events::HTLCDestination or not
abstract class LDKCOption_HTLCDestinationZ_Tag {
  /// When we're in this state, this COption_HTLCDestinationZ contains a crate::lightning::util::events::HTLCDestination
  static const int LDKCOption_HTLCDestinationZ_Some = 0;

  /// When we're in this state, this COption_HTLCDestinationZ contains nothing
  static const int LDKCOption_HTLCDestinationZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_HTLCDestinationZ_Sentinel = 2;
}

class LDKCOption_HTLCDestinationZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_COption_HTLCDestinationZDecodeErrorZ
class LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_HTLCDestinationZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_HTLCDestinationZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_HTLCDestinationZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_HTLCDestinationZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_HTLCDestinationZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_HTLCDestinationZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A channel_update message to be sent or received from a peer
class LDKChannelUpdate extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelUpdate> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelUpdate = nativeChannelUpdateOpaque;

/// Update to the [`NetworkGraph`] based on payment failure information conveyed via the Onion
/// return packet by a node along the route. See [BOLT #4] for details.
///
/// [BOLT #4]: https://github.com/lightning/bolts/blob/master/04-onion-routing.md
abstract class LDKNetworkUpdate_Tag {
  /// An error indicating a `channel_update` messages should be applied via
  /// [`NetworkGraph::update_channel`].
  static const int LDKNetworkUpdate_ChannelUpdateMessage = 0;

  /// An error indicating that a channel failed to route a payment, which should be applied via
  /// [`NetworkGraph::channel_failed`].
  static const int LDKNetworkUpdate_ChannelFailure = 1;

  /// An error indicating that a node failed to route a payment, which should be applied via
  /// [`NetworkGraph::node_failed`].
  static const int LDKNetworkUpdate_NodeFailure = 2;

  /// Must be last for serialization purposes
  static const int LDKNetworkUpdate_Sentinel = 3;
}

class LDKNetworkUpdate_LDKChannelUpdateMessage_Body extends ffi.Struct {
  /// The update to apply via [`NetworkGraph::update_channel`].
  external LDKChannelUpdate msg;
}

class LDKNetworkUpdate_LDKChannelFailure_Body extends ffi.Struct {
  /// The short channel id of the closed channel.
  @ffi.Uint64()
  external int short_channel_id;

  /// Whether the channel should be permanently removed or temporarily disabled until a new
  /// `channel_update` message is received.
  @ffi.Bool()
  external bool is_permanent;
}

class LDKNetworkUpdate_LDKNodeFailure_Body extends ffi.Struct {
  /// The node id of the failed node.
  external LDKPublicKey node_id;

  /// Whether the node should be permanently removed from consideration or can be restored
  /// when a new `channel_update` message is received.
  @ffi.Bool()
  external bool is_permanent;
}

class LDKNetworkUpdate extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// An enum which can either contain a crate::lightning::routing::gossip::NetworkUpdate or not
abstract class LDKCOption_NetworkUpdateZ_Tag {
  /// When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::gossip::NetworkUpdate
  static const int LDKCOption_NetworkUpdateZ_Some = 0;

  /// When we're in this state, this COption_NetworkUpdateZ contains nothing
  static const int LDKCOption_NetworkUpdateZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_NetworkUpdateZ_Sentinel = 2;
}

class LDKCOption_NetworkUpdateZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A reference to a transaction output.
///
/// Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
/// due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
class LDKOutPoint extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeOutPoint> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeOutPoint = nativeOutPointOpaque;

/// Information about a spendable output to a P2WSH script. See
/// SpendableOutputDescriptor::DelayedPaymentOutput for more details on how to spend this.
class LDKDelayedPaymentOutputDescriptor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDelayedPaymentOutputDescriptor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDelayedPaymentOutputDescriptor
    = nativeDelayedPaymentOutputDescriptorOpaque;

/// Information about a spendable output to our \"payment key\". See
/// SpendableOutputDescriptor::StaticPaymentOutput for more details on how to spend this.
class LDKStaticPaymentOutputDescriptor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeStaticPaymentOutputDescriptor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeStaticPaymentOutputDescriptor
    = nativeStaticPaymentOutputDescriptorOpaque;

/// When on-chain outputs are created by rust-lightning (which our counterparty is not able to
/// claim at any point in the future) an event is generated which you must track and be able to
/// spend on-chain. The information needed to do this is provided in this enum, including the
/// outpoint describing which txid and output index is available, the full output which exists at
/// that txid/index, and any keys or other information required to sign.
abstract class LDKSpendableOutputDescriptor_Tag {
  /// An output to a script which was provided via KeysInterface directly, either from
  /// `get_destination_script()` or `get_shutdown_scriptpubkey()`, thus you should already know
  /// how to spend it. No secret keys are provided as rust-lightning was never given any key.
  /// These may include outputs from a transaction punishing our counterparty or claiming an HTLC
  /// on-chain using the payment preimage or after it has timed out.
  static const int LDKSpendableOutputDescriptor_StaticOutput = 0;

  /// An output to a P2WSH script which can be spent with a single signature after a CSV delay.
  ///
  /// The witness in the spending input should be:
  /// <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
  ///
  /// Note that the nSequence field in the spending input must be set to to_self_delay
  /// (which means the transaction is not broadcastable until at least to_self_delay
  /// blocks after the outpoint confirms).
  ///
  /// These are generally the result of a \"revocable\" output to us, spendable only by us unless
  /// it is an output from an old state which we broadcast (which should never happen).
  ///
  /// To derive the delayed_payment key which is used to sign for this input, you must pass the
  /// holder delayed_payment_base_key (ie the private key which corresponds to the pubkey in
  /// Sign::pubkeys().delayed_payment_basepoint) and the provided per_commitment_point to
  /// chan_utils::derive_private_key. The public key can be generated without the secret key
  /// using chan_utils::derive_public_key and only the delayed_payment_basepoint which appears in
  /// Sign::pubkeys().
  ///
  /// To derive the revocation_pubkey provided here (which is used in the witness
  /// script generation), you must pass the counterparty revocation_basepoint (which appears in the
  /// call to Sign::ready_channel) and the provided per_commitment point
  /// to chan_utils::derive_public_revocation_key.
  ///
  /// The witness script which is hashed and included in the output script_pubkey may be
  /// regenerated by passing the revocation_pubkey (derived as above), our delayed_payment pubkey
  /// (derived as above), and the to_self_delay contained here to
  /// chan_utils::get_revokeable_redeemscript.
  static const int LDKSpendableOutputDescriptor_DelayedPaymentOutput = 1;

  /// An output to a P2WPKH, spendable exclusively by our payment key (ie the private key which
  /// corresponds to the public key in Sign::pubkeys().payment_point).
  /// The witness in the spending input, is, thus, simply:
  /// <BIP 143 signature> <payment key>
  ///
  /// These are generally the result of our counterparty having broadcast the current state,
  /// allowing us to claim the non-HTLC-encumbered outputs immediately.
  static const int LDKSpendableOutputDescriptor_StaticPaymentOutput = 2;

  /// Must be last for serialization purposes
  static const int LDKSpendableOutputDescriptor_Sentinel = 3;
}

class LDKSpendableOutputDescriptor_LDKStaticOutput_Body extends ffi.Struct {
  /// The outpoint which is spendable
  external LDKOutPoint outpoint;

  /// The output which is referenced by the given outpoint.
  external LDKTxOut output;
}

class LDKSpendableOutputDescriptor extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of crate::lightning::chain::keysinterface::SpendableOutputDescriptors of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_SpendableOutputDescriptorZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKSpendableOutputDescriptor> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// Features used within the channel_type field in an OpenChannel message.
///
/// A channel is always of some known \"type\", describing the transaction formats used and the exact
/// semantics of our interaction with our peer.
///
/// Note that because a channel is a specific type which is proposed by the opener and accepted by
/// the counterparty, only required features are allowed here.
///
/// This is serialized differently from other feature types - it is not prefixed by a length, and
/// thus must only appear inside a TLV where its length is known in advance.
class LDKChannelTypeFeatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelTypeFeatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelTypeFeatures = nativeChannelTypeFeaturesOpaque;

/// An Event which you should probably take some action in response to.
///
/// Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
/// them directly as they don't round-trip exactly (for example FundingGenerationReady is never
/// written as it makes no sense to respond to it after reconnecting to peers).
abstract class LDKEvent_Tag {
  /// Used to indicate that the client should generate a funding transaction with the given
  /// parameters and then call [`ChannelManager::funding_transaction_generated`].
  /// Generated in [`ChannelManager`] message handling.
  /// Note that *all inputs* in the funding transaction must spend SegWit outputs or your
  /// counterparty can steal your funds!
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  /// [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
  static const int LDKEvent_FundingGenerationReady = 0;

  /// Indicates we've received (an offer of) money! Just gotta dig out that payment preimage and
  /// feed it to [`ChannelManager::claim_funds`] to get it....
  ///
  /// Note that if the preimage is not known, you should call
  /// [`ChannelManager::fail_htlc_backwards`] to free up resources for this HTLC and avoid
  /// network congestion.
  /// If you fail to call either [`ChannelManager::claim_funds`] or
  /// [`ChannelManager::fail_htlc_backwards`] within the HTLC's timeout, the HTLC will be
  /// automatically failed.
  ///
  /// # Note
  /// LDK will not stop an inbound payment from being paid multiple times, so multiple
  /// `PaymentReceived` events may be generated for the same payment.
  ///
  /// [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
  /// [`ChannelManager::fail_htlc_backwards`]: crate::ln::channelmanager::ChannelManager::fail_htlc_backwards
  static const int LDKEvent_PaymentReceived = 1;

  /// Indicates a payment has been claimed and we've received money!
  ///
  /// This most likely occurs when [`ChannelManager::claim_funds`] has been called in response
  /// to an [`Event::PaymentReceived`]. However, if we previously crashed during a
  /// [`ChannelManager::claim_funds`] call you may see this event without a corresponding
  /// [`Event::PaymentReceived`] event.
  ///
  /// # Note
  /// LDK will not stop an inbound payment from being paid multiple times, so multiple
  /// `PaymentReceived` events may be generated for the same payment. If you then call
  /// [`ChannelManager::claim_funds`] twice for the same [`Event::PaymentReceived`] you may get
  /// multiple `PaymentClaimed` events.
  ///
  /// [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
  static const int LDKEvent_PaymentClaimed = 2;

  /// Indicates an outbound payment we made succeeded (i.e. it made it all the way to its target
  /// and we got back the payment preimage for it).
  ///
  /// Note for MPP payments: in rare cases, this event may be preceded by a `PaymentPathFailed`
  /// event. In this situation, you SHOULD treat this payment as having succeeded.
  static const int LDKEvent_PaymentSent = 3;

  /// Indicates an outbound payment failed. Individual [`Event::PaymentPathFailed`] events
  /// provide failure information for each MPP part in the payment.
  ///
  /// This event is provided once there are no further pending HTLCs for the payment and the
  /// payment is no longer retryable, either due to a several-block timeout or because
  /// [`ChannelManager::abandon_payment`] was previously called for the corresponding payment.
  ///
  /// [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
  static const int LDKEvent_PaymentFailed = 4;

  /// Indicates that a path for an outbound payment was successful.
  ///
  /// Always generated after [`Event::PaymentSent`] and thus useful for scoring channels. See
  /// [`Event::PaymentSent`] for obtaining the payment preimage.
  static const int LDKEvent_PaymentPathSuccessful = 5;

  /// Indicates an outbound HTLC we sent failed. Probably some intermediary node dropped
  /// something. You may wish to retry with a different route.
  ///
  /// Note that this does *not* indicate that all paths for an MPP payment have failed, see
  /// [`Event::PaymentFailed`] and [`all_paths_failed`].
  ///
  /// [`all_paths_failed`]: Self::PaymentPathFailed::all_paths_failed
  static const int LDKEvent_PaymentPathFailed = 6;

  /// Indicates that a probe payment we sent returned successful, i.e., only failed at the destination.
  static const int LDKEvent_ProbeSuccessful = 7;

  /// Indicates that a probe payment we sent failed at an intermediary node on the path.
  static const int LDKEvent_ProbeFailed = 8;

  /// Used to indicate that [`ChannelManager::process_pending_htlc_forwards`] should be called at
  /// a time in the future.
  ///
  /// [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
  static const int LDKEvent_PendingHTLCsForwardable = 9;

  /// Used to indicate that an output which you should know how to spend was confirmed on chain
  /// and is now spendable.
  /// Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
  /// counterparty spending them due to some kind of timeout. Thus, you need to store them
  /// somewhere and spend them when you create on-chain transactions.
  static const int LDKEvent_SpendableOutputs = 10;

  /// This event is generated when a payment has been successfully forwarded through us and a
  /// forwarding fee earned.
  static const int LDKEvent_PaymentForwarded = 11;

  /// Used to indicate that a previously opened channel with the given `channel_id` is in the
  /// process of closure.
  static const int LDKEvent_ChannelClosed = 12;

  /// Used to indicate to the user that they can abandon the funding transaction and recycle the
  /// inputs for another purpose.
  static const int LDKEvent_DiscardFunding = 13;

  /// Indicates a request to open a new channel by a peer.
  ///
  /// To accept the request, call [`ChannelManager::accept_inbound_channel`]. To reject the
  /// request, call [`ChannelManager::force_close_without_broadcasting_txn`].
  ///
  /// The event is only triggered when a new open channel request is received and the
  /// [`UserConfig::manually_accept_inbound_channels`] config flag is set to true.
  ///
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
  /// [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
  static const int LDKEvent_OpenChannelRequest = 14;

  /// Indicates that the HTLC was accepted, but could not be processed when or after attempting to
  /// forward it.
  ///
  /// Some scenarios where this event may be sent include:
  /// * Insufficient capacity in the outbound channel
  /// * While waiting to forward the HTLC, the channel it is meant to be forwarded through closes
  /// * When an unknown SCID is requested for forwarding a payment.
  /// * Claiming an amount for an MPP payment that exceeds the HTLC total
  /// * The HTLC has timed out
  ///
  /// This event, however, does not get generated if an HTLC fails to meet the forwarding
  /// requirements (i.e. insufficient fees paid, or a CLTV that is too soon).
  static const int LDKEvent_HTLCHandlingFailed = 15;

  /// Must be last for serialization purposes
  static const int LDKEvent_Sentinel = 16;
}

class LDKEvent_LDKFundingGenerationReady_Body extends ffi.Struct {
  /// The random channel_id we picked which you'll need to pass into
  /// [`ChannelManager::funding_transaction_generated`].
  ///
  /// [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
  external LDKThirtyTwoBytes temporary_channel_id;

  /// The counterparty's node_id, which you'll need to pass back into
  /// [`ChannelManager::funding_transaction_generated`].
  ///
  /// [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
  external LDKPublicKey counterparty_node_id;

  /// The value, in satoshis, that the output should have.
  @ffi.Uint64()
  external int channel_value_satoshis;

  /// The script which should be used in the transaction output.
  external LDKCVec_u8Z output_script;

  /// The `user_channel_id` value passed in to [`ChannelManager::create_channel`], or 0 for
  /// an inbound channel.
  ///
  /// [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
  @ffi.Uint64()
  external int user_channel_id;
}

class LDKEvent_LDKPaymentReceived_Body extends ffi.Struct {
  /// The hash for which the preimage should be handed to the ChannelManager. Note that LDK will
  /// not stop you from registering duplicate payment hashes for inbound payments.
  external LDKThirtyTwoBytes payment_hash;

  /// The value, in thousandths of a satoshi, that this payment is for.
  @ffi.Uint64()
  external int amount_msat;

  /// Information for claiming this received payment, based on whether the purpose of the
  /// payment is to pay an invoice or to send a spontaneous payment.
  external LDKPaymentPurpose purpose;
}

class LDKEvent_LDKPaymentClaimed_Body extends ffi.Struct {
  /// The payment hash of the claimed payment. Note that LDK will not stop you from
  /// registering duplicate payment hashes for inbound payments.
  external LDKThirtyTwoBytes payment_hash;

  /// The value, in thousandths of a satoshi, that this payment is for.
  @ffi.Uint64()
  external int amount_msat;

  /// The purpose of this claimed payment, i.e. whether the payment was for an invoice or a
  /// spontaneous payment.
  external LDKPaymentPurpose purpose;
}

class LDKEvent_LDKPaymentSent_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_payment`] and used with
  /// [`ChannelManager::retry_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  /// [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes payment_id;

  /// The preimage to the hash given to ChannelManager::send_payment.
  /// Note that this serves as a payment receipt, if you wish to have such a thing, you must
  /// store it somehow!
  external LDKThirtyTwoBytes payment_preimage;

  /// The hash that was given to [`ChannelManager::send_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  external LDKThirtyTwoBytes payment_hash;

  /// The total fee which was spent at intermediate hops in this payment, across all paths.
  ///
  /// Note that, like [`Route::get_total_fees`] this does *not* include any potential
  /// overpayment to the recipient node.
  ///
  /// If the recipient or an intermediate node misbehaves and gives us free money, this may
  /// overstate the amount paid, though this is unlikely.
  ///
  /// [`Route::get_total_fees`]: crate::routing::router::Route::get_total_fees
  external LDKCOption_u64Z fee_paid_msat;
}

class LDKEvent_LDKPaymentFailed_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_payment`] and used with
  /// [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  /// [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
  /// [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
  external LDKThirtyTwoBytes payment_id;

  /// The hash that was given to [`ChannelManager::send_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  external LDKThirtyTwoBytes payment_hash;
}

class LDKEvent_LDKPaymentPathSuccessful_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_payment`] and used with
  /// [`ChannelManager::retry_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  /// [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
  external LDKThirtyTwoBytes payment_id;

  /// The hash that was given to [`ChannelManager::send_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes payment_hash;

  /// The payment path that was successful.
  ///
  /// May contain a closed channel if the HTLC sent along the path was fulfilled on chain.
  external LDKCVec_RouteHopZ path;
}

class LDKEvent_LDKPaymentPathFailed_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_payment`] and used with
  /// [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  /// [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
  /// [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes payment_id;

  /// The hash that was given to [`ChannelManager::send_payment`].
  ///
  /// [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
  external LDKThirtyTwoBytes payment_hash;

  /// Indicates the payment was rejected for some reason by the recipient. This implies that
  /// the payment has failed, not just the route in question. If this is not set, you may
  /// retry the payment via a different route.
  @ffi.Bool()
  external bool rejected_by_dest;

  /// Any failure information conveyed via the Onion return packet by a node along the failed
  /// payment route.
  ///
  /// Should be applied to the [`NetworkGraph`] so that routing decisions can take into
  /// account the update.
  ///
  /// [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
  external LDKCOption_NetworkUpdateZ network_update;

  /// For both single-path and multi-path payments, this is set if all paths of the payment have
  /// failed. This will be set to false if (1) this is an MPP payment and (2) other parts of the
  /// larger MPP payment were still in flight when this event was generated.
  ///
  /// Note that if you are retrying individual MPP parts, using this value to determine if a
  /// payment has fully failed is race-y. Because multiple failures can happen prior to events
  /// being processed, you may retry in response to a first failure, with a second failure
  /// (with `all_paths_failed` set) still pending. Then, when the second failure is processed
  /// you will see `all_paths_failed` set even though the retry of the first failure still
  /// has an associated in-flight HTLC. See (1) for an example of such a failure.
  ///
  /// If you wish to retry individual MPP parts and learn when a payment has failed, you must
  /// call [`ChannelManager::abandon_payment`] and wait for a [`Event::PaymentFailed`] event.
  ///
  /// (1) <https://github.com/lightningdevkit/rust-lightning/issues/1164>
  ///
  /// [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
  @ffi.Bool()
  external bool all_paths_failed;

  /// The payment path that failed.
  external LDKCVec_RouteHopZ path;

  /// The channel responsible for the failed payment path.
  ///
  /// Note that for route hints or for the first hop in a path this may be an SCID alias and
  /// may not refer to a channel in the public network graph. These aliases may also collide
  /// with channels in the public network graph.
  ///
  /// If this is `Some`, then the corresponding channel should be avoided when the payment is
  /// retried. May be `None` for older [`Event`] serializations.
  external LDKCOption_u64Z short_channel_id;

  /// Parameters needed to compute a new [`Route`] when retrying the failed payment path.
  ///
  /// See [`find_route`] for details.
  ///
  /// [`Route`]: crate::routing::router::Route
  /// [`find_route`]: crate::routing::router::find_route
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKRouteParameters retry;
}

class LDKEvent_LDKProbeSuccessful_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_probe`].
  ///
  /// [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
  external LDKThirtyTwoBytes payment_id;

  /// The hash generated by [`ChannelManager::send_probe`].
  ///
  /// [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
  external LDKThirtyTwoBytes payment_hash;

  /// The payment path that was successful.
  external LDKCVec_RouteHopZ path;
}

class LDKEvent_LDKProbeFailed_Body extends ffi.Struct {
  /// The id returned by [`ChannelManager::send_probe`].
  ///
  /// [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
  external LDKThirtyTwoBytes payment_id;

  /// The hash generated by [`ChannelManager::send_probe`].
  ///
  /// [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
  external LDKThirtyTwoBytes payment_hash;

  /// The payment path that failed.
  external LDKCVec_RouteHopZ path;

  /// The channel responsible for the failed probe.
  ///
  /// Note that for route hints or for the first hop in a path this may be an SCID alias and
  /// may not refer to a channel in the public network graph. These aliases may also collide
  /// with channels in the public network graph.
  external LDKCOption_u64Z short_channel_id;
}

class LDKEvent_LDKPendingHTLCsForwardable_Body extends ffi.Struct {
  /// The minimum amount of time that should be waited prior to calling
  /// process_pending_htlc_forwards. To increase the effort required to correlate payments,
  /// you should wait a random amount of time in roughly the range (now + time_forwardable,
  /// now + 5*time_forwardable).
  @ffi.Uint64()
  external int time_forwardable;
}

class LDKEvent_LDKSpendableOutputs_Body extends ffi.Struct {
  /// The outputs which you should store as spendable by you.
  external LDKCVec_SpendableOutputDescriptorZ outputs;
}

class LDKEvent_LDKPaymentForwarded_Body extends ffi.Struct {
  /// The incoming channel between the previous node and us. This is only `None` for events
  /// generated or serialized by versions prior to 0.0.107.
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes prev_channel_id;

  /// The outgoing channel between the next node and us. This is only `None` for events
  /// generated or serialized by versions prior to 0.0.107.
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKThirtyTwoBytes next_channel_id;

  /// The fee, in milli-satoshis, which was earned as a result of the payment.
  ///
  /// Note that if we force-closed the channel over which we forwarded an HTLC while the HTLC
  /// was pending, the amount the next hop claimed will have been rounded down to the nearest
  /// whole satoshi. Thus, the fee calculated here may be higher than expected as we still
  /// claimed the full value in millisatoshis from the source. In this case,
  /// `claim_from_onchain_tx` will be set.
  ///
  /// If the channel which sent us the payment has been force-closed, we will claim the funds
  /// via an on-chain transaction. In that case we do not yet know the on-chain transaction
  /// fees which we will spend and will instead set this to `None`. It is possible duplicate
  /// `PaymentForwarded` events are generated for the same payment iff `fee_earned_msat` is
  /// `None`.
  external LDKCOption_u64Z fee_earned_msat;

  /// If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
  /// transaction.
  @ffi.Bool()
  external bool claim_from_onchain_tx;
}

class LDKEvent_LDKChannelClosed_Body extends ffi.Struct {
  /// The channel_id of the channel which has been closed. Note that on-chain transactions
  /// resolving the channel are likely still awaiting confirmation.
  external LDKThirtyTwoBytes channel_id;

  /// The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
  /// channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
  /// [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
  /// `user_channel_id` will be 0 for an inbound channel.
  /// This will always be zero for objects serialized with LDK versions prior to 0.0.102.
  ///
  /// [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
  @ffi.Uint64()
  external int user_channel_id;

  /// The reason the channel was closed.
  external LDKClosureReason reason;
}

class LDKEvent_LDKDiscardFunding_Body extends ffi.Struct {
  /// The channel_id of the channel which has been closed.
  external LDKThirtyTwoBytes channel_id;

  /// The full transaction received from the user
  external LDKTransaction transaction;
}

class LDKEvent_LDKOpenChannelRequest_Body extends ffi.Struct {
  /// The temporary channel ID of the channel requested to be opened.
  ///
  /// When responding to the request, the `temporary_channel_id` should be passed
  /// back to the ChannelManager through [`ChannelManager::accept_inbound_channel`] to accept,
  /// or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject.
  ///
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
  external LDKThirtyTwoBytes temporary_channel_id;

  /// The node_id of the counterparty requesting to open the channel.
  ///
  /// When responding to the request, the `counterparty_node_id` should be passed
  /// back to the `ChannelManager` through [`ChannelManager::accept_inbound_channel`] to
  /// accept the request, or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject the
  /// request.
  ///
  /// [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
  /// [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
  external LDKPublicKey counterparty_node_id;

  /// The channel value of the requested channel.
  @ffi.Uint64()
  external int funding_satoshis;

  /// Our starting balance in the channel if the request is accepted, in milli-satoshi.
  @ffi.Uint64()
  external int push_msat;

  /// The features that this channel will operate with. If you reject the channel, a
  /// well-behaved counterparty may automatically re-attempt the channel with a new set of
  /// feature flags.
  ///
  /// Note that if [`ChannelTypeFeatures::supports_scid_privacy`] returns true on this type,
  /// the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
  /// 0.0.106.
  ///
  /// Furthermore, note that if [`ChannelTypeFeatures::supports_zero_conf`] returns true on this type,
  /// the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
  /// 0.0.107. Channels setting this type also need to get manually accepted via
  /// [`crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`],
  /// or will be rejected otherwise.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  external LDKChannelTypeFeatures channel_type;
}

class LDKEvent_LDKHTLCHandlingFailed_Body extends ffi.Struct {
  /// The channel over which the HTLC was received.
  external LDKThirtyTwoBytes prev_channel_id;

  /// Destination of the HTLC that failed to be processed.
  external LDKHTLCDestination failed_next_destination;
}

class LDKEvent extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// An enum which can either contain a crate::lightning::util::events::Event or not
abstract class LDKCOption_EventZ_Tag {
  /// When we're in this state, this COption_EventZ contains a crate::lightning::util::events::Event
  static const int LDKCOption_EventZ_Some = 0;

  /// When we're in this state, this COption_EventZ contains nothing
  static const int LDKCOption_EventZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_EventZ_Sentinel = 2;
}

class LDKCOption_EventZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_COption_EventZDecodeErrorZ
class LDKCResult_COption_EventZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_EventZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_EventZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_EventZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An accept_channel message to be sent or received from a peer
class LDKAcceptChannel extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeAcceptChannel> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeAcceptChannel = nativeAcceptChannelOpaque;

/// An open_channel message to be sent or received from a peer
class LDKOpenChannel extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeOpenChannel> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeOpenChannel = nativeOpenChannelOpaque;

/// A funding_created message to be sent or received from a peer
class LDKFundingCreated extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeFundingCreated> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeFundingCreated = nativeFundingCreatedOpaque;

/// A funding_signed message to be sent or received from a peer
class LDKFundingSigned extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeFundingSigned> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeFundingSigned = nativeFundingSignedOpaque;

/// A channel_ready message to be sent or received from a peer
class LDKChannelReady extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelReady> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelReady = nativeChannelReadyOpaque;

/// An announcement_signatures message to be sent or received from a peer
class LDKAnnouncementSignatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeAnnouncementSignatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeAnnouncementSignatures = nativeAnnouncementSignaturesOpaque;

/// Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
/// transaction updates if they were pending.
class LDKCommitmentUpdate extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCommitmentUpdate> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCommitmentUpdate = nativeCommitmentUpdateOpaque;

/// A revoke_and_ack message to be sent or received from a peer
class LDKRevokeAndACK extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRevokeAndACK> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRevokeAndACK = nativeRevokeAndACKOpaque;

/// A closing_signed message to be sent or received from a peer
class LDKClosingSigned extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeClosingSigned> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeClosingSigned = nativeClosingSignedOpaque;

/// A shutdown message to be sent or received from a peer
class LDKShutdown extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeShutdown> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeShutdown = nativeShutdownOpaque;

/// A channel_reestablish message to be sent or received from a peer
class LDKChannelReestablish extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelReestablish> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelReestablish = nativeChannelReestablishOpaque;

/// A channel_announcement message to be sent or received from a peer
class LDKChannelAnnouncement extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelAnnouncement> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelAnnouncement = nativeChannelAnnouncementOpaque;

/// A node_announcement message to be sent or received from a peer
class LDKNodeAnnouncement extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeAnnouncement> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeAnnouncement = nativeNodeAnnouncementOpaque;

/// An error message to be sent or received from a peer
class LDKErrorMessage extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeErrorMessage> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeErrorMessage = nativeErrorMessageOpaque;

/// A warning message to be sent or received from a peer
class LDKWarningMessage extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeWarningMessage> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeWarningMessage = nativeWarningMessageOpaque;

/// Used to put an error message in a LightningError
abstract class LDKErrorAction_Tag {
  /// The peer took some action which made us think they were useless. Disconnect them.
  static const int LDKErrorAction_DisconnectPeer = 0;

  /// The peer did something harmless that we weren't able to process, just log and ignore
  static const int LDKErrorAction_IgnoreError = 1;

  /// The peer did something harmless that we weren't able to meaningfully process.
  /// If the error is logged, log it at the given level.
  static const int LDKErrorAction_IgnoreAndLog = 2;

  /// The peer provided us with a gossip message which we'd already seen. In most cases this
  /// should be ignored, but it may result in the message being forwarded if it is a duplicate of
  /// our own channel announcements.
  static const int LDKErrorAction_IgnoreDuplicateGossip = 3;

  /// The peer did something incorrect. Tell them.
  static const int LDKErrorAction_SendErrorMessage = 4;

  /// The peer did something incorrect. Tell them without closing any channels.
  static const int LDKErrorAction_SendWarningMessage = 5;

  /// Must be last for serialization purposes
  static const int LDKErrorAction_Sentinel = 6;
}

class LDKErrorAction_LDKDisconnectPeer_Body extends ffi.Struct {
  /// An error message which we should make an effort to send before we disconnect.
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKErrorMessage msg;
}

class LDKErrorAction_LDKSendErrorMessage_Body extends ffi.Struct {
  /// The message to send.
  external LDKErrorMessage msg;
}

class LDKErrorAction_LDKSendWarningMessage_Body extends ffi.Struct {
  /// The message to send.
  external LDKWarningMessage msg;

  /// The peer may have done something harmless that we weren't able to meaningfully process,
  /// though we should still tell them about it.
  /// If this event is logged, log it at the given level.
  @ffi.Int32()
  external int log_level;
}

class LDKErrorAction extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A query_channel_range message is used to query a peer for channel
/// UTXOs in a range of blocks. The recipient of a query makes a best
/// effort to reply to the query using one or more reply_channel_range
/// messages.
class LDKQueryChannelRange extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeQueryChannelRange> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeQueryChannelRange = nativeQueryChannelRangeOpaque;

/// A query_short_channel_ids message is used to query a peer for
/// routing gossip messages related to one or more short_channel_ids.
/// The query recipient will reply with the latest, if available,
/// channel_announcement, channel_update and node_announcement messages
/// it maintains for the requested short_channel_ids followed by a
/// reply_short_channel_ids_end message. The short_channel_ids sent in
/// this query are encoded. We only support encoding_type=0 uncompressed
/// serialization and do not support encoding_type=1 zlib serialization.
class LDKQueryShortChannelIds extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeQueryShortChannelIds> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeQueryShortChannelIds = nativeQueryShortChannelIdsOpaque;

/// A reply_channel_range message is a reply to a query_channel_range
/// message. Multiple reply_channel_range messages can be sent in reply
/// to a single query_channel_range message. The query recipient makes a
/// best effort to respond based on their local network view which may
/// not be a perfect view of the network. The short_channel_ids in the
/// reply are encoded. We only support encoding_type=0 uncompressed
/// serialization and do not support encoding_type=1 zlib serialization.
class LDKReplyChannelRange extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeReplyChannelRange> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeReplyChannelRange = nativeReplyChannelRangeOpaque;

/// A gossip_timestamp_filter message is used by a node to request
/// gossip relay for messages in the requested time range when the
/// gossip_queries feature has been negotiated.
class LDKGossipTimestampFilter extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeGossipTimestampFilter> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeGossipTimestampFilter = nativeGossipTimestampFilterOpaque;

/// An event generated by ChannelManager which indicates a message should be sent to a peer (or
/// broadcast to most peers).
/// These events are handled by PeerManager::process_events if you are using a PeerManager.
abstract class LDKMessageSendEvent_Tag {
  /// Used to indicate that we've accepted a channel open and should send the accept_channel
  /// message provided to the given peer.
  static const int LDKMessageSendEvent_SendAcceptChannel = 0;

  /// Used to indicate that we've initiated a channel open and should send the open_channel
  /// message provided to the given peer.
  static const int LDKMessageSendEvent_SendOpenChannel = 1;

  /// Used to indicate that a funding_created message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendFundingCreated = 2;

  /// Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendFundingSigned = 3;

  /// Used to indicate that a channel_ready message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendChannelReady = 4;

  /// Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendAnnouncementSignatures = 5;

  /// Used to indicate that a series of HTLC update messages, as well as a commitment_signed
  /// message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_UpdateHTLCs = 6;

  /// Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendRevokeAndACK = 7;

  /// Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendClosingSigned = 8;

  /// Used to indicate that a shutdown message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendShutdown = 9;

  /// Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
  static const int LDKMessageSendEvent_SendChannelReestablish = 10;

  /// Used to indicate that a channel_announcement and channel_update should be broadcast to all
  /// peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
  ///
  /// Note that after doing so, you very likely (unless you did so very recently) want to call
  /// ChannelManager::broadcast_node_announcement to trigger a BroadcastNodeAnnouncement event.
  /// This ensures that any nodes which see our channel_announcement also have a relevant
  /// node_announcement, including relevant feature flags which may be important for routing
  /// through or to us.
  static const int LDKMessageSendEvent_BroadcastChannelAnnouncement = 11;

  /// Used to indicate that a node_announcement should be broadcast to all peers.
  static const int LDKMessageSendEvent_BroadcastNodeAnnouncement = 12;

  /// Used to indicate that a channel_update should be broadcast to all peers.
  static const int LDKMessageSendEvent_BroadcastChannelUpdate = 13;

  /// Used to indicate that a channel_update should be sent to a single peer.
  /// In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
  /// private channel and we shouldn't be informing all of our peers of channel parameters.
  static const int LDKMessageSendEvent_SendChannelUpdate = 14;

  /// Broadcast an error downstream to be handled
  static const int LDKMessageSendEvent_HandleError = 15;

  /// Query a peer for channels with funding transaction UTXOs in a block range.
  static const int LDKMessageSendEvent_SendChannelRangeQuery = 16;

  /// Request routing gossip messages from a peer for a list of channels identified by
  /// their short_channel_ids.
  static const int LDKMessageSendEvent_SendShortIdsQuery = 17;

  /// Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
  /// emitted during processing of the query.
  static const int LDKMessageSendEvent_SendReplyChannelRange = 18;

  /// Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
  /// enable receiving gossip messages from the peer.
  static const int LDKMessageSendEvent_SendGossipTimestampFilter = 19;

  /// Must be last for serialization purposes
  static const int LDKMessageSendEvent_Sentinel = 20;
}

class LDKMessageSendEvent_LDKSendAcceptChannel_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKAcceptChannel msg;
}

class LDKMessageSendEvent_LDKSendOpenChannel_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKOpenChannel msg;
}

class LDKMessageSendEvent_LDKSendFundingCreated_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKFundingCreated msg;
}

class LDKMessageSendEvent_LDKSendFundingSigned_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKFundingSigned msg;
}

class LDKMessageSendEvent_LDKSendChannelReady_Body extends ffi.Struct {
  /// The node_id of the node which should receive these message(s)
  external LDKPublicKey node_id;

  /// The channel_ready message which should be sent.
  external LDKChannelReady msg;
}

class LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body
    extends ffi.Struct {
  /// The node_id of the node which should receive these message(s)
  external LDKPublicKey node_id;

  /// The announcement_signatures message which should be sent.
  external LDKAnnouncementSignatures msg;
}

class LDKMessageSendEvent_LDKUpdateHTLCs_Body extends ffi.Struct {
  /// The node_id of the node which should receive these message(s)
  external LDKPublicKey node_id;

  /// The update messages which should be sent. ALL messages in the struct should be sent!
  external LDKCommitmentUpdate updates;
}

class LDKMessageSendEvent_LDKSendRevokeAndACK_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKRevokeAndACK msg;
}

class LDKMessageSendEvent_LDKSendClosingSigned_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKClosingSigned msg;
}

class LDKMessageSendEvent_LDKSendShutdown_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKShutdown msg;
}

class LDKMessageSendEvent_LDKSendChannelReestablish_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The message which should be sent.
  external LDKChannelReestablish msg;
}

class LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body
    extends ffi.Struct {
  /// The channel_announcement which should be sent.
  external LDKChannelAnnouncement msg;

  /// The followup channel_update which should be sent.
  external LDKChannelUpdate update_msg;
}

class LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body extends ffi.Struct {
  /// The node_announcement which should be sent.
  external LDKNodeAnnouncement msg;
}

class LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body extends ffi.Struct {
  /// The channel_update which should be sent.
  external LDKChannelUpdate msg;
}

class LDKMessageSendEvent_LDKSendChannelUpdate_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The channel_update which should be sent.
  external LDKChannelUpdate msg;
}

class LDKMessageSendEvent_LDKHandleError_Body extends ffi.Struct {
  /// The node_id of the node which should receive this message
  external LDKPublicKey node_id;

  /// The action which should be taken.
  external LDKErrorAction action;
}

class LDKMessageSendEvent_LDKSendChannelRangeQuery_Body extends ffi.Struct {
  /// The node_id of this message recipient
  external LDKPublicKey node_id;

  /// The query_channel_range which should be sent.
  external LDKQueryChannelRange msg;
}

class LDKMessageSendEvent_LDKSendShortIdsQuery_Body extends ffi.Struct {
  /// The node_id of this message recipient
  external LDKPublicKey node_id;

  /// The query_short_channel_ids which should be sent.
  external LDKQueryShortChannelIds msg;
}

class LDKMessageSendEvent_LDKSendReplyChannelRange_Body extends ffi.Struct {
  /// The node_id of this message recipient
  external LDKPublicKey node_id;

  /// The reply_channel_range which should be sent.
  external LDKReplyChannelRange msg;
}

class LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body extends ffi.Struct {
  /// The node_id of this message recipient
  external LDKPublicKey node_id;

  /// The gossip_timestamp_filter which should be sent.
  external LDKGossipTimestampFilter msg;
}

class LDKMessageSendEvent extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of crate::lightning::util::events::MessageSendEvents of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_MessageSendEventZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKMessageSendEvent> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_TxOutAccessErrorZ
class LDKCResult_TxOutAccessErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTxOut> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_TxOutAccessErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::TxOut on success and a crate::lightning::chain::AccessError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TxOutAccessErrorZ extends ffi.Struct {
  /// The contents of this CResult_TxOutAccessErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TxOutAccessErrorZPtr contents;

  /// Whether this CResult_TxOutAccessErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_usizeTransactionZ extends ffi.Struct {
  /// The element at position 0
  @uintptr_t()
  external int a;

  /// The element at position 1
  external LDKTransaction b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_usizeTransactionZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_usizeTransactionZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_TxidZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKThirtyTwoBytes> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_NoneChannelMonitorUpdateErrZ
class LDKCResult_NoneChannelMonitorUpdateErrZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_NoneChannelMonitorUpdateErrZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::chain::ChannelMonitorUpdateErr on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneChannelMonitorUpdateErrZ extends ffi.Struct {
  /// The contents of this CResult_NoneChannelMonitorUpdateErrZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneChannelMonitorUpdateErrZPtr contents;

  /// Whether this CResult_NoneChannelMonitorUpdateErrZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
/// chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
/// preimage claim backward will lead to loss of funds.
class LDKHTLCUpdate extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeHTLCUpdate> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeHTLCUpdate = nativeHTLCUpdateOpaque;

/// An event to be processed by the ChannelManager.
abstract class LDKMonitorEvent_Tag {
  /// A monitor event containing an HTLCUpdate.
  static const int LDKMonitorEvent_HTLCEvent = 0;

  /// A monitor event that the Channel's commitment transaction was confirmed.
  static const int LDKMonitorEvent_CommitmentTxConfirmed = 1;

  /// Indicates a [`ChannelMonitor`] update has completed. See
  /// [`ChannelMonitorUpdateErr::TemporaryFailure`] for more information on how this is used.
  ///
  /// [`ChannelMonitorUpdateErr::TemporaryFailure`]: super::ChannelMonitorUpdateErr::TemporaryFailure
  static const int LDKMonitorEvent_UpdateCompleted = 2;

  /// Indicates a [`ChannelMonitor`] update has failed. See
  /// [`ChannelMonitorUpdateErr::PermanentFailure`] for more information on how this is used.
  ///
  /// [`ChannelMonitorUpdateErr::PermanentFailure`]: super::ChannelMonitorUpdateErr::PermanentFailure
  static const int LDKMonitorEvent_UpdateFailed = 3;

  /// Must be last for serialization purposes
  static const int LDKMonitorEvent_Sentinel = 4;
}

class LDKMonitorEvent_LDKUpdateCompleted_Body extends ffi.Struct {
  /// The funding outpoint of the [`ChannelMonitor`] that was updated
  external LDKOutPoint funding_txo;

  /// The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
  /// [`ChannelMonitor::get_latest_update_id`].
  ///
  /// Note that this should only be set to a given update's ID if all previous updates for the
  /// same [`ChannelMonitor`] have been applied and persisted.
  @ffi.Uint64()
  external int monitor_update_id;
}

class LDKMonitorEvent extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_MonitorEventZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKMonitorEvent> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A tuple of 3 elements. See the individual fields for the types contained.
class LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ extends ffi.Struct {
  /// The element at position 0
  external LDKOutPoint a;

  /// The element at position 1
  external LDKCVec_MonitorEventZ b;

  /// The element at position 2
  external LDKPublicKey c;
}

/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An enum which can either contain a crate::c_types::derived::C2Tuple_usizeTransactionZ or not
abstract class LDKCOption_C2Tuple_usizeTransactionZZ_Tag {
  /// When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains a crate::c_types::derived::C2Tuple_usizeTransactionZ
  static const int LDKCOption_C2Tuple_usizeTransactionZZ_Some = 0;

  /// When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains nothing
  static const int LDKCOption_C2Tuple_usizeTransactionZZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_C2Tuple_usizeTransactionZZ_Sentinel = 2;
}

class LDKCOption_C2Tuple_usizeTransactionZZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// [`Score`] implementation that uses a fixed penalty.
class LDKFixedPenaltyScorer extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeFixedPenaltyScorer> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeFixedPenaltyScorer = nativeFixedPenaltyScorerOpaque;

/// The contents of CResult_FixedPenaltyScorerDecodeErrorZ
class LDKCResult_FixedPenaltyScorerDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKFixedPenaltyScorer> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_FixedPenaltyScorerDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_FixedPenaltyScorerDecodeErrorZPtr contents;

  /// Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_u64u64Z extends ffi.Struct {
  /// The element at position 0
  @ffi.Uint64()
  external int a;

  /// The element at position 1
  @ffi.Uint64()
  external int b;
}

/// An enum which can either contain a crate::c_types::derived::C2Tuple_u64u64Z or not
abstract class LDKCOption_C2Tuple_u64u64ZZ_Tag {
  /// When we're in this state, this COption_C2Tuple_u64u64ZZ contains a crate::c_types::derived::C2Tuple_u64u64Z
  static const int LDKCOption_C2Tuple_u64u64ZZ_Some = 0;

  /// When we're in this state, this COption_C2Tuple_u64u64ZZ contains nothing
  static const int LDKCOption_C2Tuple_u64u64ZZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_C2Tuple_u64u64ZZ_Sentinel = 2;
}

class LDKCOption_C2Tuple_u64u64ZZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// Represents the compressed public key of a node
class LDKNodeId extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeId> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeId = nativeNodeIdOpaque;

/// A dynamically-allocated array of crate::lightning::routing::gossip::NodeIds of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_NodeIdZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKNodeId> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A Record, unit of logging output with Metadata to enable filtering
/// Module_path, file, line to inform on log's source
class LDKRecord extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRecord> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRecord = nativeRecordOpaque;

/// A trait encapsulating the operations required of a logger
class LDKLogger extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Logs the `Record`
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<LDKRecord>)>>
      log;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Represents the network as nodes and channels between them
class LDKNetworkGraph extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNetworkGraph> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNetworkGraph = nativeNetworkGraphOpaque;

/// [`Score`] implementation using channel success probability distributions.
///
/// Based on *Optimally Reliable & Cheap Payment Flows on the Lightning Network* by Rene Pickhardt
/// and Stefan Richter [[1]]. Given the uncertainty of channel liquidity balances, probability
/// distributions are defined based on knowledge learned from successful and unsuccessful attempts.
/// Then the negative `log10` of the success probability is used to determine the cost of routing a
/// specific HTLC amount through a channel.
///
/// Knowledge about channel liquidity balances takes the form of upper and lower bounds on the
/// possible liquidity. Certainty of the bounds is decreased over time using a decay function. See
/// [`ProbabilisticScoringParameters`] for details.
///
/// Since the scorer aims to learn the current channel liquidity balances, it works best for nodes
/// with high payment volume or that actively probe the [`NetworkGraph`]. Nodes with low payment
/// volume are more likely to experience failed payment paths, which would need to be retried.
///
/// # Note
///
/// Mixing the `no-std` feature between serialization and deserialization results in undefined
/// behavior.
///
/// [1]: https://arxiv.org/abs/2107.05322
class LDKProbabilisticScorer extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeProbabilisticScorer> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeProbabilisticScorer = nativeProbabilisticScorerOpaque;

/// The contents of CResult_ProbabilisticScorerDecodeErrorZ
class LDKCResult_ProbabilisticScorerDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKProbabilisticScorer> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ProbabilisticScorerDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ProbabilisticScorerDecodeErrorZPtr contents;

  /// Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Features used within an `init` message.
class LDKInitFeatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInitFeatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInitFeatures = nativeInitFeaturesOpaque;

/// The contents of CResult_InitFeaturesDecodeErrorZ
class LDKCResult_InitFeaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInitFeatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InitFeaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InitFeaturesDecodeErrorZPtr contents;

  /// Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Features used within a `channel_announcement` message.
class LDKChannelFeatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelFeatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelFeatures = nativeChannelFeaturesOpaque;

/// The contents of CResult_ChannelFeaturesDecodeErrorZ
class LDKCResult_ChannelFeaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelFeatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelFeaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Features used within a `node_announcement` message.
class LDKNodeFeatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeFeatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeFeatures = nativeNodeFeaturesOpaque;

/// The contents of CResult_NodeFeaturesDecodeErrorZ
class LDKCResult_NodeFeaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeFeatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeFeaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeFeaturesDecodeErrorZPtr contents;

  /// Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Features used within an invoice.
class LDKInvoiceFeatures extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInvoiceFeatures> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInvoiceFeatures = nativeInvoiceFeaturesOpaque;

/// The contents of CResult_InvoiceFeaturesDecodeErrorZ
class LDKCResult_InvoiceFeaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInvoiceFeatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InvoiceFeaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_InvoiceFeaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InvoiceFeaturesDecodeErrorZPtr contents;

  /// Whether this CResult_InvoiceFeaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
class LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelTypeFeatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelTypeFeaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NodeIdDecodeErrorZ
class LDKCResult_NodeIdDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeId> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeIdDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeIdDecodeErrorZPtr contents;

  /// Whether this CResult_NodeIdDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
class LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_NetworkUpdateZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_NetworkUpdateZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The `Access` trait defines behavior for accessing chain data and state, such as blocks and
/// UTXOs.
class LDKAccess extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
  /// Returns an error if `genesis_hash` is for a different chain or if such a transaction output
  /// is unknown.
  ///
  /// [`short_channel_id`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#definition-of-short_channel_id
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_TxOutAccessErrorZ Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Uint64)>> get_utxo;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An enum which can either contain a crate::lightning::chain::Access or not
abstract class LDKCOption_AccessZ_Tag {
  /// When we're in this state, this COption_AccessZ contains a crate::lightning::chain::Access
  static const int LDKCOption_AccessZ_Some = 0;

  /// When we're in this state, this COption_AccessZ contains nothing
  static const int LDKCOption_AccessZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_AccessZ_Sentinel = 2;
}

class LDKCOption_AccessZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_boolLightningErrorZ
class LDKCResult_boolLightningErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<ffi.Bool> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKLightningError> err;
}

/// A CResult_boolLightningErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_boolLightningErrorZ extends ffi.Struct {
  /// The contents of this CResult_boolLightningErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_boolLightningErrorZPtr contents;

  /// Whether this CResult_boolLightningErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 3 elements. See the individual fields for the types contained.
class LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
    extends ffi.Struct {
  /// The element at position 0
  external LDKChannelAnnouncement a;

  /// The element at position 1
  external LDKChannelUpdate b;

  /// The element at position 2
  external LDKChannelUpdate c;
}

/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ
    extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi
      .Pointer<LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::lightning::ln::msgs::NodeAnnouncements of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_NodeAnnouncementZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKNodeAnnouncement> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_NoneLightningErrorZ
class LDKCResult_NoneLightningErrorZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKLightningError> err;
}

/// A CResult_NoneLightningErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneLightningErrorZ extends ffi.Struct {
  /// The contents of this CResult_NoneLightningErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneLightningErrorZPtr contents;

  /// Whether this CResult_NoneLightningErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Details about one direction of a channel as received within a [`ChannelUpdate`].
class LDKChannelUpdateInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelUpdateInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelUpdateInfo = nativeChannelUpdateInfoOpaque;

/// The contents of CResult_ChannelUpdateInfoDecodeErrorZ
class LDKCResult_ChannelUpdateInfoDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelUpdateInfo> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelUpdateInfoDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelUpdateInfoDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Details about a channel (both directions).
/// Received within a channel announcement.
class LDKChannelInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelInfo = nativeChannelInfoOpaque;

/// The contents of CResult_ChannelInfoDecodeErrorZ
class LDKCResult_ChannelInfoDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelInfo> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelInfoDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelInfoDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Fees for routing via a given channel or a node
class LDKRoutingFees extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRoutingFees> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRoutingFees = nativeRoutingFeesOpaque;

/// The contents of CResult_RoutingFeesDecodeErrorZ
class LDKCResult_RoutingFeesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRoutingFees> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RoutingFeesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RoutingFeesDecodeErrorZPtr contents;

  /// Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A 4-byte byte array.
class LDKFourBytes extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint8> data;
}

/// A 16-byte byte array.
class LDKSixteenBytes extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> data;
}

/// A 12-byte byte array.
class LDKTwelveBytes extends ffi.Struct {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Uint8> data;
}

/// Represents a hostname for serialization purposes.
/// Only the character set and length will be validated.
/// The character set consists of ASCII alphanumeric characters, hyphens, and periods.
/// Its length is guaranteed to be representable by a single byte.
/// This serialization is used by BOLT 7 hostnames.
class LDKHostname extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeHostname> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeHostname = nativeHostnameOpaque;

/// An address which can be used to connect to a remote peer
abstract class LDKNetAddress_Tag {
  /// An IPv4 address/port on which the peer is listening.
  static const int LDKNetAddress_IPv4 = 0;

  /// An IPv6 address/port on which the peer is listening.
  static const int LDKNetAddress_IPv6 = 1;

  /// An old-style Tor onion address/port on which the peer is listening.
  ///
  /// This field is deprecated and the Tor network generally no longer supports V2 Onion
  /// addresses. Thus, the details are not parsed here.
  static const int LDKNetAddress_OnionV2 = 2;

  /// A new-style Tor onion address/port on which the peer is listening.
  /// To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,
  /// wrap as base32 and append \".onion\".
  static const int LDKNetAddress_OnionV3 = 3;

  /// A hostname/port on which the peer is listening.
  static const int LDKNetAddress_Hostname = 4;

  /// Must be last for serialization purposes
  static const int LDKNetAddress_Sentinel = 5;
}

class LDKNetAddress_LDKIPv4_Body extends ffi.Struct {
  /// The 4-byte IPv4 address
  external LDKFourBytes addr;

  /// The port on which the node is listening
  @ffi.Uint16()
  external int port;
}

class LDKNetAddress_LDKIPv6_Body extends ffi.Struct {
  /// The 16-byte IPv6 address
  external LDKSixteenBytes addr;

  /// The port on which the node is listening
  @ffi.Uint16()
  external int port;
}

class LDKNetAddress_LDKOnionV3_Body extends ffi.Struct {
  /// The ed25519 long-term public key of the peer
  external LDKThirtyTwoBytes ed25519_pubkey;

  /// The checksum of the pubkey and version, as included in the onion address
  @ffi.Uint16()
  external int checksum;

  /// The version byte, as defined by the Tor Onion v3 spec.
  @ffi.Uint8()
  external int version;

  /// The port on which the node is listening
  @ffi.Uint16()
  external int port;
}

class LDKNetAddress_LDKHostname_Body extends ffi.Struct {
  /// The hostname on which the node is listening.
  external LDKHostname hostname;

  /// The port on which the node is listening.
  @ffi.Uint16()
  external int port;
}

class LDKNetAddress extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of crate::lightning::ln::msgs::NetAddresss of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_NetAddressZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKNetAddress> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// Information received in the latest node_announcement from this node.
class LDKNodeAnnouncementInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeAnnouncementInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeAnnouncementInfo = nativeNodeAnnouncementInfoOpaque;

/// The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
class LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeAnnouncementInfo> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeAnnouncementInfoDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;

  /// Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class LDKNodeAlias extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeAlias> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeAlias = nativeNodeAliasOpaque;

/// The contents of CResult_NodeAliasDecodeErrorZ
class LDKCResult_NodeAliasDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeAlias> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeAliasDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAlias on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeAliasDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeAliasDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeAliasDecodeErrorZPtr contents;

  /// Whether this CResult_NodeAliasDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Details about a node in the network, known from the network announcement.
class LDKNodeInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeNodeInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeNodeInfo = nativeNodeInfoOpaque;

/// The contents of CResult_NodeInfoDecodeErrorZ
class LDKCResult_NodeInfoDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeInfo> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeInfoDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeInfoDecodeErrorZPtr contents;

  /// Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NetworkGraphDecodeErrorZ
class LDKCResult_NetworkGraphDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNetworkGraph> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NetworkGraphDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NetworkGraphDecodeErrorZPtr contents;

  /// Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An enum which can either contain a crate::c_types::derived::CVec_NetAddressZ or not
abstract class LDKCOption_CVec_NetAddressZZ_Tag {
  /// When we're in this state, this COption_CVec_NetAddressZZ contains a crate::c_types::derived::CVec_NetAddressZ
  static const int LDKCOption_CVec_NetAddressZZ_Some = 0;

  /// When we're in this state, this COption_CVec_NetAddressZZ contains nothing
  static const int LDKCOption_CVec_NetAddressZZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_CVec_NetAddressZZ_Sentinel = 2;
}

class LDKCOption_CVec_NetAddressZZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
class LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKDelayedPaymentOutputDescriptor> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::keysinterface::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr contents;

  /// Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
class LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKStaticPaymentOutputDescriptor> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::keysinterface::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr contents;

  /// Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
class LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSpendableOutputDescriptor> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::keysinterface::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SpendableOutputDescriptorDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;

  /// Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_SecretKeyNoneZ
class LDKCResult_SecretKeyNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSecretKey> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_SecretKeyNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::SecretKey on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SecretKeyNoneZ extends ffi.Struct {
  /// The contents of this CResult_SecretKeyNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SecretKeyNoneZPtr contents;

  /// Whether this CResult_SecretKeyNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A cloneable signer.
///
/// Although we require signers to be cloneable, it may be useful for developers to be able to use
/// signers in an un-sized way, for example as `dyn BaseSign`. Therefore we separate the Clone trait,
/// which implies Sized, into this derived trait.
class LDKSign extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Implementation of BaseSign for this object.
  external LDKBaseSign BaseSign;

  /// Serialize the object into a byte array
  external ffi.Pointer<
      ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<ffi.Void>)>> write;

  /// Called, if set, after this Sign has been cloned into a duplicate object.
  /// The new Sign is provided, and should be mutated as needed to perform a
  /// deep copy of the object pointed to by this_arg or avoid any double-freeing.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKSign>)>>
      cloned;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// The contents of CResult_SignDecodeErrorZ
class LDKCResult_SignDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSign> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_SignDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::keysinterface::Sign on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SignDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_SignDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SignDecodeErrorZPtr contents;

  /// Whether this CResult_SignDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Integer in the range `0..32`
class LDKu5 extends ffi.Struct {
  @ffi.Uint8()
  external int _0;
}

/// A dynamically-allocated array of crate::c_types::u5s of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_u5Z extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKu5> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// Represents a secp256k1 signature serialized as two 32-byte numbers as well as a tag which
/// allows recovering the exact public key which created the signature given the message.
class LDKRecoverableSignature extends ffi.Struct {
  @ffi.Array.multi([68])
  external ffi.Array<ffi.Uint8> serialized_form;
}

/// The contents of CResult_RecoverableSignatureNoneZ
class LDKCResult_RecoverableSignatureNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRecoverableSignature> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::RecoverableSignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RecoverableSignatureNoneZ extends ffi.Struct {
  /// The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RecoverableSignatureNoneZPtr contents;

  /// Whether this CResult_RecoverableSignatureNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::c_types::derived::CVec_u8Zs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_CVec_u8ZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKCVec_u8Z> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_CVec_CVec_u8ZZNoneZ
class LDKCResult_CVec_CVec_u8ZZNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCVec_CVec_u8ZZ> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_CVec_CVec_u8ZZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_CVec_u8ZZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CVec_CVec_u8ZZNoneZ extends ffi.Struct {
  /// The contents of this CResult_CVec_CVec_u8ZZNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;

  /// Whether this CResult_CVec_CVec_u8ZZNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A simple implementation of Sign that just keeps the private keys in memory.
///
/// This implementation performs no policy checks and is insufficient by itself as
/// a secure external signer.
class LDKInMemorySigner extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInMemorySigner> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInMemorySigner = nativeInMemorySignerOpaque;

/// The contents of CResult_InMemorySignerDecodeErrorZ
class LDKCResult_InMemorySignerDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInMemorySigner> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::keysinterface::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InMemorySignerDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InMemorySignerDecodeErrorZPtr contents;

  /// Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_TxOutZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKTxOut> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_TransactionNoneZ
class LDKCResult_TransactionNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKTransaction> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_TransactionNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Transaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_TransactionNoneZ extends ffi.Struct {
  /// The contents of this CResult_TransactionNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_TransactionNoneZPtr contents;

  /// Whether this CResult_TransactionNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
/// on-chain transactions to ensure no loss of funds occurs.
///
/// You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
/// information and are actively monitoring the chain.
///
/// Pending Events or updated HTLCs which have not yet been read out by
/// get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
/// reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
/// gotten are fully handled before re-serializing the new state.
///
/// Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
/// the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
/// returned block hash and the the current chain and then reconnecting blocks to get to the
/// best chain) upon deserializing the object!
class LDKChannelMonitor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelMonitor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelMonitor = nativeChannelMonitorOpaque;

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_BlockHashChannelMonitorZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKChannelMonitor b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_BlockHashChannelMonitorZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_BlockHashChannelMonitorZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
class LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCVec_C2Tuple_BlockHashChannelMonitorZZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_BlockHashChannelMonitorZZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
    extends ffi.Struct {
  /// The contents of this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr contents;

  /// Whether this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An enum which can either contain a u16 or not
abstract class LDKCOption_u16Z_Tag {
  /// When we're in this state, this COption_u16Z contains a u16
  static const int LDKCOption_u16Z_Some = 0;

  /// When we're in this state, this COption_u16Z contains nothing
  static const int LDKCOption_u16Z_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_u16Z_Sentinel = 2;
}

class LDKCOption_u16Z extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// Indicates an error on the client's part (usually some variant of attempting to use too-low or
/// too-high values)
abstract class LDKAPIError_Tag {
  /// Indicates the API was wholly misused (see err for more). Cases where these can be returned
  /// are documented, but generally indicates some precondition of a function was violated.
  static const int LDKAPIError_APIMisuseError = 0;

  /// Due to a high feerate, we were unable to complete the request.
  /// For example, this may be returned if the feerate implies we cannot open a channel at the
  /// requested value, but opening a larger channel would succeed.
  static const int LDKAPIError_FeeRateTooHigh = 1;

  /// A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
  /// too-many-hops, etc).
  static const int LDKAPIError_RouteError = 2;

  /// We were unable to complete the request as the Channel required to do so is unable to
  /// complete the request (or was not found). This can take many forms, including disconnected
  /// peer, channel at capacity, channel shutting down, etc.
  static const int LDKAPIError_ChannelUnavailable = 3;

  /// An attempt to call watch/update_channel returned an Err (ie you did this!), causing the
  /// attempted action to fail.
  static const int LDKAPIError_MonitorUpdateFailed = 4;

  /// [`KeysInterface::get_shutdown_scriptpubkey`] returned a shutdown scriptpubkey incompatible
  /// with the channel counterparty as negotiated in [`InitFeatures`].
  ///
  /// Using a SegWit v0 script should resolve this issue. If you cannot, you won't be able to open
  /// a channel or cooperatively close one with this peer (and will have to force-close instead).
  ///
  /// [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
  /// [`InitFeatures`]: crate::ln::features::InitFeatures
  static const int LDKAPIError_IncompatibleShutdownScript = 5;

  /// Must be last for serialization purposes
  static const int LDKAPIError_Sentinel = 6;
}

class LDKAPIError_LDKAPIMisuseError_Body extends ffi.Struct {
  /// A human-readable error message
  external LDKStr err;
}

class LDKAPIError_LDKFeeRateTooHigh_Body extends ffi.Struct {
  /// A human-readable error message
  external LDKStr err;

  /// The feerate which was too high.
  @ffi.Uint32()
  external int feerate;
}

class LDKAPIError_LDKRouteError_Body extends ffi.Struct {
  /// A human-readable error message
  external LDKStr err;
}

class LDKAPIError_LDKChannelUnavailable_Body extends ffi.Struct {
  /// A human-readable error message
  external LDKStr err;
}

class LDKAPIError_LDKIncompatibleShutdownScript_Body extends ffi.Struct {
  /// The incompatible shutdown script.
  external LDKShutdownScript script;
}

class LDKAPIError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_NoneAPIErrorZ
class LDKCResult_NoneAPIErrorZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKAPIError> err;
}

/// A CResult_NoneAPIErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneAPIErrorZ extends ffi.Struct {
  /// The contents of this CResult_NoneAPIErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneAPIErrorZPtr contents;

  /// Whether this CResult_NoneAPIErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_CResult_NoneAPIErrorZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKCResult_NoneAPIErrorZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_APIErrorZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKAPIError> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult__u832APIErrorZ
class LDKCResult__u832APIErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKAPIError> err;
}

/// A CResult__u832APIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult__u832APIErrorZ extends ffi.Struct {
  /// The contents of this CResult__u832APIErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult__u832APIErrorZPtr contents;

  /// Whether this CResult__u832APIErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// If a payment fails to send, it can be in one of several states. This enum is returned as the
/// Err() type describing which state the payment is in, see the description of individual enum
/// states for more.
abstract class LDKPaymentSendFailure_Tag {
  /// A parameter which was passed to send_payment was invalid, preventing us from attempting to
  /// send the payment at all. No channel state has been changed or messages sent to peers, and
  /// once you've changed the parameter at error, you can freely retry the payment in full.
  static const int LDKPaymentSendFailure_ParameterError = 0;

  /// A parameter in a single path which was passed to send_payment was invalid, preventing us
  /// from attempting to send the payment at all. No channel state has been changed or messages
  /// sent to peers, and once you've changed the parameter at error, you can freely retry the
  /// payment in full.
  ///
  /// The results here are ordered the same as the paths in the route object which was passed to
  /// send_payment.
  static const int LDKPaymentSendFailure_PathParameterError = 1;

  /// All paths which were attempted failed to send, with no channel state change taking place.
  /// You can freely retry the payment in full (though you probably want to do so over different
  /// paths than the ones selected).
  static const int LDKPaymentSendFailure_AllFailedRetrySafe = 2;

  /// Some paths which were attempted failed to send, though possibly not all. At least some
  /// paths have irrevocably committed to the HTLC and retrying the payment in full would result
  /// in over-/re-payment.
  ///
  /// The results here are ordered the same as the paths in the route object which was passed to
  /// send_payment, and any Errs which are not APIError::MonitorUpdateFailed can be safely
  /// retried (though there is currently no API with which to do so).
  ///
  /// Any entries which contain Err(APIError::MonitorUpdateFailed) or Ok(()) MUST NOT be retried
  /// as they will result in over-/re-payment. These HTLCs all either successfully sent (in the
  /// case of Ok(())) or will send once channel_monitor_updated is called on the next-hop channel
  /// with the latest update_id.
  static const int LDKPaymentSendFailure_PartialFailure = 3;

  /// Must be last for serialization purposes
  static const int LDKPaymentSendFailure_Sentinel = 4;
}

class LDKPaymentSendFailure_LDKPartialFailure_Body extends ffi.Struct {
  /// The errors themselves, in the same order as the route hops.
  external LDKCVec_CResult_NoneAPIErrorZZ results;

  /// If some paths failed without irrevocably committing to the new HTLC(s), this will
  /// contain a [`RouteParameters`] object which can be used to calculate a new route that
  /// will pay all remaining unpaid balance.
  ///
  /// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
  external LDKRouteParameters failed_paths_retry;

  /// The payment id for the payment, which is now at least partially pending.
  external LDKThirtyTwoBytes payment_id;
}

class LDKPaymentSendFailure extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_PaymentIdPaymentSendFailureZ
class LDKCResult_PaymentIdPaymentSendFailureZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPaymentSendFailure> err;
}

/// A CResult_PaymentIdPaymentSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentIdPaymentSendFailureZ extends ffi.Struct {
  /// The contents of this CResult_PaymentIdPaymentSendFailureZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentIdPaymentSendFailureZPtr contents;

  /// Whether this CResult_PaymentIdPaymentSendFailureZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NonePaymentSendFailureZ
class LDKCResult_NonePaymentSendFailureZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPaymentSendFailure> err;
}

/// A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NonePaymentSendFailureZ extends ffi.Struct {
  /// The contents of this CResult_NonePaymentSendFailureZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NonePaymentSendFailureZPtr contents;

  /// Whether this CResult_NonePaymentSendFailureZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_PaymentHashPaymentIdZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKThirtyTwoBytes b;
}

/// The contents of CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
class LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_PaymentHashPaymentIdZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPaymentSendFailure> err;
}

/// A CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentIdZ on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
    extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr
      contents;

  /// Whether this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_ThirtyTwoBytesZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKThirtyTwoBytes> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_PaymentHashPaymentSecretZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKThirtyTwoBytes b;
}

/// The contents of CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
class LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_PaymentHashPaymentSecretZ> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr contents;

  /// Whether this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
class LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_PaymentHashPaymentSecretZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKAPIError> err;
}

/// A CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr contents;

  /// Whether this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_PaymentSecretNoneZ
class LDKCResult_PaymentSecretNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_PaymentSecretNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentSecretNoneZ extends ffi.Struct {
  /// The contents of this CResult_PaymentSecretNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentSecretNoneZPtr contents;

  /// Whether this CResult_PaymentSecretNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_PaymentSecretAPIErrorZ
class LDKCResult_PaymentSecretAPIErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKAPIError> err;
}

/// A CResult_PaymentSecretAPIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentSecretAPIErrorZ extends ffi.Struct {
  /// The contents of this CResult_PaymentSecretAPIErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentSecretAPIErrorZPtr contents;

  /// Whether this CResult_PaymentSecretAPIErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_PaymentPreimageAPIErrorZ
class LDKCResult_PaymentPreimageAPIErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKAPIError> err;
}

/// A CResult_PaymentPreimageAPIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentPreimageAPIErrorZ extends ffi.Struct {
  /// The contents of this CResult_PaymentPreimageAPIErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentPreimageAPIErrorZPtr contents;

  /// Whether this CResult_PaymentPreimageAPIErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Information needed for constructing an invoice route hint for this channel.
class LDKCounterpartyForwardingInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCounterpartyForwardingInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCounterpartyForwardingInfo
    = nativeCounterpartyForwardingInfoOpaque;

/// The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
class LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCounterpartyForwardingInfo> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CounterpartyForwardingInfoDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr contents;

  /// Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
/// to better separate parameters.
class LDKChannelCounterparty extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelCounterparty> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelCounterparty = nativeChannelCounterpartyOpaque;

/// The contents of CResult_ChannelCounterpartyDecodeErrorZ
class LDKCResult_ChannelCounterpartyDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelCounterparty> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelCounterpartyDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelCounterpartyDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelDetailsDecodeErrorZ
class LDKCResult_ChannelDetailsDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelDetails> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelDetailsDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelDetailsDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Route hints used in constructing invoices for [phantom node payents].
///
/// [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
class LDKPhantomRouteHints extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePhantomRouteHints> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePhantomRouteHints = nativePhantomRouteHintsOpaque;

/// The contents of CResult_PhantomRouteHintsDecodeErrorZ
class LDKCResult_PhantomRouteHintsDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPhantomRouteHints> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PhantomRouteHintsDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PhantomRouteHintsDecodeErrorZPtr contents;

  /// Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_ChannelMonitorZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKChannelMonitor> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An update generated by the underlying Channel itself which contains some new information the
/// ChannelMonitor should be made aware of.
class LDKChannelMonitorUpdate extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelMonitorUpdate> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelMonitorUpdate = nativeChannelMonitorUpdateOpaque;

/// The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
/// blocks are connected and disconnected.
///
/// Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
/// responsible for maintaining a set of monitors such that they can be updated accordingly as
/// channel state changes and HTLCs are resolved. See method documentation for specific
/// requirements.
///
/// Implementations **must** ensure that updates are successfully applied and persisted upon method
/// completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
/// without taking any further action such as persisting the current state.
///
/// If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
/// backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
/// could result in a revoked transaction being broadcast, allowing the counterparty to claim all
/// funds in the channel. See [`ChannelMonitorUpdateErr`] for more details about how to handle
/// multiple instances.
///
/// [`PermanentFailure`]: ChannelMonitorUpdateErr::PermanentFailure
class LDKWatch extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Watches a channel identified by `funding_txo` using `monitor`.
  ///
  /// Implementations are responsible for watching the chain for the funding transaction along
  /// with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
  /// calling [`block_connected`] and [`block_disconnected`] on the monitor.
  ///
  /// Note: this interface MUST error with `ChannelMonitorUpdateErr::PermanentFailure` if
  /// the given `funding_txo` has previously been registered via `watch_channel`.
  ///
  /// [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
  /// [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
  /// [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneChannelMonitorUpdateErrZ Function(
                  ffi.Pointer<ffi.Void>, LDKOutPoint, LDKChannelMonitor)>>
      watch_channel;

  /// Updates a channel identified by `funding_txo` by applying `update` to its monitor.
  ///
  /// Implementations must call [`update_monitor`] with the given update. See
  /// [`ChannelMonitorUpdateErr`] for invariants around returning an error.
  ///
  /// [`update_monitor`]: channelmonitor::ChannelMonitor::update_monitor
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneChannelMonitorUpdateErrZ Function(
                  ffi.Pointer<ffi.Void>, LDKOutPoint, LDKChannelMonitorUpdate)>>
      update_channel;

  /// Returns any monitor events since the last call. Subsequent calls must only return new
  /// events.
  ///
  /// Note that after any block- or transaction-connection calls to a [`ChannelMonitor`], no
  /// further events may be returned here until the [`ChannelMonitor`] has been fully persisted
  /// to disk.
  ///
  /// For details on asynchronous [`ChannelMonitor`] updating and returning
  /// [`MonitorEvent::UpdateCompleted`] here, see [`ChannelMonitorUpdateErr::TemporaryFailure`].
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ Function(
              ffi.Pointer<ffi.Void>)>> release_pending_monitor_events;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An interface to send a transaction to the Bitcoin network.
class LDKBroadcasterInterface extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Sends a transaction out to (hopefully) be mined.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKTransaction)>>
      broadcast_transaction;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A "slice" referencing some byte array. This is simply a length-tagged pointer which does not
/// own the memory pointed to by data.
class LDKu8slice extends ffi.Struct {
  /// A pointer to the byte buffer
  external ffi.Pointer<ffi.Uint8> data;

  /// The number of bytes pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A trait to describe an object which can get user secrets and key material.
class LDKKeysInterface extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Get node secret key based on the provided [`Recipient`].
  ///
  /// The node_id/network_key is the public key that corresponds to this secret key.
  ///
  /// This method must return the same value each time it is called with a given `Recipient`
  /// parameter.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_SecretKeyNoneZ Function(
              ffi.Pointer<ffi.Void>, ffi.Int32)>> get_node_secret;

  /// Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
  ///
  /// This method should return a different value each time it is called, to avoid linking
  /// on-chain funds across channels as controlled to the same user.
  external ffi.Pointer<
          ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<ffi.Void>)>>
      get_destination_script;

  /// Get a script pubkey which we will send funds to when closing a channel.
  ///
  /// This method should return a different value each time it is called, to avoid linking
  /// on-chain funds across channels as controlled to the same user.
  external ffi.Pointer<
          ffi.NativeFunction<LDKShutdownScript Function(ffi.Pointer<ffi.Void>)>>
      get_shutdown_scriptpubkey;

  /// Get a new set of Sign for per-channel secrets. These MUST be unique even if you
  /// restarted with some stale data!
  ///
  /// This method must return a different value each time it is called.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKSign Function(ffi.Pointer<ffi.Void>, ffi.Bool, ffi.Uint64)>>
      get_channel_signer;

  /// Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
  /// onion packets and for temporary channel IDs. There is no requirement that these be
  /// persisted anywhere, though they must be unique across restarts.
  ///
  /// This method must return a different value each time it is called.
  external ffi.Pointer<
          ffi.NativeFunction<LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Void>)>>
      get_secure_random_bytes;

  /// Reads a `Signer` for this `KeysInterface` from the given input stream.
  /// This is only called during deserialization of other objects which contain
  /// `Sign`-implementing objects (ie `ChannelMonitor`s and `ChannelManager`s).
  /// The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
  /// contain no versioning scheme. You may wish to include your own version prefix and ensure
  /// you've read all of the provided bytes to ensure no corruption occurred.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_SignDecodeErrorZ Function(
              ffi.Pointer<ffi.Void>, LDKu8slice)>> read_chan_signer;

  /// Sign an invoice.
  /// By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
  /// this trait to parse the invoice and make sure they're signing what they expect, rather than
  /// blindly signing the hash.
  /// The hrp is ascii bytes, while the invoice data is base32.
  ///
  /// The secret key used to sign the invoice is dependent on the [`Recipient`].
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_RecoverableSignatureNoneZ Function(
                  ffi.Pointer<ffi.Void>, LDKu8slice, LDKCVec_u5Z, ffi.Int32)>>
      sign_invoice;

  /// Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
  ///
  /// If the implementor of this trait supports [phantom node payments], then every node that is
  /// intended to be included in the phantom invoice route hints must return the same value from
  /// this method.
  ///
  /// This method must return the same value each time it is called.
  ///
  /// [phantom node payments]: PhantomKeysManager
  external ffi.Pointer<
          ffi.NativeFunction<LDKThirtyTwoBytes Function(ffi.Pointer<ffi.Void>)>>
      get_inbound_payment_key_material;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A trait which should be implemented to provide feerate information on a number of time
/// horizons.
///
/// Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
/// called from inside the library in response to chain events, P2P events, or timer events).
class LDKFeeEstimator extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Gets estimated satoshis of fee required per 1000 Weight-Units.
  ///
  /// LDK will wrap this method and ensure that the value returned is no smaller than 253
  /// (ie 1 satoshi-per-byte rounded up to ensure later round-downs don't put us below 1 satoshi-per-byte).
  ///
  /// The following unit conversions can be used to convert to sats/KW:
  /// * satoshis-per-byte * 250
  /// * satoshis-per-kbyte / 4
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>
      get_est_sat_per_1000_weight;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Manager which keeps track of a number of channels and sends messages to the appropriate
/// channel, also tracking HTLC preimages and forwarding onion packets appropriately.
///
/// Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
/// to individual Channels.
///
/// Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
/// all peers during write/read (though does not modify this instance, only the instance being
/// serialized). This will result in any channels which have not yet exchanged funding_created (ie
/// called funding_transaction_generated for outbound channels).
///
/// Note that you can be a bit lazier about writing out ChannelManager than you can be with
/// ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
/// returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
/// happens out-of-band (and will prevent any other ChannelManager operations from occurring during
/// the serialization process). If the deserialized version is out-of-date compared to the
/// ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
/// ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
///
/// Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
/// the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
/// block_connected() to step towards your best block) upon deserialization before using the
/// object!
///
/// Note that ChannelManager is responsible for tracking liveness of its channels and generating
/// ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
/// spam due to quick disconnection/reconnection, updates are not sent until the channel has been
/// offline for a full minute. In order to track this, you must call
/// timer_tick_occurred roughly once per minute, though it doesn't have to be perfect.
///
/// Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
/// a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
/// essentially you should default to using a SimpleRefChannelManager, and use a
/// SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
/// you're using lightning-net-tokio.
class LDKChannelManager extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelManager> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelManager = nativeChannelManagerOpaque;

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_BlockHashChannelManagerZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKChannelManager b;
}

/// The contents of CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
class LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_BlockHashChannelManagerZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_BlockHashChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
    extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr contents;

  /// Whether this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Options which apply on a per-channel basis and may change at runtime or based on negotiation
/// with our counterparty.
class LDKChannelConfig extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelConfig> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelConfig = nativeChannelConfigOpaque;

/// The contents of CResult_ChannelConfigDecodeErrorZ
class LDKCResult_ChannelConfigDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelConfig> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelConfigDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelConfigDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_OutPointDecodeErrorZ
class LDKCResult_OutPointDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKOutPoint> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_OutPointDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_OutPointDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_OutPointDecodeErrorZPtr contents;

  /// Whether this CResult_OutPointDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Defines a type identifier for sending messages over the wire.
///
/// Messages implementing this trait specify a type and must be [`Writeable`].
class LDKType extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Returns the type identifying the message payload.
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<ffi.Void>)>> type_id;

  /// Return a human-readable "debug" string describing this object
  external ffi
          .Pointer<ffi.NativeFunction<LDKStr Function(ffi.Pointer<ffi.Void>)>>
      debug_str;

  /// Serialize the object into a byte array
  external ffi.Pointer<
      ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<ffi.Void>)>> write;

  /// Called, if set, after this Type has been cloned into a duplicate object.
  /// The new Type is provided, and should be mutated as needed to perform a
  /// deep copy of the object pointed to by this_arg or avoid any double-freeing.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LDKType>)>>
      cloned;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An enum which can either contain a crate::lightning::ln::wire::Type or not
abstract class LDKCOption_TypeZ_Tag {
  /// When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
  static const int LDKCOption_TypeZ_Some = 0;

  /// When we're in this state, this COption_TypeZ contains nothing
  static const int LDKCOption_TypeZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_TypeZ_Sentinel = 2;
}

class LDKCOption_TypeZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_COption_TypeZDecodeErrorZ
class LDKCResult_COption_TypeZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_TypeZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_TypeZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_TypeZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An error that may occur when making a payment.
abstract class LDKPaymentError_Tag {
  /// An error resulting from the provided [`Invoice`] or payment hash.
  static const int LDKPaymentError_Invoice = 0;

  /// An error occurring when finding a route.
  static const int LDKPaymentError_Routing = 1;

  /// An error occurring when sending a payment.
  static const int LDKPaymentError_Sending = 2;

  /// Must be last for serialization purposes
  static const int LDKPaymentError_Sentinel = 3;
}

class LDKPaymentError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_PaymentIdPaymentErrorZ
class LDKCResult_PaymentIdPaymentErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKThirtyTwoBytes> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPaymentError> err;
}

/// A CResult_PaymentIdPaymentErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning_invoice::payment::PaymentError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PaymentIdPaymentErrorZ extends ffi.Struct {
  /// The contents of this CResult_PaymentIdPaymentErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PaymentIdPaymentErrorZPtr contents;

  /// Whether this CResult_PaymentIdPaymentErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Sub-errors which don't have specific information in them use this type.
class LDKError extends ffi.Struct {
  /// Zero-Sized_types aren't consistent across Rust/C/C++, so we add some size here
  @ffi.Uint8()
  external int _dummy;
}

/// Errors that indicate what is wrong with the invoice. They have some granularity for debug
/// reasons, but should generally result in an \"invalid BOLT11 invoice\" message for the user.
abstract class LDKParseError_Tag {
  static const int LDKParseError_Bech32Error = 0;
  static const int LDKParseError_ParseAmountError = 1;
  static const int LDKParseError_MalformedSignature = 2;
  static const int LDKParseError_BadPrefix = 3;
  static const int LDKParseError_UnknownCurrency = 4;
  static const int LDKParseError_UnknownSiPrefix = 5;
  static const int LDKParseError_MalformedHRP = 6;
  static const int LDKParseError_TooShortDataPart = 7;
  static const int LDKParseError_UnexpectedEndOfTaggedFields = 8;
  static const int LDKParseError_DescriptionDecodeError = 9;
  static const int LDKParseError_PaddingError = 10;
  static const int LDKParseError_IntegerOverflowError = 11;
  static const int LDKParseError_InvalidSegWitProgramLength = 12;
  static const int LDKParseError_InvalidPubKeyHashLength = 13;
  static const int LDKParseError_InvalidScriptHashLength = 14;
  static const int LDKParseError_InvalidRecoveryId = 15;
  static const int LDKParseError_InvalidSliceLength = 16;

  /// Not an error, but used internally to signal that a part of the invoice should be ignored
  /// according to BOLT11
  static const int LDKParseError_Skip = 17;

  /// Must be last for serialization purposes
  static const int LDKParseError_Sentinel = 18;
}

class LDKParseError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_SiPrefixParseErrorZ
class LDKCResult_SiPrefixParseErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<ffi.Int32> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKParseError> err;
}

/// A CResult_SiPrefixParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SiPrefixParseErrorZ extends ffi.Struct {
  /// The contents of this CResult_SiPrefixParseErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SiPrefixParseErrorZPtr contents;

  /// Whether this CResult_SiPrefixParseErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Represents a syntactically and semantically correct lightning BOLT11 invoice.
///
/// There are three ways to construct an `Invoice`:
/// 1. using `InvoiceBuilder`
/// 2. using `Invoice::from_signed(SignedRawInvoice)`
/// 3. using `str::parse::<Invoice>(&str)`
class LDKInvoice extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInvoice> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInvoice = nativeInvoiceOpaque;

/// Indicates that something went wrong while parsing or validating the invoice. Parsing errors
/// should be mostly seen as opaque and are only there for debugging reasons. Semantic errors
/// like wrong signatures, missing fields etc. could mean that someone tampered with the invoice.
abstract class LDKParseOrSemanticError_Tag {
  /// The invoice couldn't be decoded
  static const int LDKParseOrSemanticError_ParseError = 0;

  /// The invoice could be decoded but violates the BOLT11 standard
  static const int LDKParseOrSemanticError_SemanticError = 1;

  /// Must be last for serialization purposes
  static const int LDKParseOrSemanticError_Sentinel = 2;
}

class LDKParseOrSemanticError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_InvoiceParseOrSemanticErrorZ
class LDKCResult_InvoiceParseOrSemanticErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInvoice> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKParseOrSemanticError> err;
}

/// A CResult_InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InvoiceParseOrSemanticErrorZ extends ffi.Struct {
  /// The contents of this CResult_InvoiceParseOrSemanticErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InvoiceParseOrSemanticErrorZPtr contents;

  /// Whether this CResult_InvoiceParseOrSemanticErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Represents a signed `RawInvoice` with cached hash. The signature is not checked and may be
/// invalid.
///
/// # Invariants
/// The hash has to be either from the deserialized invoice or from the serialized `raw_invoice`.
class LDKSignedRawInvoice extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeSignedRawInvoice> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeSignedRawInvoice = nativeSignedRawInvoiceOpaque;

/// The contents of CResult_SignedRawInvoiceParseErrorZ
class LDKCResult_SignedRawInvoiceParseErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKSignedRawInvoice> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKParseError> err;
}

/// A CResult_SignedRawInvoiceParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SignedRawInvoice on success and a crate::lightning_invoice::ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_SignedRawInvoiceParseErrorZ extends ffi.Struct {
  /// The contents of this CResult_SignedRawInvoiceParseErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_SignedRawInvoiceParseErrorZPtr contents;

  /// Whether this CResult_SignedRawInvoiceParseErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Represents an syntactically correct Invoice for a payment on the lightning network,
/// but without the signature information.
/// De- and encoding should not lead to information loss but may lead to different hashes.
///
/// For methods without docs see the corresponding methods in `Invoice`.
class LDKRawInvoice extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRawInvoice> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRawInvoice = nativeRawInvoiceOpaque;

/// Recoverable signature
class LDKInvoiceSignature extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInvoiceSignature> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInvoiceSignature = nativeInvoiceSignatureOpaque;

/// A tuple of 3 elements. See the individual fields for the types contained.
class LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ extends ffi.Struct {
  /// The element at position 0
  external LDKRawInvoice a;

  /// The element at position 1
  external LDKThirtyTwoBytes b;

  /// The element at position 2
  external LDKInvoiceSignature c;
}

/// Payee public key
class LDKPayeePubKey extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePayeePubKey> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePayeePubKey = nativePayeePubKeyOpaque;

/// The contents of CResult_PayeePubKeyErrorZ
class LDKCResult_PayeePubKeyErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPayeePubKey> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_PayeePubKeyErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PayeePubKeyErrorZ extends ffi.Struct {
  /// The contents of this CResult_PayeePubKeyErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PayeePubKeyErrorZPtr contents;

  /// Whether this CResult_PayeePubKeyErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Private routing information
///
/// # Invariants
/// The encoded route has to be <1024 5bit characters long (<=639 bytes or <=12 hops)
class LDKPrivateRoute extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePrivateRoute> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePrivateRoute = nativePrivateRouteOpaque;

/// A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_PrivateRouteZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKPrivateRoute> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A timestamp that refers to a date after 1 January 1970.
///
/// # Invariants
///
/// The Unix timestamp representing the stored time has to be positive and no greater than
/// [`MAX_TIMESTAMP`].
class LDKPositiveTimestamp extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePositiveTimestamp> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePositiveTimestamp = nativePositiveTimestampOpaque;

/// The contents of CResult_PositiveTimestampCreationErrorZ
class LDKCResult_PositiveTimestampCreationErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPositiveTimestamp> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PositiveTimestampCreationErrorZ extends ffi.Struct {
  /// The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PositiveTimestampCreationErrorZPtr contents;

  /// Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NoneSemanticErrorZ
class LDKCResult_NoneSemanticErrorZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_NoneSemanticErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning_invoice::SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NoneSemanticErrorZ extends ffi.Struct {
  /// The contents of this CResult_NoneSemanticErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NoneSemanticErrorZPtr contents;

  /// Whether this CResult_NoneSemanticErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_InvoiceSemanticErrorZ
class LDKCResult_InvoiceSemanticErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInvoice> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_InvoiceSemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InvoiceSemanticErrorZ extends ffi.Struct {
  /// The contents of this CResult_InvoiceSemanticErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InvoiceSemanticErrorZPtr contents;

  /// Whether this CResult_InvoiceSemanticErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// Description string
///
/// # Invariants
/// The description can be at most 639 __bytes__ long
class LDKDescription extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDescription> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDescription = nativeDescriptionOpaque;

/// The contents of CResult_DescriptionCreationErrorZ
class LDKCResult_DescriptionCreationErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKDescription> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_DescriptionCreationErrorZ extends ffi.Struct {
  /// The contents of this CResult_DescriptionCreationErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_DescriptionCreationErrorZPtr contents;

  /// Whether this CResult_DescriptionCreationErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_PrivateRouteCreationErrorZ
class LDKCResult_PrivateRouteCreationErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPrivateRoute> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PrivateRouteCreationErrorZ extends ffi.Struct {
  /// The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PrivateRouteCreationErrorZPtr contents;

  /// Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_StringErrorZ
class LDKCResult_StringErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKStr> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<ffi.Int32> err;
}

/// A CResult_StringErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_StringErrorZ extends ffi.Struct {
  /// The contents of this CResult_StringErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_StringErrorZPtr contents;

  /// Whether this CResult_StringErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
class LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelMonitorUpdate> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelMonitorUpdateDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
abstract class LDKCOption_MonitorEventZ_Tag {
  /// When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
  static const int LDKCOption_MonitorEventZ_Some = 0;

  /// When we're in this state, this COption_MonitorEventZ contains nothing
  static const int LDKCOption_MonitorEventZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_MonitorEventZ_Sentinel = 2;
}

class LDKCOption_MonitorEventZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_COption_MonitorEventZDecodeErrorZ
class LDKCResult_COption_MonitorEventZDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCOption_MonitorEventZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_COption_MonitorEventZDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_COption_MonitorEventZDecodeErrorZPtr contents;

  /// Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_HTLCUpdateDecodeErrorZ
class LDKCResult_HTLCUpdateDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKHTLCUpdate> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_HTLCUpdateDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_HTLCUpdateDecodeErrorZPtr contents;

  /// Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_OutPointScriptZ extends ffi.Struct {
  /// The element at position 0
  external LDKOutPoint a;

  /// The element at position 1
  external LDKCVec_u8Z b;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_u32ScriptZ extends ffi.Struct {
  /// The element at position 0
  @ffi.Uint32()
  external int a;

  /// The element at position 1
  external LDKCVec_u8Z b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32ScriptZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_u32ScriptZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_u32ScriptZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKCVec_C2Tuple_u32ScriptZZ b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::lightning::util::events::Events of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_EventZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKEvent> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_TransactionZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKTransaction> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_u32TxOutZ extends ffi.Struct {
  /// The element at position 0
  @ffi.Uint32()
  external int a;

  /// The element at position 1
  external LDKTxOut b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_u32TxOutZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_u32TxOutZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ extends ffi.Struct {
  /// The element at position 0
  external LDKThirtyTwoBytes a;

  /// The element at position 1
  external LDKCVec_C2Tuple_u32TxOutZZ b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_TransactionOutputsZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// Details about the balance(s) available for spending once the channel appears on chain.
///
/// See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
/// be provided.
abstract class LDKBalance_Tag {
  /// The channel is not yet closed (or the commitment or closing transaction has not yet
  /// appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
  /// force-closed now.
  static const int LDKBalance_ClaimableOnChannelClose = 0;

  /// The channel has been closed, and the given balance is ours but awaiting confirmations until
  /// we consider it spendable.
  static const int LDKBalance_ClaimableAwaitingConfirmations = 1;

  /// The channel has been closed, and the given balance should be ours but awaiting spending
  /// transaction confirmation. If the spending transaction does not confirm in time, it is
  /// possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
  ///
  /// Once the spending transaction confirms, before it has reached enough confirmations to be
  /// considered safe from chain reorganizations, the balance will instead be provided via
  /// [`Balance::ClaimableAwaitingConfirmations`].
  static const int LDKBalance_ContentiousClaimable = 2;

  /// HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
  /// fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
  /// likely to be claimed by our counterparty before we do.
  static const int LDKBalance_MaybeClaimableHTLCAwaitingTimeout = 3;

  /// Must be last for serialization purposes
  static const int LDKBalance_Sentinel = 4;
}

class LDKBalance_LDKClaimableOnChannelClose_Body extends ffi.Struct {
  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @ffi.Uint64()
  external int claimable_amount_satoshis;
}

class LDKBalance_LDKClaimableAwaitingConfirmations_Body extends ffi.Struct {
  /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
  /// were spent in broadcasting the transaction.
  @ffi.Uint64()
  external int claimable_amount_satoshis;

  /// The height at which an [`Event::SpendableOutputs`] event will be generated for this
  /// amount.
  @ffi.Uint32()
  external int confirmation_height;
}

class LDKBalance_LDKContentiousClaimable_Body extends ffi.Struct {
  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @ffi.Uint64()
  external int claimable_amount_satoshis;

  /// The height at which the counterparty may be able to claim the balance if we have not
  /// done so.
  @ffi.Uint32()
  external int timeout_height;
}

class LDKBalance_LDKMaybeClaimableHTLCAwaitingTimeout_Body extends ffi.Struct {
  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @ffi.Uint64()
  external int claimable_amount_satoshis;

  /// The height at which we will be able to claim the balance if our counterparty has not
  /// done so.
  @ffi.Uint32()
  external int claimable_height;
}

class LDKBalance extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_BalanceZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKBalance> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
class LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr
    extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKC2Tuple_BlockHashChannelMonitorZ> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
    extends ffi.Struct {
  /// The contents of this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr contents;

  /// Whether this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A tuple of 2 elements. See the individual fields for the types contained.
class LDKC2Tuple_PublicKeyTypeZ extends ffi.Struct {
  /// The element at position 0
  external LDKPublicKey a;

  /// The element at position 1
  external LDKType b;
}

/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_C2Tuple_PublicKeyTypeZZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKC2Tuple_PublicKeyTypeZ> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An enum which can either contain a crate::lightning::ln::msgs::NetAddress or not
abstract class LDKCOption_NetAddressZ_Tag {
  /// When we're in this state, this COption_NetAddressZ contains a crate::lightning::ln::msgs::NetAddress
  static const int LDKCOption_NetAddressZ_Some = 0;

  /// When we're in this state, this COption_NetAddressZ contains nothing
  static const int LDKCOption_NetAddressZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_NetAddressZ_Sentinel = 2;
}

class LDKCOption_NetAddressZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// Error for PeerManager errors. If you get one of these, you must disconnect the socket and
/// generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
/// descriptor.
class LDKPeerHandleError extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePeerHandleError> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePeerHandleError = nativePeerHandleErrorOpaque;

/// The contents of CResult_CVec_u8ZPeerHandleErrorZ
class LDKCResult_CVec_u8ZPeerHandleErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCVec_u8Z> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPeerHandleError> err;
}

/// A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CVec_u8ZPeerHandleErrorZ extends ffi.Struct {
  /// The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;

  /// Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NonePeerHandleErrorZ
class LDKCResult_NonePeerHandleErrorZPtr extends ffi.Union {
  /// Note that this value is always NULL, as there are no contents in the OK variant
  external ffi.Pointer<ffi.Void> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPeerHandleError> err;
}

/// A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NonePeerHandleErrorZ extends ffi.Struct {
  /// The contents of this CResult_NonePeerHandleErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NonePeerHandleErrorZPtr contents;

  /// Whether this CResult_NonePeerHandleErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_boolPeerHandleErrorZ
class LDKCResult_boolPeerHandleErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<ffi.Bool> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKPeerHandleError> err;
}

/// A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_boolPeerHandleErrorZ extends ffi.Struct {
  /// The contents of this CResult_boolPeerHandleErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_boolPeerHandleErrorZPtr contents;

  /// Whether this CResult_boolPeerHandleErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// All-encompassing standard error type that processing can return
abstract class LDKGraphSyncError_Tag {
  /// Error trying to read the update data, typically due to an erroneous data length indication
  /// that is greater than the actual amount of data provided
  static const int LDKGraphSyncError_DecodeError = 0;

  /// Error applying the patch to the network graph, usually the result of updates that are too
  /// old or missing prerequisite data to the application of updates out of order
  static const int LDKGraphSyncError_LightningError = 1;

  /// Must be last for serialization purposes
  static const int LDKGraphSyncError_Sentinel = 2;
}

class LDKGraphSyncError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_u32GraphSyncErrorZ
class LDKCResult_u32GraphSyncErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<ffi.Uint32> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKGraphSyncError> err;
}

/// A CResult_u32GraphSyncErrorZ represents the result of a fallible operation,
/// containing a u32 on success and a crate::lightning_rapid_gossip_sync::error::GraphSyncError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_u32GraphSyncErrorZ extends ffi.Struct {
  /// The contents of this CResult_u32GraphSyncErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_u32GraphSyncErrorZPtr contents;

  /// Whether this CResult_u32GraphSyncErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NetAddressDecodeErrorZ
class LDKCResult_NetAddressDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNetAddress> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NetAddressDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::NetAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NetAddressDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NetAddressDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NetAddressDecodeErrorZPtr contents;

  /// Whether this CResult_NetAddressDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An update_add_htlc message to be sent or received from a peer
class LDKUpdateAddHTLC extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUpdateAddHTLC> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUpdateAddHTLC = nativeUpdateAddHTLCOpaque;

/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_UpdateAddHTLCZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKUpdateAddHTLC> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An update_fulfill_htlc message to be sent or received from a peer
class LDKUpdateFulfillHTLC extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUpdateFulfillHTLC> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUpdateFulfillHTLC = nativeUpdateFulfillHTLCOpaque;

/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_UpdateFulfillHTLCZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKUpdateFulfillHTLC> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An update_fail_htlc message to be sent or received from a peer
class LDKUpdateFailHTLC extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUpdateFailHTLC> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUpdateFailHTLC = nativeUpdateFailHTLCOpaque;

/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_UpdateFailHTLCZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKUpdateFailHTLC> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// An update_fail_malformed_htlc message to be sent or received from a peer
class LDKUpdateFailMalformedHTLC extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUpdateFailMalformedHTLC> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUpdateFailMalformedHTLC = nativeUpdateFailMalformedHTLCOpaque;

/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_UpdateFailMalformedHTLCZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKUpdateFailMalformedHTLC> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// The contents of CResult_AcceptChannelDecodeErrorZ
class LDKCResult_AcceptChannelDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKAcceptChannel> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_AcceptChannelDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_AcceptChannelDecodeErrorZPtr contents;

  /// Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_AnnouncementSignaturesDecodeErrorZ
class LDKCResult_AnnouncementSignaturesDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKAnnouncementSignatures> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_AnnouncementSignaturesDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;

  /// Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelReestablishDecodeErrorZ
class LDKCResult_ChannelReestablishDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelReestablish> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelReestablishDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelReestablishDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ClosingSignedDecodeErrorZ
class LDKCResult_ClosingSignedDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKClosingSigned> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ClosingSignedDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ClosingSignedDecodeErrorZPtr contents;

  /// Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The minimum and maximum fees which the sender is willing to place on the closing transaction.
/// This is provided in [`ClosingSigned`] by both sides to indicate the fee range they are willing
/// to use.
class LDKClosingSignedFeeRange extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeClosingSignedFeeRange> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeClosingSignedFeeRange = nativeClosingSignedFeeRangeOpaque;

/// The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
class LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKClosingSignedFeeRange> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ClosingSignedFeeRangeDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr contents;

  /// Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A commitment_signed message to be sent or received from a peer
class LDKCommitmentSigned extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeCommitmentSigned> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeCommitmentSigned = nativeCommitmentSignedOpaque;

/// The contents of CResult_CommitmentSignedDecodeErrorZ
class LDKCResult_CommitmentSignedDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKCommitmentSigned> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_CommitmentSignedDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_CommitmentSignedDecodeErrorZPtr contents;

  /// Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_FundingCreatedDecodeErrorZ
class LDKCResult_FundingCreatedDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKFundingCreated> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_FundingCreatedDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_FundingCreatedDecodeErrorZPtr contents;

  /// Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_FundingSignedDecodeErrorZ
class LDKCResult_FundingSignedDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKFundingSigned> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_FundingSignedDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_FundingSignedDecodeErrorZPtr contents;

  /// Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelReadyDecodeErrorZ
class LDKCResult_ChannelReadyDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelReady> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelReadyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReady on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelReadyDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelReadyDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelReadyDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelReadyDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An init message to be sent or received from a peer
class LDKInit extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInit> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInit = nativeInitOpaque;

/// The contents of CResult_InitDecodeErrorZ
class LDKCResult_InitDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInit> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_InitDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InitDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_InitDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InitDecodeErrorZPtr contents;

  /// Whether this CResult_InitDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_OpenChannelDecodeErrorZ
class LDKCResult_OpenChannelDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKOpenChannel> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_OpenChannelDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_OpenChannelDecodeErrorZPtr contents;

  /// Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_RevokeAndACKDecodeErrorZ
class LDKCResult_RevokeAndACKDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKRevokeAndACK> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_RevokeAndACKDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_RevokeAndACKDecodeErrorZPtr contents;

  /// Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ShutdownDecodeErrorZ
class LDKCResult_ShutdownDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKShutdown> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ShutdownDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ShutdownDecodeErrorZPtr contents;

  /// Whether this CResult_ShutdownDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_UpdateFailHTLCDecodeErrorZ
class LDKCResult_UpdateFailHTLCDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUpdateFailHTLC> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UpdateFailHTLCDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;

  /// Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
class LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUpdateFailMalformedHTLC> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;

  /// Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// An update_fee message to be sent or received from a peer
class LDKUpdateFee extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUpdateFee> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUpdateFee = nativeUpdateFeeOpaque;

/// The contents of CResult_UpdateFeeDecodeErrorZ
class LDKCResult_UpdateFeeDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUpdateFee> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UpdateFeeDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UpdateFeeDecodeErrorZPtr contents;

  /// Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
class LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUpdateFulfillHTLC> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UpdateFulfillHTLCDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;

  /// Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_UpdateAddHTLCDecodeErrorZ
class LDKCResult_UpdateAddHTLCDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUpdateAddHTLC> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UpdateAddHTLCDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;

  /// Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A ping message to be sent or received from a peer
class LDKPing extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePing> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePing = nativePingOpaque;

/// The contents of CResult_PingDecodeErrorZ
class LDKCResult_PingDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPing> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_PingDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PingDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_PingDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PingDecodeErrorZPtr contents;

  /// Whether this CResult_PingDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A pong message to be sent or received from a peer
class LDKPong extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePong> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePong = nativePongOpaque;

/// The contents of CResult_PongDecodeErrorZ
class LDKCResult_PongDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKPong> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_PongDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_PongDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_PongDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_PongDecodeErrorZPtr contents;

  /// Whether this CResult_PongDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
class LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUnsignedChannelAnnouncement> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;

  /// Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelAnnouncementDecodeErrorZ
class LDKCResult_ChannelAnnouncementDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelAnnouncement> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelAnnouncementDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The unsigned part of a channel_update
class LDKUnsignedChannelUpdate extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUnsignedChannelUpdate> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUnsignedChannelUpdate = nativeUnsignedChannelUpdateOpaque;

/// The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
class LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUnsignedChannelUpdate> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UnsignedChannelUpdateDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;

  /// Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ChannelUpdateDecodeErrorZ
class LDKCResult_ChannelUpdateDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKChannelUpdate> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ChannelUpdateDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ChannelUpdateDecodeErrorZPtr contents;

  /// Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ErrorMessageDecodeErrorZ
class LDKCResult_ErrorMessageDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKErrorMessage> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ErrorMessageDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ErrorMessageDecodeErrorZPtr contents;

  /// Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_WarningMessageDecodeErrorZ
class LDKCResult_WarningMessageDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKWarningMessage> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_WarningMessageDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_WarningMessageDecodeErrorZPtr contents;

  /// Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The unsigned part of a node_announcement
class LDKUnsignedNodeAnnouncement extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUnsignedNodeAnnouncement> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUnsignedNodeAnnouncement
    = nativeUnsignedNodeAnnouncementOpaque;

/// The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
class LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKUnsignedNodeAnnouncement> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;

  /// Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_NodeAnnouncementDecodeErrorZ
class LDKCResult_NodeAnnouncementDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKNodeAnnouncement> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_NodeAnnouncementDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;

  /// Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_QueryShortChannelIdsDecodeErrorZ
class LDKCResult_QueryShortChannelIdsDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKQueryShortChannelIds> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_QueryShortChannelIdsDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;

  /// Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A reply_short_channel_ids_end message is sent as a reply to a
/// query_short_channel_ids message. The query recipient makes a best
/// effort to respond based on their local network view which may not be
/// a perfect view of the network.
class LDKReplyShortChannelIdsEnd extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeReplyShortChannelIdsEnd> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeReplyShortChannelIdsEnd = nativeReplyShortChannelIdsEndOpaque;

/// The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
class LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKReplyShortChannelIdsEnd> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;

  /// Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_QueryChannelRangeDecodeErrorZ
class LDKCResult_QueryChannelRangeDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKQueryChannelRange> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_QueryChannelRangeDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;

  /// Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_ReplyChannelRangeDecodeErrorZ
class LDKCResult_ReplyChannelRangeDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKReplyChannelRange> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_ReplyChannelRangeDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;

  /// Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// The contents of CResult_GossipTimestampFilterDecodeErrorZ
class LDKCResult_GossipTimestampFilterDecodeErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKGossipTimestampFilter> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKDecodeError> err;
}

/// A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_GossipTimestampFilterDecodeErrorZ extends ffi.Struct {
  /// The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;

  /// Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_PhantomRouteHintsZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKPhantomRouteHints> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// When signing using a fallible method either an user-supplied `SignError` or a `CreationError`
/// may occur.
abstract class LDKSignOrCreationError_Tag {
  /// An error occurred during signing
  static const int LDKSignOrCreationError_SignError = 0;

  /// An error occurred while building the transaction
  static const int LDKSignOrCreationError_CreationError = 1;

  /// Must be last for serialization purposes
  static const int LDKSignOrCreationError_Sentinel = 2;
}

class LDKSignOrCreationError extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// The contents of CResult_InvoiceSignOrCreationErrorZ
class LDKCResult_InvoiceSignOrCreationErrorZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKInvoice> result;

  /// A pointer to the contents in the error state.
  /// Reading from this pointer when `result_ok` is set is undefined.
  external ffi.Pointer<LDKSignOrCreationError> err;
}

/// A CResult_InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_InvoiceSignOrCreationErrorZ extends ffi.Struct {
  /// The contents of this CResult_InvoiceSignOrCreationErrorZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_InvoiceSignOrCreationErrorZPtr contents;

  /// Whether this CResult_InvoiceSignOrCreationErrorZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
///
/// Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
/// spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
/// the return value of [`Filter::register_output`].
///
/// If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
/// may have been spent there. See [`Filter::register_output`] for details.
///
/// [`ChannelMonitor`]: channelmonitor::ChannelMonitor
/// [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
class LDKWatchedOutput extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeWatchedOutput> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeWatchedOutput = nativeWatchedOutputOpaque;

/// The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
/// channels.
///
/// This is useful in order to have a [`Watch`] implementation convey to a chain source which
/// transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
/// the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
/// receiving full blocks from a chain source, any further filtering is unnecessary.
///
/// After an output has been registered, subsequent block retrievals from the chain source must not
/// exclude any transactions matching the new criteria nor any in-block descendants of such
/// transactions.
///
/// Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
/// should not block on I/O. Implementations should instead queue the newly monitored data to be
/// processed later. Then, in order to block until the data has been processed, any [`Watch`]
/// invocation that has called the `Filter` must return [`TemporaryFailure`].
///
/// [`TemporaryFailure`]: ChannelMonitorUpdateErr::TemporaryFailure
/// [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
/// [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
class LDKFilter extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
  /// a spending condition.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, LDKu8slice)>> register_tx;

  /// Registers interest in spends of a transaction output.
  ///
  /// Optionally, when `output.block_hash` is set, should return any transaction spending the
  /// output that is found in the corresponding block along with its index.
  ///
  /// This return value is useful for Electrum clients in order to supply in-block descendant
  /// transactions which otherwise were not included. This is not necessary for other clients if
  /// such descendant transactions were already included (e.g., when a BIP 157 client provides the
  /// full block).
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCOption_C2Tuple_usizeTransactionZZ Function(
              ffi.Pointer<ffi.Void>, LDKWatchedOutput)>> register_output;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An enum which can either contain a crate::lightning::chain::Filter or not
abstract class LDKCOption_FilterZ_Tag {
  /// When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
  static const int LDKCOption_FilterZ_Some = 0;

  /// When we're in this state, this COption_FilterZ contains nothing
  static const int LDKCOption_FilterZ_None = 1;

  /// Must be last for serialization purposes
  static const int LDKCOption_FilterZ_Sentinel = 2;
}

class LDKCOption_FilterZ extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A read-only reference to a current ChannelMonitor.
///
/// Note that this holds a mutex in [`ChainMonitor`] and may block other events until it is
/// released.
class LDKLockedChannelMonitor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeLockedChannelMonitor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeLockedChannelMonitor = nativeLockedChannelMonitorOpaque;

/// The contents of CResult_LockedChannelMonitorNoneZ
class LDKCResult_LockedChannelMonitorNoneZPtr extends ffi.Union {
  /// A pointer to the contents in the success state.
  /// Reading from this pointer when `result_ok` is not set is undefined.
  external ffi.Pointer<LDKLockedChannelMonitor> result;

  /// Note that this value is always NULL, as there are no contents in the Err variant
  external ffi.Pointer<ffi.Void> err;
}

/// A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
class LDKCResult_LockedChannelMonitorNoneZ extends ffi.Struct {
  /// The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
  /// `err` or `result` depending on the state of `result_ok`.
  external LDKCResult_LockedChannelMonitorNoneZPtr contents;

  /// Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
  @ffi.Bool()
  external bool result_ok;
}

/// A dynamically-allocated array of crate::lightning::chain::transaction::OutPoints of arbitrary size.
/// This corresponds to std::vector in C++
class LDKCVec_OutPointZ extends ffi.Struct {
  /// The elements in the array.
  /// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
  external ffi.Pointer<LDKOutPoint> data;

  /// The number of elements pointed to by `data`.
  @uintptr_t()
  external int datalen;
}

/// A trait indicating an object may generate message send events
class LDKMessageSendEventsProvider extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Gets the list of pending events which were generated by previous actions, clearing the list
  /// in the process.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCVec_MessageSendEventZ Function(ffi.Pointer<ffi.Void>)>>
      get_and_clear_pending_msg_events;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A trait implemented for objects handling events from [`EventsProvider`].
class LDKEventHandler extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Handles the given [`Event`].
  ///
  /// See [`EventsProvider`] for details that must be considered when implementing this method.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<LDKEvent>)>>
      handle_event;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A trait indicating an object may generate events.
///
/// Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
///
/// # Requirements
///
/// See [`process_pending_events`] for requirements around event processing.
///
/// When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
/// event since the last invocation. The handler must either act upon the event immediately
/// or preserve it for later handling.
///
/// Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
/// consult the provider's documentation on the implication of processing events and how a handler
/// may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
/// [`ChainMonitor::process_pending_events`]).
///
/// (C-not implementable) As there is likely no reason for a user to implement this trait on their
/// own type(s).
///
/// [`process_pending_events`]: Self::process_pending_events
/// [`handle_event`]: EventHandler::handle_event
/// [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
/// [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
class LDKEventsProvider extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Processes any events generated since the last call using the given event handler.
  ///
  /// Subsequent calls must only process new events. However, handlers must be capable of handling
  /// duplicate events across process restarts. This may occur if the provider was recovered from
  /// an old state (i.e., it hadn't been successfully persisted after processing pending events).
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKEventHandler)>>
      process_pending_events;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Lightning TLV uses a custom variable-length integer called BigSize. It is similar to Bitcoin's
/// variable-length integers except that it is serialized in big-endian instead of little-endian.
///
/// Like Bitcoin's variable-length integer, it exhibits ambiguity in that certain values can be
/// encoded in several different ways, which we must check for at deserialization-time. Thus, if
/// you're looking for an example of a variable-length integer to use for your own project, move
/// along, this is a rather poor design.
class LDKBigSize extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeBigSize> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeBigSize = nativeBigSizeOpaque;

/// Proposed use of a channel passed as a parameter to [`Score::channel_penalty_msat`].
class LDKChannelUsage extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelUsage> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelUsage = nativeChannelUsageOpaque;

/// An interface used to score payment channels for path finding.
///
/// \tScoring is in terms of fees willing to be paid in order to avoid routing through a channel.
class LDKScore extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
  /// given channel in the direction from `source` to `target`.
  ///
  /// The channel's capacity (less any other MPP parts that are also being considered for use in
  /// the same payment) is given by `capacity_msat`. It may be determined from various sources
  /// such as a chain data, network gossip, or invoice hints. For invoice hints, a capacity near
  /// [`u64::max_value`] is given to indicate sufficient capacity for the invoice's full amount.
  /// Thus, implementations should be overflow-safe.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<ffi.Void>,
              ffi.Uint64,
              ffi.Pointer<LDKNodeId>,
              ffi.Pointer<LDKNodeId>,
              LDKChannelUsage)>> channel_penalty_msat;

  /// Handles updating channel penalties after failing to route through a channel.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, LDKCVec_RouteHopZ, ffi.Uint64)>>
      payment_path_failed;

  /// Handles updating channel penalties after successfully routing along a path.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKCVec_RouteHopZ)>>
      payment_path_successful;

  /// Handles updating channel penalties after a probe over the given path failed.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, LDKCVec_RouteHopZ, ffi.Uint64)>>
      probe_failed;

  /// Handles updating channel penalties after a probe over the given path succeeded.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKCVec_RouteHopZ)>>
      probe_successful;

  /// Serialize the object into a byte array
  external ffi.Pointer<
      ffi.NativeFunction<LDKCVec_u8Z Function(ffi.Pointer<ffi.Void>)>> write;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A concrete implementation of [`LockableScore`] which supports multi-threading.
class LDKMultiThreadedLockableScore extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeMultiThreadedLockableScore> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeMultiThreadedLockableScore
    = nativeMultiThreadedLockableScoreOpaque;

/// Trait that handles persisting a [`ChannelManager`], [`NetworkGraph`], and [`MultiThreadedLockableScore`] to disk.
class LDKPersister extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Persist the given ['ChannelManager'] to disk, returning an error if persistence failed.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneErrorZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKChannelManager>)>>
      persist_manager;

  /// Persist the given [`NetworkGraph`] to disk, returning an error if persistence failed.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneErrorZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKNetworkGraph>)>>
      persist_graph;

  /// Persist the given [`MultiThreadedLockableScore`] to disk, returning an error if persistence failed.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneErrorZ Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKMultiThreadedLockableScore>)>> persist_scorer;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Configuration we set when applicable.
///
/// Default::default() provides sane defaults.
class LDKChannelHandshakeConfig extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelHandshakeConfig> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelHandshakeConfig = nativeChannelHandshakeConfigOpaque;

/// Optional channel limits which are applied during channel creation.
///
/// These limits are only applied to our counterparty's limits, not our own.
///
/// Use 0/<type>::max_value() as appropriate to skip checking.
///
/// Provides sane defaults for most configurations.
///
/// Most additional limits are disabled except those with which specify a default in individual
/// field documentation. Note that this may result in barely-usable channels, but since they
/// are applied mostly only to incoming channels that's not much of a problem.
class LDKChannelHandshakeLimits extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelHandshakeLimits> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelHandshakeLimits = nativeChannelHandshakeLimitsOpaque;

/// Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
///
/// Default::default() provides sane defaults for most configurations
/// (but currently with 0 relay fees!)
class LDKUserConfig extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeUserConfig> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeUserConfig = nativeUserConfigOpaque;

/// The best known block as identified by its hash and height.
class LDKBestBlock extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeBestBlock> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeBestBlock = nativeBestBlockOpaque;

/// The `Listen` trait is used to notify when blocks have been connected or disconnected from the
/// chain.
///
/// Useful when needing to replay chain data upon startup or as new chain events occur. Clients
/// sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
/// Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
/// when needed.
///
/// By using [`Listen::filtered_block_connected`] this interface supports clients fetching the
/// entire header chain and only blocks with matching transaction data using BIP 157 filters or
/// other similar filtering.
class LDKListen extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Notifies the listener that a block was added at the given height, with the transaction data
  /// possibly filtered.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              ffi.Uint32)>> filtered_block_connected;

  /// Notifies the listener that a block was added at the given height.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKu8slice, ffi.Uint32)>>
      block_connected;

  /// Notifies the listener that a block was removed at the given height.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint32)>> block_disconnected;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// The `Confirm` trait is used to notify when transactions have been confirmed on chain or
/// unconfirmed during a chain reorganization.
///
/// Clients sourcing chain data using a transaction-oriented API should prefer this interface over
/// [`Listen`]. For instance, an Electrum client may implement [`Filter`] by subscribing to activity
/// related to registered transactions and outputs. Upon notification, it would pass along the
/// matching transactions using this interface.
///
/// # Use
///
/// The intended use is as follows:
/// - Call [`transactions_confirmed`] to process any on-chain activity of interest.
/// - Call [`transaction_unconfirmed`] to process any transaction returned by [`get_relevant_txids`]
/// that has been reorganized out of the chain.
/// - Call [`best_block_updated`] whenever a new chain tip becomes available.
///
/// # Order
///
/// Clients must call these methods in chain order. Specifically:
/// - Transactions confirmed in a block must be given before transactions confirmed in a later
/// block.
/// - Dependent transactions within the same block must be given in topological order, possibly in
/// separate calls.
/// - Unconfirmed transactions must be given after the original confirmations and before any
/// reconfirmation.
///
/// See individual method documentation for further details.
///
/// [`transactions_confirmed`]: Self::transactions_confirmed
/// [`transaction_unconfirmed`]: Self::transaction_unconfirmed
/// [`best_block_updated`]: Self::best_block_updated
/// [`get_relevant_txids`]: Self::get_relevant_txids
class LDKConfirm extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Processes transactions confirmed in a block with a given header and height.
  ///
  /// Should be called for any transactions registered by [`Filter::register_tx`] or any
  /// transactions spending an output registered by [`Filter::register_output`]. Such transactions
  /// appearing in the same block do not need to be included in the same call; instead, multiple
  /// calls with additional transactions may be made so long as they are made in [chain order].
  ///
  /// May be called before or after [`best_block_updated`] for the corresponding block. However,
  /// in the event of a chain reorganization, it must not be called with a `header` that is no
  /// longer in the chain as of the last call to [`best_block_updated`].
  ///
  /// [chain order]: Confirm#Order
  /// [`best_block_updated`]: Self::best_block_updated
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              LDKCVec_C2Tuple_usizeTransactionZZ,
              ffi.Uint32)>> transactions_confirmed;

  /// Processes a transaction that is no longer confirmed as result of a chain reorganization.
  ///
  /// Should be called for any transaction returned by [`get_relevant_txids`] if it has been
  /// reorganized out of the best chain. Once called, the given transaction should not be returned
  /// by [`get_relevant_txids`] unless it has been reconfirmed via [`transactions_confirmed`].
  ///
  /// [`get_relevant_txids`]: Self::get_relevant_txids
  /// [`transactions_confirmed`]: Self::transactions_confirmed
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>
      transaction_unconfirmed;

  /// Processes an update to the best header connected at the given height.
  ///
  /// Should be called when a new header is available but may be skipped for intermediary blocks
  /// if they become available at the same time.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Uint32)>> best_block_updated;

  /// Returns transactions that should be monitored for reorganization out of the chain.
  ///
  /// Should include any transactions passed to [`transactions_confirmed`] that have insufficient
  /// confirmations to be safe from a chain reorganization. Should not include any transactions
  /// passed to [`transaction_unconfirmed`] unless later reconfirmed.
  ///
  /// May be called to determine the subset of transactions that must still be monitored for
  /// reorganization. Will be idempotent between calls but may change as a result of calls to the
  /// other interface methods. Thus, this is useful to determine which transactions may need to be
  /// given to [`transaction_unconfirmed`].
  ///
  /// [`transactions_confirmed`]: Self::transactions_confirmed
  /// [`transaction_unconfirmed`]: Self::transaction_unconfirmed
  external ffi.Pointer<
          ffi.NativeFunction<LDKCVec_TxidZ Function(ffi.Pointer<ffi.Void>)>>
      get_relevant_txids;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An opaque identifier describing a specific [`Persist`] method call.
class LDKMonitorUpdateId extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeMonitorUpdateId> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeMonitorUpdateId = nativeMonitorUpdateIdOpaque;

/// `Persist` defines behavior for persisting channel monitors: this could mean
/// writing once to disk, and/or uploading to one or more backup services.
///
/// Each method can return three possible values:
/// * If persistence (including any relevant `fsync()` calls) happens immediately, the
/// implementation should return `Ok(())`, indicating normal channel operation should continue.
/// * If persistence happens asynchronously, implementations should first ensure the
/// [`ChannelMonitor`] or [`ChannelMonitorUpdate`] are written durably to disk, and then return
/// `Err(ChannelMonitorUpdateErr::TemporaryFailure)` while the update continues in the
/// background. Once the update completes, [`ChainMonitor::channel_monitor_updated`] should be
/// called with the corresponding [`MonitorUpdateId`].
///
/// Note that unlike the direct [`chain::Watch`] interface,
/// [`ChainMonitor::channel_monitor_updated`] must be called once for *each* update which occurs.
///
/// * If persistence fails for some reason, implementations should return
/// `Err(ChannelMonitorUpdateErr::PermanentFailure)`, in which case the channel will likely be
/// closed without broadcasting the latest state. See
/// [`ChannelMonitorUpdateErr::PermanentFailure`] for more details.
class LDKPersist extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Persist a new channel's data in response to a [`chain::Watch::watch_channel`] call. This is
  /// called by [`ChannelManager`] for new channels, or may be called directly, e.g. on startup.
  ///
  /// The data can be stored any way you want, but the identifier provided by LDK is the
  /// channel's outpoint (and it is up to you to maintain a correct mapping between the outpoint
  /// and the stored channel data). Note that you **must** persist every new monitor to disk.
  ///
  /// The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
  /// if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
  ///
  /// See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`
  /// and [`ChannelMonitorUpdateErr`] for requirements when returning errors.
  ///
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  /// [`Writeable::write`]: crate::util::ser::Writeable::write
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function(
              ffi.Pointer<ffi.Void>,
              LDKOutPoint,
              ffi.Pointer<LDKChannelMonitor>,
              LDKMonitorUpdateId)>> persist_new_channel;

  /// Update one channel's data. The provided [`ChannelMonitor`] has already applied the given
  /// update.
  ///
  /// Note that on every update, you **must** persist either the [`ChannelMonitorUpdate`] or the
  /// updated monitor itself to disk/backups. See the [`Persist`] trait documentation for more
  /// details.
  ///
  /// During blockchain synchronization operations, this may be called with no
  /// [`ChannelMonitorUpdate`], in which case the full [`ChannelMonitor`] needs to be persisted.
  /// Note that after the full [`ChannelMonitor`] is persisted any previous
  /// [`ChannelMonitorUpdate`]s which were persisted should be discarded - they can no longer be
  /// applied to the persisted [`ChannelMonitor`] as they were already applied.
  ///
  /// If an implementer chooses to persist the updates only, they need to make
  /// sure that all the updates are applied to the `ChannelMonitors` *before*
  /// the set of channel monitors is given to the `ChannelManager`
  /// deserialization routine. See [`ChannelMonitor::update_monitor`] for
  /// applying a monitor update to a monitor. If full `ChannelMonitors` are
  /// persisted, then there is no need to persist individual updates.
  ///
  /// Note that there could be a performance tradeoff between persisting complete
  /// channel monitors on every update vs. persisting only updates and applying
  /// them in batches. The size of each monitor grows `O(number of state updates)`
  /// whereas updates are small and `O(1)`.
  ///
  /// The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
  /// if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
  ///
  /// See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`,
  /// [`Writeable::write`] on [`ChannelMonitorUpdate`] for writing out an update, and
  /// [`ChannelMonitorUpdateErr`] for requirements when returning errors.
  ///
  /// [`Writeable::write`]: crate::util::ser::Writeable::write
  ///
  /// Note that update (or a relevant inner pointer) may be NULL or all-0s to represent None
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneChannelMonitorUpdateErrZ Function(
              ffi.Pointer<ffi.Void>,
              LDKOutPoint,
              ffi.Pointer<LDKChannelMonitorUpdate>,
              ffi.Pointer<LDKChannelMonitor>,
              LDKMonitorUpdateId)>> update_persisted_channel;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// An implementation of [`chain::Watch`] for monitoring channels.
///
/// Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
/// [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
/// or used independently to monitor channels remotely. See the [module-level documentation] for
/// details.
///
/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
/// [module-level documentation]: crate::chain::chainmonitor
class LDKChainMonitor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChainMonitor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChainMonitor = nativeChainMonitorOpaque;

/// Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
/// and derives keys from that.
///
/// Your node_id is seed/0'
/// ChannelMonitor closes may use seed/1'
/// Cooperative closes may use seed/2'
/// The two close keys may be needed to claim on-chain funds!
///
/// This struct cannot be used for nodes that wish to support receiving phantom payments;
/// [`PhantomKeysManager`] must be used instead.
///
/// Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
/// previously issued invoices and attempts to pay previous invoices will fail.
class LDKKeysManager extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeKeysManager> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeKeysManager = nativeKeysManagerOpaque;

/// Similar to [`KeysManager`], but allows the node using this struct to receive phantom node
/// payments.
///
/// A phantom node payment is a payment made to a phantom invoice, which is an invoice that can be
/// paid to one of multiple nodes. This works because we encode the invoice route hints such that
/// LDK will recognize an incoming payment as destined for a phantom node, and collect the payment
/// itself without ever needing to forward to this fake node.
///
/// Phantom node payments are useful for load balancing between multiple LDK nodes. They also
/// provide some fault tolerance, because payers will automatically retry paying other provided
/// nodes in the case that one node goes down.
///
/// Note that multi-path payments are not supported in phantom invoices for security reasons.
/// Switching between this struct and [`KeysManager`] will invalidate any previously issued
/// invoices and attempts to pay previous invoices will fail.
class LDKPhantomKeysManager extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePhantomKeysManager> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePhantomKeysManager = nativePhantomKeysManagerOpaque;

/// Chain-related parameters used to construct a new `ChannelManager`.
///
/// Typically, the block-specific parameters are derived from the best block hash for the network,
/// as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
/// are not needed when deserializing a previously constructed `ChannelManager`.
class LDKChainParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChainParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChainParameters = nativeChainParametersOpaque;

/// A 3-byte byte array.
class LDKThreeBytes extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint8> data;
}

/// A trait to describe an object which can receive channel messages.
///
/// Messages MAY be called in parallel when they originate from different their_node_ids, however
/// they MUST NOT be called in parallel when the two calls have the same their_node_id.
class LDKChannelMessageHandler extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Handle an incoming open_channel message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              LDKInitFeatures,
              ffi.Pointer<LDKOpenChannel>)>> handle_open_channel;

  /// Handle an incoming accept_channel message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              LDKInitFeatures,
              ffi.Pointer<LDKAcceptChannel>)>> handle_accept_channel;

  /// Handle an incoming funding_created message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKFundingCreated>)>> handle_funding_created;

  /// Handle an incoming funding_signed message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKFundingSigned>)>> handle_funding_signed;

  /// Handle an incoming channel_ready message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKChannelReady>)>> handle_channel_ready;

  /// Handle an incoming shutdown message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              ffi.Pointer<LDKInitFeatures>,
              ffi.Pointer<LDKShutdown>)>> handle_shutdown;

  /// Handle an incoming closing_signed message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKClosingSigned>)>> handle_closing_signed;

  /// Handle an incoming update_add_htlc message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKUpdateAddHTLC>)>> handle_update_add_htlc;

  /// Handle an incoming update_fulfill_htlc message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKUpdateFulfillHTLC>)>> handle_update_fulfill_htlc;

  /// Handle an incoming update_fail_htlc message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKUpdateFailHTLC>)>> handle_update_fail_htlc;

  /// Handle an incoming update_fail_malformed_htlc message from the given peer.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
                  ffi.Pointer<LDKUpdateFailMalformedHTLC>)>>
      handle_update_fail_malformed_htlc;

  /// Handle an incoming commitment_signed message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKCommitmentSigned>)>> handle_commitment_signed;

  /// Handle an incoming revoke_and_ack message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKRevokeAndACK>)>> handle_revoke_and_ack;

  /// Handle an incoming update_fee message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKUpdateFee>)>> handle_update_fee;

  /// Handle an incoming announcement_signatures message from the given peer.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
                  ffi.Pointer<LDKAnnouncementSignatures>)>>
      handle_announcement_signatures;

  /// Indicates a connection to the peer failed/an existing connection was lost. If no connection
  /// is believed to be possible in the future (eg they're sending us messages we don't
  /// understand or indicate they require unknown feature bits), no_connection_possible is set
  /// and any outstanding channels should be failed.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey, ffi.Bool)>>
      peer_disconnected;

  /// Handle a peer reconnecting, possibly generating channel_reestablish message(s).
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, LDKPublicKey, ffi.Pointer<LDKInit>)>>
      peer_connected;

  /// Handle an incoming channel_reestablish message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKChannelReestablish>)>> handle_channel_reestablish;

  /// Handle an incoming channel update from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKChannelUpdate>)>> handle_channel_update;

  /// Handle an incoming error message from the given peer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, LDKPublicKey,
              ffi.Pointer<LDKErrorMessage>)>> handle_error;

  /// Implementation of MessageSendEventsProvider for this object.
  external LDKMessageSendEventsProvider MessageSendEventsProvider;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Arguments for the creation of a ChannelManager that are not deserialized.
///
/// At a high-level, the process for deserializing a ChannelManager and resuming normal operation
/// is:
/// 1) Deserialize all stored [`ChannelMonitor`]s.
/// 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
/// `<(BlockHash, ChannelManager)>::read(reader, args)`
/// This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
/// [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
/// 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
/// same way you would handle a [`chain::Filter`] call using
/// [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
/// 4) Reconnect blocks on your [`ChannelMonitor`]s.
/// 5) Disconnect/connect blocks on the [`ChannelManager`].
/// 6) Re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
/// Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
/// will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
/// the next step.
/// 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
/// [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
///
/// Note that the ordering of #4-7 is not of importance, however all four must occur before you
/// call any other methods on the newly-deserialized [`ChannelManager`].
///
/// Note that because some channels may be closed during deserialization, it is critical that you
/// always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
/// you. If you deserialize an old ChannelManager (during which force-closure transactions may be
/// broadcast), and then later deserialize a newer version of the same ChannelManager (which will
/// not force-close the same channels but consider them live), you may end up revoking a state for
/// which you've already broadcasted the transaction.
///
/// [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
class LDKChannelManagerReadArgs extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeChannelManagerReadArgs> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeChannelManagerReadArgs = nativeChannelManagerReadArgsOpaque;

/// A set of keys that were HKDF-expanded from an initial call to
/// [`KeysInterface::get_inbound_payment_key_material`].
///
/// [`KeysInterface::get_inbound_payment_key_material`]: crate::chain::keysinterface::KeysInterface::get_inbound_payment_key_material
class LDKExpandedKey extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeExpandedKey> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeExpandedKey = nativeExpandedKeyOpaque;

/// Proof that the sender knows the per-commitment secret of the previous commitment transaction.
/// This is used to convince the recipient that the channel is at a certain commitment
/// number even if they lost that data due to a local failure.  Of course, the peer may lie
/// and even later commitments may have been revoked.
class LDKDataLossProtect extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDataLossProtect> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDataLossProtect = nativeDataLossProtectOpaque;

/// A trait to describe an object which can receive routing messages.
///
/// # Implementor DoS Warnings
///
/// For `gossip_queries` messages there are potential DoS vectors when handling
/// inbound queries. Implementors using an on-disk network graph should be aware of
/// repeated disk I/O for queries accessing different parts of the network graph.
class LDKRoutingMessageHandler extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Handle an incoming node_announcement message, returning true if it should be forwarded on,
  /// false or returning an Err otherwise.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_boolLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKNodeAnnouncement>)>>
      handle_node_announcement;

  /// Handle a channel_announcement message, returning true if it should be forwarded on, false
  /// or returning an Err otherwise.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_boolLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKChannelAnnouncement>)>>
      handle_channel_announcement;

  /// Handle an incoming channel_update message, returning true if it should be forwarded on,
  /// false or returning an Err otherwise.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_boolLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<LDKChannelUpdate>)>>
      handle_channel_update;

  /// Gets a subset of the channel announcements and updates required to dump our routing table
  /// to a remote node, starting at the short_channel_id indicated by starting_point and
  /// including the batch_amount entries immediately higher in numerical value than starting_point.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ
                  Function(ffi.Pointer<ffi.Void>, ffi.Uint64, ffi.Uint8)>>
      get_next_channel_announcements;

  /// Gets a subset of the node announcements required to dump our routing table to a remote node,
  /// starting at the node *after* the provided publickey and including batch_amount entries
  /// immediately higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
  /// If None is provided for starting_point, we start at the first node.
  ///
  /// Note that starting_point (or a relevant inner pointer) may be NULL or all-0s to represent None
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCVec_NodeAnnouncementZ Function(
                  ffi.Pointer<ffi.Void>, LDKPublicKey, ffi.Uint8)>>
      get_next_node_announcements;

  /// Called when a connection is established with a peer. This can be used to
  /// perform routing table synchronization using a strategy defined by the
  /// implementor.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, LDKPublicKey, ffi.Pointer<LDKInit>)>>
      peer_connected;

  /// Handles the reply of a query we initiated to learn about channels
  /// for a given range of blocks. We can expect to receive one or more
  /// replies to a single query.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, LDKPublicKey, LDKReplyChannelRange)>>
      handle_reply_channel_range;

  /// Handles the reply of a query we initiated asking for routing gossip
  /// messages for a list of channels. We should receive this message when
  /// a node has completed its best effort to send us the pertaining routing
  /// gossip messages.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneLightningErrorZ Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              LDKReplyShortChannelIdsEnd)>> handle_reply_short_channel_ids_end;

  /// Handles when a peer asks us to send a list of short_channel_ids
  /// for the requested range of blocks.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, LDKPublicKey, LDKQueryChannelRange)>>
      handle_query_channel_range;

  /// Handles when a peer asks us to send routing gossip messages for a
  /// list of short_channel_ids.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NoneLightningErrorZ Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              LDKQueryShortChannelIds)>> handle_query_short_channel_ids;

  /// Implementation of MessageSendEventsProvider for this object.
  external LDKMessageSendEventsProvider MessageSendEventsProvider;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Trait to be implemented by custom message (unrelated to the channel/gossip LN layers)
/// decoders.
class LDKCustomMessageReader extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Decodes a custom message to `CustomMessageType`. If the given message type is known to the
  /// implementation and the message could be decoded, must return `Ok(Some(message))`. If the
  /// message type is unknown to the implementation, must return `Ok(None)`. If a decoding error
  /// occur, must return `Err(DecodeError::X)` where `X` details the encountered error.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_COption_TypeZDecodeErrorZ Function(
              ffi.Pointer<ffi.Void>, ffi.Uint16, LDKu8slice)>> read;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Handler for BOLT1-compliant messages.
class LDKCustomMessageHandler extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Called with the message type that was received and the buffer to be read.
  /// Can return a `MessageHandlingError` if the message could not be handled.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCResult_NoneLightningErrorZ Function(
                  ffi.Pointer<ffi.Void>, LDKType, LDKPublicKey)>>
      handle_custom_message;

  /// Gets the list of pending messages which were generated by the custom message
  /// handler, clearing the list in the process. The first tuple element must
  /// correspond to the intended recipients node ids. If no connection to one of the
  /// specified node does not exist, the message is simply not sent to it.
  external ffi.Pointer<
          ffi.NativeFunction<
              LDKCVec_C2Tuple_PublicKeyTypeZZ Function(ffi.Pointer<ffi.Void>)>>
      get_and_clear_pending_msg;

  /// Implementation of CustomMessageReader for this object.
  external LDKCustomMessageReader CustomMessageReader;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A dummy struct which implements `RoutingMessageHandler` without storing any routing information
/// or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
class LDKIgnoringMessageHandler extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeIgnoringMessageHandler> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeIgnoringMessageHandler = nativeIgnoringMessageHandlerOpaque;

/// A dummy struct which implements `ChannelMessageHandler` without having any channels.
/// You can provide one of these as the route_handler in a MessageHandler.
class LDKErroringMessageHandler extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeErroringMessageHandler> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeErroringMessageHandler = nativeErroringMessageHandlerOpaque;

/// Provides references to trait impls which handle different types of messages.
class LDKMessageHandler extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeMessageHandler> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeMessageHandler = nativeMessageHandlerOpaque;

/// Provides an object which can be used to send data to and which uniquely identifies a connection
/// to a remote host. You will need to be able to generate multiple of these which meet Eq and
/// implement Hash to meet the PeerManager API.
///
/// For efficiency, Clone should be relatively cheap for this type.
///
/// Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
/// has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
/// having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
/// further calls to the [`PeerManager`] related to the original socket occur. This allows you to
/// use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
/// to simply use another value which is guaranteed to be globally unique instead.
class LDKSocketDescriptor extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Attempts to send some data from the given slice to the peer.
  ///
  /// Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
  /// Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
  /// called and further write attempts may occur until that time.
  ///
  /// If the returned size is smaller than `data.len()`, a
  /// [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
  /// written. Additionally, until a `send_data` event completes fully, no further
  /// [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
  /// prevent denial-of-service issues, you should not read or buffer any data from the socket
  /// until then.
  ///
  /// If a [`PeerManager::read_event`] call on this descriptor had previously returned true
  /// (indicating that read events should be paused to prevent DoS in the send buffer),
  /// `resume_read` may be set indicating that read events on this descriptor should resume. A
  /// `resume_read` of false carries no meaning, and should not cause any action.
  external ffi.Pointer<
          ffi.NativeFunction<
              uintptr_t Function(ffi.Pointer<ffi.Void>, LDKu8slice, ffi.Bool)>>
      send_data;

  /// Disconnect the socket pointed to by this SocketDescriptor.
  ///
  /// You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
  /// call (doing so is a noop).
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      disconnect_socket;

  /// Checks if two objects are equal given this object's this_arg pointer and another object.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<LDKSocketDescriptor>)>> eq;

  /// Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
  /// This is used, for example, for inclusion of this object in a hash map.
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>> hash;

  /// Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
  /// The new SocketDescriptor is provided, and should be mutated as needed to perform a
  /// deep copy of the object pointed to by this_arg or avoid any double-freeing.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<LDKSocketDescriptor>)>> cloned;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
/// socket events into messages which it passes on to its [`MessageHandler`].
///
/// Locks are taken internally, so you must never assume that reentrancy from a
/// [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
///
/// Calls to [`read_event`] will decode relevant messages and pass them to the
/// [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
/// parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
/// [`PeerManager`] functions related to the same connection must occur only in serial, making new
/// calls only after previous ones have returned.
///
/// Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
/// a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
/// essentially you should default to using a SimpleRefPeerManager, and use a
/// SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
/// you're using lightning-net-tokio.
///
/// [`read_event`]: PeerManager::read_event
class LDKPeerManager extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativePeerManager> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativePeerManager = nativePeerManagerOpaque;

/// Static channel fields used to build transactions given per-commitment fields, organized by
/// broadcaster/countersignatory.
///
/// This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
/// as_holder_broadcastable and as_counterparty_broadcastable functions.
class LDKDirectedChannelTransactionParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDirectedChannelTransactionParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDirectedChannelTransactionParameters
    = nativeDirectedChannelTransactionParametersOpaque;

/// Integer in the range `0..=16`
class LDKWitnessVersion extends ffi.Struct {
  @ffi.Uint8()
  external int _0;
}

/// A read-only view of [`NetworkGraph`].
class LDKReadOnlyNetworkGraph extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeReadOnlyNetworkGraph> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeReadOnlyNetworkGraph = nativeReadOnlyNetworkGraphOpaque;

/// Receives and validates network updates from peers,
/// stores authentic and relevant data as a network graph.
/// This network graph is then used for routing payments.
/// Provides interface to help with initial routing sync by
/// serving historical announcements.
///
/// Serves as an [`EventHandler`] for applying updates from [`Event::PaymentPathFailed`] to the
/// [`NetworkGraph`].
class LDKP2PGossipSync extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeP2PGossipSync> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeP2PGossipSync = nativeP2PGossipSyncOpaque;

/// A wrapper around [`ChannelInfo`] representing information about the channel as directed from a
/// source node to a target node.
class LDKDirectedChannelInfo extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDirectedChannelInfo> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDirectedChannelInfo = nativeDirectedChannelInfoOpaque;

/// The effective capacity of a channel for routing purposes.
///
/// While this may be smaller than the actual channel capacity, amounts greater than
/// [`Self::as_msat`] should not be routed through the channel.
abstract class LDKEffectiveCapacity_Tag {
  /// The available liquidity in the channel known from being a channel counterparty, and thus a
  /// direct hop.
  static const int LDKEffectiveCapacity_ExactLiquidity = 0;

  /// The maximum HTLC amount in one direction as advertised on the gossip network.
  static const int LDKEffectiveCapacity_MaximumHTLC = 1;

  /// The total capacity of the channel as determined by the funding transaction.
  static const int LDKEffectiveCapacity_Total = 2;

  /// A capacity sufficient to route any payment, typically used for private channels provided by
  /// an invoice.
  static const int LDKEffectiveCapacity_Infinite = 3;

  /// A capacity that is unknown possibly because either the chain state is unavailable to know
  /// the total capacity or the `htlc_maximum_msat` was not advertised on the gossip network.
  static const int LDKEffectiveCapacity_Unknown = 4;

  /// Must be last for serialization purposes
  static const int LDKEffectiveCapacity_Sentinel = 5;
}

class LDKEffectiveCapacity_LDKExactLiquidity_Body extends ffi.Struct {
  /// Either the inbound or outbound liquidity depending on the direction, denominated in
  /// millisatoshi.
  @ffi.Uint64()
  external int liquidity_msat;
}

class LDKEffectiveCapacity_LDKMaximumHTLC_Body extends ffi.Struct {
  /// The maximum HTLC amount denominated in millisatoshi.
  @ffi.Uint64()
  external int amount_msat;
}

class LDKEffectiveCapacity_LDKTotal_Body extends ffi.Struct {
  /// The funding amount denominated in millisatoshi.
  @ffi.Uint64()
  external int capacity_msat;

  /// The maximum HTLC amount denominated in millisatoshi.
  external LDKCOption_u64Z htlc_maximum_msat;
}

class LDKEffectiveCapacity extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A scorer that is accessed under a lock.
///
/// Needed so that calls to [`Score::channel_penalty_msat`] in [`find_route`] can be made while
/// having shared ownership of a scorer but without requiring internal locking in [`Score`]
/// implementations. Internal locking would be detrimental to route finding performance and could
/// result in [`Score::channel_penalty_msat`] returning a different value for the same channel.
///
/// [`find_route`]: crate::routing::router::find_route
class LDKLockableScore extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Returns the locked scorer.
  external ffi
          .Pointer<ffi.NativeFunction<LDKScore Function(ffi.Pointer<ffi.Void>)>>
      lock;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// Parameters for configuring [`ProbabilisticScorer`].
///
/// Used to configure base, liquidity, and amount penalties, the sum of which comprises the channel
/// penalty (i.e., the amount in msats willing to be paid to avoid routing through the channel).
///
/// The penalty applied to any channel by the [`ProbabilisticScorer`] is the sum of each of the
/// parameters here.
class LDKProbabilisticScoringParameters extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeProbabilisticScoringParameters> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeProbabilisticScoringParameters
    = nativeProbabilisticScoringParametersOpaque;

/// FilesystemPersister persists channel data on disk, where each channel's
/// data is stored in a file named after its funding outpoint.
///
/// Warning: this module does the best it can with calls to persist data, but it
/// can only guarantee that the data is passed to the drive. It is up to the
/// drive manufacturers to do the actual persistence properly, which they often
/// don't (especially on consumer-grade hardware). Therefore, it is up to the
/// user to validate their entire storage stack, to ensure the writes are
/// persistent.
/// Corollary: especially when dealing with larger amounts of money, it is best
/// practice to have multiple channel data backups and not rely only on one
/// FilesystemPersister.
class LDKFilesystemPersister extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeFilesystemPersister> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeFilesystemPersister = nativeFilesystemPersisterOpaque;

/// `BackgroundProcessor` takes care of tasks that (1) need to happen periodically to keep
/// Rust-Lightning running properly, and (2) either can or should be run in the background. Its
/// responsibilities are:
/// * Processing [`Event`]s with a user-provided [`EventHandler`].
/// * Monitoring whether the [`ChannelManager`] needs to be re-persisted to disk, and if so,
/// writing it to disk/backups by invoking the callback given to it at startup.
/// [`ChannelManager`] persistence should be done in the background.
/// * Calling [`ChannelManager::timer_tick_occurred`] and [`PeerManager::timer_tick_occurred`]
/// at the appropriate intervals.
/// * Calling [`NetworkGraph::remove_stale_channels`] (if a [`GossipSync`] with a [`NetworkGraph`]
/// is provided to [`BackgroundProcessor::start`]).
///
/// It will also call [`PeerManager::process_events`] periodically though this shouldn't be relied
/// upon as doing so may result in high latency.
///
/// # Note
///
/// If [`ChannelManager`] persistence fails and the persisted manager becomes out-of-date, then
/// there is a risk of channels force-closing on startup when the manager realizes it's outdated.
/// However, as long as [`ChannelMonitor`] backups are sound, no funds besides those used for
/// unilateral chain closure fees are at risk.
///
/// [`ChannelMonitor`]: lightning::chain::channelmonitor::ChannelMonitor
/// [`Event`]: lightning::util::events::Event
/// BackgroundProcessor will immediately stop on drop. It should be stored until shutdown.
class LDKBackgroundProcessor extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeBackgroundProcessor> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeBackgroundProcessor = nativeBackgroundProcessorOpaque;

/// Rapid Gossip Sync struct
/// See [crate-level documentation] for usage.
///
/// [crate-level documentation]: crate
class LDKRapidGossipSync extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRapidGossipSync> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRapidGossipSync = nativeRapidGossipSyncOpaque;

/// Either [`P2PGossipSync`] or [`RapidGossipSync`].
abstract class LDKGossipSync_Tag {
  /// Gossip sync via the lightning peer-to-peer network as defined by BOLT 7.
  static const int LDKGossipSync_P2P = 0;

  /// Rapid gossip sync from a trusted server.
  static const int LDKGossipSync_Rapid = 1;

  /// No gossip sync.
  static const int LDKGossipSync_None = 2;

  /// Must be last for serialization purposes
  static const int LDKGossipSync_Sentinel = 3;
}

class LDKGossipSync extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// Data of the `RawInvoice` that is encoded in the data part
class LDKRawDataPart extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeRawDataPart> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeRawDataPart = nativeRawDataPartOpaque;

/// SHA-256 hash
class LDKSha256 extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeSha256> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeSha256 = nativeSha256Opaque;

/// Positive duration that defines when (relatively to the timestamp) in the future the invoice
/// expires
class LDKExpiryTime extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeExpiryTime> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeExpiryTime = nativeExpiryTimeOpaque;

/// `min_final_cltv_expiry` to use for the last HTLC in the route
class LDKMinFinalCltvExpiry extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeMinFinalCltvExpiry> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeMinFinalCltvExpiry = nativeMinFinalCltvExpiryOpaque;

/// A 20-byte byte array.
class LDKTwentyBytes extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> data;
}

/// Fallback address in case no LN payment is possible
abstract class LDKFallback_Tag {
  static const int LDKFallback_SegWitProgram = 0;
  static const int LDKFallback_PubKeyHash = 1;
  static const int LDKFallback_ScriptHash = 2;

  /// Must be last for serialization purposes
  static const int LDKFallback_Sentinel = 3;
}

class LDKFallback_LDKSegWitProgram_Body extends ffi.Struct {
  external LDKu5 version;

  external LDKCVec_u8Z program;
}

class LDKFallback extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A trait defining behavior of an [`Invoice`] payer.
class LDKPayer extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Returns the payer's node id.
  external ffi.Pointer<
      ffi.NativeFunction<LDKPublicKey Function(ffi.Pointer<ffi.Void>)>> node_id;

  /// Returns the payer's channels.
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCVec_ChannelDetailsZ Function(ffi.Pointer<ffi.Void>)>> first_hops;

  /// Sends a payment over the Lightning Network using the given [`Route`].
  ///
  /// Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes,
              LDKThirtyTwoBytes)>> send_payment;

  /// Sends a spontaneous payment over the Lightning Network using the given [`Route`].
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_PaymentIdPaymentSendFailureZ Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKRoute>,
              LDKThirtyTwoBytes)>> send_spontaneous_payment;

  /// Retries a failed payment path for the [`PaymentId`] using the given [`Route`].
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_NonePaymentSendFailureZ Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<LDKRoute>, LDKThirtyTwoBytes)>> retry_payment;

  /// Signals that no further retries for the given payment will occur.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, LDKThirtyTwoBytes)>>
      abandon_payment;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A trait defining behavior for routing an [`Invoice`] payment.
class LDKRouter extends ffi.Struct {
  /// An opaque pointer which is passed to your function implementations as an argument.
  /// This has no meaning in the LDK, and can be NULL or any other value.
  external ffi.Pointer<ffi.Void> this_arg;

  /// Finds a [`Route`] between `payer` and `payee` for a payment with the given values.
  ///
  /// Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
  external ffi.Pointer<
      ffi.NativeFunction<
          LDKCResult_RouteLightningErrorZ Function(
              ffi.Pointer<ffi.Void>,
              LDKPublicKey,
              ffi.Pointer<LDKRouteParameters>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<LDKCVec_ChannelDetailsZ>,
              ffi.Pointer<LDKScore>)>> find_route;

  /// Frees any resources associated with this object given its this_arg pointer.
  /// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;
}

/// A utility for paying [`Invoice`]s and sending spontaneous payments.
///
/// See [module-level documentation] for details.
///
/// [module-level documentation]: crate::payment
class LDKInvoicePayer extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeInvoicePayer> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeInvoicePayer = nativeInvoicePayerOpaque;

/// Strategies available to retry payment path failures for an [`Invoice`].
abstract class LDKRetry_Tag {
  /// Max number of attempts to retry payment.
  ///
  /// Note that this is the number of *path* failures, not full payment retries. For multi-path
  /// payments, if this is less than the total number of paths, we will never even retry all of the
  /// payment's paths.
  static const int LDKRetry_Attempts = 0;

  /// Time elapsed before abandoning retries for a payment.
  static const int LDKRetry_Timeout = 1;

  /// Must be last for serialization purposes
  static const int LDKRetry_Sentinel = 2;
}

class LDKRetry extends ffi.Struct {
  @ffi.Int32()
  external int tag;
}

/// A [`Router`] implemented using [`find_route`].
class LDKDefaultRouter extends ffi.Struct {
  /// A pointer to the opaque Rust object.
  /// Nearly everywhere, inner must be non-null, however in places where
  /// the Rust equivalent takes an Option, it may be set to null to indicate None.
  external ffi.Pointer<LDKnativeDefaultRouter> inner;

  /// Indicates that this is the only struct which contains the same pointer.
  /// Rust functions which take ownership of an object provided via an argument require
  /// this to be true and invalidate the object pointed to by inner.
  @ffi.Bool()
  external bool is_owned;
}

typedef LDKnativeDefaultRouter = nativeDefaultRouterOpaque;

const int __GNUC_VA_LIST = 1;

const int true1 = 1;

const int false1 = 0;

const int __bool_true_false_are_defined = 1;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const String _LDK_HEADER_VER = 'v0.0.110-12-g6343277cddee74ed-dirty';

const String _LDK_C_BINDINGS_HEADER_VER = 'v0.0.110.1-dirty';
